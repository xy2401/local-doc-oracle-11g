<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Types of Parallelism</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-27T4:11:53Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database VLDB and Partitioning Guide" />
<meta name="dcterms.identifier" content="E25523-01" />
<meta name="dcterms.isVersionOf" content="VLDBG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="parallel002.htm" title="Previous" type="text/html" />
<link rel="Next" href="parallel004.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25523.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">20/27</span> <!-- End Header --><a id="CACBAABB"></a><a id="VLDBG0107"></a>
<div class="sect1">
<h1 class="sect1">Types of Parallelism</h1>
<p>This section discusses the <a id="sthref937"></a><a id="sthref938"></a><a id="sthref939"></a><a id="sthref940"></a><a id="sthref941"></a><a id="sthref942"></a><a id="sthref943"></a>types of parallelism in the following topics:</p>
<ul>
<li>
<p><a href="#i1006439">About Parallel Queries</a></p>
</li>
<li>
<p><a href="#i1006520">About Parallel DDL Statements</a></p>
</li>
<li>
<p><a href="#i1006712">About Parallel DML Operations</a></p>
</li>
<li>
<p><a href="#i1007127">About Parallel Execution of Functions</a></p>
</li>
<li>
<p><a href="#i1007156">About Other Types of Parallelism</a></p>
</li>
</ul>
<a id="i1006439"></a><a id="VLDBG1403"></a>
<div class="sect2">
<h2 class="sect2">About Parallel Queries</h2>
<p><a id="sthref944"></a><a id="sthref945"></a>You can use parallel queries and parallel subqueries in <code>SELECT</code> statements and execute in parallel the query portions of DDL statements and DML statements (<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>). You can also query external tables in parallel.</p>
<p>Parallelization has two components: the decision to parallelize and the degree of parallelism (DOP). These components are determined differently for queries, DDL operations, and DML operations. To determine the DOP, Oracle Database looks at the reference objects:</p>
<ul>
<li>
<p>Parallel query looks at each table and index, in the portion of the query to be executed in parallel, to determine which is the reference table. The basic rule is to pick the table or index with the largest DOP.</p>
</li>
<li>
<p>For parallel DML (<code>INSERT</code>, <code>UPDATE</code>, <code>MERGE</code>, and <code>DELETE</code>), the reference object that determines the DOP is the table being modified by and insert, update, or delete operation. Parallel DML also adds some limits to the DOP to prevent deadlock. If the parallel DML statement includes a subquery, the subquery's DOP is equivalent to that for the DML operation.</p>
</li>
<li>
<p>For parallel DDL, the reference object that determines the DOP is the table, index, or partition being created, rebuilt, split, or moved. If the parallel DDL statement includes a subquery, the subquery's DOP is equivalent to the DDL operation.</p>
</li>
</ul>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BEIGCGEC">Parallel Queries on Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#BEIDAAFH">Nonpartitioned Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#BEIEHCCB">Partitioned Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#BEIDHEAG">Parallel Queries on Object Types</a></p>
</li>
<li>
<p><a href="#CIHDABCC">Rules for Parallelizing Queries</a></p>
</li>
</ul>
<p>For information about the query operations that Oracle Database can execute in parallel, refer to <a href="parallel001.htm#CACGFHCC">"Operations That Can Use Parallel Execution"</a>. For an explanation of how the processes perform parallel queries, refer to <a href="parallel002.htm#i1006328">"Parallel Execution of SQL Statements"</a>. For examples of queries that reference a remote object, refer to <a href="#i1007101">"Distributed Transaction Restrictions"</a>. For information about the conditions for executing a query in parallel and the factors that determine the DOP, refer to <a href="#CIHDABCC">"Rules for Parallelizing Queries"</a>.</p>
<a id="BEIGCGEC"></a><a id="VLDBG1404"></a>
<div class="sect3">
<h3 class="sect3">Parallel Queries on Index-Organized Tables</h3>
<p><a id="sthref946"></a><a id="sthref947"></a>The following parallel scan methods are supported on index-organized tables:</p>
<ul>
<li>
<p>Parallel fast full scan of a nonpartitioned index-organized table</p>
</li>
<li>
<p>Parallel fast full scan of a partitioned index-organized table</p>
</li>
<li>
<p>Parallel index range scan of a partitioned index-organized table</p>
</li>
</ul>
<p>These scan methods can be used for index-organized tables with overflow areas and for index-organized tables that contain LOBs.</p>
</div>
<!-- class="sect3" -->
<a id="BEIDAAFH"></a><a id="VLDBG1405"></a>
<div class="sect3">
<h3 class="sect3">Nonpartitioned Index-Organized Tables</h3>
<p>Parallel query on a nonpartitioned index-organized table uses parallel fast full scan. The DOP is determined, in decreasing order of priority, by:</p>
<ol>
<li>
<p>A <code>PARALLEL</code> hint (if present)</p>
</li>
<li>
<p>An <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>QUERY</code> statement</p>
</li>
<li>
<p>The parallel degree associated with the table, if the parallel degree is specified in the <code>CREATE</code> <code>TABLE</code> or <code>ALTER</code> <code>TABLE</code> statement</p>
</li>
</ol>
<p>Work is allocated by dividing the index segment into a sufficiently large number of block ranges and then assigning the block ranges to parallel execution servers in a demand-driven manner. The overflow blocks corresponding to any row are accessed in a demand-driven manner only by the process, which owns that row.</p>
</div>
<!-- class="sect3" -->
<a id="BEIEHCCB"></a><a id="VLDBG1406"></a>
<div class="sect3">
<h3 class="sect3">Partitioned Index-Organized Tables</h3>
<p>Both index range scan and fast full scan can be performed in parallel. For parallel fast full scan, parallelization is the same as for nonpartitioned index-organized tables. For a parallel index range scan on a partitioned index-organized table, the DOP is the minimum of the degree obtained from the previous priority list (such as in parallel fast full scan) and the number of partitions in the index-organized table. Depending on the DOP, each parallel execution server gets one or more partitions, each of which contains the primary key index segment and the associated overflow segment, if any.</p>
</div>
<!-- class="sect3" -->
<a id="BEIDHEAG"></a><a id="VLDBG1407"></a>
<div class="sect3">
<h3 class="sect3">Parallel Queries on Object Types</h3>
<p><a id="sthref948"></a><a id="sthref949"></a>Parallel queries can be performed on object type tables and tables containing object type columns. Parallel query for object types supports all of the features that are available for sequential queries on object types, including:</p>
<ul>
<li>
<p>Methods on object types</p>
</li>
<li>
<p>Attribute access of object types</p>
</li>
<li>
<p>Constructors to create object type instances</p>
</li>
<li>
<p>Object views</p>
</li>
<li>
<p>PL/SQL and Oracle Call Interface (OCI) queries for object types</p>
</li>
</ul>
<p>There are no limitations on the size of the object types for parallel queries.</p>
<p><a id="sthref950"></a><a id="sthref951"></a>The following restrictions apply to using parallel query for object types:</p>
<ul>
<li>
<p>A <code>MAP</code> function is needed to execute queries in parallel for queries involving joins and sorts (through <code>ORDER</code> <code>BY</code>, <code>GROUP</code> <code>BY</code>, or set operations). Without a <code>MAP</code> function, the query is automatically executed serially.</p>
</li>
<li>
<p><a id="sthref952"></a><a id="sthref953"></a>Parallel DML and parallel DDL are not supported with object types, and such statements are always performed serially.</p>
</li>
</ul>
<p>In all cases where the query cannot execute in parallel because of any of these restrictions, the whole query executes serially without giving an error message.</p>
</div>
<!-- class="sect3" -->
<a id="CIHDABCC"></a><a id="VLDBG1408"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Rules for Parallelizing Queries</h3>
<p>This section discusses the following rules for executing queries in parallel.</p>
<ul>
<li>
<p><a href="#BEIJBCCD">Decision to Parallelize</a></p>
</li>
<li>
<p><a href="#BEIFAIFA">Degree of Parallelism</a></p>
</li>
</ul>
<a id="BEIJBCCD"></a><a id="VLDBG1409"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4">Decision to Parallelize</h4>
<p>A <code>SELECT</code> statement can be executed in parallel only if the following conditions are satisfied:</p>
<ul>
<li>
<p>The query includes a parallel hint specification (<code>PARALLEL</code> or <code>PARALLEL_INDEX</code>) or the schema objects referred to in the query have a <code>PARALLEL</code> declaration associated with them.</p>
</li>
<li>
<p>At least one table specified in the query requires one of the following:</p>
<ul>
<li>
<p>A full table scan</p>
</li>
<li>
<p>An index range scan spanning multiple partitions</p>
</li>
</ul>
</li>
<li>
<p>No scalar subqueries are in the <code>SELECT</code> list.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="BEIFAIFA"></a><a id="VLDBG1410"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4">Degree of Parallelism</h4>
<p>The DOP for a query is determined by the following rules:</p>
<ul>
<li>
<p>The query uses the maximum DOP taken from all of the table declarations involved in the query and all of the potential indexes that are candidates to satisfy the query (the reference objects). That is, the table or index that has the greatest DOP determines the query's <a id="sthref954"></a><a id="sthref955"></a>DOP maximum query directive.</p>
</li>
<li>
<p>If a table has both a parallel hint specification in the query and a parallel declaration in its table specification, the hint specification takes precedence over parallel declaration specification. See <a href="#CACCAGCH">Table 8-2</a> for precedence rules.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006520"></a><a id="VLDBG1411"></a>
<div class="sect2">
<h2 class="sect2">About Parallel DDL Statements</h2>
<p><a id="sthref956"></a>This section discusses the following topics on parallelism for DDL statements:</p>
<ul>
<li>
<p><a href="#CACBFGDD">DDL Statements That Can Be Parallelized</a></p>
</li>
<li>
<p><a href="#i1006600">CREATE TABLE ... AS SELECT in Parallel</a></p>
</li>
<li>
<p><a href="#i1006628">Recoverability and Parallel DDL</a></p>
</li>
<li>
<p><a href="#i1006645">Space Management for Parallel DDL</a></p>
</li>
<li>
<p><a href="#BEIBFHFB">Storage Space When Using Dictionary-Managed Tablespaces</a></p>
</li>
<li>
<p><a href="#BEICCJCD">Rules for DDL Statements</a></p>
</li>
<li>
<p><a href="#BEIBEFDD">Rules for [CREATE | REBUILD] INDEX or [MOVE | SPLIT] PARTITION</a></p>
</li>
<li>
<p><a href="#BEIHIIBI">Rules for CREATE TABLE AS SELECT</a></p>
</li>
</ul>
<a id="CACBFGDD"></a><a id="VLDBG1412"></a>
<div class="sect3">
<h3 class="sect3">DDL Statements That Can Be Parallelized</h3>
<p>You can execute DDL statements in parallel for tables and indexes that are nonpartitioned or partitioned. <a href="#CACCAGCH">Table 8-2</a> summarizes the operations that can be executed in parallel in DDL statements.</p>
<p>The parallel DDL statements for nonpartitioned tables and indexes are:</p>
<ul>
<li>
<p><code>CREATE</code> <code>INDEX</code></p>
</li>
<li>
<p><code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code></p>
</li>
<li>
<p><code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code></p>
</li>
</ul>
<p><a id="sthref957"></a><a id="sthref958"></a>The parallel DDL statements for partitioned tables and indexes are:</p>
<ul>
<li>
<p><code>CREATE</code> <code>INDEX</code></p>
</li>
<li>
<p><code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code></p>
</li>
<li>
<p><code>ALTER</code> <code>TABLE</code> ... [<code>MOVE|SPLIT|COALESCE]</code> <code>PARTITION</code></p>
</li>
<li>
<p><code>ALTER</code> <code>INDEX</code> ... [<code>REBUILD|SPLIT</code>] <code>PARTITION</code></p>
<ul>
<li>
<p>This statement can be executed in parallel only if the (global) index partition being split is usable.</p>
</li>
</ul>
</li>
</ul>
<p><a id="sthref959"></a><a id="sthref960"></a>All of these DDL operations can be performed in <code>NOLOGGING</code> mode for either parallel or serial execution.</p>
<p><code>The <a id="sthref961"></a><a id="sthref962"></a><a id="sthref963"></a>CREATE</code> <code>TABLE</code> statement for an index-organized table can be executed in parallel either with or without an <code>AS</code> <code>SELECT</code> clause.</p>
<p>Different parallelism is used for different operations (see <a href="#CACCAGCH">Table 8-2</a>). Parallel <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statements on partitioned tables and parallel <code>CREATE</code> <code>INDEX</code> statements on partitioned indexes execute with a DOP equal to the number of partitions.</p>
<p><a id="sthref964"></a><a id="sthref965"></a><a id="sthref966"></a><a id="sthref967"></a><a id="sthref968"></a>Parallel DDL cannot occur on tables with object columns. Parallel DDL cannot occur on nonpartitioned tables with <code>LOB</code> columns.</p>
</div>
<!-- class="sect3" -->
<a id="i1006600"></a><a id="VLDBG1413"></a>
<div class="sect3">
<h3 class="sect3">CREATE TABLE ... AS SELECT in Parallel</h3>
<p><a id="sthref969"></a>Parallel execution<a id="sthref970"></a><a id="sthref971"></a><a id="sthref972"></a><a id="sthref973"></a><a id="sthref974"></a><a id="sthref975"></a><a id="sthref976"></a> lets you execute the query in parallel and create operations of creating a table as a subquery from another table or set of tables. This can be extremely useful in the creation of summary or rollup tables.</p>
<p>Clustered tables cannot be created and populated in parallel.</p>
<p><a href="#i1006622">Figure 8-4</a> illustrates creating a summary table from a subquery in parallel.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006622"></a><a id="VLDBG1414"></a>Figure 8-4 Creating a Summary Table in Parallel</p>
<img width="653" height="366" src="img/vldbg012.gif" alt="Description of Figure 8-4 follows" /><br />
<a id="sthref977" href="img_text/vldbg012.htm">Description of "Figure 8-4 Creating a Summary Table in Parallel"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="i1006628"></a><a id="VLDBG1415"></a>
<div class="sect3">
<h3 class="sect3">Recoverability and Parallel DDL</h3>
<p><a id="sthref978"></a><a id="sthref979"></a>Parallel DDL is often used to create summary tables or do massive data loads that are standalone transactions, which do not always need to be recoverable. By switching off Oracle Database logging, no undo or redo log is generated, so the parallel DML operation is likely to perform better, but becomes an <span class="italic">all</span> <span class="italic">or</span> <span class="italic">nothing</span> operation. In other words, if the operation fails, for whatever reason, you must completely redo the operation, it is not possible to restart it.</p>
<p>If you disable logging during parallel table creation (or any other parallel DDL operation), you should back up the tablespace containing the table after the table is created to avoid loss of the table due to media failure.</p>
<p>Use the <code>NOLOGGING</code> clause of the <code>CREATE</code> <code>TABLE</code>, <code>CREATE</code> <code>INDEX</code>, <code>ALTER</code> <code>TABLE</code>, and <code>ALTER</code> <code>INDEX</code> statements to disable undo and redo log generation.</p>
</div>
<!-- class="sect3" -->
<a id="i1006645"></a><a id="VLDBG1416"></a>
<div class="sect3">
<h3 class="sect3">Space Management for Parallel DDL</h3>
<p><a id="sthref980"></a>Creating a table or index in parallel has space management implications that affect both the storage space required during a parallel operation and the free space available after a table or index has been created.</p>
</div>
<!-- class="sect3" -->
<a id="BEIBFHFB"></a><a id="VLDBG1417"></a>
<div class="sect3">
<h3 class="sect3">Storage Space When Using Dictionary-Managed Tablespaces</h3>
<p><a id="sthref981"></a><a id="sthref982"></a><a id="sthref983"></a>When creating a table or index in parallel, each parallel execution server uses the values in the <code>STORAGE</code> clause of the <code>CREATE</code> statement to create temporary segments to store the rows. Therefore, a table created with a <code>NEXT</code> setting of 4 MB and a <code>PARALLEL</code> <code>DEGREE</code> of 16 consumes at least 64 megabytes (MB) of storage during table creation because each parallel server process starts with an extent of 4 MB. When the parallel execution coordinator combines the segments, some segments may be trimmed, and the resulting table may be smaller than the requested 64 MB.</p>
</div>
<!-- class="sect3" -->
<a id="i1006671"></a><a id="VLDBG1418"></a>
<div class="sect3">
<h3 class="sect3">Free Space and Parallel DDL</h3>
<p><a id="sthref984"></a><a id="sthref985"></a><a id="sthref986"></a><a id="sthref987"></a><a id="sthref988"></a>When you create indexes and tables in parallel, each parallel execution server allocates a new extent and fills the extent with the table or index data. Thus, if you create an index with a DOP of 4, the index has at least four extents initially. This allocation of extents is the same for rebuilding indexes in parallel and for moving, splitting, or rebuilding partitions in parallel.</p>
<p>Serial operations require the schema object to have at least one extent. Parallel creations require that tables or indexes have at least as many extents as there are parallel execution servers creating the schema object.</p>
<p><a id="sthref989"></a><a id="sthref990"></a><a id="sthref991"></a>When you create a table or index in parallel, it is possible to create areas of free space. This occurs when the temporary segments used by the parallel execution servers are larger than what is needed to store the rows.</p>
<ul>
<li>
<p><a id="sthref992"></a><a id="sthref993"></a>If the unused space in each temporary segment is larger than the value of the <code>MINIMUM</code> <code>EXTENT</code> parameter set at the tablespace level, then Oracle Database trims the unused space when merging rows from all of the temporary segments into the table or index. The unused space is returned to the system free space and can be allocated for new extents, but it cannot be coalesced into a larger segment because it is not contiguous space (external fragmentation).</p>
</li>
<li>
<p>If the unused space in each temporary segment is smaller than the value of the <code>MINIMUM</code> <code>EXTENT</code> parameter, then unused space cannot be trimmed when the rows in the temporary segments are merged. This unused space is not returned to the system free space; it becomes part of the table or index (internal fragmentation) and is available only for subsequent insertions or for updates that require additional space.</p>
</li>
</ul>
<p>For example, if you specify a DOP of 3 for a <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statement, but there is only one data file in the tablespace, then internal fragmentation may occur, as shown in <a href="#i1006705">Figure 8-5</a>. The areas of free space within the internal table extents of a data file cannot be coalesced with other free space and cannot be allocated as extents.</p>
<p>See <a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about creating tables and indexes in parallel.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006705"></a><a id="VLDBG1419"></a>Figure 8-5 Unusable Free Space (Internal Fragmentation)</p>
<img width="662" height="452" src="img/vldbg014.gif" alt="Description of Figure 8-5 follows" /><br />
<a id="sthref994" href="img_text/vldbg014.htm">Description of "Figure 8-5 Unusable Free Space (Internal Fragmentation)"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="BEICCJCD"></a><a id="VLDBG1420"></a>
<div class="sect3">
<h3 class="sect3">Rules for DDL Statements</h3>
<p>You must consider the following topics when parallelizing DDL statements:</p>
<ul>
<li>
<p><a href="#BEIDJFGJ">Decision to Parallelize</a></p>
</li>
<li>
<p><a href="#BEIDDIHF">Degree of Parallelism</a></p>
</li>
</ul>
<a id="BEIDJFGJ"></a><a id="VLDBG1421"></a>
<div class="sect4">
<h4 class="sect4">Decision to Parallelize</h4>
<p>DDL operations can be executed in parallel if a <code>PARALLEL</code> clause (declaration) is specified in the syntax. For <code>CREATE</code> <code>INDEX</code> and <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> or <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> <code>PARTITION</code>, the parallel declaration is stored in the data dictionary.</p>
<p><a id="sthref995"></a>You can use the <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code> statement to override the parallel clauses of subsequent DDL statements in a session.</p>
</div>
<!-- class="sect4" -->
<a id="BEIDDIHF"></a><a id="VLDBG1422"></a>
<div class="sect4">
<h4 class="sect4">Degree of Parallelism</h4>
<p>The DOP is determined by the specification in the <code>PARALLEL</code> clause, unless it is overridden by an <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code> statement. A rebuild of a partitioned index is never executed in parallel.</p>
<p>Parallel clauses in <code>CREATE</code> <code>TABLE</code> and <code>ALTER</code> <code>TABLE</code> statements specify table parallelism. If a parallel clause exists in a table definition, it determines the parallelism of DDL statements and queries. If the DDL statement contains explicit parallel hints for a table, however, those hints override the effect of parallel clauses for that table. You can use the <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code> statement to override parallel clauses.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEIBEFDD"></a><a id="VLDBG1423"></a>
<div class="sect3">
<h3 class="sect3">Rules for [CREATE | REBUILD] INDEX or [MOVE | SPLIT] PARTITION</h3>
<p>The rules for creating and altering indexes are discussed in the following topics:</p>
<ul>
<li>
<p><a href="#BEIGCBFG">Parallel CREATE INDEX or ALTER INDEX ... REBUILD</a></p>
</li>
<li>
<p><a href="#BEICHHII">Parallel MOVE PARTITION or SPLIT PARTITION</a></p>
</li>
</ul>
<a id="BEIGCBFG"></a><a id="VLDBG1424"></a>
<div class="sect4">
<h4 class="sect4">Parallel CREATE INDEX or ALTER INDEX ... REBUILD</h4>
<p><a id="sthref996"></a><a id="sthref997"></a><a id="sthref998"></a><a id="sthref999"></a>The <code>CREATE</code> <code>INDEX</code> and <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> statements can be parallelized only by a <code>PARALLEL</code> clause or an <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code> statement.</p>
<p>The <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> statement can be parallelized only for a nonpartitioned index, but <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> <code>PARTITION</code> can be parallelized by a <code>PARALLEL</code> clause or an <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code> statement.</p>
<p>The scan operation for <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> (nonpartitioned), <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> <code>PARTITION</code>, and <code>CREATE</code> <code>INDEX</code> has the same parallelism as the <code>REBUILD</code> or <code>CREATE</code> operation and uses the same DOP. If the DOP is not specified for <code>REBUILD</code> or <code>CREATE</code>, the default is the number of CPUs.</p>
</div>
<!-- class="sect4" -->
<a id="BEICHHII"></a><a id="VLDBG1425"></a>
<div class="sect4">
<h4 class="sect4">Parallel MOVE PARTITION or SPLIT PARTITION</h4>
<p><a id="sthref1000"></a><a id="sthref1001"></a><a id="sthref1002"></a><a id="sthref1003"></a>The <code>ALTER</code> <code>INDEX</code> <code>... MOVE</code> <code>PARTITION</code> and <code>ALTER</code> <code>IN</code><code>DEX</code> ...<code>SPLIT</code> <code>PARTITION</code> statements can be parallelized only by a <code>PARALLEL</code> clause or an <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code> statement. Their scan operations have the same parallelism as the corresponding <code>MOVE</code> or <code>SPLIT</code> operations. If the DOP is not specified, the default is the number of CPUs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If <code>PARALLEL_DEGREE_POLICY</code> is set to <code>AUTO</code>, then statement-level parallelism is ignored.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEIHIIBI"></a><a id="VLDBG1426"></a>
<div class="sect3">
<h3 class="sect3">Rules for CREATE TABLE AS SELECT</h3>
<p><a id="sthref1004"></a>The <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statement contains two parts: a <code>CREATE</code> part (DDL) and a <code>SELECT</code> part (query). <a id="sthref1005"></a>Oracle Database can parallelize both parts of the statement. The <code>CREATE</code> part follows the same rules as other DDL operations.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BEIFIDIE">Decision to Parallelize (Query Part)</a></p>
</li>
<li>
<p><a href="#BEIIADHH">Degree of Parallelism (Query Part)</a></p>
</li>
<li>
<p><a href="#BEIHHJBF">Decision to Parallelize (CREATE Part)</a></p>
</li>
<li>
<p><a href="#BEIGBABB">Degree of Parallelism (CREATE Part)</a></p>
</li>
</ul>
<a id="BEIFIDIE"></a><a id="VLDBG1427"></a>
<div class="sect4">
<h4 class="sect4">Decision to Parallelize (Query Part)</h4>
<p>The query part of a <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statement can be parallelized only if the following conditions are satisfied:</p>
<ul>
<li>
<p>The query includes a parallel hint specification (<code>PARALLEL</code> or <code>PARALLEL_INDEX</code>) or the <code>CREATE</code> part of the statement has a <code>PARALLEL</code> clause specification or the schema objects referred to in the query have a <code>PARALLEL</code>&nbsp;declaration associated with them.</p>
</li>
<li>
<p>At least one table specified in the query requires either a full table scan or an index range scan spanning multiple partitions.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="BEIIADHH"></a><a id="VLDBG1428"></a>
<div class="sect4">
<h4 class="sect4">Degree of Parallelism (Query Part)</h4>
<p>The DOP for the query part of a <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statement is determined by one of the following rules:</p>
<ul>
<li>
<p>The query part uses the values specified in the <code>PARALLEL</code> clause of the <code>CREATE</code> part.</p>
</li>
<li>
<p>If the <code>PARALLEL</code> clause is not specified, the default DOP is the number of CPUs.</p>
</li>
<li>
<p>If the <code>CREATE</code> is serial, then the DOP is determined by the query.</p>
</li>
</ul>
<p>Note that any values specified in a hint for parallelism are ignored.</p>
</div>
<!-- class="sect4" -->
<a id="BEIHHJBF"></a><a id="VLDBG1429"></a>
<div class="sect4">
<h4 class="sect4">Decision to Parallelize (CREATE Part)</h4>
<p><a id="sthref1006"></a>The <code>CREATE</code> operation of <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> can be parallelized only by a <code>PARALLEL</code> clause or an <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code> statement.</p>
<p>When the <code>CREATE</code> operation of <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> is parallelized, Oracle Database also parallelizes the scan operation if possible. The scan operation cannot be parallelized if, for example:</p>
<ul>
<li>
<p>The <code>SELECT</code> clause has a <code>NO_PARALLEL</code> hint.</p>
</li>
<li>
<p>The operation scans an index of a nonpartitioned table.</p>
</li>
</ul>
<p>When the <code>CREATE</code> operation is not parallelized, the <code>SELECT</code> can be parallelized if it has a <code>PARALLEL</code> hint or if the selected table (or partitioned index) has a parallel declaration.</p>
</div>
<!-- class="sect4" -->
<a id="BEIGBABB"></a><a id="VLDBG1430"></a>
<div class="sect4">
<h4 class="sect4">Degree of Parallelism (CREATE Part)</h4>
<p>The DOP for the <code>CREATE</code> operation, and for the <code>SELECT</code> operation if it is parallelized, is specified by the <code>PARALLEL</code> clause of the <code>CREATE</code> statement, unless it is overridden by an <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code> statement. If the <code>PARALLEL</code> clause does not specify the DOP, the default is the number of CPUs.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006712"></a><a id="VLDBG1431"></a>
<div class="sect2">
<h2 class="sect2">About Parallel DML Operations</h2>
<p><a id="sthref1007"></a><a id="sthref1008"></a>Parallel DML (<code>PARALLEL</code> <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>MERGE</code>) uses parallel execution mechanisms to speed up or scale up large DML operations against large database tables and indexes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although DML generally includes queries, in this chapter the term DML refers only to <code>INSERT</code>, <code>UPDATE</code>, <code>MERGE</code>, and <code>DELETE</code> operations.</div>
<p>This section discusses the following parallel DML topics:</p>
<ul>
<li>
<p><a href="#i1006771">When to Use Parallel DML</a></p>
</li>
<li>
<p><a href="#CACFJJGG">Enabling Parallel DML</a></p>
</li>
<li>
<p><a href="#i1006876">Transaction Restrictions for Parallel DML</a></p>
</li>
<li>
<p><a href="#i1006893">Rollback Segments</a></p>
</li>
<li>
<p><a href="#i1006906">Recovery for Parallel DML</a></p>
</li>
<li>
<p><a href="#i1006938">Space Considerations for Parallel DML</a></p>
</li>
<li>
<p><a href="#CACEJACE">Restrictions on Parallel DML</a></p>
</li>
<li>
<p><a href="#BEIFGEHC">Data Integrity Restrictions</a></p>
</li>
<li>
<p><a href="#BEICCEJJ">Trigger Restrictions</a></p>
</li>
<li>
<p><a href="#i1007101">Distributed Transaction Restrictions</a></p>
</li>
<li>
<p><a href="#BEICAIHF">Examples of Distributed Transaction Parallelization</a></p>
</li>
</ul>
<a id="i1006771"></a><a id="VLDBG1432"></a>
<div class="sect3">
<h3 class="sect3">When to Use Parallel DML</h3>
<p><a id="sthref1009"></a><span class="italic"><a id="sthref1010"></a><a id="sthref1011"></a></span><a id="sthref1012"></a><a id="sthref1013"></a><a id="sthref1014"></a><a id="sthref1015"></a><a id="sthref1016"></a>Parallel DML is useful in a decision support system (DSS) environment where the performance and scalability of accessing large objects are important. Parallel DML complements parallel query in providing you with both querying and updating capabilities for your DSS databases.</p>
<p><a id="sthref1017"></a>The overhead of setting up parallelism makes parallel DML operations not feasible for short OLTP transactions. However, parallel DML operations can speed up batch jobs running in an OLTP database.</p>
<p>Several scenarios where parallel DML is used include:</p>
<ul>
<li>
<p><a href="#i1006805">Refreshing Tables in a Data Warehouse System</a></p>
</li>
<li>
<p><a href="#CIHCJHFJ">Creating Intermediate Summary Tables</a></p>
</li>
<li>
<p><a href="#i1006824">Using Scoring Tables</a></p>
</li>
<li>
<p><a href="#i1006829">Updating Historical Tables</a></p>
</li>
<li>
<p><a href="#i1006836">Running Batch Jobs</a></p>
</li>
</ul>
<a id="i1006805"></a><a id="VLDBG1433"></a>
<div class="sect4">
<h4 class="sect4">Refreshing Tables in a Data Warehouse System</h4>
<p><a id="sthref1018"></a><a id="sthref1019"></a><a id="sthref1020"></a>In a data warehouse system, large tables must be refreshed (updated) periodically with new or modified data from the production system. You can do this efficiently by using the <code>MERGE</code> statement.</p>
</div>
<!-- class="sect4" -->
<a id="CIHCJHFJ"></a><a id="VLDBG1434"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4">Creating Intermediate Summary Tables</h4>
<p>In a DSS environment, many applications require complex computations that involve constructing and manipulating many large intermediate summary tables. These summary tables are often temporary and frequently do not need to be logged. Parallel DML can speed up the operations against these large intermediate tables. One benefit is that you can put incremental results in the intermediate tables and perform parallel updates.</p>
<p>In addition, the summary tables may contain cumulative or comparative information which has to persist beyond application sessions; thus, temporary tables are not feasible. Parallel DML operations can speed up the changes to these large summary tables.</p>
</div>
<!-- class="sect4" -->
<a id="i1006824"></a><a id="VLDBG1435"></a>
<div class="sect4">
<h4 class="sect4">Using Scoring Tables</h4>
<p><span class="italic"><a id="sthref1021"></a></span>Many DSS applications score customers periodically based on a set of criteria. The scores are usually stored in large DSS tables. The score information is then used in making a decision, for example, inclusion in a mailing list.</p>
<p>This scoring activity queries and updates a large number of rows in the table. Parallel DML can speed up the operations against these large tables.</p>
</div>
<!-- class="sect4" -->
<a id="i1006829"></a><a id="VLDBG1436"></a>
<div class="sect4">
<h4 class="sect4">Updating Historical Tables</h4>
<p><a id="sthref1022"></a><a id="sthref1023"></a>Historical tables describe the business transactions of an enterprise over a recent time interval. Periodically, the DBA deletes the set of oldest rows and inserts a set of new rows into the table. Parallel <code>INSERT</code> ... <code>SELECT</code> and parallel <code>DELETE</code> operations can speed up this rollover task.</p>
<p>Dropping a partition can also be used to delete old rows. However, the table has to be partitioned by date and with the appropriate time interval.</p>
</div>
<!-- class="sect4" -->
<a id="i1006836"></a><a id="VLDBG1437"></a>
<div class="sect4">
<h4 class="sect4">Running Batch Jobs</h4>
<p><a id="sthref1024"></a><a id="sthref1025"></a>Batch jobs executed in an OLTP database during off hours have a fixed time during which the jobs must complete. A good way to ensure timely job completion is to execute their operations in parallel. As the workload increases, more computer resources can be added; the scaleup property of parallel operations ensures that the time constraint can be met.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CACFJJGG"></a><a id="VLDBG1438"></a>
<div class="sect3">
<h3 class="sect3">Enabling Parallel DML</h3>
<p><a id="sthref1026"></a><a id="sthref1027"></a><a id="sthref1028"></a>A DML statement can be parallelized only if you have explicitly enabled parallel DML in the session, as in the following statement:</p>
<pre>
ALTER SESSION ENABLE PARALLEL DML;
</pre>
<p>This mode is required because parallel DML and serial DML have different locking, transaction, and disk space requirements and parallel DML is disabled for a session by default.</p>
<p>When parallel DML is disabled, no DML is executed in parallel even if the <code>PARALLEL</code> hint is used.</p>
<p>When parallel DML is enabled in a session, all DML statements in this session are considered for parallel execution. However, even if parallel DML is enabled, the DML operation may still execute serially if there are no parallel hints or no tables with a parallel attribute or if restrictions on parallel operations are violated.</p>
<p>The session's <code>PARALLEL</code> <code>DML</code> mode does not influence the parallelism of <code>SELECT</code> statements, DDL statements, and the query portions of DML statements. Thus, if this mode is not set, the DML operation is not parallelized, but scans or join operations within the DML statement may still be parallelized.</p>
<p>For more information, refer to <a href="#i1006938">"Space Considerations for Parallel DML"</a> and <a href="#CACEJACE">"Restrictions on Parallel DML"</a>.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1439"></a>
<div class="sect3"><a id="sthref1029"></a>
<h3 class="sect3">Rules for UPDATE, MERGE, and DELETE</h3>
<p><a id="sthref1030"></a><a id="sthref1031"></a><a id="sthref1032"></a><a id="sthref1033"></a><a id="sthref1034"></a><a id="sthref1035"></a>You have two ways to specify parallel directives for <code>UPDATE</code>, <code>MERGE</code>, and <code>DELETE</code> operations (if <code>PARALLEL</code> <code>DML</code> mode is enabled):</p>
<ul>
<li>
<p>Use a parallel clause in the definition of the table being updated or deleted (the reference object).</p>
</li>
<li>
<p>Use an update, merge, or delete parallel hint in the statement.</p>
</li>
</ul>
<p><a id="sthref1036"></a>Parallel hints are placed immediately after the <code>UPDATE</code>, <code>MERGE</code>, or <code>DELETE</code> keywords in <code>UPDATE</code>, <code>MERGE</code>, and <code>DELETE</code> statements. The hint also applies to the underlying scan of the table being changed.</p>
<p><a id="sthref1037"></a>You can use the <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DML</code> statement to override parallel clauses for subsequent <code>UPDATE</code>, <code>MERGE</code>, and <code>DELETE</code> statements in a session. Parallel hints in <code>UPDATE</code>, <code>MERGE</code>, and <code>DELETE</code> statements override the <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DML</code> statement.</p>
<p>For possible limitations, see <a href="parallel007.htm#i1009083">"Limitation on the Degree of Parallelism"</a>.</p>
<a id="VLDBG1440"></a>
<div class="sect4"><a id="sthref1038"></a>
<h4 class="sect4">Decision to Parallelize</h4>
<p>The following rule determines whether the <code>UPDATE</code>, <code>MERGE</code>, or <code>DELETE</code> operation should be executed in parallel:</p>
<p>The <code>UPDATE</code> or <code>DELETE</code> operation is parallelized if and only if at least one of the following is true:</p>
<ul>
<li>
<p>The table being updated or deleted has a <code>PARALLEL</code> specification.</p>
</li>
<li>
<p>The <code>PARALLEL</code> hint is specified in the DML statement.</p>
</li>
<li>
<p><a id="sthref1039"></a>An <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DML</code> statement has been issued previously during the session.</p>
</li>
</ul>
<p>If the statement contains subqueries or updatable views, then they may have their own separate parallel hints or clauses. However, these parallel directives do not affect the decision to parallelize the <code>UPDATE</code>, <code>MERGE</code>, or <code>DELETE</code> operations.</p>
<p>The parallel hint or clause on the tables is used by both the query and the <code>UPDATE</code>, <code>MERGE</code>, <code>DELETE</code> portions to determine parallelism, the decision to parallelize the <code>UPDATE</code>, <code>MERGE</code>, or <code>DELETE</code> portion is independent of the query portion, and vice versa.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1441"></a>
<div class="sect4"><a id="sthref1040"></a>
<h4 class="sect4">Degree of Parallelism</h4>
<p>The DOP is determined by the same rules as for the queries. Note that, for <code>UPDATE</code> and <code>DELETE</code> operations, only the target table to be modified (the only reference object) is involved. Thus, the <code>UPDATE</code> or <code>DELETE</code> parallel hint specification takes precedence over the parallel declaration specification of the target table. In other words, the precedence order is: <code>MERGE</code>, <code>UPDATE</code>, <code>DELETE</code> hint, then Session, and then Parallel declaration specification of target table. See <a href="#CACCAGCH">Table 8-2</a> for precedence rules.</p>
<p><a id="sthref1041"></a><a id="sthref1042"></a>If the DOP is less than the number of partitions, then the first process to finish work on one partition continues working on another partition, and so on until the work is finished on all partitions. If the DOP is greater than the number of partitions involved in the operation, then the excess parallel execution servers have no work to do.</p>
<p><a href="#BEIIBHDE">Example 8-4</a> illustrates an update operation that might be executed in parallel. If <code>tbl_1</code> is a partitioned table and its table definition has a parallel clause and if the table has multiple partitions with <code>c1</code> greater than 100, then the update operation is parallelized even if the scan on the table is serial (such as an index scan).</p>
<div class="example">
<p class="titleinexample"><a id="BEIIBHDE"></a><a id="VLDBG1442"></a>Example 8-4 Parallelization: Example 1</p>
<pre>
UPDATE tbl_1 SET c1=c1+1 WHERE c1&gt;100;
</pre>
<p><a href="#BEIBHBBI">Example 8-5</a> illustrates an update operation with a <code>PARALLEL</code> hint. Both the scan and update operations on <code>tbl_2</code> are executed in parallel with degree four.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BEIBHBBI"></a><a id="VLDBG1443"></a>Example 8-5 Parallelization: Example 2</p>
<pre>
UPDATE /*+ PARALLEL(tbl_2,4) */ tbl_2 SET c1=c1+1;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1007618"></a><a id="VLDBG1444"></a>
<div class="sect3">
<h3 class="sect3">Rules for INSERT ... SELECT</h3>
<p><a id="sthref1043"></a>An <code>INSERT</code> ... <code>SELECT</code> statement parallelizes its <code>INSERT</code> and <code>SELECT</code> operations independently, except for the DOP.</p>
<p>You can specify a parallel hint after the <code>INSERT</code> keyword in an <code>INSERT</code> ... <code>SELECT</code> statement. Because the tables being queried are usually different than the table being inserted into, the hint enables you to specify parallel directives specifically for the insert operation.</p>
<p>You have the following ways to specify parallel directives for an <code>INSERT</code> ... <code>SELECT</code> statement (if <code>PARALLEL</code> <code>DML</code> mode is enabled):</p>
<ul>
<li>
<p><code>SELECT</code> parallel hints specified at the statement</p>
</li>
<li>
<p>Parallel clauses specified in the definition of tables being selected</p>
</li>
<li>
<p><code>INSERT</code> parallel hint specified at the statement</p>
</li>
<li>
<p>Parallel clause specified in the definition of tables being inserted into</p>
</li>
</ul>
<p><a id="sthref1044"></a>You can use the <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DML</code> statement to override parallel clauses for subsequent <code>INSERT</code> operations in a session. Parallel hints in insert operations override the <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DML</code> statement.</p>
<a id="VLDBG1445"></a>
<div class="sect4"><a id="sthref1045"></a>
<h4 class="sect4">Decision to Parallelize</h4>
<p>The following rule determines whether the <code>INSERT</code> operation should be parallelized in an <code>INSERT</code> ... <code>SELECT</code> statement:</p>
<p>The <code>INSERT</code> operation is executed in parallel if and only if at least one of the following is true:</p>
<ul>
<li>
<p>The <code>PARALLEL</code> hint is specified after the <code>INSERT</code> in the DML statement.</p>
</li>
<li>
<p>The table being inserted into (the reference object) has a <code>PARALLEL</code> declaration specification.</p>
</li>
<li>
<p><a id="sthref1046"></a>An <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> <code>DML</code> statement has been issued previously during the session.</p>
</li>
</ul>
<p>The decision to parallelize the <code>INSERT</code> operation is independent of the <code>SELECT</code> operation, and vice versa.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1446"></a>
<div class="sect4"><a id="sthref1047"></a>
<h4 class="sect4">Degree of Parallelism</h4>
<p>After the decision to parallelize the <code>SELECT</code> or <code>INSERT</code> operation is made, one parallel directive is picked for deciding the DOP of the whole statement, using the following precedence rule Insert hint directive, then Session, then Parallel declaration specification of the inserting table, and then Maximum query directive.</p>
<p>In this context, maximum query directive means that among multiple tables and indexes, the table or index that has the maximum DOP determines the parallelism for the query operation.</p>
<p>In <a href="#BEIEDAAJ">Example 8-6</a>, the chosen parallel directive is applied to both the <code>SELECT</code> and <code>INSERT</code> operations.</p>
<div class="example">
<p class="titleinexample"><a id="BEIEDAAJ"></a><a id="VLDBG1447"></a>Example 8-6 Parallelization: Example 3</p>
<p>The DOP used is 2, as specified in the <code>INSERT</code> hint:</p>
<pre>
INSERT /*+ PARALLEL(tbl_ins,2) */ INTO tbl_ins
SELECT /*+ PARALLEL(tbl_sel,4) */ * FROM tbl_sel;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1006876"></a><a id="VLDBG1448"></a>
<div class="sect3">
<h3 class="sect3">Transaction Restrictions for Parallel DML</h3>
<p><a id="sthref1048"></a><a id="sthref1049"></a>To execute a DML operation in parallel, the parallel execution coordinator acquires parallel execution servers, and each parallel execution server executes a portion of the work under its own parallel process transaction.</p>
<p>Note the following conditions:</p>
<ul>
<li>
<p>Each parallel execution server creates a different parallel process transaction.</p>
</li>
<li>
<p>If you use rollback segments instead of Automatic Undo Management, you may want to reduce contention on the rollback segments by limiting the number of parallel process transactions residing in the same rollback segment. See <a class="olink SQLRF01610" href="../../server.112/e41084/statements_9021.htm#SQLRF01610"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
</li>
</ul>
<p>The coordinator also has its own coordinator transaction, which can have its own rollback segment. To ensure user-level transactional atomicity, the coordinator uses a two-phase commit protocol to commit the changes performed by the parallel process transactions.</p>
<p>A session that is enabled for parallel DML may put transactions in the session in a special mode: If any DML statement in a transaction modifies a table in parallel, no subsequent serial or parallel query or DML statement can access the same table again in that transaction. The results of parallel modifications cannot be seen during the transaction.</p>
<p>Serial or parallel statements that attempt to access a table that has been modified in parallel within the same transaction are rejected with an error message.</p>
<p>If a PL/SQL procedure or block is executed in a parallel DML-enabled session, then this rule applies to statements in the procedure or block.</p>
</div>
<!-- class="sect3" -->
<a id="i1006893"></a><a id="VLDBG1449"></a>
<div class="sect3">
<h3 class="sect3">Rollback Segments</h3>
<p>If you use rollback segments instead of Automatic Undo Management, there are some restrictions when using parallel DML. See <a class="olink SQLRF01610" href="../../server.112/e41084/statements_9021.htm#SQLRF01610"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about restrictions for parallel DML and rollback segments.</p>
</div>
<!-- class="sect3" -->
<a id="i1006906"></a><a id="VLDBG1450"></a>
<div class="sect3">
<h3 class="sect3">Recovery for Parallel DML</h3>
<p><a id="sthref1050"></a><a id="sthref1051"></a>The time required to roll back a parallel DML operation is roughly equal to the time it takes to perform the forward operation.</p>
<p>Oracle Database supports parallel rollback after transaction and process failures, and after instance and system failures. Oracle Database can parallelize both the rolling forward stage and the rolling back stage of transaction recovery.</p>
<p>See <a class="olink BRADV" href="../../backup.112/e10642/toc.htm"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for details about parallel rollback.</p>
<a id="VLDBG1451"></a>
<div class="sect4"><a id="sthref1052"></a>
<h4 class="sect4">Transaction Recovery for User-Issued Rollback</h4>
<p>A user-issued rollback in a transaction failure due to statement error is performed in parallel by the parallel execution coordinator and the parallel execution servers. The rollback takes approximately the same amount of time as the forward transaction.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1452"></a>
<div class="sect4"><a id="sthref1053"></a>
<h4 class="sect4">Process Recovery</h4>
<p><a id="sthref1054"></a>Recovery from the failure of a parallel execution coordinator or parallel execution server is performed by the PMON process. If a parallel execution server or a parallel execution coordinator fails, PMON rolls back the work from that process and all other processes in the transaction roll back their changes.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1453"></a>
<div class="sect4"><a id="sthref1055"></a>
<h4 class="sect4">System Recovery</h4>
<p><a id="sthref1056"></a>Recovery from a system failure requires a new startup. Recovery is performed by the SMON process and any recovery server processes spawned by SMON. Parallel DML statements may be recovered using parallel rollback. If the initialization parameter <code>COMPATIBLE</code> is set to 8.1.3 or greater, Fast-Start On-Demand Rollback enables terminated transactions to be recovered, on demand, one block at a time.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1006938"></a><a id="VLDBG1454"></a>
<div class="sect3">
<h3 class="sect3">Space Considerations for Parallel DML</h3>
<p>Parallel <code>UPDATE</code> uses the existing free space in the object, while direct-path <code>INSERT</code> gets new extents for the data.</p>
<p>Space usage characteristics may be different in parallel than serial execution because multiple concurrent child transactions modify the object.</p>
</div>
<!-- class="sect3" -->
<a id="CACEJACE"></a><a id="VLDBG1455"></a>
<div class="sect3">
<h3 class="sect3">Restrictions on Parallel DML</h3>
<p><a id="sthref1057"></a><a id="sthref1058"></a><a id="sthref1059"></a><a id="sthref1060"></a>The following restrictions apply to parallel DML (including direct-path <code>INSERT</code>):</p>
<ul>
<li>
<p>Intra-partition parallelism for <code>UPDATE</code>, <code>MERGE</code>, and <code>DELETE</code> operations require that the <code>COMPATIBLE</code> initialization parameter be set to 9.2 or greater.</p>
</li>
<li>
<p>The <code>INSERT</code> <code>VALUES</code> statement is never executed in parallel.</p>
</li>
<li>
<p>A transaction can contain multiple parallel DML statements that modify different tables, but after a parallel DML statement modifies a table, no subsequent serial or parallel statement (DML or query) can access the same table again in that transaction.</p>
<ul>
<li>
<p>This restriction also exists after a serial direct-path <code>INSERT</code> statement: no subsequent SQL statement (DML or query) can access the modified table during that transaction.</p>
</li>
<li>
<p>Queries that access the same table are allowed before a parallel DML or direct-path <code>INSERT</code> statement, but not after.</p>
</li>
<li>
<p>Any serial or parallel statements attempting to access a table that has been modified by a parallel <code>UPDATE</code>, <code>DELETE</code>, or <code>MERGE</code>, or a direct-path <code>INSERT</code> during the same transaction are rejected with an error message.</p>
</li>
</ul>
</li>
<li>
<p><a id="sthref1061"></a>Parallel DML operations cannot be done on tables with triggers.</p>
</li>
<li>
<p><a id="sthref1062"></a>Replication functionality is not supported for parallel DML.</p>
</li>
<li>
<p>Parallel DML cannot occur in the presence of certain constraints: self-referential integrity, delete cascade, and deferred integrity. In addition, for direct-path <code>INSERT</code>, there is no support for any referential integrity.</p>
</li>
<li>
<p><a id="sthref1063"></a><a id="sthref1064"></a><a id="sthref1065"></a><a id="sthref1066"></a>Parallel DML can be done on tables with object columns provided the object columns are not accessed.</p>
</li>
<li>
<p><a id="sthref1067"></a><a id="sthref1068"></a><a id="sthref1069"></a><a id="sthref1070"></a>Parallel DML can be done on tables with <code>LOB</code> columns provided the table is partitioned. However, intra-partition parallelism is not supported.</p>
</li>
<li>
<p>A transaction involved in a parallel DML operation cannot be or become a distributed transaction.</p>
</li>
<li>
<p>Clustered tables are not supported.</p>
</li>
<li>
<p>Parallel <code>UPDATE</code>, <code>DELETE</code>, and <code>MERGE</code> operations are not supported for temporary tables.</p>
</li>
</ul>
<p>Violations of these restrictions cause the statement to execute serially without warnings or error messages (except for the restriction on statements accessing the same table in a transaction, which can cause error messages).</p>
<a id="VLDBG1456"></a>
<div class="sect4"><a id="sthref1071"></a>
<h4 class="sect4">Partitioning Key Restriction</h4>
<p>You can only update the partitioning key of a partitioned table to a new value if the update does not cause the row to move to a new partition. The update is possible if the table is defined with the row movement clause enabled.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1457"></a>
<div class="sect4"><a id="sthref1072"></a>
<h4 class="sect4">Function Restrictions</h4>
<p>The function restrictions for parallel DML are the same as those for parallel DDL and parallel query. See <a href="#i1007127">"About Parallel Execution of Functions"</a> for more information.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEIFGEHC"></a><a id="VLDBG1458"></a>
<div class="sect3">
<h3 class="sect3">Data Integrity Restrictions</h3>
<p><a id="sthref1073"></a><a id="sthref1074"></a>This section describes the interactions of integrity constraints and parallel DML statements.</p>
<a id="VLDBG1459"></a>
<div class="sect4"><a id="sthref1075"></a>
<h4 class="sect4">NOT NULL and CHECK</h4>
<p>These types of integrity constraints are allowed. They are not a problem for parallel DML because they are enforced on the column and row level, respectively.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1460"></a>
<div class="sect4"><a id="sthref1076"></a>
<h4 class="sect4">UNIQUE and PRIMARY KEY</h4>
<p>These types of integrity constraints are allowed.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1461"></a>
<div class="sect4"><a id="sthref1077"></a>
<h4 class="sect4">FOREIGN KEY (Referential Integrity)</h4>
<p>Restrictions for referential integrity occur whenever a DML operation on one table could cause a recursive DML operation on another table. These restrictions also apply when, to perform an integrity check, it is necessary to see simultaneously all changes made to the object being modified.</p>
<p><a href="#g1016143">Table 8-1</a> lists all of the operations that are possible on tables that are involved in referential integrity constraints.</p>
<div class="tblformal">
<p class="titleintable"><a id="VLDBG1462"></a><a id="sthref1078"></a><a id="g1016143"></a>Table 8-1 Referential Integrity Restrictions</p>
<table class="cellalignment1838" title="Referential Integrity Restrictions" summary="Referential Integrity Restrictions" dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t11">DML Statement</th>
<th class="cellalignment1836" id="r1c2-t11">Issued on Parent</th>
<th class="cellalignment1836" id="r1c3-t11">Issued on Child</th>
<th class="cellalignment1836" id="r1c4-t11">Self-Referential</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t11" headers="r1c1-t11">
<p><code>INSERT</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t11 r1c2-t11">
<p>(Not applicable)</p>
</td>
<td class="cellalignment1837" headers="r2c1-t11 r1c3-t11">
<p>Not parallelized</p>
</td>
<td class="cellalignment1837" headers="r2c1-t11 r1c4-t11">
<p>Not parallelized</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t11" headers="r1c1-t11">
<p><code>MERGE</code></p>
</td>
<td class="cellalignment1837" headers="r3c1-t11 r1c2-t11">
<p>(Not applicable)</p>
</td>
<td class="cellalignment1837" headers="r3c1-t11 r1c3-t11">
<p>Not parallelized</p>
</td>
<td class="cellalignment1837" headers="r3c1-t11 r1c4-t11">
<p>Not parallelized</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r4c1-t11" headers="r1c1-t11">
<p><code>UPDATE</code> No Action</p>
</td>
<td class="cellalignment1837" headers="r4c1-t11 r1c2-t11">
<p>Supported</p>
</td>
<td class="cellalignment1837" headers="r4c1-t11 r1c3-t11">
<p>Supported</p>
</td>
<td class="cellalignment1837" headers="r4c1-t11 r1c4-t11">
<p>Not parallelized</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r5c1-t11" headers="r1c1-t11">
<p><code>DELETE</code> No Action</p>
</td>
<td class="cellalignment1837" headers="r5c1-t11 r1c2-t11">
<p>Supported</p>
</td>
<td class="cellalignment1837" headers="r5c1-t11 r1c3-t11">
<p>Supported</p>
</td>
<td class="cellalignment1837" headers="r5c1-t11 r1c4-t11">
<p>Not parallelized</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r6c1-t11" headers="r1c1-t11">
<p><code>DELETE</code> Cascade</p>
</td>
<td class="cellalignment1837" headers="r6c1-t11 r1c2-t11">
<p>Not parallelized</p>
</td>
<td class="cellalignment1837" headers="r6c1-t11 r1c3-t11">
<p>(Not applicable)</p>
</td>
<td class="cellalignment1837" headers="r6c1-t11 r1c4-t11">
<p>Not parallelized</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect4" -->
<a id="VLDBG1463"></a>
<div class="sect4"><a id="sthref1079"></a>
<h4 class="sect4">Delete Cascade</h4>
<p>Deletion on tables having a foreign key with delete cascade is not parallelized because parallel execution servers attempt to delete rows from multiple partitions (parent and child tables).</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1464"></a>
<div class="sect4"><a id="sthref1080"></a>
<h4 class="sect4">Self-Referential Integrity</h4>
<p>DML on tables with self-referential integrity constraints is not parallelized if the referenced keys (primary keys) are involved. For DML on all other columns, parallelism is possible.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1465"></a>
<div class="sect4"><a id="sthref1081"></a>
<h4 class="sect4">Deferrable Integrity Constraints</h4>
<p>If any deferrable constraints apply to the table being operated on, the DML operation is not executed in parallel.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEICCEJJ"></a><a id="VLDBG1466"></a>
<div class="sect3">
<h3 class="sect3">Trigger Restrictions</h3>
<p><a id="sthref1082"></a>A DML operation is not executed in parallel if the affected tables contain enabled triggers that may get invoked as a result of the statement. This implies that DML statements on tables that are being replicated are not parallelized.</p>
<p>Relevant triggers must be disabled to parallelize DML on the table. Note that, if you enable or disable triggers, the dependent shared cursors are invalidated.</p>
</div>
<!-- class="sect3" -->
<a id="i1007101"></a><a id="VLDBG1467"></a>
<div class="sect3">
<h3 class="sect3">Distributed Transaction Restrictions</h3>
<p><a id="sthref1083"></a><a id="sthref1084"></a><a id="sthref1085"></a><a id="sthref1086"></a>A DML operation cannot be executed in parallel if it is in a distributed transaction or if the DML or the query operation is on a remote object.</p>
</div>
<!-- class="sect3" -->
<a id="BEICAIHF"></a><a id="VLDBG1468"></a>
<div class="sect3">
<h3 class="sect3">Examples of Distributed Transaction Parallelization</h3>
<p>This section contains several examples of distributed transaction processing.</p>
<p>In <a href="#BEIIBEHF">Example 8-7</a>, the DML statement queries a remote object. The query operation is executed serially without notification because it references a remote object.</p>
<div class="example">
<p class="titleinexample"><a id="BEIIBEHF"></a><a id="VLDBG1469"></a>Example 8-7 Distributed Transaction Parallelization</p>
<pre>
INSERT /*+ APPEND PARALLEL (t3,2) */ INTO t3 SELECT * FROM t4@dblink;
</pre></div>
<!-- class="example" -->
<p>In <a href="#BEIBHCCB">Example 8-8</a>, the DML operation is applied to a remote object. The <code>DELETE</code> operation is not parallelized because it references a remote object.</p>
<div class="example">
<p class="titleinexample"><a id="BEIBHCCB"></a><a id="VLDBG1470"></a>Example 8-8 Distributed Transaction Parallelization</p>
<pre>
DELETE /*+ PARALLEL (t1, 2) */ FROM t1@dblink;
</pre></div>
<!-- class="example" -->
<p>In <a href="#BEIDCJBG">Example 8-9</a>, the DML operation is in a distributed transaction. The <code>DELETE</code> operation is not executed in parallel because it occurs in a distributed transaction (which is started by the <code>SELECT</code> statement).</p>
<div class="example">
<p class="titleinexample"><a id="BEIDCJBG"></a><a id="VLDBG1471"></a>Example 8-9 Distributed Transaction Parallelization</p>
<pre>
SELECT * FROM t1@dblink; 
DELETE /*+ PARALLEL (t2,2) */ FROM t2;
COMMIT; 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007127"></a><a id="VLDBG1472"></a>
<div class="sect2">
<h2 class="sect2">About Parallel Execution of Functions</h2>
<p><a id="sthref1087"></a><a id="sthref1088"></a>SQL statements can contain user-defined functions written in PL/SQL, in Java, or as external procedures in C that can appear as part of the <code>SELECT</code> list, <code>SET</code> clause, or <code>WHERE</code> clause. When the SQL statement is parallelized, these functions are executed on a per-row basis by the parallel execution server process. Any PL/SQL package variables or Java static attributes used by the function are entirely private to each individual parallel execution process and are newly initialized when each row is processed, rather than being copied from the original session. Because of this process, not all functions generate correct results if executed in parallel.</p>
<p>User-written table functions can appear in the statement's <code>FROM</code> list. These functions act like source tables in that they produce row output. Table functions are initialized once during the statement at the start of each parallel execution process. All variables are entirely private to the parallel execution process.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BEIEHJAJ">Functions in Parallel Queries</a></p>
</li>
<li>
<p><a href="#BEIJCAAI">Functions in Parallel DML and DDL Statements</a></p>
</li>
</ul>
<a id="BEIEHJAJ"></a><a id="VLDBG1473"></a>
<div class="sect3">
<h3 class="sect3">Functions in Parallel Queries</h3>
<p><a id="sthref1089"></a><a id="sthref1090"></a>In a <code>SELECT</code> statement or a subquery in a DML or DDL statement, a user-written function may be executed in parallel in any of the following cases:</p>
<ul>
<li>
<p>If it has been declared with the <code>PARALLEL_ENABLE</code> keyword</p>
</li>
<li>
<p>If it is declared in a package or type and has a <code>PRAGMA</code> <code>RESTRICT_REFERENCES</code> clause that indicates all of <code>WNDS</code>, <code>RNPS</code>, and <code>WNPS</code></p>
</li>
<li>
<p>If it is declared with <code>CREATE</code> <code>FUNCTION</code> and the system can analyze the body of the PL/SQL code and determine that the code neither writes to the database nor reads or modifies package variables</p>
</li>
</ul>
<p>Other parts of a query or subquery can sometimes execute in parallel even if a given function execution must remain serial.</p>
<p>Refer to <a class="olink ADFNS" href="../../appdev.112/e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for information about the <code>PRAGMA</code> <code>RESTRICT_REFERENCES</code> clause and <a class="olink SQLRF01208" href="../../server.112/e41084/statements_5011.htm#SQLRF01208"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code>CREATE</code> <code>FUNCTION</code> statement.</p>
</div>
<!-- class="sect3" -->
<a id="BEIJCAAI"></a><a id="VLDBG1474"></a>
<div class="sect3">
<h3 class="sect3">Functions in Parallel DML and DDL Statements</h3>
<p><a id="sthref1091"></a><a id="sthref1092"></a>In a parallel DML or DDL statement, as in a parallel query, a user-written function may be executed in parallel in any of the following cases:</p>
<ul>
<li>
<p>If it has been declared with the <code>PARALLEL_ENABLE</code> keyword</p>
</li>
<li>
<p>If it is declared in a package or type and has a <code>PRAGMA</code> <code>RESTRICT_REFERENCES</code> clause that indicates all of <code>RNDS</code>, <code>WNDS</code>, <code>RNPS</code>, and <code>WNPS</code></p>
</li>
<li>
<p>If it is declared with the <code>CREATE</code> <code>FUNCTION</code> statement and the system can analyze the body of the PL/SQL code and determine that the code neither reads nor writes to the database or reads or modifies package variables</p>
</li>
</ul>
<p>For a parallel DML statement, any function call that cannot be executed in parallel causes the entire DML statement to be executed serially. For an <code>INSERT</code> ... <code>SELECT</code> or <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statement, function calls in the query portion are parallelized according to the parallel query rules described in this section. The query may be parallelized even if the remainder of the statement must execute serially, or vice versa.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007156"></a><a id="VLDBG1475"></a>
<div class="sect2">
<h2 class="sect2">About Other Types of Parallelism</h2>
<p><a id="sthref1093"></a><a id="sthref1094"></a><a id="sthref1095"></a><a id="sthref1096"></a>In addition to parallel SQL execution, Oracle Database can use parallelism for the following types of operations:</p>
<ul>
<li>
<p>Parallel recovery</p>
</li>
<li>
<p>Parallel propagation (replication)</p>
</li>
<li>
<p>Parallel load (external tables and the SQL*Loader utility)</p>
</li>
</ul>
<p>Like parallel SQL, parallel recovery, propagation, and external table loads are performed by a parallel execution coordinator and multiple parallel execution servers. Parallel load using SQL*Loader, however, uses a different mechanism.</p>
<p>The behavior of the parallel execution coordinator and parallel execution servers may differ, depending on what kind of operation they perform (SQL, recovery, or propagation). For example, if all parallel execution servers in the pool are occupied and the maximum number of parallel execution servers has been started:</p>
<ul>
<li>
<p>In parallel SQL and external table loads, the parallel execution coordinator switches to serial processing.</p>
</li>
<li>
<p>In parallel propagation, the parallel execution coordinator returns an error.</p>
</li>
</ul>
<p>For a given session, the parallel execution coordinator coordinates only one kind of operation. A parallel execution coordinator cannot coordinate, for example, parallel SQL and parallel recovery or propagation at the same time.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SUTIL" href="../e22490/toc.htm"><span class="italic">Oracle Database Utilities</span></a> for information about parallel load and SQL*Loader</p>
</li>
<li>
<p><a class="olink BRADV" href="../../backup.112/e10642/toc.htm"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for information about parallel media recovery</p>
</li>
<li>
<p><a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information about parallel instance recovery</p>
</li>
<li>
<p><a class="olink REPLN" href="../e10706/toc.htm"><span class="italic">Oracle Database Advanced Replication</span></a> for information about parallel propagation</p>
</li>
</ul>
</div>
<a id="VLDBG1476"></a>
<div class="sect3"><a id="sthref1097"></a>
<h3 class="sect3">Summary of Parallelization Rules</h3>
<p><a href="#CACCAGCH">Table 8-2</a> shows how various types of SQL statements can be executed in parallel and indicates which <a id="sthref1098"></a><a id="sthref1099"></a>methods of specifying parallelism take precedence.</p>
<ul>
<li>
<p>The priority (1) specification overrides priority (2) and priority (3).</p>
</li>
<li>
<p>The priority (2) specification overrides priority (3).</p>
</li>
</ul>
<div class="tblformalwide">
<p class="titleintable"><a id="VLDBG1477"></a><a id="sthref1100"></a><a id="CACCAGCH"></a>Table 8-2 Parallelization Priority Order: By Clause, Hint, or Underlying Table or Index Declaration</p>
<table class="cellalignment1835" title="Parallelization Priority Order: By Clause, Hint, or Underlying Table or Index Declaration" summary="Parallelization Priority Order" dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t13">Parallel Operation</th>
<th class="cellalignment1836" id="r1c2-t13">PARALLEL Hint</th>
<th class="cellalignment1836" id="r1c3-t13">PARALLEL Clause</th>
<th class="cellalignment1836" id="r1c4-t13">ALTER SESSION</th>
<th class="cellalignment1836" id="r1c5-t13">Parallel Declaration</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t13" headers="r1c1-t13">
<p>Parallel query table scan (partitioned or nonpartitioned table)</p>
</td>
<td class="cellalignment1837" headers="r2c1-t13 r1c2-t13">
<p>(Priority 1) <code>PARALLEL</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t13 r1c3-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r2c1-t13 r1c4-t13">
<p>(Priority 2) <code>FORCE</code> <code>PARALLEL</code> <code>QUERY</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t13 r1c5-t13">
<p>(Priority 3) of table</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t13" headers="r1c1-t13">
<p>Parallel query index range scan (partitioned index)</p>
</td>
<td class="cellalignment1837" headers="r3c1-t13 r1c2-t13">
<p>(Priority 1) <code>PARALLEL_INDEX</code></p>
</td>
<td class="cellalignment1837" headers="r3c1-t13 r1c3-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r3c1-t13 r1c4-t13">
<p>(Priority 2) <code>FORCE</code> <code>PARALLEL</code> <code>QUERY</code></p>
</td>
<td class="cellalignment1837" headers="r3c1-t13 r1c5-t13">
<p>(Priority 2) of index</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r4c1-t13" headers="r1c1-t13">
<p>Parallel <code>UPDATE</code> or <code>DELETE</code> (partitioned table only)</p>
</td>
<td class="cellalignment1837" headers="r4c1-t13 r1c2-t13">
<p>(Priority 1) <code>PARALLEL</code></p>
</td>
<td class="cellalignment1837" headers="r4c1-t13 r1c3-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r4c1-t13 r1c4-t13">
<p>(Priority 2) <code><a id="sthref1101"></a>FORCE</code> <code>PARALLEL</code> <code>DML</code></p>
</td>
<td class="cellalignment1837" headers="r4c1-t13 r1c5-t13">
<p>(Priority 3) of table being updated or deleted from</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r5c1-t13" headers="r1c1-t13">
<p><code>INSERT</code> operation of parallel <code>INSERT</code>... <code>SELECT</code> (partitioned or nonpartitioned table)</p>
</td>
<td class="cellalignment1837" headers="r5c1-t13 r1c2-t13">
<p>(Priority 1) <code>PARALLEL</code> of insert</p>
</td>
<td class="cellalignment1837" headers="r5c1-t13 r1c3-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r5c1-t13 r1c4-t13">
<p>(Priority 2) <code><a id="sthref1102"></a>FORCE</code> <code>PARALLEL</code> <code>DML</code></p>
</td>
<td class="cellalignment1837" headers="r5c1-t13 r1c5-t13">
<p>(Priority 3) of table being inserted into</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r6c1-t13" headers="r1c1-t13">
<p><code>SELECT</code> operation of <code>INSERT</code> ... <code>SELECT</code> when <code>INSERT</code> is parallel</p>
</td>
<td class="cellalignment1837" headers="r6c1-t13 r1c2-t13">
<p>Takes degree from <code>INSERT</code> statement</p>
</td>
<td class="cellalignment1837" headers="r6c1-t13 r1c3-t13">
<p>Takes degree from <code>INSERT</code> statement</p>
</td>
<td class="cellalignment1837" headers="r6c1-t13 r1c4-t13">
<p>Takes degree from <code>INSERT</code> statement</p>
</td>
<td class="cellalignment1837" headers="r6c1-t13 r1c5-t13">
<p>Takes degree from <code>INSERT</code> statement</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r7c1-t13" headers="r1c1-t13">
<p><code>SELECT</code> operation of <code>INSERT</code> ... <code>SELECT</code> when <code>INSERT</code> is serial</p>
</td>
<td class="cellalignment1837" headers="r7c1-t13 r1c2-t13">
<p>(Priority 1) <code>PARALLEL</code></p>
</td>
<td class="cellalignment1837" headers="r7c1-t13 r1c3-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r7c1-t13 r1c4-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r7c1-t13 r1c5-t13">
<p>(Priority 2) of table being selected from</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r8c1-t13" headers="r1c1-t13">
<p><code>CREATE</code> operation of parallel <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> (partitioned or nonpartitioned table)</p>
</td>
<td class="cellalignment1837" headers="r8c1-t13 r1c2-t13">
<p>Note: Hint in the <code>SELECT</code> clause does not affect the <code>CREATE</code> operation</p>
</td>
<td class="cellalignment1837" headers="r8c1-t13 r1c3-t13">
<p>(Priority 2)</p>
</td>
<td class="cellalignment1837" headers="r8c1-t13 r1c4-t13">
<p>(Priority 1) <code><a id="sthref1103"></a><a id="sthref1104"></a>FORCE</code> <code>PARALLEL</code> <code>DDL</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t13 r1c5-t13">&nbsp;</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r9c1-t13" headers="r1c1-t13">
<p><code>SELECT</code> operation of <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> when <code>CREATE</code> is parallel</p>
</td>
<td class="cellalignment1837" headers="r9c1-t13 r1c2-t13">
<p>Takes degree from <code>CREATE</code> statement</p>
</td>
<td class="cellalignment1837" headers="r9c1-t13 r1c3-t13">
<p>Takes degree from <code>CREATE</code> statement</p>
</td>
<td class="cellalignment1837" headers="r9c1-t13 r1c4-t13">
<p>Takes degree from <code>CREATE</code> statement</p>
</td>
<td class="cellalignment1837" headers="r9c1-t13 r1c5-t13">
<p>Takes degree from <code>CREATE</code> statement</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r10c1-t13" headers="r1c1-t13">
<p><code>SELECT</code> operation of <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> when <code>CREATE</code> is serial</p>
</td>
<td class="cellalignment1837" headers="r10c1-t13 r1c2-t13">
<p>(Priority 1) <code>PARALLEL</code> or <code>PARALLEL_INDEX</code></p>
</td>
<td class="cellalignment1837" headers="r10c1-t13 r1c3-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r10c1-t13 r1c4-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r10c1-t13 r1c5-t13">
<p>(Priority 2) of querying tables or partitioned indexes</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r11c1-t13" headers="r1c1-t13">
<p>Parallel <code>CREATE</code> <code>INDEX</code> (partitioned or nonpartitioned index)</p>
</td>
<td class="cellalignment1837" headers="r11c1-t13 r1c2-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r11c1-t13 r1c3-t13">
<p>(Priority 2)</p>
</td>
<td class="cellalignment1837" headers="r11c1-t13 r1c4-t13">
<p>(Priority 1) <code><a id="sthref1105"></a>FORCE</code> <code>PARALLEL</code> <code>DDL</code></p>
</td>
<td class="cellalignment1837" headers="r11c1-t13 r1c5-t13">&nbsp;</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r12c1-t13" headers="r1c1-t13">
<p>Parallel <code>REBUILD</code> <code>INDEX</code> (nonpartitioned index)</p>
</td>
<td class="cellalignment1837" headers="r12c1-t13 r1c2-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r12c1-t13 r1c3-t13">
<p>(Priority 2)</p>
</td>
<td class="cellalignment1837" headers="r12c1-t13 r1c4-t13">
<p>(Priority 1) <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t13 r1c5-t13">&nbsp;</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r13c1-t13" headers="r1c1-t13">
<p><code>REBUILD</code> <code>INDEX</code> (partitioned index)&mdash;never parallelized</p>
</td>
<td class="cellalignment1837" headers="r13c1-t13 r1c2-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r13c1-t13 r1c3-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r13c1-t13 r1c4-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r13c1-t13 r1c5-t13">&nbsp;</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r14c1-t13" headers="r1c1-t13">
<p>Parallel <code>REBUILD</code> <code>INDEX</code> partition</p>
</td>
<td class="cellalignment1837" headers="r14c1-t13 r1c2-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r14c1-t13 r1c3-t13">
<p>(Priority 2)</p>
</td>
<td class="cellalignment1837" headers="r14c1-t13 r1c4-t13">
<p>(Priority 1) <code>FORCE</code> <code>PARALLEL</code> <code>DDL</code></p>
</td>
<td class="cellalignment1837" headers="r14c1-t13 r1c5-t13">&nbsp;</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r15c1-t13" headers="r1c1-t13">
<p>Parallel <code>MOVE</code> or <code>SPLIT</code> partition</p>
</td>
<td class="cellalignment1837" headers="r15c1-t13 r1c2-t13">&nbsp;</td>
<td class="cellalignment1837" headers="r15c1-t13 r1c3-t13">
<p>(Priority 2)</p>
</td>
<td class="cellalignment1837" headers="r15c1-t13 r1c4-t13">
<p>(Priority 1) <code><a id="sthref1106"></a>FORCE</code> <code>PARALLEL</code> <code>DDL</code></p>
</td>
<td class="cellalignment1837" headers="r15c1-t13 r1c5-t13">&nbsp;</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1828">
<tr>
<td class="cellalignment1837">
<table class="cellalignment1833">
<tr>
<td class="cellalignment1832"><a href="parallel002.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1832"><a href="parallel004.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1840">
<table class="cellalignment1831">
<tr>
<td class="cellalignment1832"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1832"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1832"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1832"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1832"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1832"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
