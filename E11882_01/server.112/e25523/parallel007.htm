<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Miscellaneous Parallel Execution Tuning Tips</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-27T4:11:54Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database VLDB and Partitioning Guide" />
<meta name="dcterms.identifier" content="E25523-01" />
<meta name="dcterms.isVersionOf" content="VLDBG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="parallel006.htm" title="Previous" type="text/html" />
<link rel="Next" href="vldb_backup.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25523.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">24/27</span> <!-- End Header --><a id="i1008847"></a><a id="VLDBG1525"></a>
<div class="sect1">
<h1 class="sect1">Miscellaneous Parallel Execution Tuning Tips</h1>
<p>This section contains some ideas for improving performance in a parallel execution environment and includes the following topics:</p>
<ul>
<li>
<p><a href="#i1008959">Creating and Populating Tables in Parallel</a></p>
</li>
<li>
<p><a href="#i1009020">Using EXPLAIN PLAN to Show Parallel Operations Plans</a></p>
</li>
<li>
<p><a href="#i1009045">Additional Considerations for Parallel DML</a></p>
</li>
<li>
<p><a href="#i1009131">Creating Indexes in Parallel</a></p>
</li>
<li>
<p><a href="#i1009173">Parallel DML Tips</a></p>
</li>
<li>
<p><a href="#i1009302">Incremental Data Loading in Parallel</a></p>
</li>
</ul>
<a id="i1008959"></a><a id="VLDBG1526"></a>
<div class="sect2">
<h2 class="sect2">Creating and Populating Tables in Parallel</h2>
<p><a id="sthref1213"></a>Oracle Database cannot return results to a user process in parallel. If a query returns a large number of rows, execution of the query might indeed be faster. However, the user process can receive the rows only serially. To optimize parallel execution performance for queries that retrieve large result sets, use <a id="sthref1214"></a><code>PARALLEL</code> <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> or direct-path <code>INSERT</code> to store the result set in the database. At a later time, users can view the result set serially.</p>
<p>Performing the <code>SELECT</code> in parallel does not influence the <code>CREATE</code> statement. If the <code>CREATE</code> statement is executed in parallel, however, the optimizer tries to make the <code>SELECT</code> run in parallel also.</p>
<p>When combined with the <code><a id="sthref1215"></a><a id="sthref1216"></a>NOLOGGING</code> option, the parallel version of <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> provides a very efficient intermediate table facility, for example:</p>
<pre>
CREATE TABLE summary PARALLEL NOLOGGING AS SELECT dim_1, dim_2 ..., 
SUM (meas_1)
FROM facts GROUP BY dim_1, dim_2;
</pre>
<p>These tables can also be incrementally loaded with parallel <code>INSERT</code>. You can take advantage of intermediate tables using the following techniques:</p>
<ul>
<li>
<p>Common subqueries can be computed once and referenced many times. This can allow some queries against star schemas (in particular, queries without selective <code>WHERE</code>-clause predicates) to be better parallelized. Note that star queries with selective <code>WHERE</code>-clause predicates using the star-transformation technique can be effectively parallelized automatically without any modification to the SQL.</p>
</li>
<li>
<p>Decompose complex queries into simpler steps to provide application-level checkpoint or restart. For example, a complex multitable join on a one terabyte database could run for dozens of hours. A failure during this query would mean starting over from the beginning. Using <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> or <code>PARALLEL</code> <code>INSERT</code> <code>AS</code> <code>SELECT</code>, you can rewrite the query as a sequence of simpler queries that run for a few hours each. If a system failure occurs, the query can be restarted from the last completed step.</p>
</li>
<li>
<p>Implement manual parallel delete operations efficiently by creating a new table that omits the unwanted rows from the original table, and then dropping the original table. Alternatively, you can use the convenient parallel delete feature, which directly deletes rows from the original table.</p>
</li>
<li>
<p>Create summary tables for efficient multidimensional drill-down analysis. For example, a summary table might store the sum of revenue grouped by month, brand, region, and salesman.</p>
</li>
<li>
<p>Reorganize tables, eliminating chained rows, compressing free space, and so on, by copying the old table to a new table. This is much faster than export/import and easier than reloading.</p>
</li>
</ul>
<p>Be sure to use the <code>DBMS_STATS</code> package to gather optimizer statistics on newly created tables. To avoid I/O bottlenecks, specify a tablespace that is striped across at least as many physical disks as CPUs. To avoid fragmentation in allocating space, the number of files in a tablespace should be a multiple of the number of CPUs. See <a class="olink DWHSG004" href="../../server.112/e25554/hardware.htm#DWHSG004"><span class="italic">Oracle Database Data Warehousing Guide</span></a>, for more information about bottlenecks.</p>
</div>
<!-- class="sect2" -->
<a id="i1009020"></a><a id="VLDBG1527"></a>
<div class="sect2">
<h2 class="sect2">Using EXPLAIN PLAN to Show Parallel Operations Plans</h2>
<p>Use the <code><a id="sthref1217"></a><a id="sthref1218"></a><a id="sthref1219"></a>EXPLAIN</code> <code>PLAN</code> statement to see the execution plans for parallel queries. The <code>EXPLAIN</code> <code>PLAN</code> output shows optimizer information in the <code>COST</code>, <code>BYTES</code>, and <code>CARDINALITY</code> columns. You can also use the <code>utlxplp.sql</code> script to present the <code>EXPLAIN</code> <code>PLAN</code> output with all relevant parallel information.</p>
<p>There are several ways to optimize the parallel execution of join statements. You can alter system configuration, adjust parameters as discussed earlier in this chapter, or use hints, such as the <code>DISTRIBUTION</code> hint.</p>
<p>The key points when using <code>EXPLAIN</code> <code>PLAN</code> are to:</p>
<ul>
<li>
<p>Verify optimizer selectivity estimates. If the optimizer thinks that only one row is produced from a query, it tends to favor using a nested loop. This could be an indication that the tables are not analyzed or that the optimizer has made an incorrect estimate about the correlation of multiple predicates on the same table. Extended statistics or a hint may be required to provide the optimizer with the correct selectivity or to force the optimizer to use another join method.</p>
</li>
<li>
<p>Use hash join on low cardinality join keys. If a join key has few distinct values, then a hash join may not be optimal. If the number of distinct values is less than the degree of parallelism (DOP), then some parallel query servers may be unable to work on the particular query.</p>
</li>
<li>
<p>Consider data skew. If a join key involves excessive data skew, a hash join may require some parallel query servers to work more than others. Consider using a hint to cause a <code>BROADCAST</code> distribution method if the optimizer did not choose it. Note that the optimizer considers the <code>BROADCAST</code> distribution method only if the <code>OPTIMIZER_FEATURES_ENABLE</code> is set to 9.0.2 or higher. See <a href="parallel006.htm#i1008657">"V$PQ_TQSTAT"</a> for more information.</p>
</li>
</ul>
<a id="VLDBG1528"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1220"></a>
<h3 class="sect3">Example: Using EXPLAIN PLAN to Show Parallel Operations</h3>
<p>The following example illustrates how the optimizer intends to execute a parallel query:</p>
<pre>
explain plan for 
SELECT /*+ PARALLEL */ cust_first_name, cust_last_name 
FROM customers c, sales s WHERE c.cust_id = s.cust_id;

----------------------------------------------------------
| Id  | Operation                       |  Name          |
----------------------------------------------------------
|   0 | SELECT STATEMENT                |                |
|   1 |  PX COORDINATOR                 |                |
|   2 |   PX SEND QC (RANDOM)           | :TQ10000       |
|   3 |    NESTED LOOPS                 |                |
|   4 |     PX BLOCK ITERATOR           |                |
|   5 |      TABLE ACCESS FULL          | CUSTOMERS      |
|   6 |     PARTITION RANGE ALL         |                |
|   7 |      BITMAP CONVERSION TO ROWIDS|                |
|   8 |       BITMAP INDEX SINGLE VALUE | SALES_CUST_BIX |
----------------------------------------------------------

Note
-----
   - Computed Degree of Parallelism is 2
   - Degree of Parallelism of 2 is derived from scan of object SH.CUSTOMERS
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009045"></a><a id="VLDBG1529"></a>
<div class="sect2">
<h2 class="sect2">Additional Considerations for Parallel DML</h2>
<p><a id="sthref1221"></a><a id="sthref1222"></a>When you want to refresh your data warehouse database using parallel insert, update, or delete operations on a data warehouse, there are additional issues to consider when designing the physical database. These considerations do not affect parallel execution operations. These issues are:</p>
<ul>
<li>
<p><a href="#CACHECAJ">Parallel DML and Direct-Path Restrictions</a></p>
</li>
<li>
<p><a href="#i1009083">Limitation on the Degree of Parallelism</a></p>
</li>
<li>
<p><a href="#i1009092">Increasing INITRANS</a></p>
</li>
<li>
<p><a href="#i1009096">Limitation on Available Number of Transaction Free Lists for Segments</a></p>
</li>
<li>
<p><a href="#i1009103">Using Multiple Archivers</a></p>
</li>
<li>
<p><a href="#i1009108">Database Writer Process (DBWn) Workload</a></p>
</li>
<li>
<p><a href="#i1009116">[NO]LOGGING Clause</a></p>
</li>
</ul>
<a id="CACHECAJ"></a><a id="VLDBG1530"></a>
<div class="sect3">
<h3 class="sect3">Parallel DML and Direct-Path Restrictions</h3>
<p>If a parallel restriction is violated, the operation is simply performed serially. If a direct-path <code>INSERT</code> restriction is violated, then the <code>APPEND</code> hint is ignored and a conventional insert operation is performed. No error message is returned.</p>
</div>
<!-- class="sect3" -->
<a id="i1009083"></a><a id="VLDBG1531"></a>
<div class="sect3">
<h3 class="sect3">Limitation on the Degree of Parallelism</h3>
<p>For tables that do not have the parallel DML <code>itl</code> invariant property (tables created before Oracle Database release 9.2 or tables that were created with the <code>COMPATIBLE</code> initialization parameter set to less than <code>9.2</code>), the degree of parallelism (DOP) equals the number of partitions or subpartitions. That means that, if the table is not partitioned, the query runs serially. To see what tables do not have this property, issue the following statement:</p>
<pre>
SELECT u.name, o.name FROM obj$ o, tab$ t, user$ u
WHERE o.obj# = t.obj# AND o.owner# = u.user#
 AND bitand(t.property,536870912) != 536870912;
</pre>
<p>For information about the interested transaction list (ITL), also called the transaction table, refer to <a class="olink CNCPT88965" href="../../server.112/e40540/consist.htm#CNCPT88965"><span class="italic">Oracle Database Concepts</span></a>.</p>
</div>
<!-- class="sect3" -->
<a id="i1009092"></a><a id="VLDBG1532"></a>
<div class="sect3">
<h3 class="sect3">Increasing INITRANS</h3>
<p>If you have global indexes, a global index segment and global index blocks are shared by server processes of the same parallel DML statement. Even if the operations are not performed against the same row, the server processes can share the same index blocks. Each server transaction needs one transaction entry in the index block header before it can make changes to a block. Therefore, in the <code>CREATE</code> <code>INDEX</code> or <code>ALTER</code> <code>INDEX</code> statements, you should set <code>INITRANS</code>, the initial number of transactions allocated within each data block, to a large value, such as the maximum DOP against this index.</p>
</div>
<!-- class="sect3" -->
<a id="i1009096"></a><a id="VLDBG1533"></a>
<div class="sect3">
<h3 class="sect3">Limitation on Available Number of Transaction Free Lists for Segments</h3>
<p>There is a limitation on the available number of transaction free lists for segments in dictionary-managed tablespaces. After a segment has been created, the number of process and transaction free lists is fixed and cannot be altered. If you specify a large number of process free lists in the segment header, you might find that this limits the number of transaction free lists that are available. You can abate this limitation the next time you re-create the segment header by decreasing the number of process free lists; this leaves more room for transaction free lists in the segment header.</p>
<p>For <code>UPDATE</code> and <code>DELETE</code> operations, each server process can require its own transaction free list. The parallel DML DOP is thus effectively limited by the smallest number of transaction free lists available on the table and on any of the global indexes the DML statement must maintain. For example, if the table has 25 transaction free lists and the table has two global indexes, one with 50 transaction free lists and one with 30 transaction free lists, the DOP is limited to 25. If the table had 40 transaction free lists, the DOP would have been limited to 30.</p>
<p>The <code><a id="sthref1223"></a><a id="sthref1224"></a>FREELISTS</code> parameter of the <code>STORAGE</code> clause is used to set the number of process free lists. By default, no process free lists are created.</p>
<p>The default number of transaction free lists depends on the block size. For example, if the number of process free lists is not set explicitly, a 4 KB block has about 80 transaction free lists by default. The minimum number of transaction free lists is 25.</p>
</div>
<!-- class="sect3" -->
<a id="i1009103"></a><a id="VLDBG1534"></a>
<div class="sect3">
<h3 class="sect3">Using Multiple Archivers</h3>
<p>Parallel DDL and parallel DML operations can generate a large number of redo logs. A single <code><a id="sthref1225"></a><a id="sthref1226"></a>ARCH</code> process to archive these<a id="sthref1227"></a> redo logs might not be able to keep up. To avoid this problem, you can spawn multiple archiver processes manually or by using a job queue.</p>
</div>
<!-- class="sect3" -->
<a id="i1009108"></a><a id="VLDBG1535"></a>
<div class="sect3">
<h3 class="sect3">Database Writer Process (DBWn) Workload</h3>
<p>Parallel DML operations use a large number of data, index, and undo blocks in the buffer cache during a short interval. For example, suppose you see a high number of <code>free_buffer_waits</code> after querying the <a id="sthref1228"></a><a id="sthref1229"></a><code>V$SYSTEM_EVENT</code> view, as in the following syntax:</p>
<pre>
SELECT TOTAL_WAITS FROM V$SYSTEM_EVENT WHERE EVENT = 'FREE BUFFER WAITS';
</pre>
<p>In this case, you should consider increasing the <a id="sthref1230"></a>DBW<span class="italic">n</span> processes. If there are no waits for free buffers, the query does not return any rows.</p>
</div>
<!-- class="sect3" -->
<a id="i1009116"></a><a id="VLDBG1536"></a>
<div class="sect3">
<h3 class="sect3">[NO]LOGGING Clause</h3>
<p>The <code>[NO]LOGGING</code> clause applies to tables, partitions, tablespaces, and indexes. Virtually no log is generated for certain operations (such as direct-path <code>INSERT</code>) if the <code>NOLOGGING</code> clause is used. The <a id="sthref1231"></a><a id="sthref1232"></a><code>NOLOGGING</code> attribute is not specified at the <code>INSERT</code> statement level but is instead specified when using the <code>ALTER</code> or <code>CREATE</code> statement for a table, partition, index, or tablespace.</p>
<p>When a table or index has <code>NOLOGGING</code> set, neither parallel nor serial direct-path <code>INSERT</code> operations generate redo logs. Processes running with the <code>NOLOGGING</code> option set run faster because no redo is generated. However, after a <code>NOLOGGING</code> operation against a table, partition, or index, if a media failure occurs before a backup is performed, then all tables, partitions, and indexes that have been modified might be corrupted.</p>
<p>Direct-path <code>INSERT</code> operations (except for dictionary updates) never generate redo logs if the <code>NOLOGGING</code> clause is used. The <code>NOLOGGING</code> attribute does not affect undo, only redo. To be precise, <code>NOLOGGING</code> allows the direct-path <code>INSERT</code> operation to generate a negligible amount of redo (range-invalidation redo, as opposed to full image redo).</p>
<p>For backward compatibility, <code>[UN]RECOVERABLE</code> is still supported as an alternate keyword with the <code>CREATE</code> <code>TABLE</code> statement. This alternate keyword might not be supported, however, in future releases.</p>
<p>At the tablespace level, the logging clause specifies the default logging attribute for all tables, indexes, and partitions created in the tablespace. When an existing tablespace logging attribute is changed by the <code>ALTER</code> <code>TABLESPACE</code> statement, then all tables, indexes, and partitions created after the <code>ALTER</code> statement have the new logging attribute; existing ones do not change their logging attributes. The tablespace-level logging attribute can be overridden by the specifications at the table, index, or partition level.</p>
<p>The default logging attribute is <code>LOGGING</code>. However, if you have put the database in <code><a id="sthref1233"></a>NOARCHIVELOG</code> mode, by issuing <code>ALTER</code> <code>DATABASE</code> <code>NOARCHIVELOG</code>, then all operations that can be done without logging do not generate logs, regardless of the specified logging attribute.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009131"></a><a id="VLDBG1537"></a>
<div class="sect2">
<h2 class="sect2">Creating Indexes in Parallel</h2>
<p><a id="sthref1234"></a><a id="sthref1235"></a><a id="sthref1236"></a>Multiple processes can work simultaneously to create an index. By dividing the work necessary to create an index among multiple server processes, Oracle Database can create the index more quickly than if a single server process created the index serially.</p>
<p>Parallel<a id="sthref1237"></a> index creation works in much the same way as a table scan with an <code>ORDER</code> <code>BY</code> clause. The table is randomly sampled and a set of index keys is found that equally divides the index into the same number of pieces as the DOP. A first set of query processes scans the table, extracts key-rowid pairs, and sends each pair to a process in a second set of query processes based on a key. Each process in the second set sorts the keys and builds an index in the usual fashion. After all index pieces are built, the parallel execution coordinator simply concatenates the pieces (which are ordered) to form the final index.</p>
<p>Parallel local <a id="sthref1238"></a>index creation uses a single server set. Each server process in the set is assigned a table partition to scan and for which to build an index partition. Because half as many server processes are used for a given DOP, parallel local index creation can be run with a higher DOP. However, the DOP is restricted to be less than or equal to the number of index partitions you want to create. To avoid this limitation, you can use the <code>DBMS_PCLXUTIL</code> package.</p>
<p>You can optionally specify that no redo and undo logging should occur during index creation. This can significantly improve performance but temporarily renders the index unrecoverable. Recoverability is restored after the new index is backed up. If your application can tolerate a window where recovery of the index requires it to be re-created, then you should consider using the <code><a id="sthref1239"></a>NOLOGGING</code> clause.</p>
<p>The <code>PARALLEL</code> clause in the <code><a id="sthref1240"></a>CREATE</code> <code>INDEX</code> statement is the only way in which you can specify the DOP for creating the index. If the DOP is not specified in the parallel clause of the <code>CREATE</code> <code>INDEX</code> statement, then the number of CPUs is used as the DOP. If there is no <code>PARALLEL</code> clause, <a id="sthref1241"></a>index creation is done serially.</p>
<p>When creating an index in parallel, the <code>STORAGE</code> clause refers to the storage of each of the subindexes created by the query server processes. Therefore, an index created with an <code>INITIAL</code> value of 5 MB and a DOP of 12 consumes at least 60 MB of storage during index creation because each process starts with an extent of 5 MB. When the query coordinator process combines the sorted subindexes, some extents might be trimmed, and the resulting index might be smaller than the requested 60 MB.</p>
<p>When you add or enable a <code><a id="sthref1242"></a>UNIQUE</code> or <code><a id="sthref1243"></a>PRIMARY</code> <code>KEY</code> constraint on a table, you cannot automatically create the required index in parallel. Instead, manually create an index on the desired columns, using the <code>CREATE</code> <code>INDEX</code> statement and an appropriate <code>PARALLEL</code> clause, and then add or enable the constraint. Oracle Database then uses the existing index when enabling or adding the constraint.</p>
<p>Multiple constraints on the same table can be enabled concurrently and in parallel if all the constraints are in the <code>ENABLE</code> <code>NOVALIDATE</code> state. In the following example, the <code>ALTER</code> <code>TABLE</code> ... <code>ENABLE</code> <code>CONSTRAINT</code> statement performs the table scan that checks the constraint in parallel:</p>
<pre>
CREATE TABLE a (a1 NUMBER CONSTRAINT ach CHECK (a1 &gt; 0) ENABLE NOVALIDATE)
PARALLEL; 
INSERT INTO a values (1);
COMMIT;
ALTER TABLE a ENABLE CONSTRAINT ach;
</pre></div>
<!-- class="sect2" -->
<a id="i1009173"></a><a id="VLDBG1538"></a>
<div class="sect2">
<h2 class="sect2">Parallel DML Tips</h2>
<p>This section provides an overview of parallel DML functionality. The topics covered include:</p>
<ul>
<li>
<p><a href="#i1009198">Parallel DML Tip 1: INSERT</a></p>
</li>
<li>
<p><a href="#i1009248">Parallel DML Tip 2: Direct-Path INSERT</a></p>
</li>
<li>
<p><a href="#i1009257">Parallel DML Tip 3: Parallelizing INSERT, MERGE, UPDATE, and DELETE</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN01509" href="../../server.112/e25494/tables.htm#ADMIN01509"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about improving load performance with direct-path insert</p>
</li>
<li>
<p><a class="olink SQLRF01604" href="../../server.112/e41084/statements_9014.htm#SQLRF01604"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code>INSERT</code> statement</p>
</li>
</ul>
</div>
<a id="i1009198"></a><a id="VLDBG1539"></a>
<div class="sect3">
<h3 class="sect3">Parallel DML Tip 1: INSERT</h3>
<p>The functionality available using an <code><a id="sthref1244"></a>INSERT</code> statement can be summarized as shown in <a href="#BEIIHGDC">Table 8-5</a>:</p>
<div class="tblformalwide">
<p class="titleintable"><a id="VLDBG1540"></a><a id="sthref1245"></a><a id="BEIIHGDC"></a>Table 8-5 Summary of INSERT Features</p>
<table class="cellalignment1835" title="Summary of INSERT Features" summary="Summary of INSERT Features" dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t22">Insert Type</th>
<th class="cellalignment1836" id="r1c2-t22">Parallel</th>
<th class="cellalignment1836" id="r1c3-t22">Serial</th>
<th class="cellalignment1836" id="r1c4-t22">NOLOGGING</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t22" headers="r1c1-t22">
<p>Conventional</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c2-t22">
<p>No</p>
<p>See text in this section for information about using the <code>NOAPPEND</code> hint with parallel DML enabled to perform a parallel conventional insert.</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c3-t22">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c4-t22">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t22" headers="r1c1-t22">
<p>Direct-path</p>
<p><code>INSERT</code></p>
<p>(<code>APPEND</code>)</p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c2-t22">
<p>Yes, but requires</p>
<p><code>ALTER</code> <code>SESSION</code> <code>ENABLE</code> <code>PARALLEL</code> <code>DML</code> to enable <code>PARALLEL</code> <code>DML</code> mode</p>
<p>and one of the following:</p>
<ul>
<li>
<p>Table <code>PARALLEL</code> attribute or <code>PARALLEL</code> hint to explicitly set parallelism</p>
</li>
<li>
<p><code>APPEND</code> hint to explicitly set mode</p>
</li>
</ul>
<p>Or the following</p>
<p><code>ALTER</code> <code>SESSION</code> <code>PARALLEL</code> <code>FORCE</code> to force <code>PARALLEL</code> <code>DML</code> mode</p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c3-t22">
<p>Yes, but requires:</p>
<p><code>APPEND</code> hint</p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c4-t22">
<p>Yes, but requires:</p>
<p><code>NOLOGGING</code> attribute set for partition or table</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p>If parallel DML is enabled and there is a <code><a id="sthref1246"></a><a id="sthref1247"></a>PARALLEL</code> hint or<a id="sthref1248"></a> <code>PARALLEL</code> attribute set for the table in the data dictionary, then insert operations are parallel and appended, unless a restriction applies. If either the <code>PARALLEL</code> hint or <code>PARALLEL</code> attribute is missing, the insert operation is performed serially. Note that automatic DOP only parallelizes the DML part of a SQL statement if and only if parallel DML is enabled or forced.</p>
<p>If parallel DML is enabled, then you can use the <code>NOAPPEND</code> hint to perform a parallel conventional insert operation. For example, you can use <code>/*+</code> <code>noappend</code> <code>parallel</code> <code>*/</code> with the SQL <code>INSERT</code> statement to perform a parallel conventional insert.</p>
<pre>
SQL&gt; INSERT /*+ NOAPPEND PARALLEL */ INTO sales_hist SELECT * FROM sales;
</pre>
<p>The advantage of the parallel conventional insert operation is the ability to perform online operations with none of the restrictions of direct-path <code>INSERT</code>. The disadvantage of the parallel conventional insert operation is that this process may be slower than direct-path <code>INSERT</code>.</p>
</div>
<!-- class="sect3" -->
<a id="i1009248"></a><a id="VLDBG1541"></a>
<div class="sect3">
<h3 class="sect3">Parallel DML Tip 2: Direct-Path INSERT</h3>
<p>The append mode is the default during a parallel insert operation: data is always inserted into a new block, which is allocated to the table. Therefore, the <code><a id="sthref1249"></a><a id="sthref1250"></a>APPEND</code> hint is optional. You should use append mode to increase the speed of <code>INSERT</code> operations, but not when space utilization must be optimized. You can use <code><a id="sthref1251"></a><a id="sthref1252"></a>NOAPPEND</code> to override append mode.</p>
<p>The <code>APPEND</code> hint applies to both serial and parallel insert operation: even serial insertions are faster if you use this hint. The <code>APPEND</code> hint, however, does require more space and locking overhead.</p>
<p>You can use <code><a id="sthref1253"></a>NOLOGGING</code> with <code>APPEND</code> to make the process even faster. <code>NOLOGGING</code> means that no redo log is generated for the operation. <code>NOLOGGING</code> is never the default; use it when you want to optimize performance. It should not typically be used when recovery is needed for the table or partition. If recovery is needed, be sure to perform a backup immediately after the operation. Use the <code><a id="sthref1254"></a>ALTER</code> <code>TABLE</code> <code>[NO]LOGGING</code> statement to set the appropriate value.</p>
</div>
<!-- class="sect3" -->
<a id="i1009257"></a><a id="VLDBG1542"></a>
<div class="sect3">
<h3 class="sect3">Parallel DML Tip 3: Parallelizing INSERT, MERGE, UPDATE, and DELETE</h3>
<p>When the table or partition has the <code><a id="sthref1255"></a>PARALLEL</code> attribute in the data dictionary, that attribute setting is used to determine parallelism of <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements and queries. An explicit <code>PARALLEL</code> hint for a table in a statement overrides the effect of the <code>PARALLEL</code> attribute in the data dictionary.</p>
<p>You can use the <code>NO_PARALLEL</code> hint to override a <code>PARALLEL</code> attribute for the table in the data dictionary. In general, hints take precedence over attributes.</p>
<p>DML operations are considered for parallelization only if the session is in a <code>PARALLEL</code> <code>DML</code> enabled mode. (Use <code>ALTER</code> <code>SESSION</code> <code>ENABLE</code> <code>PARALLEL</code> <code>DML</code> to enter this mode.) The mode does not affect parallelization of queries or of the query portions of a DML statement.</p>
<a id="VLDBG1543"></a>
<div class="sect4"><a id="sthref1256"></a>
<h4 class="sect4">Parallelizing INSERT ... SELECT</h4>
<p>In the <code>INSERT</code> ... <code>SELECT</code> statement, you can specify a <code>PARALLEL</code> hint after the <code>INSERT</code> keyword, in addition to the hint after the <code>SELECT</code> keyword. The <code>PARALLEL</code> hint after the <code>INSERT</code> keyword applies to the <code>INSERT</code> operation only, and the <code>PARALLEL</code> hint after the <code>SELECT</code> keyword applies to the <code>SELECT</code> operation only. Thus, parallelism of the <code>INSERT</code> and <code>SELECT</code> operations are independent of each other. If one operation cannot be performed in parallel, it has no effect on whether the other operation can be performed in parallel.</p>
<p>The ability to parallelize insert operations causes a change in existing behavior if the user has explicitly enabled the session for parallel DML and if the table in question has a <code>PARALLEL</code> attribute set in the data dictionary entry. In that case, existing <code>INSERT</code> ... <code>SELECT</code> statements that have the select operation parallelized can also have their insert operation parallelized.</p>
<p>If you query multiple tables, you can specify multiple <code>SELECT</code> <code>PARALLEL</code> hints and multiple <code>PARALLEL</code> attributes.</p>
<p><a href="#BEIIGDGI">Example 8-10</a> shows the addition of the new employees who were hired after the acquisition of <code>ACME</code>.</p>
<div class="example">
<p class="titleinexample"><a id="BEIIGDGI"></a><a id="VLDBG1544"></a>Example 8-10 <span class="bold">Parallelizing INSERT ... SELECT</span></p>
<pre>
INSERT /*+ PARALLEL(employees) */ INTO employees
SELECT /*+ PARALLEL(ACME_EMP) */ *  FROM ACME_EMP;
</pre>
<p>The <code>APPEND</code> keyword is not required in this example because it is implied by the <code>PARALLEL</code> hint.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="VLDBG1545"></a>
<div class="sect4"><a id="sthref1257"></a>
<h4 class="sect4">Parallelizing UPDATE and DELETE</h4>
<p>The <code>PARALLEL</code> hint (placed immediately after the <code>UPDATE</code> or <code>DELETE</code> keyword) applies not only to the underlying scan operation, but also to the <code>UPDATE</code> or <code>DELETE</code> operation. Alternatively, you can specify <code>UPDATE</code> or <code>DELETE</code> parallelism in the <code>PARALLEL</code> clause specified in the definition of the table to be modified.</p>
<p>If you have explicitly enabled parallel DML for the session or transaction, <code>UPDATE</code> or <code>DELETE</code> statements that have their query operation parallelized can also have their <code>UPDATE</code> or <code>DELETE</code> operation parallelized. Any subqueries or updatable views in the statement can have their own separate <code>PARALLEL</code> hints or clauses, but these parallel directives do not affect the decision to parallelize the update or delete. If these operations cannot be performed in parallel, it has no effect on whether the <code>UPDATE</code> or <code>DELETE</code> portion can be performed in parallel.</p>
<p><a href="#BEIGDEHC">Example 8-11</a> shows the update operation to give a 10 percent salary raise to all clerks in Dallas.</p>
<div class="example">
<p class="titleinexample"><a id="BEIGDEHC"></a><a id="VLDBG1546"></a>Example 8-11 <span class="bold">Parallelizing UPDATE and DELETE</span></p>
<pre>
UPDATE /*+ PARALLEL(employees) */ employees
SET SAL=SAL * 1.1 WHERE JOB='CLERK' AND DEPTNO IN
  (SELECT DEPTNO FROM DEPT WHERE LOCATION='DALLAS');
</pre>
<p>The <code>PARALLEL</code> hint is applied to the <code>UPDATE</code> operation and to the scan.</p>
<p><a href="#BEIJIGHJ">Example 8-12</a> shows the removal of all products in the grocery category because the grocery business line was recently spun off into a separate company.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BEIJIGHJ"></a><a id="VLDBG1547"></a>Example 8-12 <span class="bold">Parallelizing UPDATE and DELETE</span></p>
<pre>
DELETE /*+ PARALLEL(PRODUCTS) */ FROM PRODUCTS 
WHERE PRODUCT_CATEGORY ='GROCERY';
</pre>
<p>Again, the parallelism is applied to the scan and <code>UPDATE</code> operations on the table <code>employees</code>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009302"></a><a id="VLDBG1548"></a>
<div class="sect2">
<h2 class="sect2">Incremental Data Loading in Parallel</h2>
<p><a id="sthref1258"></a>Parallel DML combined with the updatable join views facility provides an efficient solution for refreshing the tables of a data warehouse system. To refresh tables is to update them with the differential data generated from the OLTP production system.</p>
<p>In the following example, assume a refresh of a table named <code>customer</code> that has columns <code>c_key</code>, <code>c_name</code>, and <code>c_addr</code>. The differential data contains either new rows or rows that have been updated since the last refresh of the data warehouse. In this example, the updated data is shipped from the production system to the data warehouse system by means of ASCII files. These files must be loaded into a temporary table, named <code>diff_customer</code>, before starting the refresh process. You can use SQL*Loader with both the parallel and direct options to efficiently perform this task. You can use the <code>APPEND</code> hint when loading in parallel as well.</p>
<p>After <code>diff_customer</code> is loaded, the refresh process can be started. It can be performed in two phases or by merging in parallel, as demonstrated in the following:</p>
<ul>
<li>
<p><a href="#i1009319">Updating the Table in Parallel</a></p>
</li>
<li>
<p><a href="#i1009363">Inserting the New Rows into the Table in Parallel</a></p>
</li>
<li>
<p><a href="#i1009371">Merging in Parallel</a></p>
</li>
</ul>
<a id="i1009319"></a><a id="VLDBG1549"></a>
<div class="sect3">
<h3 class="sect3">Updating the Table in Parallel</h3>
<p>The following statement is a straightforward SQL implementation of the update using subqueries:</p>
<pre>
UPDATE customers SET(c_name, c_addr) = (SELECT c_name, c_addr
FROM diff_customer WHERE diff_customer.c_key = customer.c_key)
WHERE c_key IN(SELECT c_key FROM diff_customer);
</pre>
<p>Unfortunately, the two subqueries in this statement affect performance.</p>
<p>An alternative is to rewrite this query using updatable join views. To rewrite the query, you must first add a primary key constraint to the <code>diff_customer</code> table to ensure that the modified columns map to a key-preserved table:</p>
<pre>
CREATE UNIQUE INDEX diff_pkey_ind ON diff_customer(c_key) PARALLEL NOLOGGING;
ALTER TABLE diff_customer ADD PRIMARY KEY (c_key);
</pre>
<p>You can then update the <code>customers</code> table with the following SQL statement:</p>
<pre>
UPDATE /*+ PARALLEL(cust_joinview) */
(SELECT /*+ PARALLEL(customers) PARALLEL(diff_customer) */
CUSTOMER.c_name AS c_name CUSTOMER.c_addr AS c_addr,
diff_customer.c_name AS c_newname, diff_customer.c_addr AS c_newaddr
   FROM diff_customer
   WHERE customers.c_key = diff_customer.c_key) cust_joinview
   SET c_name = c_newname, c_addr = c_newaddr;
</pre>
<p>The underlying scans feeding the join view <code>cust_joinview</code> are done in parallel. You can then parallelize the update to further improve performance, but only if the <code>customers</code> table is partitioned.</p>
</div>
<!-- class="sect3" -->
<a id="i1009363"></a><a id="VLDBG1550"></a>
<div class="sect3">
<h3 class="sect3">Inserting the New Rows into the Table in Parallel</h3>
<p>The last phase of the refresh process consists of inserting the new rows from the <code>diff_customer</code> temporary table to the <code>customers</code> table. Unlike the update case, you cannot avoid having a subquery in the <code>INSERT</code> statement:</p>
<pre>
INSERT /*+PARALLEL(customers)*/ INTO customers SELECT * FROM diff_customer s);
</pre>
<p>However, you can guarantee that the subquery is transformed into an anti-hash join by using the <code>HASH_AJ</code> hint. Doing so enables you to use parallel <code>INSERT</code> to execute the preceding statement efficiently. Parallel <code>INSERT</code> is applicable even if the table is not partitioned.</p>
</div>
<!-- class="sect3" -->
<a id="i1009371"></a><a id="VLDBG1551"></a>
<div class="sect3">
<h3 class="sect3">Merging in Parallel</h3>
<p>You can combine update and insert operations into one statement, commonly known as a <span class="bold">merge</span>. The following statement achieves the same result as all of the statements in <a href="#i1009319">"Updating the Table in Parallel"</a> and <a href="#i1009363">"Inserting the New Rows into the Table in Parallel"</a>:</p>
<pre>
MERGE INTO customers USING diff_customer
ON (diff_customer.c_key = customer.c_key) WHEN MATCHED THEN
  UPDATE SET (c_name, c_addr) = (SELECT c_name, c_addr 
  FROM diff_customer WHERE diff_customer.c_key = customers.c_key) 
WHEN NOT MATCHED THEN
  INSERT VALUES (diff_customer.c_key,diff_customer.c_data);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1828">
<tr>
<td class="cellalignment1837">
<table class="cellalignment1833">
<tr>
<td class="cellalignment1832"><a href="parallel006.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1832"><a href="vldb_backup.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1840">
<table class="cellalignment1831">
<tr>
<td class="cellalignment1832"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1832"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1832"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1832"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1832"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1832"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
