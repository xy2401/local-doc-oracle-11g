<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Creating Partitions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-27T4:11:52Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database VLDB and Partitioning Guide" />
<meta name="dcterms.identifier" content="E25523-01" />
<meta name="dcterms.isVersionOf" content="VLDBG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="part_admin.htm" title="Previous" type="text/html" />
<link rel="Next" href="part_admin002.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25523.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/27</span> <!-- End Header --><a id="i1106387"></a><a id="VLDBG1084"></a>
<div class="sect1">
<h1 class="sect1">Creating Partitions</h1>
<p><a id="sthref271"></a><a id="sthref272"></a><a id="sthref273"></a>Creating a partitioned table or index is very similar to creating a nonpartitioned table or index, but you include a partitioning clause in the <code>CREATE TABLE</code> statement. The partitioning clause, and subclauses, that you include depend upon the type of partitioning you want to achieve.</p>
<p>Partitioning is possible on both regular (heap organized) tables and <a id="sthref274"></a><a id="sthref275"></a><a id="sthref276"></a>index-organized tables, except for those containing <code>LONG</code> or <code>LONG RAW</code> columns. You can create nonpartitioned global indexes, range or hash-partitioned global indexes, and local indexes on partitioned tables.</p>
<p>When you create (or alter) a partitioned table, a row movement clause (either <code>ENABLE ROW MOVEMENT</code><a id="sthref277"></a><a id="sthref278"></a><a id="sthref279"></a><a id="sthref280"></a><a id="sthref281"></a> or <code>DISABLE ROW MOVEMENT</code>) can be specified. This clause either enables or disables the migration of a row to a new partition if its key is updated. The default is <code>DISABLE ROW MOVEMENT</code>.</p>
<p>The following sections present details and examples of creating partitions for the various types of partitioned tables and indexes:</p>
<ul>
<li>
<p><a href="#i1006455">Creating Range-Partitioned Tables and Global Indexes</a></p>
</li>
<li>
<p><a href="#BAJHFFBE">Creating Interval-Partitioned Tables</a></p>
</li>
<li>
<p><a href="#i1006508">Creating Hash-Partitioned Tables and Global Indexes</a></p>
</li>
<li>
<p><a href="#i1006532">Creating List-Partitioned Tables</a></p>
</li>
<li>
<p><a href="#BAJDDEEC">Creating Reference-Partitioned Tables</a></p>
</li>
<li>
<p><a href="#i1006565">Creating Composite Partitioned Tables</a></p>
</li>
<li>
<p><a href="#i1006655">Using Subpartition Templates to Describe Composite Partitioned Tables</a></p>
</li>
<li>
<p><a href="#i1008909">Using Multicolumn Partitioning Keys</a></p>
</li>
<li>
<p><a href="#BAJCHBAJ">Using Virtual Column-Based Partitioning</a></p>
</li>
<li>
<p><a href="#BAJCAHBJ">Using Table Compression with Partitioned Tables</a></p>
</li>
<li>
<p><a href="#BAJECHCD">Using Key Compression with Partitioned Indexes</a></p>
</li>
<li>
<p><a href="#CHDFCCHA">Using Partitioning with Segments</a></p>
</li>
<li>
<p><a href="#i1006727">Creating Partitioned Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#i1006806">Partitioning Restrictions for Multiple Block Sizes</a></p>
</li>
<li>
<p><a href="#CDCHCHBD">Partitioning of Collections in XMLType and Objects</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN015" href="../../server.112/e25494/tables.htm#ADMIN015"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about managing tables</p>
</li>
<li>
<p><a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> for the exact syntax of the partitioning clauses for creating partitioned tables and indexes, any restrictions on their use, and specific privileges required for creating and altering tables</p>
</li>
<li>
<p><a class="olink ADLOB" href="../../appdev.112/e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for information specific to creating partitioned tables containing columns with <code>LOB</code>s or other objects stored as <code>LOB</code>s</p>
</li>
<li>
<p><a class="olink ADOBJ006" href="../../appdev.112/e11822/adobjadv.htm#ADOBJ006"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for information specific to creating tables with object types, nested tables, or VARRAYs</p>
</li>
</ul>
</div>
<a id="i1006455"></a><a id="VLDBG1085"></a>
<div class="sect2">
<h2 class="sect2">Creating Range-Partitioned Tables and Global Indexes</h2>
<p><a id="sthref282"></a><a id="sthref283"></a>The <a id="sthref284"></a><code>PARTITION BY RANGE</code> clause of the <code><a id="sthref285"></a>CREATE TABLE</code> statement specifies that the table or index is to be range-partitioned. The <a id="sthref286"></a><code>PARTITION</code> clauses identify the individual partition ranges, and the optional subclauses of a <code>PARTITION</code> clause can specify physical and other attributes specific to a partition segment. If not overridden at the partition level, partitions inherit the attributes of their underlying table.</p>
<a id="VLDBG1086"></a>
<div class="sect3"><a id="sthref287"></a>
<h3 class="sect3">Creating a Range-Partitioned Table</h3>
<p><a id="sthref288"></a><a id="sthref289"></a><a id="sthref290"></a><a id="sthref291"></a><a id="sthref292"></a><a id="sthref293"></a><a href="#CHDJDFAF">Example 4-1</a> creates a table of four partitions, one for each quarter of sales. The columns <code>sale_year</code>, <code>sale_month</code>, and <code>sale_day</code> are the <span class="bold">partitioning columns</span>, while their values constitute the <span class="bold">partitioning key</span> of a specific row. The <code>VALUES LESS THAN</code> clause determines the <span class="bold">partition bound</span>: rows with partitioning key values that compare less than the ordered list of values specified by the clause are stored in the partition. Each partition is given a name (<code>sales_q1</code>, <code>sales_q2</code>, ...), and each partition is contained in a separate tablespace (<code>tsa</code>, <code>tsb</code>, ...).</p>
<div class="example">
<p class="titleinexample"><a id="CHDJDFAF"></a><a id="VLDBG14039"></a>Example 4-1 Creating a range-partitioned table</p>
<pre>
CREATE TABLE sales
  ( prod_id       NUMBER(6)
  , cust_id       NUMBER
  , time_id       DATE
  , channel_id    CHAR(1)
  , promo_id      NUMBER(6)
  , quantity_sold NUMBER(3)
  , amount_sold   NUMBER(10,2)
  )
 PARTITION BY RANGE (time_id)
 ( PARTITION sales_q1_2006 VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy'))
    TABLESPACE tsa
 , PARTITION sales_q2_2006 VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy'))
    TABLESPACE tsb
 , PARTITION sales_q3_2006 VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
    TABLESPACE tsc
 , PARTITION sales_q4_2006 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
    TABLESPACE tsd
 );
</pre></div>
<!-- class="example" -->
<p>A row with <code>time_id=17-MAR-2006</code> would be stored in partition <code>sales_q1_2006</code>.</p>
<p>For more information, refer to <a href="#i1008909">"Using Multicolumn Partitioning Keys"</a>.</p>
<p>In <a href="#CHDCEIJJ">Example 4-2</a>, more complexity is added to the example presented earlier for a range-partitioned table. Storage parameters and a <code>LOGGING</code> attribute are specified at the table level. These replace the corresponding defaults inherited from the tablespace level for the table itself, and are inherited by the range partitions. However, because there was little business in the first quarter, the storage attributes for partition <code>sales_q1_2006</code> are made smaller. The <code>ENABLE ROW MOVEMENT</code><a id="sthref294"></a> clause is specified to allow the automatic migration of a row to a new partition if an update to a key value is made that would place the row in a different partition.</p>
<div class="example">
<p class="titleinexample"><a id="CHDCEIJJ"></a><a id="VLDBG14040"></a>Example 4-2 Creating a range-partitioned table with ENABLE ROW MOVEMENT</p>
<pre>
CREATE TABLE sales
  ( prod_id       NUMBER(6)
  , cust_id       NUMBER
  , time_id       DATE
  , channel_id    CHAR(1)
  , promo_id      NUMBER(6)
  , quantity_sold NUMBER(3)
  , amount_sold   NUMBER(10,2)
  )
 STORAGE (INITIAL 100K NEXT 50K) LOGGING
 PARTITION BY RANGE (time_id)
 ( PARTITION sales_q1_2006 VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy'))
    TABLESPACE tsa STORAGE (INITIAL 20K NEXT 10K)
 , PARTITION sales_q2_2006 VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy'))
    TABLESPACE tsb
 , PARTITION sales_q3_2006 VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
    TABLESPACE tsc
 , PARTITION sales_q4_2006 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
    TABLESPACE tsd
 )
 ENABLE ROW MOVEMENT;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="VLDBG1087"></a>
<div class="sect3"><a id="sthref295"></a>
<h3 class="sect3">Creating a Range-Partitioned Global Index</h3>
<p>The rules for creating range-partitioned global indexes<a id="sthref296"></a><a id="sthref297"></a> are similar to those for creating range-partitioned tables. <a href="#CHDHGFAG">Example 4-3</a> creates a range-partitioned global index on <code>sale_month</code> for the tables created in the previous examples. Each index<a id="sthref298"></a> partition is named but is stored in the default tablespace for the index.</p>
<div class="example">
<p class="titleinexample"><a id="CHDHGFAG"></a><a id="VLDBG14041"></a>Example 4-3 Creating a range-partitioned global index table</p>
<pre>
CREATE INDEX amount_sold_ix ON sales(amount_sold)
   GLOBAL PARTITION BY RANGE(sale_month)
      ( PARTITION p_100 VALUES LESS THAN (100)
      , PARTITION p_1000 VALUES LESS THAN (1000)
      , PARTITION p_10000 VALUES LESS THAN (10000)
      , PARTITION p_100000 VALUES LESS THAN (100000)
      , PARTITION p_1000000 VALUES LESS THAN (1000000)
      , PARTITION p_greater_than_1000000 VALUES LESS THAN (maxvalue)
      );
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
If your enterprise has databases using different character sets, use caution when partitioning on character columns, because the sort sequence of characters is not identical in all character sets. For more information, see <a class="olink NLSPG" href="../e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide.</span></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BAJHFFBE"></a><a id="VLDBG1088"></a>
<div class="sect2">
<h2 class="sect2">Creating Interval-Partitioned Tables</h2>
<p><a id="sthref299"></a><a id="sthref300"></a><a id="sthref301"></a><a id="sthref302"></a>The <code>INTERVAL</code> clause of the <code>CREATE TABLE</code> statement establishes interval partitioning for the table. You must specify at least one range partition using the <code>PARTITION</code> clause. The range partitioning key value determines the high value of the range partitions, which is called the transition point, and the database automatically creates interval partitions for data beyond that transition point. The lower boundary of every interval partition is the non-inclusive upper boundary of the previous range or interval partition.</p>
<p>For example, if you create an interval partitioned table with monthly intervals and the transition point is at January 1, 2010, then the lower boundary for the January 2010 interval is January 1, 2010. The lower boundary for the July 2010 interval is July 1, 2010, regardless of whether the June 2010 partition was previously created. Note, however, that using a date where the high or low bound of the partition would be out of the range set for storage causes an error. For example, <code>TO_DATE('9999-12-01', 'YYYY-MM-DD')</code> causes the high bound to be 10000-01-01, which would not be storable if 10000 is out of the legal range.</p>
<p>For interval partitioning, the partitioning key can only be a single column name from the table and it must be of <code>NUMBER</code> or <code>DATE</code> type. The optional <code>STORE IN</code> clause lets you specify one or more tablespaces into which the database stores interval partition data using a round-robin algorithm for subsequently created interval partitions.</p>
<p><a href="#CHDJAHJH">Example 4-4</a> specifies four partitions with varying interval widths. It also specifies that above the transition point of January 1, 2010, partitions are created with an interval width of one month.</p>
<div class="example">
<p class="titleinexample"><a id="CHDJAHJH"></a><a id="VLDBG14042"></a>Example 4-4 Creating an interval-partitioned table</p>
<pre>
CREATE TABLE interval_sales
    ( prod_id        NUMBER(6)
    , cust_id        NUMBER
    , time_id        DATE
    , channel_id     CHAR(1)
    , promo_id       NUMBER(6)
    , quantity_sold  NUMBER(3)
    , amount_sold    NUMBER(10,2)
    ) 
  PARTITION BY RANGE (time_id) 
  INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'))
    ( PARTITION p0 VALUES LESS THAN (TO_DATE('1-1-2008', 'DD-MM-YYYY')),
      PARTITION p1 VALUES LESS THAN (TO_DATE('1-1-2009', 'DD-MM-YYYY')),
      PARTITION p2 VALUES LESS THAN (TO_DATE('1-7-2009', 'DD-MM-YYYY')),
      PARTITION p3 VALUES LESS THAN (TO_DATE('1-1-2010', 'DD-MM-YYYY')) );
</pre></div>
<!-- class="example" -->
<p>The high bound of partition <code>p3</code> represents the transition point. <code>p3</code> and all partitions below it (<code>p0</code>, <code>p1</code>, and <code>p2</code> in this example) are in the range section while all partitions above it fall into the interval section.</p>
</div>
<!-- class="sect2" -->
<a id="i1006508"></a><a id="VLDBG1089"></a>
<div class="sect2">
<h2 class="sect2">Creating Hash-Partitioned Tables and Global Indexes</h2>
<p><a id="sthref303"></a><a id="sthref304"></a>The <a id="sthref305"></a><code>PARTITION BY HASH</code> clause of the <code>CREATE TABLE</code> statement identifies that the table is to be hash-partitioned. The <a id="sthref306"></a><code>PARTITIONS</code> clause can then be used to specify the number of partitions to create, and optionally, the tablespaces to store them in. Alternatively, you can use <a id="sthref307"></a><code>PARTITION</code> clauses to name the individual partitions and their tablespaces.</p>
<p>The only attribute you can specify for hash partitions is <code>TABLESPACE</code>. All of the hash partitions of a table must share the same segment attributes (except <code>TABLESPACE</code>), which are inherited from the table level.</p>
<a id="VLDBG1090"></a>
<div class="sect3"><a id="sthref308"></a>
<h3 class="sect3">Creating a Hash Partitioned Table</h3>
<p><a id="sthref309"></a><a id="sthref310"></a><a href="#CHDDDCDB">Example 4-5</a> creates a hash-partitioned table. The partitioning column is <code>id</code>, four partitions are created and assigned system generated names, and they are placed in four named tablespaces (<code>gear1</code>, <code>gear2</code>, ...).</p>
<div class="example">
<p class="titleinexample"><a id="CHDDDCDB"></a><a id="VLDBG14043"></a>Example 4-5 Creating a hash-partitioned table</p>
<pre>
CREATE TABLE scubagear
     (id NUMBER,
      name VARCHAR2 (60))
   PARTITION BY HASH (id)
   PARTITIONS 4 
   STORE IN (gear1, gear2, gear3, gear4);
</pre></div>
<!-- class="example" -->
<p>For more information, refer to <a href="#i1008909">"Using Multicolumn Partitioning Keys"</a>.</p>
<p>The following examples illustrate two methods of creating a hash-partitioned table named <code>dept</code>. In the first example the number of partitions is specified, but system generated names are assigned to them and they are stored in the default tablespace of the table.</p>
<pre>
CREATE TABLE dept (deptno NUMBER, deptname VARCHAR(32))
     PARTITION BY HASH(deptno) PARTITIONS 16;
</pre>
<p>In the following example, names of individual partitions, and tablespaces in which they are to reside, are specified. The initial extent size for each hash partition (segment) is also explicitly stated at the table level, and all partitions inherit this attribute.</p>
<pre>
CREATE TABLE dept (deptno NUMBER, deptname VARCHAR(32))
     STORAGE (INITIAL 10K)
     PARTITION BY HASH(deptno)
       (PARTITION p1 TABLESPACE ts1, PARTITION p2 TABLESPACE ts2,
        PARTITION p3 TABLESPACE ts1, PARTITION p4 TABLESPACE ts3);
</pre>
<p>If you create a local index for this table, the database constructs the index so that it is equipartitioned with the underlying table. The database also ensures that the index is maintained automatically when maintenance operations are performed on the underlying table. The following is an example of creating a local index<a id="sthref311"></a> on the table <code>dept</code>:</p>
<pre>
CREATE INDEX loc_dept_ix ON dept(deptno) LOCAL;
</pre>
<p>You can optionally name the hash partitions and tablespaces into which the local index partitions are to be stored, but if you do not do so, then the database uses the name of the corresponding base partition as the index partition name, and stores the index partition in the same tablespace as the table partition.</p>
</div>
<!-- class="sect3" -->
<a id="i1009930"></a><a id="VLDBG1091"></a>
<div class="sect3">
<h3 class="sect3">Creating a Hash-Partitioned Global Index</h3>
<p><a id="sthref312"></a><a id="sthref313"></a>Hash-partitioned global indexes can improve the performance of indexes where a small number of leaf blocks in the index have high contention in multiuser OLTP environments. Hash-partitioned global indexes can also limit the impact of index skew on monotonously increasing column values. Queries involving the equality and <code>IN</code> predicates on the index partitioning key can efficiently use hash-partitioned global indexes.</p>
<p>The syntax for creating a hash partitioned global index is similar to that used for a hash partitioned table. For example, the statement in <a href="#CHDBDJGC">Example 4-6</a> creates a hash-partitioned global index:</p>
<div class="example">
<p class="titleinexample"><a id="CHDBDJGC"></a><a id="VLDBG14044"></a>Example 4-6 Creating a hash-partitioned global index</p>
<pre>
CREATE INDEX hgidx ON tab (c1,c2,c3) GLOBAL
     PARTITION BY HASH (c1,c2)
     (PARTITION p1  TABLESPACE tbs_1,
      PARTITION p2  TABLESPACE tbs_2,
      PARTITION p3  TABLESPACE tbs_3,
      PARTITION p4  TABLESPACE tbs_4);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006532"></a><a id="VLDBG1092"></a>
<div class="sect2">
<h2 class="sect2">Creating List-Partitioned Tables</h2>
<p><a id="sthref314"></a><a id="sthref315"></a>The semantics for creating list partitions are very similar to those for creating range partitions. However, to create list partitions, you specify a <a id="sthref316"></a><code>PARTITION BY LIST</code> clause in the <code>CREATE TABLE</code> statement, and the <a id="sthref317"></a><code>PARTITION</code> clauses specify lists of literal values, which are the discrete values of the partitioning columns that qualify rows to be included in the partition. For list partitioning, the partitioning key can only be a single column name from the table.</p>
<p>Available only with list partitioning, you can use the keyword <code><a id="sthref318"></a><a id="sthref319"></a>DEFAULT</code> to describe the value list for a partition. This identifies a partition that accommodates rows that do not map into any of the other partitions.</p>
<p>As with range partitions, optional subclauses of a <code>PARTITION</code> clause can specify physical and other attributes specific to a partition segment. If not overridden at the partition level, partitions inherit the attributes of their parent table.</p>
<p><a href="#CHDDEBEB">Example 4-7</a> creates a list-partitioned table. It creates table <code>q1_sales_by_region</code> which is partitioned by regions consisting of groups of U.S. states.</p>
<div class="example">
<p class="titleinexample"><a id="CHDDEBEB"></a><a id="VLDBG14045"></a>Example 4-7 Creating a list-partitioned table</p>
<pre>
CREATE TABLE q1_sales_by_region
      (deptno number, 
       deptname varchar2(20),
       quarterly_sales number(10, 2),
       state varchar2(2))
   PARTITION BY LIST (state)
      (PARTITION q1_northwest VALUES ('OR', 'WA'),
       PARTITION q1_southwest VALUES ('AZ', 'UT', 'NM'),
       PARTITION q1_northeast VALUES  ('NY', 'VM', 'NJ'),
       PARTITION q1_southeast VALUES ('FL', 'GA'),
       PARTITION q1_northcentral VALUES ('SD', 'WI'),
       PARTITION q1_southcentral VALUES ('OK', 'TX'));
</pre></div>
<!-- class="example" -->
<p>A row is mapped to a partition by checking whether the value of the partitioning column for a row matches a value in the value list that describes the partition.</p>
<p>For example, some sample rows are inserted as follows:</p>
<ul>
<li>
<p>(10, 'accounting', 100, 'WA') maps to partition <code>q1_northwest</code></p>
</li>
<li>
<p>(20, 'R&amp;D', 150, 'OR') maps to partition <code>q1_northwest</code></p>
</li>
<li>
<p>(30, 'sales', 100, 'FL') maps to partition <code>q1_southeast</code></p>
</li>
<li>
<p>(40, 'HR', 10, 'TX') maps to partition <code>q1_southwest</code></p>
</li>
<li>
<p>(50, 'systems engineering', 10, 'CA') does not map to any partition in the table and raises an error</p>
</li>
</ul>
<p>Unlike range partitioning, with list partitioning, there is no apparent sense of order between partitions. You can also specify a <span class="bold"><a id="sthref320"></a><a id="sthref321"></a>default partition</span> into which rows that do not map to any other partition are mapped. If a default partition were specified in the preceding example, the state CA would map to that partition.</p>
<p><a href="#CHDDDCFI">Example 4-8</a> creates table <code>sales_by_region</code> and partitions it using the list method. The first two <code>PARTITION</code> clauses specify physical attributes, which override the table-level defaults. The remaining <code>PARTITION</code> clauses do not specify attributes and those partitions inherit their physical attributes from table-level defaults. A default partition is also specified.</p>
<div class="example">
<p class="titleinexample"><a id="CHDDDCFI"></a><a id="VLDBG14046"></a>Example 4-8 Creating a list-partitioned table with a default partition</p>
<pre>
CREATE TABLE sales_by_region (item# INTEGER, qty INTEGER, 
             store_name VARCHAR(30), state_code VARCHAR(2),
             sale_date DATE)
     STORAGE(INITIAL 10K NEXT 20K) TABLESPACE tbs5 
     PARTITION BY LIST (state_code) 
     (
     PARTITION region_east
        VALUES ('MA','NY','CT','NH','ME','MD','VA','PA','NJ')
        STORAGE (INITIAL 8M) 
        TABLESPACE tbs8,
     PARTITION region_west
        VALUES ('CA','AZ','NM','OR','WA','UT','NV','CO')
        NOLOGGING,
     PARTITION region_south
        VALUES ('TX','KY','TN','LA','MS','AR','AL','GA'),
     PARTITION region_central 
        VALUES ('OH','ND','SD','MO','IL','MI','IA'),
     PARTITION region_null
        VALUES (NULL),
     PARTITION region_unknown
        VALUES (DEFAULT)
     );
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BAJDDEEC"></a><a id="VLDBG1093"></a>
<div class="sect2">
<h2 class="sect2">Creating Reference-Partitioned Tables<a id="sthref322"></a></h2>
<p><a id="sthref323"></a>To create a reference-partitioned table, you specify a <a id="sthref324"></a><code>PARTITION BY REFERENCE</code> clause in the <code>CREATE TABLE</code> statement. This clause specifies the name of a referential constraint and this constraint becomes the partitioning referential constraint that is used as the basis for reference partitioning in the table. The referential constraint must be enabled and enforced.</p>
<p>As with other partitioned tables, you can specify object-level default attributes, and you can optionally specify partition descriptors that override the object-level defaults on a per-partition basis.</p>
<p><a href="#CHDHJCFD">Example 4-9</a> creates a parent table <code>orders</code> which is range-partitioned on <code>order_date</code>. The reference-partitioned child table <code>order_items</code> is created with four partitions, <code>Q1_2005</code>, <code>Q2_2005</code>, <code>Q3_2005</code>, and <code>Q4_2005</code>, where each partition contains the <code>order_items</code> rows corresponding to orders in the respective parent partition.</p>
<div class="example">
<p class="titleinexample"><a id="CHDHJCFD"></a><a id="VLDBG14047"></a>Example 4-9 Creating reference-partitioned tables</p>
<pre>
CREATE TABLE orders
    ( order_id           NUMBER(12),
      order_date         TIMESTAMP WITH LOCAL TIME ZONE,
      order_mode         VARCHAR2(8),
      customer_id        NUMBER(6),
      order_status       NUMBER(2),
      order_total        NUMBER(8,2),
      sales_rep_id       NUMBER(6),
      promotion_id       NUMBER(6),
      CONSTRAINT orders_pk PRIMARY KEY(order_id)
    )
  PARTITION BY RANGE(order_date)
    ( PARTITION Q1_2005 VALUES LESS THAN (TO_DATE('01-APR-2005','DD-MON-YYYY')),
      PARTITION Q2_2005 VALUES LESS THAN (TO_DATE('01-JUL-2005','DD-MON-YYYY')),
      PARTITION Q3_2005 VALUES LESS THAN (TO_DATE('01-OCT-2005','DD-MON-YYYY')),
      PARTITION Q4_2005 VALUES LESS THAN (TO_DATE('01-JAN-2006','DD-MON-YYYY'))
    );

CREATE TABLE order_items
    ( order_id           NUMBER(12) NOT NULL,
      line_item_id       NUMBER(3)  NOT NULL,
      product_id         NUMBER(6)  NOT NULL,
      unit_price         NUMBER(8,2),
      quantity           NUMBER(8),
      CONSTRAINT order_items_fk
      FOREIGN KEY(order_id) REFERENCES orders(order_id)
    )
    PARTITION BY REFERENCE(order_items_fk);
</pre></div>
<!-- class="example" -->
<p>If partition descriptors are provided, then the number of partitions described must exactly equal the number of partitions or subpartitions in the referenced table. If the parent table is a composite partitioned table, then the table has one partition for each subpartition of its parent; otherwise the table has one partition for each partition of its parent.</p>
<p>Partition bounds cannot be specified for the partitions of a reference-partitioned table.</p>
<p>The partitions of a reference-partitioned table can be named. If a partition is not explicitly named, then it inherits its name from the corresponding partition in the parent table, unless this inherited name conflicts with an existing explicit name. In this case, the partition has a system-generated name.</p>
<p>Partitions of a reference-partitioned table collocate with the corresponding partition of the parent table, if no explicit tablespace is specified for the reference-partitioned table's partition.</p>
</div>
<!-- class="sect2" -->
<a id="i1006565"></a><a id="VLDBG1094"></a>
<div class="sect2">
<h2 class="sect2">Creating Composite Partitioned Tables</h2>
<p><a id="sthref325"></a><a id="sthref326"></a><a id="sthref327"></a>To create a composite partitioned table, you start by using the <a id="sthref328"></a><code>PARTITION</code> <code>BY</code> [<code>RANGE</code> | <code>LIST</code>] clause of a <code>CREATE TABLE</code> statement. Next, you specify a <a id="sthref329"></a><code>SUBPARTITION BY [RANGE | LIST | HASH]</code> clause that follows similar syntax and rules as the <code>PARTITION BY [RANGE | LIST | HASH]</code> clause. The individual <a id="sthref330"></a><code>PARTITION</code> and <a id="sthref331"></a><code>SUBPARTITION</code> or <a id="sthref332"></a><code>SUBPARTITIONS</code> clauses, and optionally a <code>SUBPARTITION TEMPLATE</code> clause, follow.</p>
<a id="i1006564"></a><a id="VLDBG1095"></a>
<div class="sect3">
<h3 class="sect3">Creating Composite Range-Hash Partitioned Tables</h3>
<p><a id="sthref333"></a><a id="sthref334"></a><a id="sthref335"></a><a id="sthref336"></a>The statement in <a href="#CHDGECFB">Example 4-10</a> creates a range-hash partitioned table. Four range partitions are created, each containing eight subpartitions. Because the subpartitions are not named, system generated names are assigned, but the <code>STORE IN</code> clause distributes them across the 4 specified tablespaces (<code>ts1</code>, ...,<code>ts4</code>).</p>
<div class="example">
<p class="titleinexample"><a id="CHDGECFB"></a><a id="VLDBG14048"></a>Example 4-10 Creating a composite range-hash partitioned table</p>
<pre>
CREATE TABLE sales
  ( prod_id       NUMBER(6)
  , cust_id       NUMBER
  , time_id       DATE
  , channel_id    CHAR(1)
  , promo_id      NUMBER(6)
  , quantity_sold NUMBER(3)
  , amount_sold   NUMBER(10,2)
  )
 PARTITION BY RANGE (time_id) SUBPARTITION BY HASH (cust_id)
  SUBPARTITIONS 8 STORE IN (ts1, ts2, ts3, ts4)
 ( PARTITION sales_q1_2006 VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy'))
 , PARTITION sales_q2_2006 VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy'))
 , PARTITION sales_q3_2006 VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
 , PARTITION sales_q4_2006 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
 );
</pre></div>
<!-- class="example" -->
<p>The partitions of a range-hash partitioned table are logical structures only, because their data is stored in the segments of their subpartitions. As with partitions, these subpartitions share the same logical attributes. Unlike range partitions in a range-partitioned table, the subpartitions cannot have different physical attributes from the owning partition, although they are not required to reside in the same tablespace.</p>
<p>Attributes specified for a range partition apply to all subpartitions of that partition. You can specify different attributes for each range partition, and you can specify a <a id="sthref337"></a><code>STORE IN</code> clause at the partition level if the list of tablespaces across which the subpartitions of that partition should be spread is different from those of other partitions. All of this is illustrated in the following example.</p>
<pre>
CREATE TABLE emp (deptno NUMBER, empname VARCHAR(32), grade NUMBER)   
     PARTITION BY RANGE(deptno) SUBPARTITION BY HASH(empname)
        SUBPARTITIONS 8 STORE IN (ts1, ts3, ts5, ts7)
    (PARTITION p1 VALUES LESS THAN (1000),
     PARTITION p2 VALUES LESS THAN (2000)
        STORE IN (ts2, ts4, ts6, ts8),
     PARTITION p3 VALUES LESS THAN (MAXVALUE)
       (SUBPARTITION p3_s1 TABLESPACE ts4,
        SUBPARTITION p3_s2 TABLESPACE ts5));
</pre>
<p>To learn how using a subpartition template can simplify the specification of a composite partitioned table, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
<p>The following statement is an example of creating a local index<a id="sthref338"></a> on the <code>emp</code> table where the index segments are spread across tablespaces <code>ts7</code>, <code>ts8</code>, and <code>ts9</code>.</p>
<pre>
CREATE INDEX emp_ix ON emp(deptno)
     LOCAL STORE IN (ts7, ts8, ts9);
</pre>
<p>This local index is equipartitioned with the base table as follows:</p>
<ul>
<li>
<p>It consists of as many partitions as the base table.</p>
</li>
<li>
<p>Each index partition consists of as many subpartitions as the corresponding base table partition.</p>
</li>
<li>
<p>Index entries for rows in a given subpartition of the base table are stored in the corresponding subpartition of the index.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1006602"></a><a id="VLDBG1096"></a>
<div class="sect3">
<h3 class="sect3">Creating Composite Range-List Partitioned Tables</h3>
<p><a id="sthref339"></a><a id="sthref340"></a><a id="sthref341"></a><a id="sthref342"></a>The range partitions of a range-list composite partitioned table are described as for non-composite range partitioned tables. This enables optional subclauses of a <code>PARTITION</code> clause to specify physical and other attributes, including tablespace, specific to a partition segment. If not overridden at the partition level, partitions inherit the attributes of their underlying table.</p>
<p>The list subpartition descriptions, in the <code>SUBPARTITION</code> clauses, are described as for non-composite list partitions, except the only physical attribute that can be specified is a tablespace (optional). Subpartitions inherit all other physical attributes from the partition description.</p>
<p><a href="#CHDFIFJG">Example 4-11</a> illustrates how range-list partitioning might be used. The example tracks sales data of products by quarters and within each quarter, groups it by specified states.</p>
<div class="example">
<p class="titleinexample"><a id="CHDFIFJG"></a><a id="VLDBG14049"></a>Example 4-11 Creating a composite range-list partitioned table</p>
<pre>
CREATE TABLE quarterly_regional_sales
      (deptno number, item_no varchar2(20),
       txn_date date, txn_amount number, state varchar2(2))
  TABLESPACE ts4
  PARTITION BY RANGE (txn_date)
    SUBPARTITION BY LIST (state)
      (PARTITION q1_1999 VALUES LESS THAN (TO_DATE('1-APR-1999','DD-MON-YYYY'))
         (SUBPARTITION q1_1999_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q1_1999_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q1_1999_northeast VALUES ('NY', 'VM', 'NJ'),
          SUBPARTITION q1_1999_southeast VALUES ('FL', 'GA'),
          SUBPARTITION q1_1999_northcentral VALUES ('SD', 'WI'),
          SUBPARTITION q1_1999_southcentral VALUES ('OK', 'TX')
         ),
       PARTITION q2_1999 VALUES LESS THAN ( TO_DATE('1-JUL-1999','DD-MON-YYYY'))
         (SUBPARTITION q2_1999_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q2_1999_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q2_1999_northeast VALUES ('NY', 'VM', 'NJ'),
          SUBPARTITION q2_1999_southeast VALUES ('FL', 'GA'),
          SUBPARTITION q2_1999_northcentral VALUES ('SD', 'WI'),
          SUBPARTITION q2_1999_southcentral VALUES ('OK', 'TX')
         ),
       PARTITION q3_1999 VALUES LESS THAN (TO_DATE('1-OCT-1999','DD-MON-YYYY'))
         (SUBPARTITION q3_1999_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q3_1999_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q3_1999_northeast VALUES ('NY', 'VM', 'NJ'),
          SUBPARTITION q3_1999_southeast VALUES ('FL', 'GA'),
          SUBPARTITION q3_1999_northcentral VALUES ('SD', 'WI'),
          SUBPARTITION q3_1999_southcentral VALUES ('OK', 'TX')
         ),
       PARTITION q4_1999 VALUES LESS THAN ( TO_DATE('1-JAN-2000','DD-MON-YYYY'))
         (SUBPARTITION q4_1999_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q4_1999_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q4_1999_northeast VALUES ('NY', 'VM', 'NJ'),
          SUBPARTITION q4_1999_southeast VALUES ('FL', 'GA'),
          SUBPARTITION q4_1999_northcentral VALUES ('SD', 'WI'),
          SUBPARTITION q4_1999_southcentral VALUES ('OK', 'TX')
         )
      );
</pre></div>
<!-- class="example" -->
<p>A row is mapped to a partition by checking whether the value of the partitioning column for a row falls within a specific partition range. The row is then mapped to a subpartition within that partition by identifying the subpartition whose descriptor value list contains a value matching the subpartition column value.</p>
<p>For example, some sample rows are inserted as follows:</p>
<ul>
<li>
<p>(10, 4532130, '23-Jan-1999', 8934.10, 'WA') maps to subpartition <code>q1_1999_northwest</code></p>
</li>
<li>
<p>(20, 5671621, '15-May-1999', 49021.21, 'OR') maps to subpartition <code>q2_1999_northwest</code></p>
</li>
<li>
<p>(30, 9977612, '07-Sep-1999', 30987.90, 'FL') maps to subpartition <code>q3_1999_southeast</code></p>
</li>
<li>
<p>(40, 9977612, '29-Nov-1999', 67891.45, 'TX') maps to subpartition <code>q4_1999_southcentral</code></p>
</li>
<li>
<p>(40, 4532130, '5-Jan-2000', 897231.55, 'TX') does not map to any partition in the table and displays an error</p>
</li>
<li>
<p>(50, 5671621, '17-Dec-1999', 76123.35, 'CA') does not map to any subpartition in the table and displays an error</p>
</li>
</ul>
<p>The partitions of a range-list partitioned table are logical structures only, because their data is stored in the segments of their subpartitions. The list subpartitions have the same characteristics as list partitions. You can specify a <a id="sthref343"></a><a id="sthref344"></a><a id="sthref345"></a>default subpartition, just as you specify a default partition for list partitioning.</p>
<p>The following example creates a table that specifies a tablespace at the partition and subpartition levels. The number of subpartitions within each partition varies, and default subpartitions are specified.</p>
<pre>
CREATE TABLE sample_regional_sales
      (deptno number, item_no varchar2(20),
       txn_date date, txn_amount number, state varchar2(2))
  PARTITION BY RANGE (txn_date)
    SUBPARTITION BY LIST (state)
      (PARTITION q1_1999 VALUES LESS THAN (TO_DATE('1-APR-1999','DD-MON-YYYY'))
          TABLESPACE tbs_1
         (SUBPARTITION q1_1999_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q1_1999_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q1_1999_northeast VALUES ('NY', 'VM', 'NJ'),
          SUBPARTITION q1_1999_southeast VALUES ('FL', 'GA'),
          SUBPARTITION q1_others VALUES (DEFAULT) TABLESPACE tbs_4
         ),
       PARTITION q2_1999 VALUES LESS THAN ( TO_DATE('1-JUL-1999','DD-MON-YYYY'))
          TABLESPACE tbs_2
         (SUBPARTITION q2_1999_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q2_1999_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q2_1999_northeast VALUES ('NY', 'VM', 'NJ'),
          SUBPARTITION q2_1999_southeast VALUES ('FL', 'GA'),
          SUBPARTITION q2_1999_northcentral VALUES ('SD', 'WI'),
          SUBPARTITION q2_1999_southcentral VALUES ('OK', 'TX')
         ),
       PARTITION q3_1999 VALUES LESS THAN (TO_DATE('1-OCT-1999','DD-MON-YYYY'))
          TABLESPACE tbs_3
         (SUBPARTITION q3_1999_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q3_1999_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q3_others VALUES (DEFAULT) TABLESPACE tbs_4
         ),
       PARTITION q4_1999 VALUES LESS THAN ( TO_DATE('1-JAN-2000','DD-MON-YYYY'))
          TABLESPACE tbs_4
      );
</pre>
<p>This example results in the following subpartition descriptions:</p>
<ul>
<li>
<p>All subpartitions inherit their physical attributes, other than tablespace, from tablespace level defaults. This is because the only physical attribute that has been specified for partitions or subpartitions is tablespace. There are no table level physical attributes specified, thus tablespace level defaults are inherited at all levels.</p>
</li>
<li>
<p>The first 4 subpartitions of partition <code>q1_1999</code> are all contained in <code>tbs_1</code>, except for the subpartition <code>q1_others</code>, which is stored in <code>tbs_4</code> and contains all rows that do not map to any of the other partitions.</p>
</li>
<li>
<p>The 6 subpartitions of partition <code>q2_1999</code> are all stored in <code>tbs_2</code>.</p>
</li>
<li>
<p>The first 2 subpartitions of partition <code>q3_1999</code> are all contained in <code>tbs_3</code>, except for the subpartition <code>q3_others</code>, which is stored in <code>tbs_4</code> and contains all rows that do not map to any of the other partitions.</p>
</li>
<li>
<p>There is no subpartition description for partition <code>q4_1999</code>. This results in one default subpartition being created and stored in <code>tbs_4</code>. The subpartition name is system generated in the form <code>SYS_SUBP</code><code><span class="codeinlineitalic">n</span></code>.</p>
</li>
</ul>
<p>To learn how using a subpartition template can simplify the specification of a composite partitioned table, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
</div>
<!-- class="sect3" -->
<a id="i1006566"></a><a id="VLDBG1097"></a>
<div class="sect3">
<h3 class="sect3">Creating Composite Range-Range Partitioned Tables<a id="sthref346"></a><a id="sthref347"></a><a id="sthref348"></a></h3>
<p><a id="sthref349"></a><a id="sthref350"></a><a id="sthref351"></a><a id="sthref352"></a>The range partitions of a range-range composite partitioned table are similar to non-composite range partitioned tables. This enables optional subclauses of a <code>PARTITION</code> clause to specify physical and other attributes, including tablespace, specific to a partition segment. If not overridden at the partition level, then partitions inherit the attributes of their underlying table.</p>
<p>The range subpartition descriptions, in the <code>SUBPARTITION</code> clauses, are similar to non-composite range partitions, except the only physical attribute that can be specified is an optional tablespace. Subpartitions inherit all other physical attributes from the partition description.</p>
<p><a href="#CHDJIIEB">Example 4-12</a> illustrates how range-range partitioning might be used. The example tracks shipments. The service level agreement with the customer states that every order is delivered in the calendar month after the order was placed. The following types of orders are identified:</p>
<ul>
<li>
<p>E (EARLY): orders that are delivered before the middle of the next month after the order was placed. These orders likely exceed customers' expectations.</p>
</li>
<li>
<p>A (AGREED): orders that are delivered in the calendar month after the order was placed (but not early orders).</p>
</li>
<li>
<p>L (LATE): orders that were only delivered starting the second calendar month after the order was placed.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="CHDJIIEB"></a><a id="VLDBG14050"></a>Example 4-12 Creating a composite range-range partitioned table</p>
<pre>
CREATE TABLE shipments
( order_id      NUMBER NOT NULL
, order_date    DATE NOT NULL
, delivery_date DATE NOT NULL
, customer_id   NUMBER NOT NULL
, sales_amount  NUMBER NOT NULL
)
PARTITION BY RANGE (order_date)
SUBPARTITION BY RANGE (delivery_date)
( PARTITION p_2006_jul VALUES LESS THAN (TO_DATE('01-AUG-2006','dd-MON-yyyy'))
  ( SUBPARTITION p06_jul_e VALUES LESS THAN (TO_DATE('15-AUG-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_jul_a VALUES LESS THAN (TO_DATE('01-SEP-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_jul_l VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_2006_aug VALUES LESS THAN (TO_DATE('01-SEP-2006','dd-MON-yyyy'))
  ( SUBPARTITION p06_aug_e VALUES LESS THAN (TO_DATE('15-SEP-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_aug_a VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_aug_l VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_2006_sep VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
  ( SUBPARTITION p06_sep_e VALUES LESS THAN (TO_DATE('15-OCT-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_sep_a VALUES LESS THAN (TO_DATE('01-NOV-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_sep_l VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_2006_oct VALUES LESS THAN (TO_DATE('01-NOV-2006','dd-MON-yyyy'))
  ( SUBPARTITION p06_oct_e VALUES LESS THAN (TO_DATE('15-NOV-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_oct_a VALUES LESS THAN (TO_DATE('01-DEC-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_oct_l VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_2006_nov VALUES LESS THAN (TO_DATE('01-DEC-2006','dd-MON-yyyy'))
  ( SUBPARTITION p06_nov_e VALUES LESS THAN (TO_DATE('15-DEC-2006','dd-MON-yyyy'))
  , SUBPARTITION p06_nov_a VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
  , SUBPARTITION p06_nov_l VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_2006_dec VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
  ( SUBPARTITION p06_dec_e VALUES LESS THAN (TO_DATE('15-JAN-2007','dd-MON-yyyy'))
  , SUBPARTITION p06_dec_a VALUES LESS THAN (TO_DATE('01-FEB-2007','dd-MON-yyyy'))
  , SUBPARTITION p06_dec_l VALUES LESS THAN (MAXVALUE)
  )
);
</pre></div>
<!-- class="example" -->
<p>A row is mapped to a partition by checking whether the value of the partitioning column for a row falls within a specific partition range. The row is then mapped to a subpartition within that partition by identifying whether the value of the subpartitioning column falls within a specific range. For example, a shipment with an order date in September 2006 and a delivery date of October 28, 2006 falls in partition <code>p06_oct_a</code>.</p>
<p>To learn how using a subpartition template can simplify the specification of a composite partitioned table, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1098"></a>
<div class="sect3"><a id="sthref353"></a>
<h3 class="sect3">Creating Composite List-* Partitioned Tables</h3>
<p><a id="sthref354"></a><a id="sthref355"></a>The concepts of list-hash, list-list, and list-range composite partitioning are similar to the concepts for range-hash, range-list, and range-range partitioning. However, for list-* composite partitioning you specify <code>PARTITION BY LIST</code> to define the partitioning strategy.</p>
<p>The list partitions of a list-* composite partitioned table are similar to non-composite range partitioned tables. This enables optional subclauses of a <code>PARTITION</code> clause to specify physical and other attributes, including tablespace, specific to a partition segment. If not overridden at the partition level, then partitions inherit the attributes of their underlying table.</p>
<p>The subpartition descriptions, in the <code>SUBPARTITION</code> or <code>SUBPARTITIONS</code> clauses, are similar to range-* composite partitioning methods.</p>
<p>For more information about the subpartition definition of a list-hash composite partitioning method, refer to <a href="#i1006564">"Creating Composite Range-Hash Partitioned Tables"</a>. For more information about the subpartition definition of a list-list composite partitioning method, refer to <a href="#i1006602">"Creating Composite Range-List Partitioned Tables"</a>. For more information about the subpartition definition of a list-range composite partitioning method, refer to <a href="#i1006566">"Creating Composite Range-Range Partitioned Tables"</a>.</p>
<p>The following sections show examples for the different list-* composite partitioning methods.</p>
<a id="VLDBG1099"></a>
<div class="sect4"><a id="sthref356"></a>
<h4 class="sect4">Creating Composite List-Hash Partitioned Tables</h4>
<p><a id="sthref357"></a><a id="sthref358"></a><a id="sthref359"></a><a id="sthref360"></a><a href="#CHDJFCCD">Example 4-13</a> shows an <code>accounts</code> table that is list partitioned by region and subpartitioned using hash by customer identifier.</p>
<div class="example">
<p class="titleinexample"><a id="CHDJFCCD"></a><a id="VLDBG14051"></a>Example 4-13 Creating a composite list-hash partitioned table</p>
<pre>
CREATE TABLE accounts
( id             NUMBER
, account_number NUMBER
, customer_id    NUMBER
, balance        NUMBER
, branch_id      NUMBER
, region         VARCHAR(2)
, status         VARCHAR2(1)
)
PARTITION BY LIST (region)
SUBPARTITION BY HASH (customer_id) SUBPARTITIONS 8
( PARTITION p_northwest VALUES ('OR', 'WA')
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
, PARTITION p_southeast VALUES ('FL', 'GA')
, PARTITION p_northcentral VALUES ('SD', 'WI')
, PARTITION p_southcentral VALUES ('OK', 'TX')
);
</pre></div>
<!-- class="example" -->
<p>To learn how using a subpartition template can simplify the specification of a composite partitioned table, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1100"></a>
<div class="sect4"><a id="sthref361"></a>
<h4 class="sect4">Creating Composite List-List Partitioned Tables</h4>
<p><a id="sthref362"></a><a id="sthref363"></a><a id="sthref364"></a><a id="sthref365"></a><a href="#CHDGDCID">Example 4-14</a> shows an <code>accounts</code> table that is list partitioned by region and subpartitioned using list by account status.</p>
<div class="example">
<p class="titleinexample"><a id="CHDGDCID"></a><a id="VLDBG14052"></a>Example 4-14 Creating a composite list-list partitioned table</p>
<pre>
CREATE TABLE accounts
( id             NUMBER
, account_number NUMBER
, customer_id    NUMBER
, balance        NUMBER
, branch_id      NUMBER
, region         VARCHAR(2)
, status         VARCHAR2(1)
)
PARTITION BY LIST (region)
SUBPARTITION BY LIST (status)
( PARTITION p_northwest VALUES ('OR', 'WA')
  ( SUBPARTITION p_nw_bad VALUES ('B')
  , SUBPARTITION p_nw_average VALUES ('A')
  , SUBPARTITION p_nw_good VALUES ('G')
  )
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
  ( SUBPARTITION p_sw_bad VALUES ('B')
  , SUBPARTITION p_sw_average VALUES ('A')
  , SUBPARTITION p_sw_good VALUES ('G')
  )
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
  ( SUBPARTITION p_ne_bad VALUES ('B')
  , SUBPARTITION p_ne_average VALUES ('A')
  , SUBPARTITION p_ne_good VALUES ('G')
  )
, PARTITION p_southeast VALUES ('FL', 'GA')
  ( SUBPARTITION p_se_bad VALUES ('B')
  , SUBPARTITION p_se_average VALUES ('A')
  , SUBPARTITION p_se_good VALUES ('G')
  )
, PARTITION p_northcentral VALUES ('SD', 'WI')
  ( SUBPARTITION p_nc_bad VALUES ('B')
  , SUBPARTITION p_nc_average VALUES ('A')
  , SUBPARTITION p_nc_good VALUES ('G')
  )
, PARTITION p_southcentral VALUES ('OK', 'TX')
  ( SUBPARTITION p_sc_bad VALUES ('B')
  , SUBPARTITION p_sc_average VALUES ('A')
  , SUBPARTITION p_sc_good VALUES ('G')
  )
);
</pre></div>
<!-- class="example" -->
<p>To learn how using a subpartition template can simplify the specification of a composite partitioned table, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1101"></a>
<div class="sect4"><a id="sthref366"></a>
<h4 class="sect4">Creating Composite List-Range Partitioned Tables</h4>
<p><a id="sthref367"></a><a id="sthref368"></a><a id="sthref369"></a><a id="sthref370"></a><a href="#CHDEAECF">Example 4-15</a> shows an <code>accounts</code> table that is list partitioned by region and subpartitioned using range by account balance. Note that row movement is enabled. Subpartitions for different list partitions could have different ranges specified.</p>
<div class="example">
<p class="titleinexample"><a id="CHDEAECF"></a><a id="VLDBG14053"></a>Example 4-15 Creating a composite list-range partitioned table</p>
<pre>
CREATE TABLE accounts
( id             NUMBER
, account_number NUMBER
, customer_id    NUMBER
, balance        NUMBER
, branch_id      NUMBER
, region         VARCHAR(2)
, status         VARCHAR2(1)
)
PARTITION BY LIST (region)
SUBPARTITION BY RANGE (balance)
( PARTITION p_northwest VALUES ('OR', 'WA')
  ( SUBPARTITION p_nw_low VALUES LESS THAN (1000)
  , SUBPARTITION p_nw_average VALUES LESS THAN (10000)
  , SUBPARTITION p_nw_high VALUES LESS THAN (100000)
  , SUBPARTITION p_nw_extraordinary VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
  ( SUBPARTITION p_sw_low VALUES LESS THAN (1000)
  , SUBPARTITION p_sw_average VALUES LESS THAN (10000)
  , SUBPARTITION p_sw_high VALUES LESS THAN (100000)
  , SUBPARTITION p_sw_extraordinary VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
  ( SUBPARTITION p_ne_low VALUES LESS THAN (1000)
  , SUBPARTITION p_ne_average VALUES LESS THAN (10000)
  , SUBPARTITION p_ne_high VALUES LESS THAN (100000)
  , SUBPARTITION p_ne_extraordinary VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_southeast VALUES ('FL', 'GA')
  ( SUBPARTITION p_se_low VALUES LESS THAN (1000)
  , SUBPARTITION p_se_average VALUES LESS THAN (10000)
  , SUBPARTITION p_se_high VALUES LESS THAN (100000)
  , SUBPARTITION p_se_extraordinary VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_northcentral VALUES ('SD', 'WI')
  ( SUBPARTITION p_nc_low VALUES LESS THAN (1000)
  , SUBPARTITION p_nc_average VALUES LESS THAN (10000)
  , SUBPARTITION p_nc_high VALUES LESS THAN (100000)
  , SUBPARTITION p_nc_extraordinary VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_southcentral VALUES ('OK', 'TX')
  ( SUBPARTITION p_sc_low VALUES LESS THAN (1000)
  , SUBPARTITION p_sc_average VALUES LESS THAN (10000)
  , SUBPARTITION p_sc_high VALUES LESS THAN (100000)
  , SUBPARTITION p_sc_extraordinary VALUES LESS THAN (MAXVALUE)
  )
) ENABLE ROW MOVEMENT;
</pre></div>
<!-- class="example" -->
<p>To learn how using a subpartition template can simplify the specification of a composite partitioned table, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="VLDBG1102"></a>
<div class="sect3"><a id="sthref371"></a>
<h3 class="sect3">Creating Composite Interval-* Partitioned Tables</h3>
<p><a id="sthref372"></a><a id="sthref373"></a>The concepts of interval-* composite partitioning are similar to the concepts for range-* partitioning. However, you extend the <code>PARTITION BY RANGE</code> clause to include the <code>INTERVAL</code> definition. You must specify at least one range partition using the <code>PARTITION</code> clause. The range partitioning key value determines the high value of the range partitions, which is called the transition point, and the database automatically creates interval partitions for data beyond that transition point.</p>
<p>The subpartitions for intervals in an interval-* partitioned table are created when the database creates the interval. You can specify the definition of future subpartitions only with a subpartition template. To learn more about how to use a subpartition template, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
<a id="VLDBG1103"></a>
<div class="sect4"><a id="sthref374"></a>
<h4 class="sect4">Creating Composite Interval-Hash Partitioned Tables</h4>
<p><a id="sthref375"></a><a id="sthref376"></a><a id="sthref377"></a><a id="sthref378"></a>You can create an interval-hash partitioned table with multiple hash partitions using one of the following methods:</p>
<ul>
<li>
<p>Specify multiple hash partitions in the <code>PARTITIONS</code> clause.</p>
</li>
<li>
<p>Use a subpartition template.</p>
</li>
</ul>
<p>If you do not use either of these methods, then future interval partitions get only a single hash subpartition.</p>
<p><a href="#CHDJGCEG">Example 4-16</a> shows the <code>sales</code> table, interval partitioned using monthly intervals on <code>time_id</code>, with hash subpartitions by <code>cust_id</code>. Note that this example specifies multiple hash partitions, without any specific tablespace assignment to the individual hash partitions.</p>
<div class="example">
<p class="titleinexample"><a id="CHDJGCEG"></a><a id="VLDBG14054"></a>Example 4-16 Creating a composite interval-hash partitioned table</p>
<pre>
CREATE TABLE sales
  ( prod_id       NUMBER(6)
  , cust_id       NUMBER
  , time_id       DATE
  , channel_id    CHAR(1)
  , promo_id      NUMBER(6)
  , quantity_sold NUMBER(3)
  , amount_sold   NUMBER(10,2)
  )
 PARTITION BY RANGE (time_id) INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
 SUBPARTITION BY HASH (cust_id) SUBPARTITIONS 4
 ( PARTITION before_2000 VALUES LESS THAN (TO_DATE('01-JAN-2000','dd-MON-yyyy')))
PARALLEL;
</pre></div>
<!-- class="example" -->
<p>The following example shows the same <code>sales</code> table, interval partitioned using monthly intervals on <code>time_id</code>, again with hash subpartitions by <code>cust_id</code>. This time, however, individual hash partitions are stored in separate tablespaces. Note that the subpartition template is used to define the tablespace assignment for future hash subpartitions. To learn more about how to use a subpartition template, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
<pre>
CREATE TABLE sales
  ( prod_id       NUMBER(6)
  , cust_id       NUMBER
  , time_id       DATE
  , channel_id    CHAR(1)
  , promo_id      NUMBER(6)
  , quantity_sold NUMBER(3)
  , amount_sold   NUMBER(10,2)
  )
 PARTITION BY RANGE (time_id) INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
 SUBPARTITION BY hash(cust_id)
   SUBPARTITION template
   ( SUBPARTITION p1 TABLESPACE ts1
   , SUBPARTITION p2 TABLESPACE ts2
   , SUBPARTITION p3 TABLESPACE ts3
   , SUBPARTITION P4 TABLESPACE ts4
   )
 ( PARTITION before_2000 VALUES LESS THAN (TO_DATE('01-JAN-2000','dd-MON-yyyy'))
) PARALLEL;
</pre></div>
<!-- class="sect4" -->
<a id="VLDBG1104"></a>
<div class="sect4"><a id="sthref379"></a>
<h4 class="sect4">Creating Composite Interval-List Partitioned Tables</h4>
<p><a id="sthref380"></a><a id="sthref381"></a><a id="sthref382"></a><a id="sthref383"></a>The only way to define list subpartitions for future interval partitions is with the subpartition template. If you do not use the subpartitioning template, then the only subpartition that are created for every interval partition is a <code>DEFAULT</code> subpartition. To learn more about how to use a subpartition template, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
<p><a href="#CHDCJDAD">Example 4-17</a> shows the <code>sales</code> table, interval partitioned using daily intervals on <code>time_id</code>, with list subpartitions by <code>channel_id</code>.</p>
<div class="example">
<p class="titleinexample"><a id="CHDCJDAD"></a><a id="VLDBG14055"></a>Example 4-17 Creating a composite interval-list partitioned table</p>
<pre>
CREATE TABLE sales
  ( prod_id       NUMBER(6)
  , cust_id       NUMBER
  , time_id       DATE
  , channel_id    CHAR(1)
  , promo_id      NUMBER(6)
  , quantity_sold NUMBER(3)
  , amount_sold   NUMBER(10,2)
  )
 PARTITION BY RANGE (time_id) INTERVAL (NUMTODSINTERVAL(1,'DAY'))
 SUBPARTITION BY LIST (channel_id)
   SUBPARTITION TEMPLATE
   ( SUBPARTITION p_catalog VALUES ('C')
   , SUBPARTITION p_internet VALUES ('I')
   , SUBPARTITION p_partners VALUES ('P')
   , SUBPARTITION p_direct_sales VALUES ('S')
   , SUBPARTITION p_tele_sales VALUES ('T')
   )
 ( PARTITION before_2000 VALUES LESS THAN (TO_DATE('01-JAN-2000','dd-MON-yyyy')))
PARALLEL;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="VLDBG1105"></a>
<div class="sect4"><a id="sthref384"></a>
<h4 class="sect4">Creating Composite Interval-Range Partitioned Tables</h4>
<p><a id="sthref385"></a><a id="sthref386"></a><a id="sthref387"></a><a id="sthref388"></a>The only way to define range subpartitions for future interval partitions is with the subpartition template. If you do not use the subpartition template, then the only subpartition that is created for every interval partition is a range subpartition with the <code>MAXVALUE</code> upper boundary. To learn more about how to use a subpartition template, see <a href="#i1006655">"Using Subpartition Templates to Describe Composite Partitioned Tables"</a>.</p>
<p><a href="#CHDIFGBB">Example 4-18</a> shows the <code>sales</code> table, interval partitioned using daily intervals on <code>time_id</code>, with range subpartitions by <code>amount_sold</code>.</p>
<div class="example">
<p class="titleinexample"><a id="CHDIFGBB"></a><a id="VLDBG14056"></a>Example 4-18 Creating a composite interval-range partitioned table</p>
<pre>
CREATE TABLE sales
  ( prod_id       NUMBER(6)
  , cust_id       NUMBER
  , time_id       DATE
  , channel_id    CHAR(1)
  , promo_id      NUMBER(6)
  , quantity_sold NUMBER(3)
  , amount_sold   NUMBER(10,2)
  )
 PARTITION BY RANGE (time_id) INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY RANGE(amount_sold)
   SUBPARTITION TEMPLATE
   ( SUBPARTITION p_low VALUES LESS THAN (1000)
   , SUBPARTITION p_medium VALUES LESS THAN (4000)
   , SUBPARTITION p_high VALUES LESS THAN (8000)
   , SUBPARTITION p_ultimate VALUES LESS THAN (maxvalue)
   )
 ( PARTITION before_2000 VALUES LESS THAN (TO_DATE('01-JAN-2000','dd-MON-yyyy')))
PARALLEL;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006655"></a><a id="VLDBG1106"></a>
<div class="sect2">
<h2 class="sect2">Using Subpartition Templates to Describe Composite Partitioned Tables</h2>
<p><a id="sthref389"></a><a id="sthref390"></a>You can create subpartitions in a composite partitioned table using a subpartition template. A subpartition template simplifies the specification of subpartitions by not requiring that a subpartition descriptor be specified for every partition in the table. Instead, you describe subpartitions only one time in a template, then apply that subpartition template to every partition in the table. For interval-* composite partitioned tables, the subpartition template is the only way to define subpartitions for interval partitions.</p>
<p>The subpartition template is used whenever a subpartition descriptor is not specified for a partition. If a subpartition descriptor is specified, then it is used instead of the subpartition template for that partition. If no subpartition template is specified, and no subpartition descriptor is supplied for a partition, then a single default subpartition is created.</p>
<a id="VLDBG1107"></a>
<div class="sect3"><a id="sthref391"></a>
<h3 class="sect3">Specifying a Subpartition Template for a *-Hash Partitioned Table</h3>
<p><a id="sthref392"></a><a id="sthref393"></a><a id="sthref394"></a>For range-hash, interval-hash, and list-hash partitioned tables, the subpartition template can describe the subpartitions in detail, or it can specify just the number of hash subpartitions.</p>
<p><a href="#CHDCGBAB">Example 4-19</a> creates a range-hash partitioned table using a subpartition template:</p>
<div class="example">
<p class="titleinexample"><a id="CHDCGBAB"></a><a id="VLDBG14057"></a>Example 4-19 Creating a range-hash partitioned table with a subpartition template</p>
<pre>
CREATE TABLE emp_sub_template (deptno NUMBER, empname VARCHAR(32), grade NUMBER)
     PARTITION BY RANGE(deptno) SUBPARTITION BY HASH(empname)
     SUBPARTITION TEMPLATE
         (SUBPARTITION a TABLESPACE ts1,
          SUBPARTITION b TABLESPACE ts2,
          SUBPARTITION c TABLESPACE ts3,
          SUBPARTITION d TABLESPACE ts4
         )
    (PARTITION p1 VALUES LESS THAN (1000),
     PARTITION p2 VALUES LESS THAN (2000),
     PARTITION p3 VALUES LESS THAN (MAXVALUE)
    );
</pre></div>
<!-- class="example" -->
<p>This example produces the following table description:</p>
<ul>
<li>
<p>Every partition has four subpartitions as described in the subpartition template.</p>
</li>
<li>
<p>Each subpartition has a tablespace specified. It is required that if a tablespace is specified for one subpartition in a subpartition template, then one must be specified for all.</p>
</li>
<li>
<p>The names of the subpartitions, unless you use interval-* subpartitioning, are generated by concatenating the partition name with the subpartition name in the form:</p>
<p><span class="italic">partition name</span>_<span class="italic">subpartition name</span></p>
<p>For interval-* subpartitioning, the subpartition names are system-generated in the form:</p>
<p><code>SYS_SUBP</code><code><span class="codeinlineitalic">n</span></code></p>
</li>
</ul>
<p>The following query displays the subpartition names and tablespaces:</p>
<pre>
SQL&gt; SELECT TABLESPACE_NAME, PARTITION_NAME, SUBPARTITION_NAME
  2  FROM DBA_TAB_SUBPARTITIONS WHERE TABLE_NAME='EMP_SUB_TEMPLATE'
  3  ORDER BY TABLESPACE_NAME;

TABLESPACE_NAME PARTITION_NAME  SUBPARTITION_NAME
--------------- --------------- ------------------
TS1             P1              P1_A
TS1             P2              P2_A
TS1             P3              P3_A
TS2             P1              P1_B
TS2             P2              P2_B
TS2             P3              P3_B
TS3             P1              P1_C
TS3             P2              P2_C
TS3             P3              P3_C
TS4             P1              P1_D
TS4             P2              P2_D
TS4             P3              P3_D

12 rows selected.
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1108"></a>
<div class="sect3"><a id="sthref395"></a>
<h3 class="sect3">Specifying a Subpartition Template for a *-List Partitioned Table</h3>
<p><a id="sthref396"></a><a id="sthref397"></a><a id="sthref398"></a><a href="#CHDDADIE">Example 4-20</a>, for a range-list partitioned table, illustrates how using a subpartition template can help you stripe data across tablespaces. In this example, a table is created where the table subpartitions are vertically striped, meaning that subpartition <span class="italic">n</span> from every partition is in the same tablespace.</p>
<div class="example">
<p class="titleinexample"><a id="CHDDADIE"></a><a id="VLDBG14058"></a>Example 4-20 Creating a range-list partitioned table with a subpartition template</p>
<pre>
CREATE TABLE stripe_regional_sales
            ( deptno number, item_no varchar2(20),
              txn_date date, txn_amount number, state varchar2(2))
   PARTITION BY RANGE (txn_date)
   SUBPARTITION BY LIST (state)
   SUBPARTITION TEMPLATE 
      (SUBPARTITION northwest VALUES ('OR', 'WA') TABLESPACE tbs_1,
       SUBPARTITION southwest VALUES ('AZ', 'UT', 'NM') TABLESPACE tbs_2,
       SUBPARTITION northeast VALUES ('NY', 'VM', 'NJ') TABLESPACE tbs_3,
       SUBPARTITION southeast VALUES ('FL', 'GA') TABLESPACE tbs_4,
       SUBPARTITION midwest VALUES ('SD', 'WI') TABLESPACE tbs_5,
       SUBPARTITION south VALUES ('AL', 'AK') TABLESPACE tbs_6,
       SUBPARTITION others VALUES (DEFAULT ) TABLESPACE tbs_7
      )
  (PARTITION q1_1999 VALUES LESS THAN ( TO_DATE('01-APR-1999','DD-MON-YYYY')),
   PARTITION q2_1999 VALUES LESS THAN ( TO_DATE('01-JUL-1999','DD-MON-YYYY')),
   PARTITION q3_1999 VALUES LESS THAN ( TO_DATE('01-OCT-1999','DD-MON-YYYY')),
   PARTITION q4_1999 VALUES LESS THAN ( TO_DATE('1-JAN-2000','DD-MON-YYYY'))
  );
</pre></div>
<!-- class="example" -->
<p>If you specified the tablespaces at the partition level (for example, <code>tbs_1</code> for partition <code>q1_1999</code>, <code>tbs_2</code> for partition <code>q2_1999</code>, <code>tbs_3</code> for partition <code>q3_1999</code>, and <code>tbs_4</code> for partition <code>q4_1999</code>) and not in the subpartition template, then the table would be horizontally striped. All subpartitions would be in the tablespace of the owning partition.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008909"></a><a id="VLDBG00301"></a>
<div class="sect2">
<h2 class="sect2">Using Multicolumn Partitioning Keys</h2>
<p>For <a id="sthref399"></a><a id="sthref400"></a>range-partitioned and <a id="sthref401"></a>hash-partitioned tables, you can specify up to 16 partitioning key columns. Use multicolumn partitioning when the partitioning key is composed of several columns and subsequent columns define a higher granularity than the preceding ones. The most common scenario is a decomposed <code>DATE</code> or <code>TIMESTAMP</code> key, consisting of separated columns, for year, month, and day.</p>
<p>In evaluating multicolumn partitioning keys, the database uses the second value only if the first value cannot uniquely identify a single target partition, and uses the third value only if the first and second do not determine the correct partition, and so forth. A value cannot determine the correct partition only when a partition bound exactly matches that value and the same bound is defined for the next partition. The <span class="italic">n</span><sup>th</sup> column is investigated only when all previous (n-1) values of the multicolumn key exactly match the (n-1) bounds of a partition. A second column, for example, is evaluated only if the first column exactly matches the partition boundary value. If all column values exactly match all of the bound values for a partition, then the database determines that the row does not fit in this partition and considers the next partition for a match.</p>
<p>For nondeterministic boundary definitions (successive partitions with identical values for at least one column), the partition boundary value becomes an inclusive value, representing a "less than or equal to" boundary. This is in contrast to deterministic boundaries, where the values are always regarded as "less than" boundaries.</p>
<p><a href="#CHDEJJFJ">Example 4-21</a> illustrates the column evaluation for a multicolumn range-partitioned table, storing the actual <code>DATE</code> information in three separate columns: <code>year</code>, <code>month</code>, and <code>day</code>. The partitioning granularity is a calendar quarter. The partitioned table being evaluated is created as follows:</p>
<div class="example">
<p class="titleinexample"><a id="CHDEJJFJ"></a><a id="VLDBG14059"></a>Example 4-21 Creating a multicolumn range-partitioned table</p>
<pre>
CREATE TABLE sales_demo (
   year          NUMBER, 
   month         NUMBER,
   day           NUMBER,
   amount_sold   NUMBER) 
PARTITION BY RANGE (year,month) 
  (PARTITION before2001 VALUES LESS THAN (2001,1),
   PARTITION q1_2001    VALUES LESS THAN (2001,4),
   PARTITION q2_2001    VALUES LESS THAN (2001,7),
   PARTITION q3_2001    VALUES LESS THAN (2001,10),
   PARTITION q4_2001    VALUES LESS THAN (2002,1),
   PARTITION future     VALUES LESS THAN (MAXVALUE,0));

REM  12-DEC-2000
INSERT INTO sales_demo VALUES(2000,12,12, 1000);
REM  17-MAR-2001
INSERT INTO sales_demo VALUES(2001,3,17, 2000);
REM  1-NOV-2001
INSERT INTO sales_demo VALUES(2001,11,1, 5000);
REM  1-JAN-2002
INSERT INTO sales_demo VALUES(2002,1,1, 4000);
</pre></div>
<!-- class="example" -->
<p>The year value for 12-DEC-2000 satisfied the first partition, <code>before2001</code>, so no further evaluation is needed:</p>
<pre>
SELECT * FROM sales_demo PARTITION(before2001);

      YEAR      MONTH        DAY AMOUNT_SOLD
---------- ---------- ---------- -----------
      2000         12         12        1000
</pre>
<p>The information for 17-MAR-2001 is stored in partition <code>q1_2001</code>. The first partitioning key column, <code>year</code>, does not by itself determine the correct partition, so the second partitioning key column, <code>month</code>, must be evaluated.</p>
<pre>
SELECT * FROM sales_demo PARTITION(q1_2001);

      YEAR      MONTH        DAY AMOUNT_SOLD
---------- ---------- ---------- -----------
      2001          3         17        2000
</pre>
<p>Following the same determination rule as for the previous record, the second column, <code>month</code>, determines partition <code>q4_2001</code> as correct partition for 1-NOV-2001:</p>
<pre>
SELECT * FROM sales_demo PARTITION(q4_2001);

      YEAR      MONTH        DAY AMOUNT_SOLD
---------- ---------- ---------- -----------
      2001         11          1        5000
</pre>
<p>The partition for 01-JAN-2002 is determined by evaluating only the <code>year</code> column, which indicates the <code>future</code> partition:</p>
<pre>
SELECT * FROM sales_demo PARTITION(future);

      YEAR      MONTH        DAY AMOUNT_SOLD
---------- ---------- ---------- -----------
      2002          1          1        4000
</pre>
<p>If the database encounters <code>MAXVALUE</code> in one of the partitioning key columns, then all other values of subsequent columns become irrelevant. That is, a definition of partition <code>future</code> in the preceding example, having a bound of (<code>MAXVALUE</code>,0) is equivalent to a bound of (<code>MAXVALUE</code>,100) or a bound of (<code>MAXVALUE</code>,<code>MAXVALUE</code>).</p>
<p>The following example illustrates the use of a multicolumn partitioned approach for table <code>supplier_parts</code>, storing the information about which suppliers deliver which parts. To distribute the data in equal-sized partitions, it is not sufficient to partition the table based on the <code>supplier_id</code>, because some suppliers might provide hundreds of thousands of parts, while others provide only a few specialty parts. Instead, you partition the table on (<code>supplier_id</code>, <code>partnum</code>) to manually enforce equal-sized partitions.</p>
<pre>
CREATE TABLE supplier_parts (
   supplier_id      NUMBER, 
   partnum          NUMBER,
   price            NUMBER)
PARTITION BY RANGE (supplier_id, partnum)
  (PARTITION p1 VALUES LESS THAN  (10,100),
   PARTITION p2 VALUES LESS THAN (10,200),
   PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE));
</pre>
<p>The following three records are inserted into the table:</p>
<pre>
INSERT INTO supplier_parts VALUES (5,5, 1000);
INSERT INTO supplier_parts VALUES (5,150, 1000);
INSERT INTO supplier_parts VALUES (10,100, 1000);
</pre>
<p>The first two records are inserted into partition <code>p1</code>, uniquely identified by <code>supplier_id</code>. However, the third record is inserted into partition <code>p2</code>; it matches all range boundary values of partition <code>p1</code> exactly and the database therefore considers the following partition for a match. The value of <code>partnum</code> satisfies the criteria &lt; 200, so it is inserted into partition <code>p2</code>.</p>
<pre>
SELECT * FROM supplier_parts PARTITION (p1);

SUPPLIER_ID    PARTNUM      PRICE
----------- ---------- ----------
          5          5       1000
          5        150       1000

SELECT * FROM supplier_parts PARTITION (p2);

SUPPLIER_ID    PARTNUM      PRICE
----------- ---------- ----------
          10       100       1000
</pre>
<p>Every row with <code>supplier_id</code> &lt; 10 is stored in partition <code>p1</code>, regardless of the <code>partnum</code> value. The column <code>partnum</code> is evaluated only if <code>supplier_id</code> =10, and the corresponding rows are inserted into partition <code>p1</code>, <code>p2</code>, or even into <code>p3</code> when <code>partnum</code> &gt;=200. To achieve equal-sized partitions for ranges of <code>supplier_parts</code>, you could choose a composite range-hash partitioned table, range partitioned by <code>supplier_id</code>, hash subpartitioned by <code>partnum</code>.</p>
<p>Defining the partition boundaries for multicolumn partitioned tables must obey some rules. For example, consider a table that is range partitioned on three columns <code>a</code>, <code>b</code>, and <code>c</code>. The individual partitions have range values represented as follows:</p>
<pre>
P0(a0, b0, c0)
P1(a1, b1, c1)
P2(a2, b2, c2)
...
Pn(an, bn, cn)
</pre>
<p>The range values you provide for each partition must follow these rules:</p>
<ul>
<li>
<p><code>a0</code> must be less than or equal to <code>a1</code>, and <code>a1</code> must be less than or equal to <code>a2</code>, and so on.</p>
</li>
<li>
<p>If <code>a0</code>=<code>a1</code>, then <code>b0</code> must be less than or equal to <code>b1</code>. If <code>a0</code> &lt; <code>a1</code>, then <code>b0</code> and <code>b1</code> can have any values. If <code>a0</code>=<code>a1</code> and <code>b0</code>=<code>b1</code>, then <code>c0</code> must be less than or equal to <code>c1</code>. If <code>b0</code>&lt;<code>b1</code>, then <code>c0</code> and <code>c1</code> can have any values, and so on.</p>
</li>
<li>
<p>If <code>a1</code>=<code>a2</code>, then <code>b1</code> must be less than or equal to <code>b2</code>. If <code>a1</code>&lt;<code>a2</code>, then <code>b1</code> and <code>b2</code> can have any values. If <code>a1</code>=<code>a2</code> and <code>b1</code>=<code>b2</code>, then <code>c1</code> must be less than or equal to <code>c2</code>. If <code>b1</code>&lt;<code>b2</code>, then <code>c1</code> and <code>c2</code> can have any values, and so on.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BAJCHBAJ"></a><a id="VLDBG1109"></a>
<div class="sect2">
<h2 class="sect2">Using Virtual Column-Based Partitioning</h2>
<p><a id="sthref402"></a><a id="sthref403"></a>With partitioning, a virtual column can be used as any regular column. All partition methods are supported when using virtual columns, including interval partitioning and all different combinations of composite partitioning. A virtual column used as the partitioning column cannot use calls to a PL/SQL function.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax on how to create a virtual column</div>
<p><a href="#CHDFCDFE">Example 4-22</a> shows the <code>sales</code> table partitioned by range-range using a virtual column for the subpartitioning key. The virtual column calculates the total value of a sale by multiplying <code>amount_sold</code> and <code>quantity_sold</code>.</p>
<div class="example">
<p class="titleinexample"><a id="CHDFCDFE"></a><a id="VLDBG14060"></a>Example 4-22 Creating a table with a virtual column for the subpartitioning key</p>
<pre>
CREATE TABLE sales
  ( prod_id       NUMBER(6) NOT NULL
  , cust_id       NUMBER NOT NULL
  , time_id       DATE NOT NULL
  , channel_id    CHAR(1) NOT NULL
  , promo_id      NUMBER(6) NOT NULL
  , quantity_sold NUMBER(3) NOT NULL
  , amount_sold   NUMBER(10,2) NOT NULL
  , total_amount AS (quantity_sold * amount_sold)
  )
 PARTITION BY RANGE (time_id) INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
 SUBPARTITION BY RANGE(total_amount)
 SUBPARTITION TEMPLATE
   ( SUBPARTITION p_small VALUES LESS THAN (1000)
   , SUBPARTITION p_medium VALUES LESS THAN (5000)
   , SUBPARTITION p_large VALUES LESS THAN (10000)
   , SUBPARTITION p_extreme VALUES LESS THAN (MAXVALUE)
   )
 (PARTITION sales_before_2007 VALUES LESS THAN
        (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
)
ENABLE ROW MOVEMENT
PARALLEL NOLOGGING;
</pre></div>
<!-- class="example" -->
<p>As the example shows, row movement is also supported with virtual columns. If row movement is enabled, then a row migrates from one partition to another partition if the virtual column evaluates to a value that belongs to another partition.</p>
</div>
<!-- class="sect2" -->
<a id="BAJCAHBJ"></a><a id="VLDBG1110"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Using Table Compression with Partitioned Tables</h2>
<p><a id="sthref404"></a><a id="sthref405"></a>For heap-organized partitioned tables, you can compress some or all partitions using table compression. The compression attribute can be declared for a tablespace, a table, or a partition of a table. Whenever the compress attribute is not specified, it is inherited like any other storage attribute.</p>
<p><a href="#CHDCCFGE">Example 4-23</a> creates a list-partitioned table with one compressed partition <code>costs_old</code>. The compression attribute for the table and all other partitions is inherited from the tablespace level.</p>
<div class="example">
<p class="titleinexample"><a id="CHDCCFGE"></a><a id="VLDBG14061"></a>Example 4-23 Creating a list-partitioned table with a compressed partition</p>
<pre>
CREATE TABLE costs_demo (
   prod_id     NUMBER(6),    time_id     DATE, 
   unit_cost   NUMBER(10,2), unit_price  NUMBER(10,2))
PARTITION BY RANGE (time_id)
   (PARTITION costs_old 
       VALUES LESS THAN (TO_DATE('01-JAN-2003', 'DD-MON-YYYY')) COMPRESS,
    PARTITION costs_q1_2003 
       VALUES LESS THAN (TO_DATE('01-APR-2003', 'DD-MON-YYYY')),
    PARTITION costs_q2_2003
       VALUES LESS THAN (TO_DATE('01-JUN-2003', 'DD-MON-YYYY')),
    PARTITION costs_recent VALUES LESS THAN (MAXVALUE));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BAJECHCD"></a><a id="VLDBG1111"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Using Key Compression with Partitioned Indexes</h2>
<p><a id="sthref406"></a><a id="sthref407"></a>You can compress some or all partitions of a B-tree index using key compression. Key compression is applicable only to B-tree indexes. Bitmap indexes are stored in a compressed manner by default. An index using key compression eliminates repeated occurrences of key column prefix values, thus saving space and I/O.</p>
<p>The following example creates a local partitioned index with all partitions except the most recent one compressed:</p>
<pre>
CREATE INDEX i_cost1 ON costs_demo (prod_id) COMPRESS LOCAL
   (PARTITION costs_old, PARTITION costs_q1_2003, 
    PARTITION costs_q2_2003, PARTITION costs_recent NOCOMPRESS);
</pre>
<p>You cannot specify <code>COMPRESS</code> (or <code>NOCOMPRESS</code>) explicitly for an index subpartition. All index subpartitions of a given partition inherit the key compression setting from the parent partition.</p>
<p>To modify the key compression attribute for all subpartitions of a given partition, you must first issue an <code>ALTER INDEX...MODIFY PARTITION</code> statement and then rebuild all subpartitions. The <code>MODIFY PARTITION</code> clause marks all index subpartitions as <code>UNUSABLE</code>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFCCHA"></a><a id="VLDBG14062"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Using Partitioning with Segments</h2>
<div class="infobox-note">
<p class="notep1">Note:</p>
This functionality is available starting with Oracle Database 11g Release 2 (11.2.0.2).</div>
<p><a id="sthref408"></a><a id="sthref409"></a>This sections discusses the functionality when using partitioning with segments:</p>
<ul>
<li>
<p><a href="#CHDHBAJH">Deferred Segment Creation for Partitioning</a></p>
</li>
<li>
<p><a href="#CHDDFIHD">Truncating Segments That Are Empty</a></p>
</li>
<li>
<p><a href="#CHDEAJAC">Maintenance Procedures for Segment Creation on Demand</a></p>
</li>
</ul>
<a id="CHDHBAJH"></a><a id="VLDBG14063"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Deferred Segment Creation for Partitioning</h3>
<p><a id="sthref410"></a><a id="sthref411"></a><a id="sthref412"></a>You can defer the creation of segments when creating a partitioned table until the first row is inserted into a partition. Subsequently, when the first row is inserted, segments are created for the base table partition, LOB columns, all global indexes, and local index partitions. Deferred segment creation can be controlled by the following:</p>
<ul>
<li>
<p>Setting the <code>DEFERRED_SEGMENT_CREATION</code> initialization parameter to <code>TRUE</code> or <code>FALSE</code> in the initialization parameter file.</p>
</li>
<li>
<p>Setting the initialization parameter <code>DEFERRED_SEGMENT_CREATION</code> to <code>TRUE</code> or <code>FALSE</code> with the <code>ALTER</code> <code>SESSION</code> or <code>ALTER</code> <code>SYSTEM</code> SQL statements.</p>
</li>
<li>
<p>Specifying the keywords <code>SEGMENT</code> <code>CREATION</code> <code>IMMEDIATE</code> or <code>SEGMENT</code> <code>CREATION</code> <code>DEFERRED</code> with the partition clause when issuing the <code>CREATE</code> <code>TABLE</code> SQL statement.</p>
</li>
</ul>
<p>You can force the creation of segments for an existing created partition with the <code>ALTER</code> <code>TABLE</code> ... <code>MODIFY</code> <code>PARTITION</code> ... <code>ALLOCATE</code> <code>EXTENT</code> SQL statement. This statement allocates one extent more than the initial number of extents specified during the <code>CREATE</code> <code>TABLE</code>.</p>
<p>Serializable transactions do not work with deferred segment creation. Inserting data into an empty table with no segment created, or into a partition of an interval partitioned table that does not have a segment yet, causes an error.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for more information about the <code>DEFERRED_SEGMENT_CREATION</code> initialization parameter</p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code>ALTER</code> <code>SESSION</code> and <code>ALTER</code> <code>SYSTEM</code> SQL statements</p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the keywords <code>SEGMENT</code> <code>CREATION</code> <code>IMMEDIATE</code> and <code>SEGMENT</code> <code>CREATION</code> <code>DEFERRED</code> of the <code>CREATE</code> <code>TABLE</code> SQL statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDDFIHD"></a><a id="VLDBG14064"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Truncating Segments That Are Empty</h3>
<p><a id="sthref413"></a><a id="sthref414"></a><a id="sthref415"></a>You can drop empty segments in tables and table fragments with the <code>DBMS_SPACE_ADMIN.DROP_EMPTY_SEGMENTS</code> procedure.</p>
<p>In addition, if a partition or subpartition has a segment, then the truncate feature drops the segment if the <code>DROP</code> <code>ALL</code> <code>STORAGE</code> clause is specified with the <code>ALTER</code> <code>TABLE</code> <code>TRUNCATE</code> <code>PARTITION</code> SQL statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>DBMS_SPACE_ADMIN</code> package</p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code>DROP</code> <code>ALL</code> <code>STORAGE</code> clause of <code>ALTER</code> <code>TABLE</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDEAJAC"></a><a id="VLDBG14065"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Maintenance Procedures for Segment Creation on Demand</h3>
<p><a id="sthref416"></a><a id="sthref417"></a><a id="sthref418"></a>You can use the <code>MATERIALIZE_DEFERRED_SEGMENTS</code> procedure in the <code>DBMS_SPACE_ADMIN</code> package to create segments for tables and dependent objects for tables with the deferred segment property.</p>
<p>You can also force the creation of segments for an existing created table and table fragment with the <code>DBMS_SPACE_ADMIN.MATERIALIZE_DEFERRED_SEGMENTS</code> procedure. The <code>MATERIALIZE_DEFERRED_SEGMENTS</code> procedure differs from the <code>ALTER</code> <code>TABLE</code> ... <code>MODIFY</code> <code>PARTITION</code> ... <code>ALLOCATE</code> <code>EXTENT</code> SQL statement because it does not allocate one additional extent for the table or table fragment.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>DBMS_SPACE_ADMIN</code> package</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006727"></a><a id="VLDBG1112"></a>
<div class="sect2">
<h2 class="sect2">Creating Partitioned Index-Organized Tables</h2>
<p><a id="sthref419"></a><a id="sthref420"></a>For index-organized tables, you can use the range, list, or hash partitioning method. The semantics for creating partitioned index-organized tables is similar to that for regular tables with these differences:</p>
<ul>
<li>
<p>When you create the table, you specify the <code>ORGANIZATION INDEX</code> clause, and <code>INCLUDING</code> and <code>OVERFLOW</code> clauses as necessary.</p>
</li>
<li>
<p>The <code>PARTITION</code> or <code>PARTITIONS</code> clauses can have <code>OVERFLOW</code> subclauses that allow you to specify attributes of the overflow segments at the partition level.</p>
</li>
</ul>
<p>Specifying an <code>OVERFLOW</code> clause results in the overflow data segments themselves being equipartitioned with the primary key index segments. Thus, for partitioned index-organized tables with overflow, each partition has an index segment and an overflow data segment.</p>
<p>For index-organized tables, the set of partitioning columns must be a subset of the primary key columns. Because rows of an index-organized table are stored in the primary key index for the table, the partitioning criterion affects the availability. By choosing the partitioning key to be a subset of the primary key, an insert operation must only verify uniqueness of the primary key in a single partition, thereby maintaining partition independence.</p>
<p>Support for secondary indexes on index-organized tables is similar to the support for regular tables. Because of the logical nature of the secondary indexes, global indexes on index-organized tables remain usable for certain operations where they would be marked <code>UNUSABLE</code> for regular tables. For more information, refer to <a href="part_admin002.htm#i1006820">"Maintaining Partitions"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN01506" href="../../server.112/e25494/tables.htm#ADMIN01506"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about managing index-organized tables</p>
</li>
<li>
<p><a class="olink CNCPT911" href="../../server.112/e40540/indexiot.htm#CNCPT911"><span class="italic">Oracle Database Concepts</span></a> for more information about index-organized tables</p>
</li>
</ul>
</div>
<a id="VLDBG1113"></a>
<div class="sect3"><a id="sthref421"></a>
<h3 class="sect3">Creating Range-Partitioned Index-Organized Tables</h3>
<p><a id="sthref422"></a><a id="sthref423"></a><a id="sthref424"></a><a id="sthref425"></a>You can partition index-organized tables, and their secondary indexes<a id="sthref426"></a><a id="sthref427"></a>, by the range method. In <a href="#CHDJCEAJ">Example 4-24</a>, a range-partitioned index-organized table <code>sales</code> is created. The <code>INCLUDING</code> clause specifies that all columns after <code>week_no</code> are to be stored in an overflow segment. There is one overflow segment for each partition, all stored in the same tablespace (<code>overflow_here</code>). Optionally, <code>OVERFLOW TABLESPACE</code> could be specified at the individual partition level, in which case some or all of the overflow segments could have separate <code>TABLESPACE</code> attributes.</p>
<div class="example">
<p class="titleinexample"><a id="CHDJCEAJ"></a><a id="VLDBG14066"></a>Example 4-24 Creating a range-partitioned index-organized table</p>
<pre>
CREATE TABLE sales(acct_no NUMBER(5), 
                   acct_name CHAR(30), 
                   amount_of_sale NUMBER(6), 
                   week_no INTEGER,
                   sale_details VARCHAR2(1000),
             PRIMARY KEY (acct_no, acct_name, week_no)) 
     ORGANIZATION INDEX 
             INCLUDING week_no
             OVERFLOW TABLESPACE overflow_here
     PARTITION BY RANGE (week_no)
            (PARTITION VALUES LESS THAN (5) 
                   TABLESPACE ts1,
             PARTITION VALUES LESS THAN (9) 
                   TABLESPACE ts2 OVERFLOW TABLESPACE overflow_ts2,
             ...
             PARTITION VALUES LESS THAN (MAXVALUE) 
                   TABLESPACE ts13);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="VLDBG1114"></a>
<div class="sect3"><a id="sthref428"></a>
<h3 class="sect3">Creating Hash-Partitioned Index-Organized Tables</h3>
<p><a id="sthref429"></a><a id="sthref430"></a><a id="sthref431"></a><a id="sthref432"></a>Another option for partitioning index-organized tables is to use the hash method. In <a href="#CHDDCFHH">Example 4-25</a>, the <code>sales</code> index-organized table is partitioned by the hash method.</p>
<div class="example">
<p class="titleinexample"><a id="CHDDCFHH"></a><a id="VLDBG14067"></a>Example 4-25 Creating a hash-partitioned index-organized table</p>
<pre>
CREATE TABLE sales(acct_no NUMBER(5), 
                   acct_name CHAR(30), 
                   amount_of_sale NUMBER(6), 
                   week_no INTEGER,
                   sale_details VARCHAR2(1000),
             PRIMARY KEY (acct_no, acct_name, week_no)) 
     ORGANIZATION INDEX 
             INCLUDING week_no
     OVERFLOW
          PARTITION BY HASH (week_no)
             PARTITIONS 16
             STORE IN (ts1, ts2, ts3, ts4)
             OVERFLOW STORE IN (ts3, ts6, ts9);
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
A well-designed hash function is intended to distribute rows in a well-balanced fashion among the partitions. Therefore, updating the primary key column(s) of a row is very likely to move that row to a different partition. Oracle recommends that you explicitly specify the <code>ENABLE ROW MOVEMENT</code> clause when creating a hash-partitioned index-organized table with a changeable partitioning key. The default is that <code>ENABLE ROW MOVEMENT</code> is disabled.</div>
</div>
<!-- class="sect3" -->
<a id="VLDBG1115"></a>
<div class="sect3"><a id="sthref433"></a>
<h3 class="sect3">Creating List-Partitioned Index-Organized Tables</h3>
<p><a id="sthref434"></a><a id="sthref435"></a><a id="sthref436"></a><a id="sthref437"></a>The other option for partitioning index-organized tables is to use the list method. In the following example, the <code>sales</code> index-organized table is partitioned by the list method. <a href="#CHDEAGIJ">Example 4-26</a> uses the <code>example</code> tablespace, which is part of the sample schemas in your seed database. Normally you would specify different tablespace storage for different partitions.</p>
<div class="example">
<p class="titleinexample"><a id="CHDEAGIJ"></a><a id="VLDBG14068"></a>Example 4-26 Creating a list-partitioned index-organized table</p>
<pre>
CREATE TABLE sales(acct_no NUMBER(5), 
                   acct_name CHAR(30), 
                   amount_of_sale NUMBER(6), 
                   week_no INTEGER,
                   sale_details VARCHAR2(1000),
             PRIMARY KEY (acct_no, acct_name, week_no)) 
     ORGANIZATION INDEX 
             INCLUDING week_no
             OVERFLOW TABLESPACE example
     PARTITION BY LIST (week_no)
            (PARTITION VALUES (1, 2, 3, 4) 
                   TABLESPACE example,
             PARTITION VALUES (5, 6, 7, 8) 
                   TABLESPACE example OVERFLOW TABLESPACE example,
             PARTITION VALUES (DEFAULT) 
                   TABLESPACE example);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006806"></a><a id="VLDBG00306"></a>
<div class="sect2">
<h2 class="sect2">Partitioning Restrictions for Multiple Block Sizes</h2>
<p><a id="sthref438"></a><a id="sthref439"></a>Use caution when creating partitioned objects in a database with tablespaces of different block sizes. The storage of partitioned objects in such tablespaces is subject to some restrictions. Specifically, all partitions of the following entities must reside in tablespaces of the same block size:</p>
<ul>
<li>
<p>Conventional tables</p>
</li>
<li>
<p>Indexes</p>
</li>
<li>
<p>Primary key index segments of index-organized tables</p>
</li>
<li>
<p>Overflow segments of index-organized tables</p>
</li>
<li>
<p><code>LOB</code> columns stored out of line</p>
</li>
</ul>
<p>Therefore:</p>
<ul>
<li>
<p>For each conventional table, all partitions of that table must be stored in tablespaces with the same block size.</p>
</li>
<li>
<p>For each index-organized table, all primary key index partitions must reside in tablespaces of the same block size, and all overflow partitions of that table must reside in tablespaces of the same block size. However, index partitions and overflow partitions can reside in tablespaces of different block size.</p>
</li>
<li>
<p>For each index (global or local), each partition of that index must reside in tablespaces of the same block size. However, partitions of different indexes defined on the same object can reside in tablespaces of different block sizes.</p>
</li>
<li>
<p>For each <code>LOB</code> column, each partition of that column must be stored in tablespaces of equal block sizes. However, different <code>LOB</code> columns can be stored in tablespaces of different block sizes.</p>
</li>
</ul>
<p>When you create or alter a partitioned table or index, all tablespaces you <span class="italic">explicitly specify</span> for the partitions and subpartitions of each entity must be of the same block size. If you <span class="italic">do not explicitly specify</span> tablespace storage for an entity, then the tablespaces the database uses by default must be of the same block size. Therefore, you must be aware of the default tablespaces at each level of the partitioned object.</p>
</div>
<!-- class="sect2" -->
<a id="CDCHCHBD"></a><a id="VLDBG1116"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Partitioning of Collections in XMLType and Objects</h2>
<p>For the <a id="sthref440"></a><a id="sthref441"></a>purposes of this discussion, the term <span class="italic">Collection</span> <span class="italic">Tables</span> is used for the following two categories: (1) ordered collection tables inside <code>XMLType</code> tables or columns, and (2) nested tables inside object tables or columns.</p>
<p>Partitioning when using <code>XMLType</code> or object tables and columns follows the basic rules for partitioning. When you partition Collection Tables, Oracle Database uses the partitioning scheme of the base table. Also, Collection Tables are automatically partitioned when the base table is partitioned. DML against a partitioned nested table behaves in a similar manner to that of a reference partitioned table.</p>
<p>The statement in <a href="#CHDEIAAF">Example 4-27</a> creates a nested table partition:</p>
<div class="example">
<p class="titleinexample"><a id="CHDEIAAF"></a><a id="VLDBG14069"></a>Example 4-27 Creating a nested table partition</p>
<pre>
CREATE TABLE print_media_part (
   product_id NUMBER(6),
   ad_id NUMBER(6),
   ad_composite BLOB,
   ad_sourcetext CLOB,
   ad_finaltext CLOB,
   ad_fltextn NCLOB,
   ad_textdocs_ntab TEXTDOC_TAB,
   ad_photo BLOB,
   ad_graphic BFILE,
   ad_header ADHEADER_TYP)
NESTED TABLE ad_textdocs_ntab STORE AS textdoc_nt
PARTITION BY RANGE (product_id)
  (PARTITION p1 VALUES LESS THAN (100),
   PARTITION p2 VALUES LESS THAN (200));
</pre></div>
<!-- class="example" -->
<p>For an example of issuing a query against a partitioned nested table and using the <code>EXPLAIN</code> <code>PLAN</code> to improve performance, see <a href="part_avail.htm#BABDECDG">"Collection Tables"</a>.</p>
<p>Note that Oracle Database provides a <code>LOCAL</code> keyword to equipartition a Collection Table with a partitioned base table. This is the default behavior in this release. The default in earlier releases was not to equipartition the Collection Table with the partitioned base table. Now you must specify the <code>GLOBAL</code> keyword to store an unpartitioned Collection Table with a partitioned base table. See <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information. Also, to convert your existing nonpartitioned collection tables to partitioned, use online redefinition, as illustrated in <a href="part_admin002.htm#BABCIHBA">"Redefining Partitions Online"</a>.</p>
<p>Out-of-line (OOL) table partitioning is supported. However, you cannot create two tables of the same XML schema that has out-of-line tables. This means that exchange partitioning cannot be performed for schemas with OOL tables because it is not possible to have two tables of the same schema.</p>
<a id="VLDBG1117"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref442"></a>
<h3 class="sect3">Performing PMOs on Partitions that Contain Collection Tables</h3>
<p><a id="sthref443"></a><a id="sthref444"></a>Whether a partition contains Collection Tables or not does not significantly affect your ability to perform partition maintenance operations (PMOs). Usually, maintenance operations on Collection Tables are carried out on the base table. The following example illustrates a typical <code>ADD</code> <code>PARTITION</code> operation based on the preceding nested table partition:</p>
<pre>
ALTER TABLE print_media_part 
   ADD PARTITION p4 VALUES LESS THAN (400)
   LOB(ad_photo, ad_composite) STORE AS (TABLESPACE omf_ts1)
   LOB(ad_sourcetext, ad_finaltext) STORE AS (TABLESPACE omf_ts1)
   NESTED TABLE ad_textdocs_ntab STORE AS nt_p3;
</pre>
<p>The storage table for nested table storage column <code>ad_textdocs_ntab</code> is named <code>nt_p3</code> and inherits all other attributes from the table-level defaults and then from the tablespace defaults.</p>
<p>You must directly invoke the following partition maintenance operations on the storage table corresponding to the collection column:</p>
<ul>
<li>
<p>modify partition</p>
</li>
<li>
<p>move partition</p>
</li>
<li>
<p>rename partition</p>
</li>
<li>
<p>modify the default attributes of a partition</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax and <a href="part_admin002.htm#g1010774">Table 4-1, "ALTER TABLE Maintenance Operations for Table Partitions"</a> for a list of partition maintenance operations that can be performed on partitioned tables and composite partitioned tables</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1828">
<tr>
<td class="cellalignment1837">
<table class="cellalignment1833">
<tr>
<td class="cellalignment1832"><a href="part_admin.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1832"><a href="part_admin002.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1840">
<table class="cellalignment1831">
<tr>
<td class="cellalignment1832"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1832"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1832"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1832"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1832"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1832"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
