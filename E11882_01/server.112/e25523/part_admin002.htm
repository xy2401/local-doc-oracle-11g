<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Maintaining Partitions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-27T4:11:52Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database VLDB and Partitioning Guide" />
<meta name="dcterms.identifier" content="E25523-01" />
<meta name="dcterms.isVersionOf" content="VLDBG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="part_admin001.htm" title="Previous" type="text/html" />
<link rel="Next" href="part_admin003.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25523.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/27</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='part_admin002'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript><a id="i1006820"></a><a id="VLDBG1118"></a>
<div class="sect1">
<h1 class="sect1">Maintaining Partitions</h1>
<p><a id="sthref445"></a><a id="sthref446"></a><a id="sthref447"></a>This section describes how to perform partition and subpartition maintenance operations for both tables and indexes.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDJCEEF">Maintenance Operations on Partitions That Can Be Performed</a></p>
</li>
<li>
<p><a href="#CHDIBFFH">Updating Indexes Automatically</a></p>
</li>
<li>
<p><a href="#i1007318">Adding Partitions</a></p>
</li>
<li>
<p><a href="#i1007442">Coalescing Partitions</a></p>
</li>
<li>
<p><a href="#i1007479">Dropping Partitions</a></p>
</li>
<li>
<p><a href="#i1107555">Exchanging Partitions</a></p>
</li>
<li>
<p><a href="#i1007638">Merging Partitions</a></p>
</li>
<li>
<p><a href="#i1007780">Modifying Default Attributes</a></p>
</li>
<li>
<p><a href="#i1007802">Modifying Real Attributes of Partitions</a></p>
</li>
<li>
<p><a href="#i1007846">Modifying List Partitions: Adding Values</a></p>
</li>
<li>
<p><a href="#i1007874">Modifying List Partitions: Dropping Values</a></p>
</li>
<li>
<p><a href="#i1007904">Modifying a Subpartition Template</a></p>
</li>
<li>
<p><a href="#i1007920">Moving Partitions</a></p>
</li>
<li>
<p><a href="#BABCIHBA">Redefining Partitions Online</a></p>
</li>
<li>
<p><a href="#i1007965">Rebuilding Index Partitions</a></p>
</li>
<li>
<p><a href="#i1008006">Renaming Partitions</a></p>
</li>
<li>
<p><a href="#i1008028">Splitting Partitions</a></p>
</li>
<li>
<p><a href="#i1008226">Truncating Partitions</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN015" href="../../server.112/e25494/tables.htm#ADMIN015"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about managing tables</p>
</li>
<li>
<p><a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for the exact syntax of the partitioning clauses for altering partitioned tables and indexes, any restrictions on their use, and specific privileges required for creating and altering tables</p>
</li>
</ul>
</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following sections discuss maintenance operations on partitioned tables. Where the usability of indexes or index partitions affected by the maintenance operation is discussed, consider the following:
<ul>
<li>
<p>Only indexes and index partitions that are <span class="italic">not</span> empty are candidates for being marked <code>UNUSABLE</code>. If they are empty, the <code>USABLE</code>/<code>UNUSABLE</code> status is left unchanged.</p>
</li>
<li>
<p>Only indexes or index partitions with <code>USABLE</code> status are updated by subsequent DML.</p>
</li>
</ul>
</div>
<a id="CHDJCEEF"></a><a id="VLDBG14070"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Maintenance Operations on Partitions That Can Be Performed</h2>
<p><a id="sthref448"></a><a id="sthref449"></a><a href="#g1010774">Table 4-1</a> lists partition maintenance operations that can be performed on partitioned tables and composite partitioned tables, and <a href="#BAJCHJJA">Table 4-2</a> lists subpartition maintenance operations that can be performed on composite partitioned tables. For each type of partitioning and subpartitioning, the specific clause of the <code><a id="sthref450"></a><a id="sthref451"></a>ALTER TABLE</code> statement that is used to perform that maintenance operation is listed.</p>
<div class="tblruleformalwidemax">
<p class="titleintable"><a id="VLDBG1119"></a><a id="sthref452"></a><a id="g1010774"></a>Table 4-1 ALTER TABLE Maintenance Operations for Table Partitions</p>
<table class="cellalignment1835" title="ALTER TABLE Maintenance Operations for Table Partitions" summary="This table lists maintenance operations along with the specific clauses used for range, interval, hash, list, and reference partitioning." >
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t15">Maintenance Operation</th>
<th class="cellalignment1836" id="r1c2-t15">RangeComposite Range-*</th>
<th class="cellalignment1836" id="r1c3-t15">IntervalComposite Interval-*</th>
<th class="cellalignment1836" id="r1c4-t15">Hash</th>
<th class="cellalignment1836" id="r1c5-t15">ListComposite List-*</th>
<th class="cellalignment1836" id="r1c6-t15">Reference</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t15" headers="r1c1-t15">
<p><a href="#i1007318">Adding Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r2c1-t15 r1c2-t15">
<p><code>ADD PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t15 r1c3-t15">
<p><code>ADD PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t15 r1c4-t15">
<p><code>ADD PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t15 r1c5-t15">
<p><code>ADD PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t15 r1c6-t15">
<p>N/A<a id="BAJCBJBA" href="#BAJCBJBA" onclick='footdisplay(1,"These operations cannot be performed on reference-partitioned tables. If performed on a parent table, then these operations cascade to all descendant tables.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t15" headers="r1c1-t15">
<p><a href="#i1007442">Coalescing Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r3c1-t15 r1c2-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r3c1-t15 r1c3-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r3c1-t15 r1c4-t15">
<p><code>COALESCE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r3c1-t15 r1c5-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r3c1-t15 r1c6-t15">
<p>N/A<a id="sthref453" href="#sthref453" onclick='footdisplay(1,"These operations cannot be performed on reference-partitioned tables. If performed on a parent table, then these operations cascade to all descendant tables.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r4c1-t15" headers="r1c1-t15">
<p><a href="#i1007479">Dropping Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r4c1-t15 r1c2-t15">
<p><code>DROP PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r4c1-t15 r1c3-t15">
<p><code>DROP PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r4c1-t15 r1c4-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r4c1-t15 r1c5-t15">
<p><code>DROP PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r4c1-t15 r1c6-t15">
<p>N/A<a id="sthref454" href="#sthref454" onclick='footdisplay(1,"These operations cannot be performed on reference-partitioned tables. If performed on a parent table, then these operations cascade to all descendant tables.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r5c1-t15" headers="r1c1-t15">
<p><a href="#i1107555">Exchanging Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r5c1-t15 r1c2-t15">
<p><code>EXCHANGE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r5c1-t15 r1c3-t15">
<p><code>EXCHANGE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r5c1-t15 r1c4-t15">
<p><code>EXCHANGE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r5c1-t15 r1c5-t15">
<p><code>EXCHANGE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r5c1-t15 r1c6-t15">
<p><code>EXCHANGE PARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r6c1-t15" headers="r1c1-t15">
<p><a href="#i1007638">Merging Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r6c1-t15 r1c2-t15">
<p><code>MERGE PARTITIONS</code></p>
</td>
<td class="cellalignment1837" headers="r6c1-t15 r1c3-t15">
<p><code>MERGE PARTITIONS</code></p>
</td>
<td class="cellalignment1837" headers="r6c1-t15 r1c4-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r6c1-t15 r1c5-t15">
<p><code>MERGE PARTITIONS</code></p>
</td>
<td class="cellalignment1837" headers="r6c1-t15 r1c6-t15">
<p>N/A<a id="sthref455" href="#sthref455" onclick='footdisplay(1,"These operations cannot be performed on reference-partitioned tables. If performed on a parent table, then these operations cascade to all descendant tables.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r7c1-t15" headers="r1c1-t15">
<p><a href="#i1007780">Modifying Default Attributes</a></p>
</td>
<td class="cellalignment1837" headers="r7c1-t15 r1c2-t15">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
</td>
<td class="cellalignment1837" headers="r7c1-t15 r1c3-t15">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
</td>
<td class="cellalignment1837" headers="r7c1-t15 r1c4-t15">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
</td>
<td class="cellalignment1837" headers="r7c1-t15 r1c5-t15">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
</td>
<td class="cellalignment1837" headers="r7c1-t15 r1c6-t15">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r8c1-t15" headers="r1c1-t15">
<p><a href="#i1007802">Modifying Real Attributes of Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r8c1-t15 r1c2-t15">
<p><code>MODIFY PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t15 r1c3-t15">
<p><code>MODIFY PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t15 r1c4-t15">
<p><code>MODIFY PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t15 r1c5-t15">
<p><code>MODIFY PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t15 r1c6-t15">
<p><code>MODIFY PARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r9c1-t15" headers="r1c1-t15">
<p><a href="#i1007846">Modifying List Partitions: Adding Values</a></p>
</td>
<td class="cellalignment1837" headers="r9c1-t15 r1c2-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r9c1-t15 r1c3-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r9c1-t15 r1c4-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r9c1-t15 r1c5-t15">
<p><code>MODIFY PARTITION ... ADD VALUES</code></p>
</td>
<td class="cellalignment1837" headers="r9c1-t15 r1c6-t15">
<p>N/A</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r10c1-t15" headers="r1c1-t15">
<p><a href="#i1007874">Modifying List Partitions: Dropping Values</a></p>
</td>
<td class="cellalignment1837" headers="r10c1-t15 r1c2-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r10c1-t15 r1c3-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r10c1-t15 r1c4-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r10c1-t15 r1c5-t15">
<p><code>MODIFY PARTITION ... DROP VALUES</code></p>
</td>
<td class="cellalignment1837" headers="r10c1-t15 r1c6-t15">
<p>N/A</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r11c1-t15" headers="r1c1-t15">
<p><a href="#i1007920">Moving Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r11c1-t15 r1c2-t15">
<p><code>MOVE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r11c1-t15 r1c3-t15">
<p><code>MOVE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r11c1-t15 r1c4-t15">
<p><code>MOVE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r11c1-t15 r1c5-t15">
<p><code>MOVE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r11c1-t15 r1c6-t15">
<p><code>MOVE PARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r12c1-t15" headers="r1c1-t15">
<p><a href="#i1008006">Renaming Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r12c1-t15 r1c2-t15">
<p><code>RENAME PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t15 r1c3-t15">
<p><code>RENAME PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t15 r1c4-t15">
<p><code>RENAME PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t15 r1c5-t15">
<p><code>RENAME PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t15 r1c6-t15">
<p><code>RENAME PARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r13c1-t15" headers="r1c1-t15">
<p><a href="#i1008028">Splitting Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r13c1-t15 r1c2-t15">
<p><code>SPLIT PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r13c1-t15 r1c3-t15">
<p><code>SPLIT PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r13c1-t15 r1c4-t15">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r13c1-t15 r1c5-t15">
<p><code>SPLIT PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r13c1-t15 r1c6-t15">
<p>N/A<a id="sthref456" href="#sthref456" onclick='footdisplay(1,"These operations cannot be performed on reference-partitioned tables. If performed on a parent table, then these operations cascade to all descendant tables.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r14c1-t15" headers="r1c1-t15">
<p><a href="#i1008226">Truncating Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r14c1-t15 r1c2-t15">
<p><code>TRUNCATE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r14c1-t15 r1c3-t15">
<p><code>TRUNCATE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r14c1-t15 r1c4-t15">
<p><code>TRUNCATE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r14c1-t15 r1c5-t15">
<p><code>TRUNCATE PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r14c1-t15 r1c6-t15">
<p><code>TRUNCATE PARTITION</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwidemax" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup>These operations cannot be performed on reference-partitioned tables. If performed on a parent table, then these operations cascade to all descendant tables.</p>
<div class="tblruleformalwidemax">
<p class="titleintable"><a id="VLDBG1120"></a><a id="sthref457"></a><a id="BAJCHJJA"></a>Table 4-2 ALTER TABLE Maintenance Operations for Table Subpartitions</p>
<table class="cellalignment1835" title="ALTER TABLE Maintenance Operations for Table Subpartitions" summary="This table lists maintenance operations along with the specific clauses used for composite partitioning." dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t16">Maintenance Operation</th>
<th class="cellalignment1836" id="r1c2-t16">Composite *-Range</th>
<th class="cellalignment1836" id="r1c3-t16">Composite *-Hash</th>
<th class="cellalignment1836" id="r1c4-t16">Composite *-List</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t16" headers="r1c1-t16">
<p><a href="#i1007318">Adding Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r2c1-t16 r1c2-t16">
<p><code>MODIFY PARTITION ... ADD SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t16 r1c3-t16">
<p><code>MODIFY PARTITION ... ADD SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r2c1-t16 r1c4-t16">
<p><code>MODIFY PARTITION ... ADD SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t16" headers="r1c1-t16">
<p><a href="#i1007442">Coalescing Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r3c1-t16 r1c2-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r3c1-t16 r1c3-t16">
<p><code>MODIFY PARTITION ... COALESCE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r3c1-t16 r1c4-t16">
<p>N/A</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r4c1-t16" headers="r1c1-t16">
<p><a href="#i1007479">Dropping Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r4c1-t16 r1c2-t16">
<p><code>DROP SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r4c1-t16 r1c3-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r4c1-t16 r1c4-t16">
<p><code>DROP SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r5c1-t16" headers="r1c1-t16">
<p><a href="#i1107555">Exchanging Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r5c1-t16 r1c2-t16">
<p><code>EXCHANGE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r5c1-t16 r1c3-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r5c1-t16 r1c4-t16">
<p><code>EXCHANGE SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r6c1-t16" headers="r1c1-t16">
<p><a href="#i1007638">Merging Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r6c1-t16 r1c2-t16">
<p><code>MERGE SUBPARTITIONS</code></p>
</td>
<td class="cellalignment1837" headers="r6c1-t16 r1c3-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r6c1-t16 r1c4-t16">
<p><code>MERGE SUBPARTITIONS</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r7c1-t16" headers="r1c1-t16">
<p><a href="#i1007780">Modifying Default Attributes</a></p>
</td>
<td class="cellalignment1837" headers="r7c1-t16 r1c2-t16">
<p><code>MODIFY DEFAULT ATTRIBUTES FOR PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r7c1-t16 r1c3-t16">
<p><code>MODIFY DEFAULT ATTRIBUTES FOR PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r7c1-t16 r1c4-t16">
<p><code>MODIFY DEFAULT ATTRIBUTES FOR PARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r8c1-t16" headers="r1c1-t16">
<p><a href="#i1007802">Modifying Real Attributes of Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r8c1-t16 r1c2-t16">
<p><code>MODIFY SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t16 r1c3-t16">
<p><code>MODIFY SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t16 r1c4-t16">
<p><code>MODIFY SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r9c1-t16" headers="r1c1-t16">
<p><a href="#i1007846">Modifying List Partitions: Adding Values</a></p>
</td>
<td class="cellalignment1837" headers="r9c1-t16 r1c2-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r9c1-t16 r1c3-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r9c1-t16 r1c4-t16">
<p><code>MODIFY SUBPARTITION ... ADD VALUES</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r10c1-t16" headers="r1c1-t16">
<p><a href="#i1007874">Modifying List Partitions: Dropping Values</a></p>
</td>
<td class="cellalignment1837" headers="r10c1-t16 r1c2-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r10c1-t16 r1c3-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r10c1-t16 r1c4-t16">
<p><code>MODIFY SUBPARTITION ... DROP VALUES</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r11c1-t16" headers="r1c1-t16">
<p><a href="#i1007904">Modifying a Subpartition Template</a></p>
</td>
<td class="cellalignment1837" headers="r11c1-t16 r1c2-t16">
<p><code>SET SUBPARTITION TEMPLATE</code></p>
</td>
<td class="cellalignment1837" headers="r11c1-t16 r1c3-t16">
<p><code>SET SUBPARTITION TEMPLATE</code></p>
</td>
<td class="cellalignment1837" headers="r11c1-t16 r1c4-t16">
<p><code>SET SUBPARTITION TEMPLATE</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r12c1-t16" headers="r1c1-t16">
<p><a href="#i1007920">Moving Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r12c1-t16 r1c2-t16">
<p><code>MOVE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t16 r1c3-t16">
<p><code>MOVE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t16 r1c4-t16">
<p><code>MOVE SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r13c1-t16" headers="r1c1-t16">
<p><a href="#i1008006">Renaming Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r13c1-t16 r1c2-t16">
<p><code>RENAME SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r13c1-t16 r1c3-t16">
<p><code>RENAME SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r13c1-t16 r1c4-t16">
<p><code>RENAME SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r14c1-t16" headers="r1c1-t16">
<p><a href="#i1008028">Splitting Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r14c1-t16 r1c2-t16">
<p><code>SPLIT SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r14c1-t16 r1c3-t16">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r14c1-t16 r1c4-t16">
<p><code>SPLIT SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r15c1-t16" headers="r1c1-t16">
<p><a href="#i1008226">Truncating Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r15c1-t16 r1c2-t16">
<p><code>TRUNCATE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r15c1-t16 r1c3-t16">
<p><code>TRUNCATE SUBPARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r15c1-t16 r1c4-t16">
<p><code>TRUNCATE SUBPARTITION</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwidemax" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The first time you use table compression to introduce a compressed partition into a partitioned table that has bitmap indexes and that currently contains only uncompressed partitions, you must do the following:
<ul>
<li>
<p>Either drop all existing bitmap indexes and bitmap index partitions, or mark them <code>UNUSABLE</code>.</p>
</li>
<li>
<p>Set the table compression attribute.</p>
</li>
<li>
<p>Rebuild the indexes.</p>
</li>
</ul>
<p>These actions are independent of whether any partitions contain data and of the operation that introduces the compressed partition.</p>
<p>This does not apply to partitioned tables with B-tree indexes or to partitioned index-organized tables.</p>
</div>
<p><a href="#g1010654">Table 4-3</a> lists maintenance operations that can be performed on index partitions<a id="sthref458"></a>, and indicates on which type of index (global or local) they can be performed. The <code>ALTER INDEX</code> clause used for the maintenance operation is shown.</p>
<p>Global indexes do not reflect the structure of the underlying table. If partitioned, they can be partitioned by range or hash. Partitioned global indexes share some, but not all, of the partition maintenance operations that can be performed on partitioned tables.</p>
<p>Because local indexes reflect the underlying structure of the table, partitioning is maintained automatically when table partitions and subpartitions are affected by maintenance activity. Therefore, partition maintenance on local indexes is less necessary and there are fewer options.</p>
<div class="tblruleformalwidemax">
<p class="titleintable"><a id="VLDBG1121"></a><a id="sthref459"></a><a id="g1010654"></a>Table 4-3 ALTER INDEX Maintenance Operations for Index Partitions</p>
<table class="cellalignment1835" title="ALTER INDEX Maintenance Operations for Index Partitions" summary="Column 1 lists the maintenance operations for indexes; column 2 lists the types of indexes; columns 3-5 list the specific clauses that are used for the operation on range, hash and list, and composite partitioned indexes respectively." dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t18" rowspan="2">Maintenance Operation</th>
<th class="cellalignment1836" id="r1c2-t18" rowspan="2">Type of Index</th>
<th class="cellalignment1836" id="r1c3-t18" colspan="3">Type of Index Partitioning</th>
</tr>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r2c1-t18" headers="r1c1-t18 r1c1-t18">Range</th>
<th class="cellalignment1836" id="r2c2-t18" headers="r1c1-t18 r2c1-t18 r1c2-t18">Hash and List</th>
<th class="cellalignment1836" id="r2c3-t18" headers="r1c1-t18 r2c1-t18 r1c3-t18">Composite</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t18" headers="r1c1-t18 r2c1-t18">
<p><a href="#i1009715">Adding Index Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r3c1-t18 r1c2-t18 r2c2-t18">
<p>Global</p>
</td>
<td class="cellalignment1837" headers="r3c1-t18 r1c3-t18 r2c3-t18">
<p><code>-</code></p>
</td>
<td class="cellalignment1837" headers="r3c1-t18 r1c3-t18">
<p><code>ADD PARTITION</code> (hash only)</p>
</td>
<td class="cellalignment1837" headers="r3c1-t18 r1c3-t18">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r4c1-t18" headers="r1c1-t18 r2c1-t18">&nbsp;</td>
<td class="cellalignment1837" headers="r4c1-t18 r1c2-t18 r2c2-t18">
<p>Local</p>
</td>
<td class="cellalignment1837" headers="r4c1-t18 r1c3-t18 r2c3-t18">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r4c1-t18 r1c3-t18">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r4c1-t18 r1c3-t18">
<p>N/A</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r5c1-t18" headers="r1c1-t18 r2c1-t18">
<p><a href="#i1007542">Dropping Index Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r5c1-t18 r1c2-t18 r2c2-t18">
<p>Global</p>
</td>
<td class="cellalignment1837" headers="r5c1-t18 r1c3-t18 r2c3-t18">
<p><code>DROP PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r5c1-t18 r1c3-t18">
<p>-</p>
</td>
<td class="cellalignment1837" headers="r5c1-t18 r1c3-t18">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r6c1-t18" headers="r1c1-t18 r2c1-t18">&nbsp;</td>
<td class="cellalignment1837" headers="r6c1-t18 r1c2-t18 r2c2-t18">
<p>Local</p>
</td>
<td class="cellalignment1837" headers="r6c1-t18 r1c3-t18 r2c3-t18">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r6c1-t18 r1c3-t18">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r6c1-t18 r1c3-t18">
<p>N/A</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r7c1-t18" headers="r1c1-t18 r2c1-t18">
<p><a href="#i1007798">Modifying Default Attributes of Index Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r7c1-t18 r1c2-t18 r2c2-t18">
<p>Global</p>
</td>
<td class="cellalignment1837" headers="r7c1-t18 r1c3-t18 r2c3-t18">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
</td>
<td class="cellalignment1837" headers="r7c1-t18 r1c3-t18">
<p>-</p>
</td>
<td class="cellalignment1837" headers="r7c1-t18 r1c3-t18">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r8c1-t18" headers="r1c1-t18 r2c1-t18">&nbsp;</td>
<td class="cellalignment1837" headers="r8c1-t18 r1c2-t18 r2c2-t18">
<p>Local</p>
</td>
<td class="cellalignment1837" headers="r8c1-t18 r1c3-t18 r2c3-t18">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t18 r1c3-t18">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
</td>
<td class="cellalignment1837" headers="r8c1-t18 r1c3-t18">
<p><code>MODIFY DEFAULT ATTRIBUTES</code></p>
<p><code>MODIFY DEFAULT ATTRIBUTES FOR PARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r9c1-t18" headers="r1c1-t18 r2c1-t18">
<p><a href="#i1007841">Modifying Real Attributes of Index Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r9c1-t18 r1c2-t18 r2c2-t18">
<p>Global</p>
</td>
<td class="cellalignment1837" headers="r9c1-t18 r1c3-t18 r2c3-t18">
<p><code>MODIFY PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r9c1-t18 r1c3-t18">
<p>-</p>
</td>
<td class="cellalignment1837" headers="r9c1-t18 r1c3-t18">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r10c1-t18" headers="r1c1-t18 r2c1-t18">&nbsp;</td>
<td class="cellalignment1837" headers="r10c1-t18 r1c2-t18 r2c2-t18">
<p>Local</p>
</td>
<td class="cellalignment1837" headers="r10c1-t18 r1c3-t18 r2c3-t18">
<p><code>MODIFY PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r10c1-t18 r1c3-t18">
<p><code>MODIFY PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r10c1-t18 r1c3-t18">
<p><code>MODIFY PARTITION</code></p>
<p><code>MODIFY SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r11c1-t18" headers="r1c1-t18 r2c1-t18">
<p><a href="#i1007965">Rebuilding Index Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r11c1-t18 r1c2-t18 r2c2-t18">
<p>Global</p>
</td>
<td class="cellalignment1837" headers="r11c1-t18 r1c3-t18 r2c3-t18">
<p><code>REBUILD PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r11c1-t18 r1c3-t18">
<p>-</p>
</td>
<td class="cellalignment1837" headers="r11c1-t18 r1c3-t18">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r12c1-t18" headers="r1c1-t18 r2c1-t18">&nbsp;</td>
<td class="cellalignment1837" headers="r12c1-t18 r1c2-t18 r2c2-t18">
<p>Local</p>
</td>
<td class="cellalignment1837" headers="r12c1-t18 r1c3-t18 r2c3-t18">
<p><code>REBUILD PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t18 r1c3-t18">
<p><code>REBUILD PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r12c1-t18 r1c3-t18">
<p><code>REBUILD SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r13c1-t18" headers="r1c1-t18 r2c1-t18">
<p><a href="#i1008019">Renaming Index Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r13c1-t18 r1c2-t18 r2c2-t18">
<p>Global</p>
</td>
<td class="cellalignment1837" headers="r13c1-t18 r1c3-t18 r2c3-t18">
<p><code>RENAME PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r13c1-t18 r1c3-t18">
<p>-</p>
</td>
<td class="cellalignment1837" headers="r13c1-t18 r1c3-t18">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r14c1-t18" headers="r1c1-t18 r2c1-t18">&nbsp;</td>
<td class="cellalignment1837" headers="r14c1-t18 r1c2-t18 r2c2-t18">
<p>Local</p>
</td>
<td class="cellalignment1837" headers="r14c1-t18 r1c3-t18 r2c3-t18">
<p><code>RENAME PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r14c1-t18 r1c3-t18">
<p><code>RENAME PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r14c1-t18 r1c3-t18">
<p><code>RENAME PARTITION</code></p>
<p><code>RENAME SUBPARTITION</code></p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r15c1-t18" headers="r1c1-t18 r2c1-t18">
<p><a href="#i1008201">Splitting Index Partitions</a></p>
</td>
<td class="cellalignment1837" headers="r15c1-t18 r1c2-t18 r2c2-t18">
<p>Global</p>
</td>
<td class="cellalignment1837" headers="r15c1-t18 r1c3-t18 r2c3-t18">
<p><code>SPLIT PARTITION</code></p>
</td>
<td class="cellalignment1837" headers="r15c1-t18 r1c3-t18">
<p>-</p>
</td>
<td class="cellalignment1837" headers="r15c1-t18 r1c3-t18">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r16c1-t18" headers="r1c1-t18 r2c1-t18">&nbsp;</td>
<td class="cellalignment1837" headers="r16c1-t18 r1c2-t18 r2c2-t18">
<p>Local</p>
</td>
<td class="cellalignment1837" headers="r16c1-t18 r1c3-t18 r2c3-t18">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r16c1-t18 r1c3-t18">
<p>N/A</p>
</td>
<td class="cellalignment1837" headers="r16c1-t18 r1c3-t18">
<p>N/A</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwidemax" --></div>
<!-- class="sect2" -->
<a id="CHDIBFFH"></a><a id="VLDBG1122"></a>
<div class="sect2">
<h2 class="sect2">Updating Indexes Automatically</h2>
<p><a id="sthref460"></a><a id="sthref461"></a>Before discussing the individual maintenance operations for partitioned tables and indexes, it is important to discuss the effects of the <code>UPDATE</code> <code>INDEXES</code> clause that can be specified in the <code>ALTER</code> <code>TABLE</code> statement.</p>
<p>By default, many table maintenance operations on partitioned tables invalidate (mark <code>UNUSABLE</code>) the corresponding indexes or index partitions. You must then rebuild the entire index or, for a global index, each of its partitions. The database lets you override this default behavior if you specify <a id="sthref462"></a><a id="sthref463"></a><a id="sthref464"></a><code>UPDATE</code> <code>INDEXES</code> in your <code>ALTER</code> <code>TABLE</code> statement for the maintenance operation. Specifying this clause tells the database to update the indexes at the time it executes the maintenance operation DDL statement. This provides the following benefits:</p>
<ul>
<li>
<p>The indexes are updated with the base table operation. You are not required to update later and independently rebuild the indexes.</p>
</li>
<li>
<p>The global indexes are more highly available, because they are not marked <code>UNUSABLE</code>. These indexes remain available even while the partition DDL is executing and can access unaffected partitions in the table.</p>
</li>
<li>
<p>You need not look up the names of all invalid indexes to rebuild them.</p>
</li>
</ul>
<p>Optional clauses for local indexes let you specify physical and storage characteristics for updated local indexes and their partitions.</p>
<ul>
<li>
<p>You can specify physical attributes, tablespace storage, and logging for each partition of each local index. Alternatively, you can specify only the <code>PARTITION</code> keyword and let the database update the partition attributes as follows:</p>
<ul>
<li>
<p>For operations on a single table partition (such as <code>MOVE</code> <code>PARTITION</code> and <code>SPLIT</code> <code>PARTITION</code>), the corresponding index partition inherits the attributes of the affected index partition. The database does not generate names for new index partitions, so any new index partitions resulting from this operation inherit their names from the corresponding new table partition.</p>
</li>
<li>
<p>For <code>MERGE</code> <code>PARTITION</code> operations, the resulting local index partition inherits its name from the resulting table partition and inherits its attributes from the local index.</p>
</li>
</ul>
</li>
<li>
<p>For a composite-partitioned index, you can specify tablespace storage for each subpartition.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The <code><span class="codeinlineitalic">update_all_indexes_clause</span></code> of <a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><code>ALTER TABLE</code></a> for the syntax for updating indexes</div>
<p>The following operations support the <code>UPDATE</code> <code>INDEXES</code> clause:</p>
<ul>
<li>
<p><code>ADD</code> <code>PARTITION</code> | <code>SUBPARTITION</code></p>
</li>
<li>
<p><code>COALESCE</code> <code>PARTITION</code> | <code>SUBPARTITION</code></p>
</li>
<li>
<p><code>DROP</code> <code>PARTITION</code> | <code>SUBPARTITION</code></p>
</li>
<li>
<p><code>EXCHANGE</code> <code>PARTITION</code> | <code>SUBPARTITION</code></p>
</li>
<li>
<p><code>MERGE</code> <code>PARTITION</code> | <code>SUBPARTITION</code></p>
</li>
<li>
<p><code>MOVE</code> <code>PARTITION</code> | <code>SUBPARTITION</code></p>
</li>
<li>
<p><code>SPLIT</code> <code>PARTITION</code> | <code>SUBPARTITION</code></p>
</li>
<li>
<p><code>TRUNCATE</code> <code>PARTITION</code> | <code>SUBPARTITION</code></p>
</li>
</ul>
<p class="subhead2"><a id="VLDBG1123"></a>SKIP_UNUSABLE_INDEXES Initialization Parameter</p>
<p><code>SKIP_UNUSABLE_INDEXES</code> is an initialization parameter with a default value of <code>TRUE</code>. This setting disables error reporting of indexes and index partitions marked <code>UNUSABLE</code>. If you do not want the database to choose an alternative execution plan to avoid the unusable elements, then you should set this parameter to <code>FALSE</code>.</p>
<p class="subhead2"><a id="VLDBG1124"></a>Considerations when Updating Indexes Automatically</p>
<p>The following implications are worth noting when you specify <code>UPDATE</code> <code>INDEXES</code>:</p>
<ul>
<li>
<p>The partition DDL statement takes longer to execute, because indexes that were previously marked <code>UNUSABLE</code> are updated. However, you must compare this increase with the time it takes to execute DDL without updating indexes, and then rebuild all indexes. A rule of thumb is that it is faster to update indexes if the size of the partition is less that 5% of the size of the table.</p>
</li>
<li>
<p>The <code>DROP</code>, <code>TRUNCATE</code>, and <code>EXCHANGE</code> operations are no longer fast operations. Again, you must compare the time it takes to do the DDL and then rebuild all indexes.</p>
</li>
<li>
<p>When you update a table with a global index:</p>
<ul>
<li>
<p>The index is updated in place. The updates to the index are logged, and redo and undo records are generated. In contrast, if you rebuild an entire global index, you can do so in <code>NOLOGGING</code> mode.</p>
</li>
<li>
<p>Rebuilding the entire index manually creates a more efficient index, because it is more compact with better space utilization.</p>
</li>
</ul>
</li>
<li>
<p>The <code>UPDATE INDEXES</code> clause is not supported for index-organized tables. However, the <code>UPDATE GLOBAL INDEXES</code> clause may be used with <code>DROP</code> <code>PARTITION</code>, <code>TRUNCATE</code> <code>PARTITION</code>, and <code>EXCHANGE</code> <code>PARTITION</code> operations to keep the global indexes on index-organized tables usable. For the remaining operations in the above list, global indexes on index-organized tables remain usable. In addition, local index partitions on index-organized tables remain usable after a <code>MOVE</code> <code>PARTITION</code> operation.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1007318"></a><a id="VLDBG1125"></a>
<div class="sect2">
<h2 class="sect2">Adding Partitions</h2>
<p><a id="sthref465"></a><a id="sthref466"></a>This section describes how to manually add new partitions to a partitioned table and explains why partitions cannot be specifically added to most partitioned indexes.</p>
<a id="i1007322"></a><a id="VLDBG1126"></a>
<div class="sect3">
<h3 class="sect3">Adding a Partition to a Range-Partitioned Table</h3>
<p><a id="sthref467"></a><a id="sthref468"></a>Use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref469"></a><code>ADD</code> <code>PARTITION</code> statement to add a new partition to the "high" end (the point after the last existing partition). To add a partition at the beginning or in the middle of a table, use the <a id="sthref470"></a><code>SPLIT</code> <code>PARTITION</code> clause.</p>
<p>For example, consider the table, <code>sales</code>, which contains data for the current month in addition to the previous 12 months. On January 1, 1999, you add a partition for January, which is stored in tablespace <code>tsx</code>.</p>
<pre>
ALTER TABLE sales
      ADD PARTITION jan99 VALUES LESS THAN ( '01-FEB-1999' )
      TABLESPACE tsx;
</pre>
<p>Local and global indexes associated with the range-partitioned table remain usable.</p>
</div>
<!-- class="sect3" -->
<a id="i1007333"></a><a id="VLDBG1127"></a>
<div class="sect3">
<h3 class="sect3">Adding a Partition to a Hash-Partitioned Table</h3>
<p><a id="sthref471"></a><a id="sthref472"></a>When you add a partition to a hash-partitioned table, the database populates the new partition with rows rehashed from an existing partition (selected by the database) as determined by the hash function. Consequently, if the table contains data, then it may take some time to add a hash partition.</p>
<p>The following statements show two ways of adding a hash partition to table <code>scubagear</code>. Choosing the first statement adds a new hash partition whose partition name is system generated, and which is placed in the default tablespace. The second statement also adds a new hash partition, but that partition is explicitly named <code>p_named</code> and is created in tablespace <code>gear5</code>.</p>
<pre>
ALTER TABLE scubagear ADD PARTITION;

ALTER TABLE scubagear
      ADD PARTITION p_named TABLESPACE gear5;
</pre>
<p>Indexes may be marked <code><a id="sthref473"></a>UNUSABLE</code> as explained in the following table:</p>
<div class="inftblruleinformal">
<table class="cellalignment1835" title="UNUSABLE Indexes" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t20">Table Type</th>
<th class="cellalignment1836" id="r1c2-t20">Index Behavior</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t20" headers="r1c1-t20">Regular (Heap)</td>
<td class="cellalignment1837" headers="r2c1-t20 r1c2-t20">Unless you specify <code>UPDATE</code> <code>INDEXES</code> as part of the <code>ALTER</code> <code>TABLE</code> statement:
<ul>
<li>
<p>The local indexes for the new partition, and for the existing partition from which rows were redistributed, are marked <code>UNUSABLE</code> and must be rebuilt.</p>
</li>
<li>
<p>All global indexes, or all partitions of partitioned global indexes, are marked <code>UNUSABLE</code> and must be rebuilt.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t20" headers="r1c1-t20">Index-organized</td>
<td class="cellalignment1837" headers="r3c1-t20 r1c2-t20">
<ul>
<li>For local indexes, the behavior is identical to heap tables.</li>
<li>
<p>All global indexes remain usable.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" --></div>
<!-- class="sect3" -->
<a id="i1007360"></a><a id="VLDBG1128"></a>
<div class="sect3">
<h3 class="sect3">Adding a Partition to a List-Partitioned Table</h3>
<p><a id="sthref474"></a><a id="sthref475"></a>The following statement illustrates how to add a new partition to a list-partitioned table. In this example, physical attributes and <code>NOLOGGING</code> are specified for the partition being added.</p>
<pre>
ALTER TABLE q1_sales_by_region 
   ADD PARTITION q1_nonmainland VALUES ('HI', 'PR')
      STORAGE (INITIAL 20K NEXT 20K) TABLESPACE tbs_3
      NOLOGGING;
</pre>
<p>Any value in the set of literal values that describe the partition being added must not exist in any of the other partitions of the table.</p>
<p>You cannot add a partition to a list-partitioned table that has a default partition, but you can split the default partition. By doing so, you effectively create a new partition defined by the values that you specify, and a second partition that remains the default partition.</p>
<p>Local and global indexes associated with the list-partitioned table remain usable.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1129"></a>
<div class="sect3"><a id="sthref476"></a>
<h3 class="sect3">Adding a Partition to an Interval-Partitioned Table</h3>
<p><a id="sthref477"></a><a id="sthref478"></a>You cannot explicitly add a partition to an interval-partitioned table unless you first lock the partition, which triggers the creation of the partition. The database automatically creates a partition for an interval when data for that interval is inserted. In general, you only must explicitly create interval partitions for a partition exchange load scenario.</p>
<p>To change the interval for future partitions, use the <a id="sthref479"></a><code>SET INTERVAL</code> clause of the <code>ALTER TABLE</code> statement. This clause changes the interval for partitions beyond the current highest boundary of all materialized interval partitions.</p>
<p>You also use the <code>SET INTERVAL</code> clause to migrate an existing range partitioned or range-* composite partitioned table into an interval or interval-* partitioned table. To disable the creation of future interval partitions, and effectively revert to a range-partitioned table, use an empty value in the <code>SET INTERVAL</code> clause. Created interval partitions are transformed into range partitions with their current high values.</p>
<p>To increase the interval for date ranges, you must ensure that you are at a relevant boundary for the new interval. For example, if the highest interval partition boundary in your daily interval partitioned table transactions is January 30, 2007 and you want to change to a monthly partition interval, then the following statement results in an error:</p>
<pre>
ALTER TABLE transactions SET INTERVAL (NUMTOYMINTERVAL(1,'MONTH');

ORA-14767: Cannot specify this interval with existing high bounds
</pre>
<p>You must create another daily partition with a high bound of February 1, 2007 to successfully change to a monthly interval:</p>
<pre>
LOCK TABLE transactions PARTITION FOR(TO_DATE('31-JAN-2007','dd-MON-yyyy') IN SHARE MODE;

ALTER TABLE transactions SET INTERVAL (NUMTOYMINTERVAL(1,'MONTH');
</pre>
<p>The lower partitions of an interval-partitioned table are range partitions. You can split range partitions to add more partitions in the range portion of the interval-partitioned table.</p>
<p>To disable interval partitioning on the <code>transactions</code> table, use:</p>
<pre>
ALTER TABLE transactions SET INTERVAL ();
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1130"></a>
<div class="sect3"><a id="sthref480"></a>
<h3 class="sect3">Adding Partitions to a Composite *-Hash Partitioned Table</h3>
<p><a id="sthref481"></a><a id="sthref482"></a>Partitions can be added at both the partition level and at the hash subpartition level.</p>
<a id="VLDBG1131"></a>
<div class="sect4"><a id="sthref483"></a>
<h4 class="sect4">Adding a Partition to a *-Hash Partitioned Table</h4>
<p>Adding a new partition to a [range | list | interval]-hash partitioned table is as described previously. For an interval-hash partitioned table, interval partitions are automatically created. You can specify a <a id="sthref484"></a><code>SUBPARTITIONS</code> clause that lets you add a specified number of subpartitions, or a <a id="sthref485"></a><code>SUBPARTITION</code> clause for naming specific subpartitions. If no <code>SUBPARTITIONS</code> or <code>SUBPARTITION</code> clause is specified, then the partition inherits table level defaults for subpartitions. For an interval-hash partitioned table, you can only add subpartitions to range or interval partitions that have been materialized.</p>
<p>This example adds a range partition <code>q1_2000</code> to the range-hash partitioned table <code>sales</code>, which is populated with data for the first quarter of the year 2000. There are eight subpartitions stored in tablespace <code>tbs5</code>. The subpartitions cannot be set explicitly to use table compression. Subpartitions inherit the compression attribute from the partition level and are stored in a compressed form in this example:</p>
<pre>
ALTER TABLE sales ADD PARTITION q1_2000
      VALUES LESS THAN (2000, 04, 01) COMPRESS
      SUBPARTITIONS 8 STORE IN tbs5;
</pre></div>
<!-- class="sect4" -->
<a id="i1007384"></a><a id="VLDBG1132"></a>
<div class="sect4">
<h4 class="sect4">Adding a Subpartition to a *-Hash Partitioned Table</h4>
<p><a id="sthref486"></a>You use the <code>MODIFY</code> <code>PARTITION</code> ... <a id="sthref487"></a><code>ADD</code> <code>SUBPARTITION</code> clause of the <code>ALTER</code> <code>TABLE</code> statement to add a hash subpartition to a [range | list | interval]-hash partitioned table. The newly added subpartition is populated with rows rehashed from other subpartitions of the same partition as determined by the hash function. For an interval-hash partitioned table, you can only add subpartitions to range or interval partitions that have been materialized.</p>
<p>In the following example, a new hash subpartition <code>us_loc5</code>, stored in tablespace <code>us1</code>, is added to range partition <code>locations_us</code> in table <code>diving</code>.</p>
<pre>
ALTER TABLE diving MODIFY PARTITION locations_us
      ADD SUBPARTITION us_locs5 TABLESPACE us1;
</pre>
<p>Index subpartitions corresponding to the added and rehashed subpartitions must be rebuilt unless you specify <code>UPDATE</code> <code>INDEXES</code>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="VLDBG1133"></a>
<div class="sect3"><a id="sthref488"></a>
<h3 class="sect3">Adding Partitions to a Composite *-List Partitioned Table</h3>
<p><a id="sthref489"></a><a id="sthref490"></a>Partitions can be added at both the partition level and at the list subpartition level.</p>
<a id="VLDBG1134"></a>
<div class="sect4"><a id="sthref491"></a>
<h4 class="sect4">Adding a Partition to a *-List Partitioned Table</h4>
<p>Adding a new partition to a [range | list | interval]-list partitioned table is as described previously. The database automatically creates interval partitions as data for a specific interval is inserted. You can specify <a id="sthref492"></a><code>SUBPARTITION</code> clauses for naming and providing value lists for the subpartitions. If no <code>SUBPARTITION</code> clauses are specified, then the partition inherits the subpartition template. If there is no subpartition template, then a single default subpartition is created.</p>
<p>The statement in <a href="#CHDJJFDF">Example 4-28</a> adds a new partition to the <code>quarterly_regional_sales</code> table that is partitioned by the range-list method. Some new physical attributes are specified for this new partition while table-level defaults are inherited for those that are not specified.</p>
<div class="example">
<p class="titleinexample"><a id="CHDJJFDF"></a><a id="VLDBG14071"></a>Example 4-28 Adding partitions to a range-list partitioned table</p>
<pre>
ALTER TABLE quarterly_regional_sales 
   ADD PARTITION q1_2000 VALUES LESS THAN (TO_DATE('1-APR-2000','DD-MON-YYYY'))
      STORAGE (INITIAL 20K NEXT 20K) TABLESPACE ts3 NOLOGGING
         (
          SUBPARTITION q1_2000_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q1_2000_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q1_2000_northeast VALUES ('NY', 'VM', 'NJ'),
          SUBPARTITION q1_2000_southeast VALUES ('FL', 'GA'),
          SUBPARTITION q1_2000_northcentral VALUES ('SD', 'WI'),
          SUBPARTITION q1_2000_southcentral VALUES ('OK', 'TX')
         );
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="VLDBG1135"></a>
<div class="sect4"><a id="sthref493"></a>
<h4 class="sect4">Adding a Subpartition to a *-List Partitioned Table</h4>
<p><a id="sthref494"></a>You use the <code>MODIFY</code> <code>PARTITION</code> ... <a id="sthref495"></a><code>ADD</code> <code>SUBPARTITION</code> clause of the <code>ALTER</code> <code>TABLE</code> statement to add a list subpartition to a [range | list | interval]-list partitioned table. For an interval-list partitioned table, you can only add subpartitions to range or interval partitions that have been materialized.</p>
<p>The following statement adds a new subpartition to the existing set of subpartitions in the range-list partitioned table <code>quarterly_regional_sales</code>. The new subpartition is created in tablespace <code>ts2</code>.</p>
<pre>
ALTER TABLE quarterly_regional_sales
   MODIFY PARTITION q1_1999 
      ADD SUBPARTITION q1_1999_south
         VALUES ('AR','MS','AL') tablespace ts2;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="VLDBG1136"></a>
<div class="sect3"><a id="sthref496"></a>
<h3 class="sect3">Adding Partitions to a Composite *-Range Partitioned Table</h3>
<p><a id="sthref497"></a><a id="sthref498"></a>Partitions can be added at both the partition level and at the range subpartition level.</p>
<a id="VLDBG1137"></a>
<div class="sect4"><a id="sthref499"></a>
<h4 class="sect4">Adding a Partition to a *-Range Partitioned Table</h4>
<p>Adding a new partition to a [range | list | interval]-range partitioned table is as described previously. The database automatically creates interval partitions for an interval-range partitioned table when data is inserted in a specific interval. You can specify a <a id="sthref500"></a><code>SUBPARTITION</code> clause for naming and providing ranges for specific subpartitions. If no <code>SUBPARTITION</code> clause is specified, then the partition inherits the subpartition template specified at the table level. If there is no subpartition template, then a single subpartition with a maximum value of <code>MAXVALUE</code> is created.</p>
<p><a href="#CHDHHJHA">Example 4-29</a> adds a range partition <code>p_2007_jan</code> to the range-range partitioned table <code>shipments</code>, which is populated with data for the shipments ordered in January 2007. There are three subpartitions. Subpartitions inherit the compression attribute from the partition level and are stored in a compressed form in this example:</p>
<div class="example">
<p class="titleinexample"><a id="CHDHHJHA"></a><a id="VLDBG14072"></a>Example 4-29 Adding partitions to a range-range partitioned table</p>
<pre>
ALTER TABLE shipments
   ADD PARTITION p_2007_jan
      VALUES LESS THAN (TO_DATE('01-FEB-2007','dd-MON-yyyy')) COMPRESS
      ( SUBPARTITION p07_jan_e VALUES LESS THAN (TO_DATE('15-FEB-2007','dd-MON-yyyy'))
      , SUBPARTITION p07_jan_a VALUES LESS THAN (TO_DATE('01-MAR-2007','dd-MON-yyyy'))
      , SUBPARTITION p07_jan_l VALUES LESS THAN (TO_DATE('01-APR-2007','dd-MON-yyyy'))
      ) ;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="i1007385"></a><a id="VLDBG1138"></a>
<div class="sect4">
<h4 class="sect4">Adding a Subpartition to a *-Range Partitioned Table</h4>
<p><a id="sthref501"></a>You use the <code>MODIFY</code> <code>PARTITION</code> ... <a id="sthref502"></a><code>ADD</code> <code>SUBPARTITION</code> clause of the <code>ALTER</code> <code>TABLE</code> statement to add a range subpartition to a [range | list | interval]-range partitioned table. For an interval-range partitioned table, you can only add partitions to range or interval partitions that have been materialized.</p>
<p>The following example adds a range subpartition to the <code>shipments</code> table that contains all values with an <code>order_date</code> in January 2007 and a <code>delivery_date</code> on or after April 1, 2007.</p>
<pre>
ALTER TABLE shipments
   MODIFY PARTITION p_2007_jan
      ADD SUBPARTITION p07_jan_vl VALUES LESS THAN (MAXVALUE) ;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="VLDBG1139"></a>
<div class="sect3"><a id="sthref503"></a>
<h3 class="sect3">Adding a Partition or Subpartition to a Reference-Partitioned Table</h3>
<p><a id="sthref504"></a><a id="sthref505"></a>A partition or subpartition can be added to a parent table in a reference partition definition just as partitions and subpartitions can be added to a range, hash, list, or composite partitioned table. The add operation automatically cascades to any descendant reference partitioned tables. The <code>DEPENDENT TABLES</code> clause can set specific properties for dependent tables when you add partitions or subpartitions to a master table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect3" -->
<a id="i1009715"></a><a id="VLDBG1140"></a>
<div class="sect3">
<h3 class="sect3">Adding Index Partitions</h3>
<p><a id="sthref506"></a><a id="sthref507"></a><a id="sthref508"></a>You cannot explicitly add a partition to a local index. Instead, a new partition is added to a local index only when you add a partition to the underlying table. Specifically, when there is a local index defined on a table and you issue the <code>ALTER</code> <code>TABLE</code> statement to add a partition, a matching partition is also added to the local index. The database assigns names and default physical storage attributes to the new index partitions, but you can rename or alter them after the <code>ADD</code> <code>PARTITION</code> operation is complete.</p>
<p>You can effectively specify a new tablespace for an index partition in an <code>ADD</code> <code>PARTITION</code> operation by first modifying the default attributes for the index. For example, assume that a local index, <code>q1_sales_by_region_locix</code>, was created for list partitioned table <code>q1_sales_by_region</code>. If before adding the new partition <code>q1_nonmainland</code>, as shown in <a href="#i1007360">"Adding a Partition to a List-Partitioned Table"</a>, you had issued the following statement, then the corresponding index partition would be created in tablespace <code>tbs_4</code>.</p>
<pre>
ALTER INDEX q1_sales_by_region_locix
   MODIFY DEFAULT ATTRIBUTES TABLESPACE tbs_4;
</pre>
<p>Otherwise, it would be necessary for you to use the following statement to move the index partition to <code>tbs_4</code> after adding it:</p>
<pre>
ALTER INDEX q1_sales_by_region_locix 
   REBUILD PARTITION q1_nonmainland TABLESPACE tbs_4;
 
</pre>
<p>You can add a partition to a hash-partitioned global index using the <code>ADD</code> <code>PARTITION</code> syntax of <code>ALTER</code> <code>INDEX</code>. The database adds hash partitions and populates them with index entries rehashed from an existing hash partition of the index, as determined by the hash function. The following statement adds a partition to the index <code>hgidx</code> shown in <a href="part_admin001.htm#i1009930">"Creating a Hash-Partitioned Global Index"</a>:</p>
<pre>
ALTER INDEX hgidx ADD PARTITION p5;
</pre>
<p>You cannot add a partition to a range-partitioned global index, because the highest partition always has a partition bound of <code>MAXVALUE</code>. To add a new highest partition, use the <code>ALTER</code> <code>INDEX</code> ... <code>SPLIT</code> <code>PARTITION</code> statement.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007442"></a><a id="VLDBG1141"></a>
<div class="sect2">
<h2 class="sect2">Coalescing Partitions</h2>
<p><a id="sthref509"></a>Coalescing partitions is a way of reducing the number of partitions in a hash-partitioned table or index, or the number of subpartitions in a *-hash partitioned table. When a hash partition is coalesced, its contents are redistributed into one or more remaining partitions determined by the hash function. The specific partition that is coalesced is selected by the database, and is dropped after its contents have been redistributed. If you coalesce a hash partition or subpartition in the parent table of a reference-partitioned table definition, then the reference-partitioned table automatically inherits the new partitioning definition.</p>
<p>Index partitions may be marked <code><a id="sthref510"></a>UNUSABLE</code> as explained in the following table:</p>
<div class="inftblruleinformal">
<table class="cellalignment1835" title="UNUSABLE Index Partitions" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t22">Table Type</th>
<th class="cellalignment1836" id="r1c2-t22">Index Behavior</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t22" headers="r1c1-t22">Regular (Heap)</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c2-t22">Unless you specify <code>UPDATE</code> <code>INDEXES</code> as part of the <code>ALTER</code> <code>TABLE</code> statement:
<ul>
<li>
<p>Any local index partition corresponding to the selected partition is also dropped. Local index partitions corresponding to the one or more absorbing partitions are marked <code>UNUSABLE</code> and must be rebuilt.</p>
</li>
<li>
<p>All global indexes, or all partitions of partitioned global indexes, are marked <code>UNUSABLE</code> and must be rebuilt.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t22" headers="r1c1-t22">Index-organized</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c2-t22">
<ul>
<li>Some local indexes are marked <code>UNUSABLE</code> as noted for heap indexes.</li>
<li>
<p>All global indexes remain usable.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" -->
<a id="VLDBG1142"></a>
<div class="sect3"><a id="sthref511"></a>
<h3 class="sect3">Coalescing a Partition in a Hash-Partitioned Table</h3>
<p>The <code>ALTER</code> <code>TABLE</code> ... <a id="sthref512"></a><code>COALESCE</code> <code>PARTITION</code> statement is used to coalesce a partition in a hash-partitioned table. The following statement reduces by one the number of partitions in a table by coalescing a partition.</p>
<pre>
ALTER TABLE ouu1
     COALESCE PARTITION;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1143"></a>
<div class="sect3"><a id="sthref513"></a>
<h3 class="sect3">Coalescing a Subpartition in a *-Hash Partitioned Table</h3>
<p>The following statement distributes the contents of a subpartition of partition <code>us_locations</code> into one or more remaining subpartitions (determined by the hash function) of the same partition. Note that for an interval-partitioned table, you can only coalesce hash subpartitions of materialized range or interval partitions. Basically, this operation is the inverse of the <code>MODIFY</code> <code>PARTITION</code> ... <code>ADD</code> <code>SUBPARTITION</code> clause discussed in <a href="#i1007384">"Adding a Subpartition to a *-Hash Partitioned Table"</a>.</p>
<pre>
ALTER TABLE diving MODIFY PARTITION us_locations
     COALESCE SUBPARTITION;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1144"></a>
<div class="sect3"><a id="sthref514"></a>
<h3 class="sect3">Coalescing Hash-Partitioned Global Indexes</h3>
<p>You can instruct the database to reduce by one the number of index partitions in a hash-partitioned global index using the <code>COALESCE</code> <code>PARTITION</code> clause of <code>ALTER</code> <code>INDEX</code>. The database selects the partition to coalesce based on the requirements of the hash partition. The following statement reduces by one the number of partitions in the <code>hgidx</code> index, created in <a href="part_admin001.htm#i1009930">"Creating a Hash-Partitioned Global Index"</a>:</p>
<pre>
ALTER INDEX hgidx COALESCE PARTITION;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007479"></a><a id="VLDBG1145"></a>
<div class="sect2">
<h2 class="sect2">Dropping Partitions</h2>
<p><a id="sthref515"></a>You can drop partitions from range, interval, list, or composite *-[range | list] partitioned tables. For interval partitioned tables, you can only drop range or interval partitions that have been materialized. For hash-partitioned tables, or hash subpartitions of composite *-hash partitioned tables, you must perform a coalesce operation instead.</p>
<p>You cannot drop a partition from a reference-partitioned table. Instead, a drop operation on a parent table cascades to all descendant tables.</p>
<a id="VLDBG1146"></a>
<div class="sect3"><a id="sthref516"></a>
<h3 class="sect3">Dropping Table Partitions</h3>
<p>Use one of the following statements to drop a table partition or subpartition:</p>
<ul>
<li>
<p><code>ALTER</code> <code>TABLE</code> ... <a id="sthref517"></a><code>DROP</code> <code>PARTITION</code> to drop a table partition</p>
</li>
<li>
<p><code>ALTER</code> <code>TABLE</code> ... <code>DROP</code> <code>SUBPARTITION</code> to drop a subpartition of a composite *-[range | list] partitioned table</p>
</li>
</ul>
<p>To preserve the data in the partition, then use the <code>MERGE</code> <code>PARTITION</code> statement instead of the <code>DROP</code> <code>PARTITION</code> statement.</p>
<p>If local indexes are defined for the table, then this statement also drops the matching partition or subpartitions from the local index. All global indexes, or all partitions of partitioned global indexes, are marked <code><a id="sthref518"></a>UNUSABLE</code> unless either of the following is true:</p>
<ul>
<li>
<p>You specify <code>UPDATE</code> <code>INDEXES</code> (Cannot be specified for index-organized tables. Use <code>UPDATE</code> <code>GLOBAL</code> <code>INDEXES</code> instead.)</p>
</li>
<li>
<p>The partition being dropped or its subpartitions are empty</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If a table contains only one partition, you cannot drop the partition. Instead, you must drop the table.</p>
</li>
<li>
<p>You cannot drop the highest range partition in the range-partitioned section of an interval-partitioned or interval-* composite partitioned table.</p>
</li>
</ul>
</div>
</li>
</ul>
<p>The following sections contain some scenarios for dropping table partitions.</p>
<a id="VLDBG1147"></a>
<div class="sect4"><a id="sthref519"></a>
<h4 class="sect4">Dropping a Partition from a Table that Contains Data and Global Indexes</h4>
<p>If the partition contains data and one or more global indexes are defined on the table, then use one of the following methods to drop the table partition.</p>
<p class="subhead2"><a id="VLDBG1148"></a>Method 1</p>
<p>Leave the global indexes in place during the <code>ALTER</code> <code>TABLE</code> ... <code>DROP</code> <code>PARTITION</code> statement. Afterward, you must rebuild any global indexes (whether partitioned or not) because the index (or index partitions) has been marked <code>UNUSABLE</code>. The following statements provide an example of dropping partition <code>dec98</code> from the <code>sales</code> table, then rebuilding its global nonpartitioned index.</p>
<pre>
ALTER TABLE sales DROP PARTITION dec98;
ALTER INDEX sales_area_ix REBUILD;
</pre>
<p>If index <code>sales_area_ix</code> were a range-partitioned global index, then all partitions of the index would require rebuilding. Further, it is not possible to rebuild all partitions of an index in one statement. You must issue a separate <code>REBUILD</code> statement for each partition in the index. The following statements rebuild the index partitions <code>jan99_ix</code>, <code>feb99_ix</code>, <code>mar99_ix</code>, ..., <code>dec99_ix</code>.</p>
<pre>
ALTER INDEX sales_area_ix REBUILD PARTITION jan99_ix;
ALTER INDEX sales_area_ix REBUILD PARTITION feb99_ix;
ALTER INDEX sales_area_ix REBUILD PARTITION mar99_ix;
...
ALTER INDEX sales_area_ix REBUILD PARTITION dec99_ix;
</pre>
<p>This method is most appropriate for large tables where the partition being dropped contains a significant percentage of the total data in the table.</p>
<p class="subhead2"><a id="VLDBG1149"></a>Method 2</p>
<p>Issue the <code>DELETE</code> statement to delete all rows from the partition before you issue the <code>ALTER</code> <code>TABLE</code> ... <code>DROP</code> <code>PARTITION</code> statement. The <code>DELETE</code> statement updates the global indexes.</p>
<p>For example, to drop the first partition, issue the following statements:</p>
<pre>
DELETE FROM sales partition (dec98);
ALTER TABLE sales DROP PARTITION dec98;
</pre>
<p>This method is most appropriate for small tables, or for large tables when the partition being dropped contains a small percentage of the total data in the table.</p>
<p class="subhead2"><a id="VLDBG1150"></a>Method 3</p>
<p>Specify <code>UPDATE</code> <code>INDEXES</code> in the <code>ALTER</code> <code>TABLE</code> statement. Doing so causes the global index to be updated at the time the partition is dropped.</p>
<pre>
ALTER TABLE sales DROP PARTITION dec98
     UPDATE INDEXES;
</pre></div>
<!-- class="sect4" -->
<a id="VLDBG1151"></a>
<div class="sect4"><a id="sthref520"></a>
<h4 class="sect4">Dropping a Partition Containing Data and Referential Integrity Constraints</h4>
<p>If a partition contains data and the table has referential integrity constraints, choose either of the following methods to drop the table partition. This table has a local index only, so it is not necessary to rebuild any indexes.</p>
<p class="subhead2"><a id="VLDBG1152"></a>Method 1</p>
<p>If there is no data referencing the data in the partition to drop, then you can disable the integrity constraints on the referencing tables, issue the <code>ALTER</code> <code>TABLE</code> ... <code>DROP</code> <code>PARTITION</code> statement, then re-enable the integrity constraints.</p>
<p>This method is most appropriate for large tables where the partition being dropped contains a significant percentage of the total data in the table. If there is still data referencing the data in the partition to be dropped, then ensure the removal of all the referencing data so that you can re-enable the referential integrity constraints.</p>
<p class="subhead2"><a id="VLDBG1153"></a>Method 2</p>
<p>If there is data in the referencing tables, then you can issue the <code>DELETE</code> statement to delete all rows from the partition before you issue the <code>ALTER</code> <code>TABLE</code> ... <code>DROP</code> <code>PARTITION</code> statement. The <code>DELETE</code> statement enforces referential integrity constraints, and also fires triggers and generates redo and undo logs. The delete can succeed if you created the constraints with the <code>ON DELETE CASCADE</code> option, deleting all rows from referencing tables as well.</p>
<pre>
DELETE FROM sales partition (dec94);
ALTER TABLE sales DROP PARTITION dec94;
</pre>
<p>This method is most appropriate for small tables or for large tables when the partition being dropped contains a small percentage of the total data in the table.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="VLDBG1154"></a>
<div class="sect3"><a id="sthref521"></a>
<h3 class="sect3">Dropping Interval Partitions</h3>
<p><a id="sthref522"></a>You can drop interval partitions in an interval-partitioned table. This operation drops the data for the interval only and leaves the interval definition in tact. If data is inserted in the interval just dropped, then the database again creates an interval partition.</p>
<p>You can also drop range partitions in an interval-partitioned table. The rules for dropping a range partition in an interval-partitioned table follow the rules for dropping a range partition in a range-partitioned table. If you drop a range partition in the middle of a set of range partitions, then the lower boundary for the next range partition shifts to the lower boundary of the range partition you just dropped. You cannot drop the highest range partition in the range-partitioned section of an interval-partitioned table.</p>
<p>The following example drops the September 2007 interval partition from the <code>sales</code> table. There are only local indexes so no indexes are invalidated.</p>
<pre>
ALTER TABLE sales DROP PARTITION FOR(TO_DATE('01-SEP-2007','dd-MON-yyyy'));
</pre></div>
<!-- class="sect3" -->
<a id="i1007542"></a><a id="VLDBG1155"></a>
<div class="sect3">
<h3 class="sect3">Dropping Index Partitions</h3>
<p><a id="sthref523"></a>You cannot explicitly drop a partition of a local index. Instead, local index partitions are dropped only when you drop a partition from the underlying table.</p>
<p>If a global index partition is empty, then you can explicitly drop it by issuing the <code>ALTER</code> <code>INDEX</code> ... <code>DROP</code> <code>PARTITION</code> statement. But, if a global index partition contains data, then dropping the partition causes the next highest partition to be marked <code><a id="sthref524"></a>UNUSABLE</code>. For example, you would like to drop the index partition P1, and P2 is the next highest partition. You must issue the following statements:</p>
<pre>
ALTER INDEX npr DROP PARTITION P1;
ALTER INDEX npr REBUILD PARTITION P2;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot drop the highest partition in a global index.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1107555"></a><a id="VLDBG1156"></a>
<div class="sect2">
<h2 class="sect2">Exchanging Partitions</h2>
<p><a id="sthref525"></a>You can convert a partition (or subpartition) into a nonpartitioned table, and a nonpartitioned table into a partition (or subpartition) of a partitioned table by exchanging their data segments. You can also convert a hash-partitioned table into a partition of a composite *-hash partitioned table, or convert the partition of a composite *-hash partitioned table into a hash-partitioned table. Similarly, you can convert a [range | list]-partitioned table into a partition of a composite *-[range | list] partitioned table, or convert a partition of the composite *-[range | list] partitioned table into a [range | list]-partitioned table.</p>
<p>Exchanging table partitions is most useful when you have an application using nonpartitioned tables to convert to partitions of a partitioned table. For example, in data warehousing environments, exchanging partitions facilitates high-speed data loading of new, incremental data into an existing partitioned table. Generically, OLTP and data warehousing environments benefit from exchanging old data partitions out of a partitioned table. The data is purged from the partitioned table without actually being deleted and can be archived separately afterward.</p>
<p>When you exchange partitions, logging attributes are preserved. You can optionally specify if local indexes are also to be exchanged (<code>INCLUDING</code> <code>INDEXES</code> clause), and if rows are to be validated for proper mapping (<code>WITH</code> <code>VALIDATION</code> clause).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you specify <code>WITHOUT</code> <code>VALIDATION</code> for the exchange partition operation, this is normally a fast operation because it involves only data dictionary updates. However, if the table or partitioned table involved in the exchange operation has a primary key or unique constraint enabled, then the exchange operation is performed as if <code>WITH</code> <code>VALIDATION</code> were specified to maintain the integrity of the constraints.
<p>To avoid the overhead of this validation activity, issue the following statement for each constraint before doing the exchange partition operation:</p>
<pre>
ALTER TABLE <span class="italic">table_name</span>
     DISABLE CONSTRAINT <span class="italic">constraint_name</span> KEEP INDEX
</pre>
<p>Then, enable the constraints after the exchange.</p>
<p>If you specify <code>WITHOUT</code> <code>VALIDATION</code>, then you must ensure that the data to be exchanged belongs in the partition you exchange.</p>
</div>
<p>Unless you specify <code>UPDATE</code> <code>INDEXES</code>, the database marks <code><a id="sthref526"></a>UNUSABLE</code> the global indexes or all global index partitions on the table whose partition is being exchanged. Global indexes or global index partitions on the table being exchanged remain invalidated. (You cannot use <code>UPDATE</code> <code>INDEXES</code> for index-organized tables. Use <code>UPDATE</code> <code>GLOBAL</code> <code>INDEXES</code> instead.)</p>
<p>For more information, refer to <a href="part_admin005.htm#i1008364">"Viewing Information About Partitioned Tables and Indexes"</a>.</p>
<a id="VLDBG1157"></a>
<div class="sect3"><a id="sthref527"></a>
<h3 class="sect3">Exchanging a Range, Hash, or List Partition</h3>
<p>To exchange a partition of a range, hash, or list-partitioned table with a nonpartitioned table, or the reverse, use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref528"></a><code>EXCHANGE</code> <code>PARTITION</code> statement. An example of converting a partition into a nonpartitioned table follows. In this example, table <code>stocks</code> can be range, hash, or list partitioned.</p>
<pre>
ALTER TABLE stocks
    EXCHANGE PARTITION p3 WITH TABLE stock_table_3;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1158"></a>
<div class="sect3"><a id="sthref529"></a>
<h3 class="sect3">Exchanging a Partition of an Interval Partitioned Table</h3>
<p>You can exchange interval partitions in an interval-partitioned table. However, you must ensure that the interval partition has been created before you can exchange the partition. You can let the database create the partition by locking the interval partition.</p>
<p>The following example shows a partition exchange for the <code>interval_sales</code> table, interval-partitioned using monthly partitions as of January 1, 2004. This example shows how to add data for June 2007 to the table using partition exchange load. Assume there are only local indexes on the <code>interval_sales</code> table, and equivalent indexes have been created on the <code>interval_sales_june_2007</code> table.</p>
<pre>
LOCK TABLE interval_sales
PARTITION FOR (TO_DATE('01-JUN-2007','dd-MON-yyyy'))
IN SHARE MODE;

ALTER TABLE interval_sales
EXCHANGE PARTITION FOR (TO_DATE('01-JUN-2007','dd-MON-yyyy'))
WITH TABLE interval_sales_jun_2007
INCLUDING INDEXES;
</pre>
<p>Note the use of the <code>FOR</code> syntax to identify a partition that was system-generated. The partition name can be used by querying the <code>*_TAB_PARTITIONS</code> data dictionary view to find out the system-generated partition name.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1159"></a>
<div class="sect3"><a id="sthref530"></a>
<h3 class="sect3">Exchanging a Partition of a Reference-Partitioned Table</h3>
<p>You can exchange partitions in a reference-partitioned table, but you must ensure that the data that you reference is available in the respective partition in the parent table.</p>
<p><a href="#CHDEJFFI">Example 4-30</a> shows a partition exchange load scenario for the range-partitioned <code>orders</code> table, and the reference partitioned <code>order_items</code> table. Note that the data in the <code>order_items_dec_2006</code> table only contains order item data for orders with an <code>order_date</code> in December 2006.</p>
<div class="example">
<p class="titleinexample"><a id="CHDEJFFI"></a><a id="VLDBG14073"></a>Example 4-30 Exchanging a partition for a range-partitioned table</p>
<pre>
ALTER TABLE orders
EXCHANGE PARTITION p_2006_dec
WITH TABLE orders_dec_2006
UPDATE GLOBAL INDEXES;

ALTER TABLE order_items_dec_2006
ADD CONSTRAINT order_items_dec_2006_fk
FOREIGN KEY (order_id)
REFERENCES orders(order_id) ;

ALTER TABLE order_items
EXCHANGE PARTITION p_2006_dec
WITH TABLE order_items_dec_2006;
</pre></div>
<!-- class="example" -->
<p>Note that you must use the <code>UPDATE GLOBAL INDEXES</code> or <code>UPDATE INDEXES</code> on the exchange partition of the parent table in order for the primary key index to remain usable. Note also that you must create or enable the foreign key constraint on the <code>order_items_dec_2006</code> table in order for the partition exchange on the reference-partitioned table to succeed.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1160"></a>
<div class="sect3"><a id="sthref531"></a>
<h3 class="sect3">Exchanging a Partition of a Table with Virtual Columns</h3>
<p>You can exchange partitions in the presence of virtual columns. In order for a partition exchange on a partitioned table with virtual columns to succeed, you must create a table that matches the definition of all non-virtual columns in a single partition of the partitioned table. You do not need to include the virtual column definitions, unless constraints or indexes have been defined on the virtual column.</p>
<p>In this case, you must include the virtual column definition to match the partitioned table's constraint and index definitions. This scenario also applies to virtual column-based partitioned tables.</p>
</div>
<!-- class="sect3" -->
<a id="i1007597"></a><a id="VLDBG1161"></a>
<div class="sect3">
<h3 class="sect3">Exchanging a Hash-Partitioned Table with a *-Hash Partition</h3>
<p>In this example, you are exchanging a whole hash-partitioned table, with all of its partitions, with the partition of a *-hash partitioned table and all of its hash subpartitions. The following example illustrates this concept for a range-hash partitioned table.</p>
<p>First, create a hash-partitioned table:</p>
<pre>
CREATE TABLE t1 (i NUMBER, j NUMBER)
     PARTITION BY HASH(i)
       (PARTITION p1, PARTITION p2);
</pre>
<p>Populate the table, then create a range-hash partitioned table as follows:</p>
<pre>
CREATE TABLE t2 (i NUMBER, j NUMBER)
     PARTITION BY RANGE(j)
     SUBPARTITION BY HASH(i)
        (PARTITION p1 VALUES LESS THAN (10)
            SUBPARTITION t2_pls1
            SUBPARTITION t2_pls2,
         PARTITION p2 VALUES LESS THAN (20)
            SUBPARTITION t2_p2s1
            SUBPARTITION t2_p2s2));
</pre>
<p>It is important that the partitioning key in table <code>t1</code> equals the subpartitioning key in table <code>t2</code>.</p>
<p>To migrate the data in <code>t1</code> to <code>t2</code>, and validate the rows, use the following statement:</p>
<pre>
ALTER TABLE t2 EXCHANGE PARTITION p1 WITH TABLE t1
     WITH VALIDATION;
</pre></div>
<!-- class="sect3" -->
<a id="i1007620"></a><a id="VLDBG1162"></a>
<div class="sect3">
<h3 class="sect3">Exchanging a Subpartition of a *-Hash Partitioned Table</h3>
<p><a id="sthref532"></a>Use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref533"></a><code>EXCHANGE</code> <code>SUBPARTITION</code> statement to convert a hash subpartition of a *-hash partitioned table into a nonpartitioned table, or the reverse. The following example converts the subpartition <code>q3_1999_s1</code> of table <code>sales</code> into the nonpartitioned table <code>q3_1999</code>. Local index partitions are exchanged with corresponding indexes on <code>q3_1999</code>.</p>
<pre>
ALTER TABLE sales EXCHANGE SUBPARTITION q3_1999_s1
      WITH TABLE q3_1999 INCLUDING INDEXES;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1163"></a>
<div class="sect3"><a id="sthref534"></a>
<h3 class="sect3">Exchanging a List-Partitioned Table with a *-List Partition</h3>
<p>The semantics of the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref535"></a><code>EXCHANGE</code> <code>PARTITION</code> statement are the same as described previously in <a href="#i1007597">"Exchanging a Hash-Partitioned Table with a *-Hash Partition"</a>. The following example shows an exchange partition scenario for a list-list partitioned table.</p>
<pre>
CREATE TABLE customers_apac
( id            NUMBER
, name          VARCHAR2(50)
, email         VARCHAR2(100)
, region        VARCHAR2(4)
, credit_rating VARCHAR2(1)
)
PARTITION BY LIST (credit_rating)
( PARTITION poor VALUES ('P')
, PARTITION mediocre VALUES ('C')
, PARTITION good VALUES ('G')
, PARTITION excellent VALUES ('E')
);
</pre>
<p>Populate the table with APAC customers. Then create a list-list partitioned table:</p>
<pre>
CREATE TABLE customers
( id            NUMBER
, name          VARCHAR2(50)
, email         VARCHAR2(100)
, region        VARCHAR2(4)
, credit_rating VARCHAR2(1)
)
PARTITION BY LIST (region)
SUBPARTITION BY LIST (credit_rating)
SUBPARTITION TEMPLATE
( SUBPARTITION poor VALUES ('P')
, SUBPARTITION mediocre VALUES ('C')
, SUBPARTITION good VALUES ('G')
, SUBPARTITION excellent VALUES ('E')
)
(PARTITION americas VALUES ('AMER')
, PARTITION emea VALUES ('EMEA')
, PARTITION apac VALUES ('APAC')
);
</pre>
<p>It is important that the partitioning key in the <code>customers_apac</code> table matches the subpartitioning key in the <code>customers</code> table.</p>
<p>Next, exchange the <code>apac</code> partition.</p>
<pre>
ALTER TABLE customers
EXCHANGE PARTITION apac
WITH TABLE customers_apac
WITH VALIDATION;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1164"></a>
<div class="sect3"><a id="sthref536"></a>
<h3 class="sect3">Exchanging a Subpartition of a *-List Partitioned Table</h3>
<p><a id="sthref537"></a>The semantics of the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref538"></a><code>EXCHANGE</code> <code>SUBPARTITION</code> are the same as described previously in <a href="#i1007620">"Exchanging a Subpartition of a *-Hash Partitioned Table"</a>.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1165"></a>
<div class="sect3"><a id="sthref539"></a>
<h3 class="sect3">Exchanging a Range-Partitioned Table with a *-Range Partition</h3>
<p>The semantics of the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref540"></a><code>EXCHANGE</code> <code>PARTITION</code> statement are the same as described previously in <a href="#i1007597">"Exchanging a Hash-Partitioned Table with a *-Hash Partition"</a>. The example below shows the <code>orders</code> table, which is interval partitioned by <code>order_date</code>, and subpartitioned by range on <code>order_total</code>. The example shows how to exchange a single monthly interval with a range-partitioned table.</p>
<pre>
CREATE TABLE orders_mar_2007
( id          NUMBER
, cust_id     NUMBER
, order_date  DATE
, order_total NUMBER
)
PARTITION BY RANGE (order_total)
( PARTITION p_small VALUES LESS THAN (1000)
, PARTITION p_medium VALUES LESS THAN (10000)
, PARTITION p_large VALUES LESS THAN (100000)
, PARTITION p_extraordinary VALUES LESS THAN (MAXVALUE)
);
</pre>
<p>Populate the table with orders for March 2007. Then create an interval-range partitioned table:</p>
<pre>
CREATE TABLE orders
( id          NUMBER
, cust_id     NUMBER
, order_date  DATE
, order_total NUMBER
)
PARTITION BY RANGE (order_date) INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
  SUBPARTITION BY RANGE (order_total)
  SUBPARTITION TEMPLATE
  ( SUBPARTITION p_small VALUES LESS THAN (1000)
  , SUBPARTITION p_medium VALUES LESS THAN (10000)
  , SUBPARTITION p_large VALUES LESS THAN (100000)
  , SUBPARTITION p_extraordinary VALUES LESS THAN (MAXVALUE)
  )
(PARTITION p_before_2007 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-
MON-yyyy')));
</pre>
<p>It is important that the partitioning key in the <code>orders_mar_2007</code> table matches the subpartitioning key in the <code>orders</code> table.</p>
<p>Next, exchange the partition. Note that because an interval partition is to be exchanged, the partition is first locked to ensure that the partition is created.</p>
<pre>
LOCK TABLE orders PARTITION FOR (TO_DATE('01-MAR-2007','dd-MON-yyyy')) 
IN SHARE MODE;

ALTER TABLE orders
EXCHANGE PARTITION
FOR (TO_DATE('01-MAR-2007','dd-MON-yyyy'))
WITH TABLE orders_mar_2007
WITH VALIDATION;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1166"></a>
<div class="sect3"><a id="sthref541"></a>
<h3 class="sect3">Exchanging a Subpartition of a *-Range Partitioned Table</h3>
<p><a id="sthref542"></a>The semantics of the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref543"></a><code>EXCHANGE</code> <code>SUBPARTITION</code> are the same as described previously in <a href="#i1007620">"Exchanging a Subpartition of a *-Hash Partitioned Table"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007638"></a><a id="VLDBG1167"></a>
<div class="sect2">
<h2 class="sect2">Merging Partitions</h2>
<p><a id="sthref544"></a>Use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref545"></a><code>MERGE</code> <code>PARTITION</code> statement to merge the contents of two partitions into one partition. The two original partitions are dropped, as are any corresponding local indexes. You cannot use this statement for a hash-partitioned table or for hash subpartitions of a composite *-hash partitioned table.</p>
<p>You cannot merge partitions for a reference-partitioned table. Instead, a merge operation on a parent table cascades to all descendant tables. However, you can use the <code>DEPENDENT TABLES</code> clause to set specific properties for dependent tables when you issue the merge operation on the master table to merge partitions or subpartitions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
<p>If the involved partitions or subpartitions contain data, then indexes may be marked <code><a id="sthref546"></a>UNUSABLE</code> as explained in the following table:</p>
<div class="inftblruleinformal">
<table class="cellalignment1835" title="UNUSABLE Indexes and Index Partitions After Merge Operations" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t27">Table Type</th>
<th class="cellalignment1836" id="r1c2-t27">Index Behavior</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t27" headers="r1c1-t27">Regular (Heap)</td>
<td class="cellalignment1837" headers="r2c1-t27 r1c2-t27">Unless you specify <code>UPDATE</code> <code>INDEXES</code> as part of the <code>ALTER</code> <code>TABLE</code> statement:
<ul>
<li>
<p>The database marks <code>UNUSABLE</code> all resulting corresponding local index partitions or subpartitions.</p>
</li>
<li>
<p>Global indexes, or all partitions of partitioned global indexes, are marked <code>UNUSABLE</code> and must be rebuilt.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t27" headers="r1c1-t27">Index-organized</td>
<td class="cellalignment1837" headers="r3c1-t27 r1c2-t27">
<ul>
<li>The database marks <code>UNUSABLE</code> all resulting corresponding local index partitions.</li>
<li>
<p>All global indexes remain usable.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" -->
<a id="i1007662"></a><a id="VLDBG1168"></a>
<div class="sect3">
<h3 class="sect3">Merging Range Partitions</h3>
<p>You are allowed to merge the contents of two adjacent range partitions into one partition. Nonadjacent range partitions cannot be merged. The resulting partition inherits the higher upper bound of the two merged partitions.</p>
<p>One reason for merging range partitions is to keep historical data online in larger partitions. For example, you can have daily partitions, with the oldest partition rolled up into weekly partitions, which can then be rolled up into monthly partitions, and so on.</p>
<p><a href="#CHDHCBBD">Example 4-31</a> shows an example of merging range partitions.</p>
<div class="example">
<p class="titleinexample"><a id="CHDHCBBD"></a><a id="VLDBG14074"></a>Example 4-31 Merging range partitions</p>
<pre>
-- First, create a partitioned table with four partitions, each on its own
-- tablespace partitioned by range on the data column
--
CREATE TABLE four_seasons
( 
        one DATE,
        two VARCHAR2(60),
        three NUMBER
)
PARTITION  BY RANGE ( one ) 
(
PARTITION quarter_one 
   VALUES LESS THAN ( TO_DATE('01-apr-1998','dd-mon-yyyy'))
   TABLESPACE quarter_one,
PARTITION quarter_two 
   VALUES LESS THAN ( TO_DATE('01-jul-1998','dd-mon-yyyy'))
   TABLESPACE quarter_two,
PARTITION quarter_three
   VALUES LESS THAN ( TO_DATE('01-oct-1998','dd-mon-yyyy'))
   TABLESPACE quarter_three,
PARTITION quarter_four
   VALUES LESS THAN ( TO_DATE('01-jan-1999','dd-mon-yyyy'))
   TABLESPACE quarter_four
);
-- 
-- Create local PREFIXED index on Four_Seasons
-- Prefixed because the leftmost columns of the index match the
-- Partitioning key 
--
CREATE INDEX i_four_seasons_l ON four_seasons ( one,two ) 
LOCAL ( 
PARTITION i_quarter_one TABLESPACE i_quarter_one,
PARTITION i_quarter_two TABLESPACE i_quarter_two,
PARTITION i_quarter_three TABLESPACE i_quarter_three,
PARTITION i_quarter_four TABLESPACE i_quarter_four
);

-- Next, merge the first two partitions 
ALTER TABLE four_seasons 
MERGE PARTITIONS quarter_one, quarter_two INTO PARTITION quarter_two
UPDATE INDEXES;
</pre></div>
<!-- class="example" -->
<p>If you omit the <code>UPDATE</code> <code>INDEXES</code> clause from the preceding statement, then you must rebuild the local index for the affected partition.</p>
<pre>
-- Rebuild index for quarter_two, which has been marked unusable 
-- because it has not had all of the data from Q1 added to it.
-- Rebuilding the index corrects this.
--
ALTER TABLE four_seasons MODIFY PARTITION 
quarter_two REBUILD UNUSABLE LOCAL INDEXES;
</pre></div>
<!-- class="sect3" -->
<a id="BAJCIFBH"></a><a id="VLDBG1169"></a>
<div class="sect3">
<h3 class="sect3">Merging Interval Partitions</h3>
<p>The contents of two adjacent interval partitions can be merged into one partition. Nonadjacent interval partitions cannot be merged. The first interval partition can also be merged with the highest range partition. The resulting partition inherits the higher upper bound of the two merged partitions.</p>
<p>Merging interval partitions always results in the transition point being moved to the higher upper bound of the two merged partitions. This result is that the range section of the interval-partitioned table is extended to the upper bound of the two merged partitions. Any materialized interval partitions with boundaries lower than the newly merged partition are automatically converted into range partitions, with their upper boundaries defined by the upper boundaries of their intervals.</p>
<p>For example, consider the following interval-partitioned table transactions:</p>
<pre>
CREATE TABLE transactions
( id               NUMBER
, transaction_date DATE
, value            NUMBER
)
PARTITION BY RANGE (transaction_date)
INTERVAL (NUMTODSINTERVAL(1,'DAY'))
( PARTITION p_before_2007 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy')));
</pre>
<p>Insert data into the interval section of the table. This creates the interval partitions for these days. Note that January 15, 2007 and January 16, 2007 are stored in adjacent interval partitions.</p>
<pre>
INSERT INTO transactions VALUES (1,TO_DATE('15-JAN-2007','dd-MON-yyyy'),100);
INSERT INTO transactions VALUES (2,TO_DATE('16-JAN-2007','dd-MON-yyyy'),600); 
INSERT INTO transactions VALUES (3,TO_DATE('30-JAN-2007','dd-MON-yyyy'),200);
</pre>
<p>Next, merge the two adjacent interval partitions. The new partition again has a system-generated name.</p>
<pre>
ALTER TABLE transactions
MERGE PARTITIONS FOR(TO_DATE('15-JAN-2007','dd-MON-yyyy'))
, FOR(TO_DATE('16-JAN-2007','dd-MON-yyyy'));
</pre>
<p>The transition point for the <code>transactions</code> table has now moved to January 17, 2007. The range section of the interval-partitioned table contains two range partitions: values less than January 1, 2007 and values less than January 17, 2007. Values greater than January 17, 2007 fall in the interval portion of the interval-partitioned table.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1170"></a>
<div class="sect3"><a id="sthref547"></a>
<h3 class="sect3">Merging List Partitions</h3>
<p>When you merge list partitions, the partitions being merged can be any two partitions. They do not need to be adjacent, as for range partitions, because list partitioning does not assume any order for partitions. The resulting partition consists of all of the data from the original two partitions. If you merge a default list partition with any other partition, then the resulting partition is the default partition.</p>
<p>The following statement merges two partitions of a table partitioned using the list method into a partition that inherits all of its attributes from the table-level default attributes. <code>MAXEXTENTS</code> is specified in the statement.</p>
<pre>
ALTER TABLE q1_sales_by_region 
   MERGE PARTITIONS q1_northcentral, q1_southcentral 
   INTO PARTITION q1_central 
      STORAGE(MAXEXTENTS 20);
</pre>
<p>The value lists for the two original partitions were specified as:</p>
<pre>
PARTITION q1_northcentral VALUES ('SD','WI')
PARTITION q1_southcentral VALUES ('OK','TX')
</pre>
<p>The resulting <code>sales_west</code> partition value list comprises the set that represents the union of these two partition value lists, or specifically:</p>
<pre>
('SD','WI','OK','TX')
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1171"></a>
<div class="sect3"><a id="sthref548"></a>
<h3 class="sect3">Merging *-Hash Partitions</h3>
<p>When you merge *-hash partitions, the subpartitions are rehashed into the number of subpartitions specified by <code>SUBPARTITIONS</code> <code><span class="codeinlineitalic">n</span></code> or the <code>SUBPARTITION</code> clause. If neither is included, table-level defaults are used.</p>
<p>Note that the inheritance of properties is different when a *-hash partition is split (discussed in <a href="#i1008098">"Splitting a *-Hash Partition"</a>), as opposed to when two *-hash partitions are merged. When a partition is split, the new partitions can inherit properties from the original partition because there is only one parent. However, when partitions are merged, properties must be inherited from the table level.</p>
<p>For interval-hash partitioned tables, you can only merge two adjacent interval partitions, or the highest range partition with the first interval partition. As described in <a href="#BAJCIFBH">"Merging Interval Partitions"</a>, the transition point moves when you merge intervals in an interval-hash partitioned table.</p>
<p>The following example merges two range-hash partitions:</p>
<pre>
ALTER TABLE all_seasons
   MERGE PARTITIONS quarter_1, quarter_2 INTO PARTITION quarter_2
   SUBPARTITIONS 8;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1172"></a>
<div class="sect3"><a id="sthref549"></a>
<h3 class="sect3">Merging *-List Partitions</h3>
<p>Partitions can be merged at the partition level and subpartitions can be merged at the list subpartition level.</p>
<a id="VLDBG1173"></a>
<div class="sect4"><a id="sthref550"></a>
<h4 class="sect4">Merging Partitions in a *-List Partitioned Table</h4>
<p>Merging partitions in a *-list partitioned table is as described previously in <a href="#i1007662">"Merging Range Partitions"</a>. However, when you merge two *-list partitions, the resulting new partition inherits the subpartition descriptions from the subpartition template, if a template exists. If no subpartition template exists, then a single default subpartition is created for the new partition.</p>
<p>For interval-list partitioned tables, you can only merge two adjacent interval partitions, or the highest range partition with the first interval partition. As described in <a href="#BAJCIFBH">"Merging Interval Partitions"</a>, the transition point moves when you merge intervals in an interval-list partitioned table.</p>
<p>The following statement merges two partitions in the range-list partitioned <code>stripe_regional_sales</code> table. A subpartition template exists for the table.</p>
<pre>
ALTER TABLE stripe_regional_sales
   MERGE PARTITIONS q1_1999, q2_1999 INTO PARTITION q1_q2_1999
      STORAGE(MAXEXTENTS 20);
</pre>
<p>Some new physical attributes are specified for this new partition while table-level defaults are inherited for those that are not specified. The new resulting partition <code>q1_q2_1999</code> inherits the high-value bound of the partition <code>q2_1999</code> and the subpartition value-list descriptions from the subpartition template description of the table.</p>
<p>The data in the resulting partitions consists of data from both the partitions. However, there may be cases where the database returns an error. This can occur because data may map out of the new partition when both of the following conditions exist:</p>
<ul>
<li>
<p>Some literal values of the merged subpartitions were not included in the subpartition template.</p>
</li>
<li>
<p>The subpartition template does not contain a default partition definition.</p>
</li>
</ul>
<p>This error condition can be eliminated by always specifying a default partition in the default subpartition template.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1174"></a>
<div class="sect4"><a id="sthref551"></a>
<h4 class="sect4">Merging Subpartitions in a *-List Partitioned Table</h4>
<p>You can merge the contents of any two arbitrary list subpartitions belonging to the <span class="italic">same</span> partition. The resulting subpartition value-list descriptor includes all of the literal values in the value lists for the partitions being merged.</p>
<p>The following statement merges two subpartitions of a table partitioned using range-list method into a new subpartition located in tablespace <code>ts4</code>:</p>
<pre>
ALTER TABLE quarterly_regional_sales
   MERGE SUBPARTITIONS q1_1999_northwest, q1_1999_southwest
      INTO SUBPARTITION q1_1999_west
         TABLESPACE ts4;
</pre>
<p>The value lists for the original two partitions were:</p>
<ul>
<li>
<p>Subpartition <code>q1_1999_northwest</code> was described as <code>('WA','OR')</code></p>
</li>
<li>
<p>Subpartition <code>q1_1999_southwest</code> was described as <code>('AZ','NM','UT')</code></p>
</li>
</ul>
<p>The resulting subpartition value list comprises the set that represents the union of these two subpartition value lists:</p>
<ul>
<li>
<p>Subpartition <code>q1_1999_west</code> has a value list described as <code>('WA','OR','AZ','NM','UT')</code></p>
</li>
</ul>
<p>The tablespace in which the resulting subpartition is located and the subpartition attributes are determined by the partition-level default attributes, except for those specified explicitly. If any of the existing subpartition names are being reused, then the new subpartition inherits the subpartition attributes of the subpartition whose name is being reused.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="VLDBG1175"></a>
<div class="sect3"><a id="sthref552"></a>
<h3 class="sect3">Merging *-Range Partitions</h3>
<p>Partitions can be merged at the partition level and subpartitions can be merged at the range subpartition level.</p>
<a id="VLDBG1176"></a>
<div class="sect4"><a id="sthref553"></a>
<h4 class="sect4">Merging Partitions in a *-Range Partitioned Table</h4>
<p>Merging partitions in a *-range partitioned table is as described previously in <a href="#i1007662">"Merging Range Partitions"</a>. However, when you merge two *-range partitions, the resulting new partition inherits the subpartition descriptions from the subpartition template, if one exists. If no subpartition template exists, then a single subpartition with an upper boundary <code>MAXVALUE</code> is created for the new partition.</p>
<p>For interval-range partitioned tables, you can only merge two adjacent interval partitions, or the highest range partition with the first interval partition. As described in <a href="#BAJCIFBH">"Merging Interval Partitions"</a>, the transition point moves when you merge intervals in an interval-range partitioned table.</p>
<p>The following statement merges two partitions in the monthly interval-range partitioned <code>orders</code> table. A subpartition template exists for the table.</p>
<pre>
ALTER TABLE orders
MERGE PARTITIONS FOR(TO_DATE('01-MAR-2007','dd-MON-yyyy')), 
FOR(TO_DATE('01-APR-2007','dd-MON-yyyy'))
INTO PARTITION p_pre_may_2007;
</pre>
<p>If the March 2007 and April 2007 partitions were still in the interval section of the interval-range partitioned table, then the merge operation would move the transition point to May 1, 2007.</p>
<p>The subpartitions for partition <code>p_pre_may_2007</code> inherit their properties from the subpartition template. The data in the resulting partitions consists of data from both the partitions. However, there may be cases where the database returns an error. This can occur because data may map out of the new partition when both of the following conditions are met:</p>
<ul>
<li>
<p>Some range values of the merged subpartitions were not included in the subpartition template.</p>
</li>
<li>
<p>The subpartition template does not have a subpartition definition with a <code>MAXVALUE</code> upper boundary.</p>
</li>
</ul>
<p>The error condition can be eliminated by always specifying a subpartition with an upper boundary of <code>MAXVALUE</code> in the subpartition template.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007780"></a><a id="VLDBG1177"></a>
<div class="sect2">
<h2 class="sect2">Modifying Default Attributes</h2>
<p><a id="sthref554"></a>You can modify the default attributes of a table, or for a partition of a composite partitioned table. When you modify default attributes, the new attributes affect only future partitions, or subpartitions, that are created. The default values can still be specifically overridden when creating a new partition or subpartition. You can modify the default attributes of a reference-partitioned table.</p>
<a id="VLDBG1178"></a>
<div class="sect3"><a id="sthref555"></a>
<h3 class="sect3">Modifying Default Attributes of a Table</h3>
<p>You can modify the default attributes that are inherited for range, hash, list, interval, or reference partitions using the <a id="sthref556"></a><a id="sthref557"></a><code>MODIFY</code> <code>DEFAULT</code> <code>ATTRIBUTES</code> clause of <code>ALTER</code> <code>TABLE</code>.</p>
<p>For hash-partitioned tables, only the <code>TABLESPACE</code> attribute can be modified.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1179"></a>
<div class="sect3"><a id="sthref558"></a>
<h3 class="sect3">Modifying Default Attributes of a Partition</h3>
<p>To modify the default attributes inherited when creating subpartitions, use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref559"></a><a id="sthref560"></a><code>MODIFY</code> <code>DEFAULT</code> <code>ATTRIBUTES</code> <code>FOR</code> <code>PARTITION</code>. The following statement modifies the <code>TABLESPACE</code> in which future subpartitions of partition <code>p1</code> in range-hash partitioned table <code>emp</code> reside.</p>
<pre>
ALTER TABLE emp
     MODIFY DEFAULT ATTRIBUTES FOR PARTITION p1 TABLESPACE ts1;
</pre>
<p>Because all subpartitions of a range-hash partitioned table must share the same attributes, except <code>TABLESPACE</code>, it is the only attribute that can be changed.</p>
<p>You cannot modify default attributes of interval partitions that have not yet been created. To change the way in which future subpartitions in an interval-partitioned table are created, you must modify the subpartition template.</p>
</div>
<!-- class="sect3" -->
<a id="i1007798"></a><a id="VLDBG1180"></a>
<div class="sect3">
<h3 class="sect3">Modifying Default Attributes of Index Partitions</h3>
<p><a id="sthref561"></a>In a similar fashion to table partitions, you can alter the default attributes that are inherited by partitions of a range-partitioned global index, or local index partitions of partitioned tables. For this you use the <code>ALTER</code> <code>INDEX</code> ... <code>MODIFY</code> <code>DEFAULT</code> <code>ATTRIBUTES</code> statement. Use the <code>ALTER</code> <code>INDEX</code> ... <a id="sthref562"></a><a id="sthref563"></a><code>MODIFY</code> <code>DEFAULT</code> <code>ATTRIBUTES</code> <code>FOR</code> <code>PARTITION</code> statement if you are altering default attributes to be inherited by subpartitions of a composite partitioned table.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007802"></a><a id="VLDBG1181"></a>
<div class="sect2">
<h2 class="sect2">Modifying Real Attributes of Partitions</h2>
<p><a id="sthref564"></a>It is possible to modify attributes of an existing partition of a table or index.</p>
<p>You cannot change the <code>TABLESPACE</code> attribute. Use <code>ALTER</code> <code>TABLE</code> ... <a id="sthref565"></a><a id="sthref566"></a><code>MOVE</code> <code>PARTITION</code>/<code>SUBPARTITION</code> to move a partition or subpartition to a new tablespace.</p>
<a id="VLDBG1182"></a>
<div class="sect3"><a id="sthref567"></a>
<h3 class="sect3">Modifying Real Attributes for a Range or List Partition</h3>
<p>Use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref568"></a><code>MODIFY</code> <code>PARTITION</code> statement to modify existing attributes of a range partition or list partition. You can modify segment attributes (except <code>TABLESPACE</code>), or you can allocate and deallocate extents, mark local index partitions <code><a id="sthref569"></a>UNUSABLE</code>, or rebuild local indexes that have been marked <code>UNUSABLE</code>.</p>
<p>If this is a range partition of a *-hash partitioned table, then note the following:</p>
<ul>
<li>
<p>If you allocate or deallocate an extent, this action is performed for every subpartition of the specified partition.</p>
</li>
<li>
<p>Likewise, changing any other attributes results in corresponding changes to those attributes of all the subpartitions for that partition. The partition level default attributes are changed as well. To avoid changing attributes of existing subpartitions, use the <a id="sthref570"></a><code>FOR</code> <code>PARTITION</code> clause of the <a id="sthref571"></a><code>MODIFY</code> <code>DEFAULT</code> <code>ATTRIBUTES</code> statement.</p>
</li>
</ul>
<p>The following are some examples of modifying the real attributes of a partition.</p>
<p>This example modifies the <code>MAXEXTENTS</code> storage attribute for the range partition <code>sales_q1</code> of table <code>sales</code>:</p>
<pre>
ALTER TABLE sales MODIFY PARTITION sales_q1
     STORAGE (MAXEXTENTS 10); 
</pre>
<p>All of the local index subpartitions of partition <code>ts1</code> in range-hash partitioned table <code>scubagear</code> are marked <code><a id="sthref572"></a>UNUSABLE</code> in the following example:</p>
<pre>
ALTER TABLE scubagear MODIFY PARTITION ts1 UNUSABLE LOCAL INDEXES;
</pre>
<p>For an interval-partitioned table you can only modify real attributes of range partitions or interval partitions that have been created.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1183"></a>
<div class="sect3"><a id="sthref573"></a>
<h3 class="sect3">Modifying Real Attributes for a Hash Partition</h3>
<p>You also use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref574"></a><code>MODIFY</code> <code>PARTITION</code> statement to modify attributes of a hash partition. However, because the physical attributes of individual hash partitions must all be the same (except for <code>TABLESPACE</code>), you are restricted to:</p>
<ul>
<li>
<p>Allocating a new extent</p>
</li>
<li>
<p>Deallocating an unused extent</p>
</li>
<li>
<p>Marking a local index subpartition <code><a id="sthref575"></a>UNUSABLE</code></p>
</li>
<li>
<p>Rebuilding local index subpartitions that are marked <code>UNUSABLE</code></p>
</li>
</ul>
<p>The following example rebuilds any unusable local index partitions associated with hash partition <code>P1</code> of table <code>dept</code>:</p>
<pre>
ALTER TABLE dept MODIFY PARTITION p1
     REBUILD UNUSABLE LOCAL INDEXES;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1184"></a>
<div class="sect3"><a id="sthref576"></a>
<h3 class="sect3">Modifying Real Attributes of a Subpartition</h3>
<p><a id="sthref577"></a>With the <a id="sthref578"></a><code>MODIFY</code> <code>SUBPARTITION</code> clause of <code>ALTER</code> <code>TABLE</code> you can perform the same actions as listed previously for partitions, but at the specific composite partitioned table subpartition level. For example:</p>
<pre>
ALTER TABLE emp MODIFY SUBPARTITION p3_s1
     REBUILD UNUSABLE LOCAL INDEXES;
</pre></div>
<!-- class="sect3" -->
<a id="i1007841"></a><a id="VLDBG1185"></a>
<div class="sect3">
<h3 class="sect3">Modifying Real Attributes of Index Partitions</h3>
<p><a id="sthref579"></a>The <code>MODIFY</code> <code>PARTITION</code> clause of <code>ALTER</code> <code>INDEX</code> lets you modify the real attributes of an index partition or its subpartitions. The rules are very similar to those for table partitions, but unlike the <code>MODIFY</code> <code>PARTITION</code> clause for <code>ALTER</code> <code>INDEX</code>, there is no subclause to rebuild an unusable index partition, but there is a subclause to coalesce an index partition or its subpartitions. In this context, coalesce means to merge index blocks where possible to free them for reuse.</p>
<p>You can also allocate or deallocate storage for a subpartition of a local index, or mark it <code>UNUSABLE</code>, using the <code>MODIFY</code> <code>PARTITION</code> clause.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007846"></a><a id="VLDBG1186"></a>
<div class="sect2">
<h2 class="sect2">Modifying List Partitions: Adding Values</h2>
<p><a id="sthref580"></a><a id="sthref581"></a>List partitioning enables you to optionally add literal values from the defining value list.</p>
<a id="VLDBG1187"></a>
<div class="sect3"><a id="sthref582"></a>
<h3 class="sect3">Adding Values for a List Partition</h3>
<p>Use the <code>MODIFY</code> <code>PARTITION</code> ... <code>ADD</code> <code>VALUES</code> clause of the <code>ALTER</code> <code>TABLE</code> statement to extend the value list of an existing partition. Literal values being added must not have been included in any other partition value list. The partition value list for any corresponding local index partition is correspondingly extended, and any global indexes, or global or local index partitions, remain usable.</p>
<p>The following statement adds a new set of state codes ('<code>OK</code>', '<code>KS</code>') to an existing partition list.</p>
<pre>
ALTER TABLE sales_by_region
   MODIFY PARTITION region_south
      ADD VALUES ('OK', 'KS');
</pre>
<p>The existence of a default partition can have a performance impact when adding values to other partitions. This is because to add values to a list partition, the database must check that the values being added do not exist in the default partition. If any of the values do exist in the default partition, then an error is displayed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The database runs a query to check for the existence of rows in the default partition that correspond to the literal values being added. Therefore, it is advisable to create a local prefixed index on the table. This speeds up the execution of the query and the overall operation.</div>
<p>You cannot add values to a default list partition.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1188"></a>
<div class="sect3"><a id="sthref583"></a>
<h3 class="sect3">Adding Values for a List Subpartition</h3>
<p>This operation is essentially the same as described for <a href="#i1007846">"Modifying List Partitions: Adding Values"</a>, however, you use a <code>MODIFY</code> <code>SUBPARTITION</code> clause instead of the <code>MODIFY</code> <code>PARTITION</code> clause. For example, to extend the range of literal values in the value list for subpartition <code>q1_1999_southeast</code>, use the following statement:</p>
<pre>
ALTER TABLE quarterly_regional_sales
   MODIFY SUBPARTITION q1_1999_southeast
      ADD VALUES ('KS');
</pre>
<p>Literal values being added must not have been included in any other subpartition value list within the owning partition. However, they can be duplicates of literal values in the subpartition value lists of other partitions within the table.</p>
<p>For an interval-list composite partitioned table, you can only add values to subpartitions of range partitions or interval partitions that have been created. To add values to subpartitions of interval partitions that have not yet been created, you must modify the subpartition template.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007874"></a><a id="VLDBG1189"></a>
<div class="sect2">
<h2 class="sect2">Modifying List Partitions: Dropping Values</h2>
<p><a id="sthref584"></a><a id="sthref585"></a>List partitioning enables you to optionally drop literal values from the defining value list.</p>
<a id="VLDBG1190"></a>
<div class="sect3"><a id="sthref586"></a>
<h3 class="sect3">Dropping Values from a List Partition</h3>
<p>Use the <code>MODIFY</code> <code>PARTITION</code> ... <code>DROP</code> <code>VALUES</code> clause of the <code>ALTER</code> <code>TABLE</code> statement to remove literal values from the value list of an existing partition. The statement is always executed with validation, meaning that it checks to see if any rows exist in the partition that corresponds to the set of values being dropped. If any such rows are found then the database returns an error message and the operation fails. When necessary, use a <code>DELETE</code> statement to delete corresponding rows from the table before attempting to drop values.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot drop all literal values from the value list describing the partition. You must use the <code>ALTER TABLE ... DROP PARTITION</code> statement instead.</div>
<p>The partition value list for any corresponding local index partition reflects the new value list, and any global index, or global or local index partitions, remain usable.</p>
<p>The following statement drops a set of state codes ('<code>OK</code>' and '<code>KS</code>') from an existing partition value list.</p>
<pre>
ALTER TABLE sales_by_region
   MODIFY PARTITION region_south
      DROP VALUES ('OK', 'KS');
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The database runs a query to check for the existence of rows in the partition that correspond to the literal values being dropped. Therefore, it is advisable to create a local prefixed index on the table. This speeds up the query and the overall operation.</div>
<p>You cannot drop values from a default list partition.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1191"></a>
<div class="sect3"><a id="sthref587"></a>
<h3 class="sect3">Dropping Values from a List Subpartition</h3>
<p>This operation is essentially the same as described for <a href="#i1007874">"Modifying List Partitions: Dropping Values"</a>, however, you use a <code>MODIFY</code> <code>SUBPARTITION</code> clause instead of the <code>MODIFY</code> <code>PARTITION</code> clause. For example, to remove a set of literal values in the value list for subpartition <code>q1_1999_southeast</code>, use the following statement:</p>
<pre>
ALTER TABLE quarterly_regional_sales
   MODIFY SUBPARTITION q1_1999_southeast
      DROP VALUES ('KS');
</pre>
<p>For an interval-list composite partitioned table, you can only drop values from subpartitions of range partitions or interval partitions that have been created. To drop values from subpartitions of interval partitions that have not yet been created, you must modify the subpartition template.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007904"></a><a id="VLDBG1192"></a>
<div class="sect2">
<h2 class="sect2">Modifying a Subpartition Template</h2>
<p><a id="sthref588"></a><a id="sthref589"></a>You can modify a subpartition template of a composite partitioned table by replacing it with a new subpartition template. Any subsequent operations that use the subpartition template (such as <code>ADD</code> <code>PARTITION</code> or <code>MERGE</code> <code>PARTITIONS</code>) now use the new subpartition template. Existing subpartitions remain unchanged.</p>
<p>If you modify a subpartition template of an interval-* composite partitioned table, then interval partitions that have not yet been created use the new subpartition template.</p>
<p>Use the <code>ALTER</code> <code>TABLE</code> ... <code>SET</code> <code>SUBPARTITION</code> <code>TEMPLATE</code> statement to specify a new subpartition template. For example:</p>
<pre>
ALTER TABLE emp_sub_template
   SET SUBPARTITION TEMPLATE
         (SUBPARTITION e TABLESPACE ts1,
          SUBPARTITION f TABLESPACE ts2,
          SUBPARTITION g TABLESPACE ts3,
          SUBPARTITION h TABLESPACE ts4
         );
</pre>
<p>You can drop a subpartition template by specifying an empty list:</p>
<pre>
ALTER TABLE emp_sub_template
   SET SUBPARTITION TEMPLATE ( );
</pre></div>
<!-- class="sect2" -->
<a id="i1007920"></a><a id="VLDBG1193"></a>
<div class="sect2">
<h2 class="sect2">Moving Partitions</h2>
<p><a id="sthref590"></a>Use the <a id="sthref591"></a><code>MOVE</code> <code>PARTITION</code> clause of the <code>ALTER</code> <code>TABLE</code> statement to:</p>
<ul>
<li>
<p>Re-cluster data and reduce fragmentation</p>
</li>
<li>
<p>Move a partition to another tablespace</p>
</li>
<li>
<p>Modify create-time attributes</p>
</li>
<li>
<p>Store the data in compressed format using table compression</p>
</li>
</ul>
<p>Typically, you can change the physical storage attributes of a partition in a single step using an <code>ALTER</code> <code>TABLE</code>/<code>INDEX</code> ... <code>MODIFY</code> <code>PARTITION</code> statement. However, there are some physical attributes, such as <code>TABLESPACE</code>, that you cannot modify using <a id="sthref592"></a><code>MODIFY</code> <code>PARTITION</code>. In these cases, use the <code>MOVE</code> <code>PARTITION</code> clause. Modifying some other attributes, such as table compression, affects only future storage, but not existing data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>ALTER</code> <code>TABLE</code>...<code>MOVE</code> does not permit DML on the partition while the command is running. To move a partition and leave it available for DML, see <a href="#BABCIHBA">"Redefining Partitions Online"</a>.</div>
<p>If the partition being moved contains any data, then indexes may be marked <code><a id="sthref593"></a>UNUSABLE</code> according to the following table:</p>
<div class="inftblruleinformal">
<table class="cellalignment1835" title="UNUSABLE Indexes and Index Partitions After Move Operations" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t32">Table Type</th>
<th class="cellalignment1836" id="r1c2-t32">Index Behavior</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t32" headers="r1c1-t32">Regular (Heap)</td>
<td class="cellalignment1837" headers="r2c1-t32 r1c2-t32">Unless you specify <code>UPDATE</code> <code>INDEXES</code> as part of the <code>ALTER</code> <code>TABLE</code> statement:
<ul>
<li>
<p>The matching partition in each local index is marked <code>UNUSABLE</code>. You must rebuild these index partitions after issuing <code>MOVE</code> <code>PARTITION</code>.</p>
</li>
<li>
<p>Any global indexes, or all partitions of partitioned global indexes, are marked <code>UNUSABLE</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t32" headers="r1c1-t32">Index-organized</td>
<td class="cellalignment1837" headers="r3c1-t32 r1c2-t32">Any local or global indexes defined for the partition being moved remain usable because they are primary-key based logical rowids. However, the guess information for these rowids becomes incorrect.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" -->
<a id="VLDBG1194"></a>
<div class="sect3"><a id="sthref594"></a>
<h3 class="sect3">Moving Table Partitions</h3>
<p>Use the <code>MOVE</code> <code>PARTITION</code> clause to move a partition. For example, to move the most active partition to a tablespace that resides on its own set of disks (to balance I/O), not log the action, and compress the data, issue the following statement:</p>
<pre>
ALTER TABLE parts MOVE PARTITION depot2
     TABLESPACE ts094 NOLOGGING COMPRESS;
</pre>
<p>This statement always drops the old partition segment and creates a new segment, even if you do not specify a new tablespace.</p>
<p>If you are moving a partition of a partitioned index-organized table, then you can specify the <code>MAPPING</code> <code>TABLE</code> clause as part of the <code>MOVE</code> <code>PARTITION</code> clause, and the mapping table partition are moved to the new location along with the table partition.</p>
<p>For an interval or interval-* partitioned table, you can only move range partitions or interval partitions that have been created. A partition move operation does not move the transition point in an interval or interval-* partitioned table.</p>
<p>You can move a partition in a reference-partitioned table independent of the partition in the master table.</p>
</div>
<!-- class="sect3" -->
<a id="i1007954"></a><a id="VLDBG1195"></a>
<div class="sect3">
<h3 class="sect3">Moving Subpartitions</h3>
<p><a id="sthref595"></a><a id="sthref596"></a>The following statement shows how to move data in a subpartition of a table. In this example, a <code>PARALLEL</code> clause has also been specified.</p>
<pre>
ALTER TABLE scuba_gear MOVE SUBPARTITION bcd_types 
     TABLESPACE tbs23 PARALLEL (DEGREE 2);
</pre>
<p>You can move a subpartition in a reference-partitioned table independent of the subpartition in the master table.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1196"></a>
<div class="sect3"><a id="sthref597"></a>
<h3 class="sect3">Moving Index Partitions</h3>
<p><a id="sthref598"></a>The <code>ALTER</code> <code>TABLE</code> ... <code>MOVE</code> <code>PARTITION</code> statement for regular tables, marks all partitions of a global index <code>UNUSABLE</code>. You can rebuild the entire index by rebuilding each partition individually using the <code>ALTER</code> <code>INDEX</code> ... <a id="sthref599"></a><code>REBUILD</code> <code>PARTITION</code> statement. You can perform these rebuilds concurrently.</p>
<p>You can also simply drop the index and re-create it.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABCIHBA"></a><a id="VLDBG00302"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Redefining Partitions Online</h2>
<p><a id="sthref600"></a>Oracle Database provides a mechanism to move a partition or to make other changes to the partition's physical structure without significantly affecting the availability of the partition for DML. This mechanism is called <span class="bold">online table redefinition</span>.</p>
<p>For information about redefining a single partition of a table, see <a class="olink ADMIN11675" href="../../server.112/e25494/tables.htm#ADMIN11675"><span class="italic">Oracle Database Administrator's Guide</span></a>.</p>
<a id="VLDBG1197"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref601"></a>
<h3 class="sect3">Redefining Partitions with Collection Tables</h3>
<p>You can use online redefinition to copy nonpartitioned Collection Tables to partitioned Collection Tables and Oracle Database inserts rows into the appropriate partitions in the Collection Table. <a href="#CHDHIDJJ">Example 4-32</a> illustrates how this is done for nested tables inside an Objects column; a similar example works for Ordered Collection Type Tables inside an <code>XMLType</code> table or column. Note that during the <code>copy_table_dependents</code> operation, you specify <code>0</code> or <code>false</code> for copying the indexes and constraints, because you want to keep the indexes and constraints of the newly defined collection table. However, it is important to note that the Collection Tables and its partitions have the same names as that of the interim table (<code>print_media2</code> in <a href="#CHDHIDJJ">Example 4-32</a>). You must take explicit steps to preserve the Collection Table names.</p>
<div class="example">
<p class="titleinexample"><a id="CHDHIDJJ"></a><a id="VLDBG14075"></a>Example 4-32 Redefining partitions with collection tables</p>
<pre>
CONNECT / AS SYSDBA
DROP USER eqnt CASCADE;
CREATE USER eqnt IDENTIFIED BY eqnt;
GRANT CONNECT, RESOURCE TO eqnt;
 
-- Grant privleges required for online redefinition.
GRANT EXECUTE ON DBMS_REDEFINITION TO eqnt;
GRANT ALTER ANY TABLE TO eqnt;
GRANT DROP ANY TABLE TO eqnt;
GRANT LOCK ANY TABLE TO eqnt;
GRANT CREATE ANY TABLE TO eqnt;
GRANT SELECT ANY TABLE TO eqnt;
 
-- Privileges required to perform cloning of dependent objects.
GRANT CREATE ANY TRIGGER TO eqnt;
GRANT CREATE ANY INDEX TO eqnt;
 
CONNECT eqnt/eqnt
 
CREATE TYPE textdoc_typ AS OBJECT ( document_typ VARCHAR2(32));
/
CREATE TYPE textdoc_tab AS TABLE OF textdoc_typ;
/

-- (old) non partitioned nested table
CREATE TABLE print_media
    ( product_id        NUMBER(6) primary key
    , ad_textdocs_ntab  textdoc_tab
    )
NESTED TABLE ad_textdocs_ntab STORE AS equi_nestedtab
(   (document_typ NOT NULL)
    STORAGE (INITIAL 8M)
)
PARTITION BY RANGE (product_id)
(
    PARTITION P1 VALUES LESS THAN (10),
    PARTITION P2 VALUES LESS THAN (20)
);
 
-- Insert into base table
INSERT INTO print_media VALUES (1,
   textdoc_tab(textdoc_typ('xx'), textdoc_typ('yy')));
INSERT INTO print_media VALUES (11,
   textdoc_tab(textdoc_typ('aa'), textdoc_typ('bb')));
COMMIT;
 
-- Insert into nested table
INSERT INTO TABLE
  (SELECT p.ad_textdocs_ntab FROM print_media p WHERE p.product_id = 11)
   VALUES ('cc');
 
SELECT * FROM print_media;

PRODUCT_ID   AD_TEXTDOCS_NTAB(DOCUMENT_TYP)
----------   ------------------------------
         1   TEXTDOC_TAB(TEXTDOC_TYP('xx'), TEXTDOC_TYP('yy'))
        11   TEXTDOC_TAB(TEXTDOC_TYP('aa'), TEXTDOC_TYP('bb'), TEXTDOC_TYP('cc'))
 
-- Creating partitioned Interim Table
CREATE TABLE print_media2
    ( product_id        NUMBER(6)
    , ad_textdocs_ntab  textdoc_tab
    )
NESTED TABLE ad_textdocs_ntab STORE AS equi_nestedtab2
(   (document_typ NOT NULL)
    STORAGE (INITIAL 8M)
)
PARTITION BY RANGE (product_id)
(
    PARTITION P1 VALUES LESS THAN (10),
    PARTITION P2 VALUES LESS THAN (20)
);
 
EXEC dbms_redefinition.start_redef_table('eqnt', 'print_media', 'print_media2');
 
DECLARE
 error_count pls_integer := 0;
BEGIN
  dbms_redefinition.copy_table_dependents('eqnt', 'print_media', 'print_media2',
                                          0, true, false, true, false,
                                          error_count);
 
  dbms_output.put_line('errors := ' || to_char(error_count));
END;
/
 
EXEC  dbms_redefinition.finish_redef_table('eqnt', 'print_media', 'print_media2');
 
-- Drop the interim table
DROP TABLE print_media2;
 
-- print_media has partitioned nested table here

SELECT * FROM print_media PARTITION (p1);

PRODUCT_ID   AD_TEXTDOCS_NTAB(DOCUMENT_TYP)
----------   ------------------------------
         1   TEXTDOC_TAB(TEXTDOC_TYP('xx'), TEXTDOC_TYP('yy'))

SELECT * FROM print_media PARTITION (p2);

PRODUCT_ID   AD_TEXTDOCS_NTAB(DOCUMENT_TYP)
----------   ------------------------------
        11   TEXTDOC_TAB(TEXTDOC_TYP('aa'), TEXTDOC_TYP('bb'), TEXTDOC_TYP('cc'))
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007965"></a><a id="VLDBG1198"></a>
<div class="sect2">
<h2 class="sect2">Rebuilding Index Partitions</h2>
<p><a id="sthref602"></a><a id="sthref603"></a>Some reasons for rebuilding index partitions include:</p>
<ul>
<li>
<p>To recover space and improve performance</p>
</li>
<li>
<p>To repair a damaged index partition caused by media failure</p>
</li>
<li>
<p>To rebuild a local index partition after loading the underlying table partition with SQL*Loader or an import utility</p>
</li>
<li>
<p>To rebuild index partitions that have been marked <code>UNUSABLE</code></p>
</li>
<li>
<p>To enable key compression for B-tree indexes</p>
</li>
</ul>
<p>The following sections discuss options for rebuilding index partitions and subpartitions.</p>
<a id="VLDBG1199"></a>
<div class="sect3"><a id="sthref604"></a>
<h3 class="sect3">Rebuilding Global Index Partitions</h3>
<p>You can rebuild global index partitions in two ways:</p>
<ul>
<li>
<p>Rebuild each partition by issuing the <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> <code>PARTITION</code> statement (you can run the rebuilds concurrently).</p>
</li>
<li>
<p>Drop the entire global index and re-create it. This method is more efficient because the table is scanned only one time.</p>
</li>
</ul>
<p>For most maintenance operations on partitioned tables with indexes, you can optionally avoid the need to rebuild the index by specifying <code>UPDATE</code> <code>INDEXES</code> on your DDL statement.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1200"></a>
<div class="sect3"><a id="sthref605"></a>
<h3 class="sect3">Rebuilding Local Index Partitions</h3>
<p>Rebuild local indexes using either <code>ALTER</code> <code>INDEX</code> or <code>ALTER</code> <code>TABLE</code> as follows:</p>
<ul>
<li>
<p><code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> <code>PARTITION</code>/<code>SUBPARTITION</code></p>
<p>This statement rebuilds an index partition or subpartition unconditionally.</p>
</li>
<li>
<p><code>ALTER</code> <code>TABLE</code> ... <code>MODIFY</code> <code>PARTITION</code>/<code>SUBPARTITION</code> ... <code>REBUILD</code> <code>UNUSABLE</code> <code>LOCAL</code> <code>INDEXES</code></p>
<p>This statement finds all of the unusable indexes for the given table partition or subpartition and rebuilds them. It only rebuilds an index partition if it has been marked <code>UNUSABLE</code>.</p>
</li>
</ul>
<a id="VLDBG1201"></a>
<div class="sect4"><a id="sthref606"></a>
<h4 class="sect4">Using ALTER INDEX to Rebuild a Partition</h4>
<p>The <code>ALTER</code> <code>INDEX</code> ... <a id="sthref607"></a><code>REBUILD</code> <code>PARTITION</code> statement rebuilds one partition of an index. It cannot be used for composite-partitioned tables. Only real physical segments can be rebuilt with this command. When you re-create the index, you can also choose to move the partition to a new tablespace or change attributes.</p>
<p>For composite-partitioned tables, use <code>ALTER</code> <code>INDEX</code> ... <a id="sthref608"></a><code>REBUILD</code> <code>SUBPARTITION</code> to rebuild a subpartition of an index. You can move the subpartition to another tablespace or specify a parallel clause. The following statement rebuilds a subpartition of a local index on a table and moves the index subpartition to another tablespace.</p>
<pre>
ALTER INDEX scuba
   REBUILD SUBPARTITION bcd_types
   TABLESPACE tbs23 PARALLEL (DEGREE 2);
</pre></div>
<!-- class="sect4" -->
<a id="VLDBG1202"></a>
<div class="sect4"><a id="sthref609"></a>
<h4 class="sect4">Using ALTER TABLE to Rebuild an Index Partition</h4>
<p>The <a id="sthref610"></a><code>REBUILD</code> <code>UNUSABLE</code> <code>LOCAL</code> <code>INDEXES</code> clause of <code>ALTER</code> <code>TABLE</code> ... <a id="sthref611"></a><code>MODIFY</code> <code>PARTITION</code> does not allow you to specify any new attributes for the rebuilt index partition. The following example finds and rebuilds any unusable local index partitions for table <code>scubagear</code>, partition <code>p1</code>.</p>
<pre>
ALTER TABLE scubagear
   MODIFY PARTITION p1 REBUILD UNUSABLE LOCAL INDEXES;
</pre>
<p>There is a corresponding <code>ALTER</code> <code>TABLE</code> ... <code>MODIFY</code> <code>SUBPARTITION</code> clause for rebuilding unusable local index subpartitions.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008006"></a><a id="VLDBG1203"></a>
<div class="sect2">
<h2 class="sect2">Renaming Partitions</h2>
<p><a id="sthref612"></a>It is possible to rename partitions and subpartitions of both tables and indexes. One reason for renaming a partition might be to assign a meaningful name, as opposed to a default system name that was assigned to the partition in another maintenance operation.</p>
<p>All partitioning methods support the <code>FOR(</code><code><span class="codeinlineitalic">value</span></code><code>)</code> method to identify a partition. You can use this method to rename a system-generated partition name into a more meaningful name. This is particularly useful in interval or interval-* partitioned tables.</p>
<p>You can independently rename partitions and subpartitions for reference-partitioned master and child tables. The rename operation on the master table is not cascaded to descendant tables.</p>
<a id="VLDBG1204"></a>
<div class="sect3"><a id="sthref613"></a>
<h3 class="sect3">Renaming a Table Partition</h3>
<p>Rename a range, hash, or list partition, using the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref614"></a><code>RENAME</code> <code>PARTITION</code> statement. For example:</p>
<pre>
ALTER TABLE scubagear RENAME PARTITION sys_p636 TO tanks;
</pre></div>
<!-- class="sect3" -->
<a id="i1008014"></a><a id="VLDBG1205"></a>
<div class="sect3">
<h3 class="sect3">Renaming a Table Subpartition</h3>
<p><a id="sthref615"></a>Likewise, you can assign new names to subpartitions of a table. In this case you would use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref616"></a><code>RENAME</code> <code>SUBPARTITION</code> syntax.</p>
</div>
<!-- class="sect3" -->
<a id="i1008019"></a><a id="VLDBG1206"></a>
<div class="sect3">
<h3 class="sect3">Renaming Index Partitions</h3>
<p><a id="sthref617"></a>Index partitions and subpartitions can be renamed in similar fashion, but the <code>ALTER INDEX</code> syntax is used.</p>
<a id="VLDBG1207"></a>
<div class="sect4"><a id="sthref618"></a>
<h4 class="sect4">Renaming an Index Partition</h4>
<p>Use the <code>ALTER</code> <code>INDEX</code> ... <a id="sthref619"></a><code>RENAME</code> <code>PARTITION</code> statement to rename an index partition.</p>
<p>The <code>ALTER INDEX</code> statement does not support the use of <code>FOR(</code><code><span class="codeinlineitalic">value</span></code><code>)</code> to identify a partition. You must use the original partition name in the rename operation.</p>
</div>
<!-- class="sect4" -->
<a id="VLDBG1208"></a>
<div class="sect4"><a id="sthref620"></a>
<h4 class="sect4">Renaming an Index Subpartition</h4>
<p>The following statement simply shows how to rename a subpartition that has a system generated name that was a consequence of adding a partition to an underlying table:</p>
<pre>
ALTER INDEX scuba RENAME SUBPARTITION sys_subp3254 TO bcd_types;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008028"></a><a id="VLDBG00303"></a>
<div class="sect2">
<h2 class="sect2">Splitting Partitions</h2>
<p><a id="sthref621"></a>The <a id="sthref622"></a><code>SPLIT</code> <code>PARTITION</code> clause of the <code>ALTER</code> <code>TABLE</code> or <code>ALTER</code> <code>INDEX</code> statement is used to redistribute the contents of a partition into two new partitions. Consider doing this when a partition becomes too large and causes backup, recovery, or maintenance operations to take a long time to complete or it is felt that there is simply too much data in the partition. You can also use the <code>SPLIT</code> <code>PARTITION</code> clause to redistribute the I/O load. This clause cannot be used for hash partitions or subpartitions.</p>
<p>If the partition you are splitting contains any data, then indexes may be marked <a id="sthref623"></a><code>UNUSABLE</code> as explained in the following table:</p>
<div class="inftblruleinformal">
<table class="cellalignment1835" title="UNUSABLE Indexes and Index Partitions After Split Operations" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t33">Table Type</th>
<th class="cellalignment1836" id="r1c2-t33">Index Behavior</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t33" headers="r1c1-t33">Regular (Heap)</td>
<td class="cellalignment1837" headers="r2c1-t33 r1c2-t33">Unless you specify <code>UPDATE</code> <code>INDEXES</code> as part of the <code>ALTER</code> <code>TABLE</code> statement:
<ul>
<li>
<p>The database marks <code>UNUSABLE</code> the new partitions (there are two) in each local index.</p>
</li>
<li>
<p>Any global indexes, or all partitions of partitioned global indexes, are marked <code>UNUSABLE</code> and must be rebuilt.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t33" headers="r1c1-t33">Index-organized</td>
<td class="cellalignment1837" headers="r3c1-t33 r1c2-t33">
<ul>
<li>The database marks <code>UNUSABLE</code> the new partitions (there are two) in each local index.</li>
<li>
<p>All global indexes remain usable.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" -->
<p>You cannot split partitions or subpartitions in a reference-partitioned table. When you split partitions or subpartitions in the parent table then the split is cascaded to all descendant tables. However, you can use the <code>DEPENDENT TABLES</code> clause to set specific properties for dependent tables when you issue the <code>SPLIT</code> statement on the master table to split partitions or subpartitions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
<a id="i1008052"></a><a id="VLDBG1209"></a>
<div class="sect3">
<h3 class="sect3">Splitting a Partition of a Range-Partitioned Table</h3>
<p><a id="sthref624"></a>You split a range partition using the <code>ALTER</code> <code>TABLE</code> ... <code>SPLIT</code> <code>PARTITION</code> statement. You specify a value of the partitioning key column within the range of the partition at which to split the partition. The first of the resulting two new partitions includes all rows in the original partition whose partitioning key column values map lower than the specified value. The second partition contains all rows whose partitioning key column values map greater than or equal to the specified value.</p>
<p>You can optionally specify new attributes for the two partitions resulting from the split. If there are local indexes defined on the table, this statement also splits the matching partition in each local index.</p>
<p>In the following example <code>fee_katy</code> is a partition in the table <code>vet_cats</code>, which has a local index, <code>jaf1</code>. There is also a global index, <code>vet</code> on the table. <code>vet</code> contains two partitions, <code>vet_parta</code>, and <code>vet_partb</code>.</p>
<p>To split the partition <code>fee_katy</code>, and rebuild the index partitions, issue the following statements:</p>
<pre>
ALTER TABLE vet_cats SPLIT PARTITION 
      fee_katy at (100) INTO ( PARTITION
      fee_katy1, PARTITION fee_katy2);
ALTER INDEX JAF1 REBUILD PARTITION fee_katy1;
ALTER INDEX JAF1 REBUILD PARTITION fee_katy2;
ALTER INDEX VET REBUILD PARTITION vet_parta;
ALTER INDEX VET REBUILD PARTITION vet_partb;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you do not specify new partition names, then the database assigns names of the form <code>SYS_P</code><code><span class="codeinlineitalic">n</span></code>. You can examine the data dictionary to locate the names assigned to the new local index partitions. You may want to rename them. Any attributes that you do not specify are inherited from the original partition.</div>
</div>
<!-- class="sect3" -->
<a id="i1008070"></a><a id="VLDBG1210"></a>
<div class="sect3">
<h3 class="sect3">Splitting a Partition of a List-Partitioned Table</h3>
<p><a id="sthref625"></a>You split a list partition by using the <code>ALTER</code> <code>TABLE</code> ... <code>SPLIT</code> <code>PARTITION</code> statement. The <code>SPLIT</code> <code>PARTITION</code> clause enables you to specify a list of literal values that define a partition into which rows with corresponding partitioning key values are inserted. The remaining rows of the original partition are inserted into a second partition whose value list contains the remaining values from the original partition. You can optionally specify new attributes for the two partitions that result from the split.</p>
<p>The following statement splits the partition <code>region_east</code> into two partitions:</p>
<pre>
ALTER TABLE sales_by_region 
   SPLIT PARTITION region_east VALUES ('CT', 'MA', 'MD') 
   INTO 
    ( PARTITION region_east_1 
         TABLESPACE tbs2,
      PARTITION region_east_2
        STORAGE (INITIAL 8M)) 
   PARALLEL 5;
</pre>
<p>The literal value list for the original <code>region_east</code> partition was specified as:</p>
<pre>
PARTITION region_east VALUES ('MA','NY','CT','NH','ME','MD','VA','PA','NJ')
</pre>
<p>The two new partitions are:</p>
<ul>
<li>
<p><code>region_east_1</code> with a literal value list of <code>('CT','MA','MD')</code></p>
</li>
<li>
<p><code>region_east_2</code> inheriting the remaining literal value list of <code>('NY','NH','ME','VA','PA','NJ')</code></p>
</li>
</ul>
<p>The individual partitions have new physical attributes specified at the partition level. The operation is executed with parallelism of degree 5.</p>
<p>You can split a default list partition just like you split any other list partition. This is also the only means of adding a partition to a list-partitioned table that contains a default partition. When you split the default partition, you create a new partition defined by the values that you specify, and a second partition that remains the default partition.</p>
<p>The following example splits the default partition of <code>sales_by_region</code>, thereby creating a new partition:</p>
<pre>
ALTER TABLE sales_by_region 
   SPLIT PARTITION region_unknown VALUES ('MT', 'WY', 'ID') 
   INTO 
    ( PARTITION region_wildwest,
      PARTITION region_unknown);
</pre></div>
<!-- class="sect3" -->
<a id="BAJDDEDD"></a><a id="VLDBG1211"></a>
<div class="sect3">
<h3 class="sect3">Splitting a Partition of an Interval-Partitioned Table</h3>
<p><a id="sthref626"></a>You split a range or a materialized interval partition using the <code>ALTER TABLE ... SPLIT PARTITION</code> statement in an interval-partitioned table. Splitting a range partition in the interval-partitioned table is described in <a href="#i1008052">"Splitting a Partition of a Range-Partitioned Table"</a>.</p>
<p>To split a materialized interval partition, you specify a value of the partitioning key column within the interval partition at which to split the partition. The first of the resulting two new partitions includes all rows in the original partition whose partitioning key column values map lower than the specified value. The second partition contains all rows whose partitioning key column values map greater than or equal to the specified value. The split partition operation moves the transition point up to the higher boundary of the partition you just split, and all materialized interval partitions lower than the newly split partitions are implicitly converted into range partitions, with their upper boundaries defined by the upper boundaries of the intervals.</p>
<p>You can optionally specify new attributes for the two range partitions resulting from the split. If there are local indexes defined on the table, then this statement also splits the matching partition in each local index. You cannot split interval partitions that have not yet been created.</p>
<p>The following example shows splitting the May 2007 partition in the monthly interval partitioned table <code>transactions</code>.</p>
<pre>
ALTER TABLE transactions
    SPLIT PARTITION FOR(TO_DATE('01-MAY-2007','dd-MON-yyyy'))
    AT (TO_DATE('15-MAY-2007','dd-MON-yyyy'));
</pre></div>
<!-- class="sect3" -->
<a id="i1008098"></a><a id="VLDBG1212"></a>
<div class="sect3">
<h3 class="sect3">Splitting a *-Hash Partition</h3>
<p><a id="sthref627"></a>This is the opposite of merging *-hash partitions. When you split *-hash partitions, the new subpartitions are rehashed into either the number of subpartitions specified in a <code>SUBPARTITIONS</code> or <a id="sthref628"></a><a id="sthref629"></a><code>SUBPARTITION</code> clause. Or, if no such clause is included, the new partitions inherit the number of subpartitions (and tablespaces) from the partition being split.</p>
<p>Note that the inheritance of properties is different when a *-hash partition is split, versus when two *-hash partitions are merged. When a partition is split, the new partitions can inherit properties from the original partition because there is only one parent. However, when partitions are merged, properties must be inherited from <span class="italic">table level</span> defaults because there are two parents and the new partition cannot inherit from either at the expense of the other.</p>
<p>The following example splits a range-hash partition:</p>
<pre>
ALTER TABLE all_seasons SPLIT PARTITION quarter_1 
     AT (TO_DATE('16-dec-1997','dd-mon-yyyy'))
     INTO (PARTITION q1_1997_1 SUBPARTITIONS 4 STORE IN (ts1,ts3),
           PARTITION q1_1997&shy;_2);
</pre>
<p>The rules for splitting an interval-hash partitioned table follow the rules for splitting an interval-partitioned table. As described in <a href="#BAJDDEDD">"Splitting a Partition of an Interval-Partitioned Table"</a>, the transition point is changed to the higher boundary of the split partition.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1213"></a>
<div class="sect3"><a id="sthref630"></a>
<h3 class="sect3">Splitting Partitions in a *-List Partitioned Table</h3>
<p><a id="sthref631"></a>Partitions can be split at both the partition level and at the list subpartition level.</p>
<a id="VLDBG1214"></a>
<div class="sect4"><a id="sthref632"></a>
<h4 class="sect4">Splitting a *-List Partition</h4>
<p>Splitting a partition of a *-list partitioned table is similar to the description in <a href="#i1008052">"Splitting a Partition of a Range-Partitioned Table"</a>. No subpartition literal value list can be specified for either of the new partitions. The new partitions inherit the subpartition descriptions from the original partition being split.</p>
<p>The following example splits the <code>q1_1999</code> partition of the <code>quarterly_regional_sales</code> table:</p>
<pre>
ALTER TABLE quarterly_regional_sales SPLIT PARTITION q1_1999
   AT (TO_DATE('15-Feb-1999','dd-mon-yyyy'))
   INTO ( PARTITION q1_1999_jan_feb
             TABLESPACE ts1,
          PARTITION q1_1999_feb_mar
             STORAGE (INITIAL 8M) TABLESPACE ts2) 
   PARALLEL 5;
</pre>
<p>This operation splits the partition <code>q1_1999</code> into two resulting partitions: <code>q1_1999_jan_feb</code> and <code>q1_1999_feb_mar</code>. Both partitions inherit their subpartition descriptions from the original partition. The individual partitions have new physical attributes, including tablespaces, specified at the partition level. These new attributes become the default attributes of the new partitions. This operation is run with parallelism of degree 5.</p>
<p>The <code>ALTER</code> <code>TABLE</code> ... <code>SPLIT</code> <code>PARTITION</code> statement provides no means of specifically naming subpartitions resulting from the split of a partition in a composite partitioned table. However, for those subpartitions in the parent partition with names of the form <code><span class="codeinlineitalic">partition name_subpartition name</span></code>, the database generates corresponding names in the newly created subpartitions using the new partition names. All other subpartitions are assigned system generated names of the form <code>SYS_SUBP</code><code><span class="codeinlineitalic">n</span></code>. System generated names are also assigned for the subpartitions of any partition resulting from the split for which a name is not specified. Unnamed partitions are assigned a system generated partition name of the form <code>SYS_P</code><code><span class="codeinlineitalic">n</span></code>.</p>
<p>The following query displays the subpartition names resulting from the previous split partition operation on table <code>quarterly_regional_sales</code>. It also reflects the results of other operations performed on this table in preceding sections of this chapter since its creation in <a href="part_admin001.htm#i1006602">"Creating Composite Range-List Partitioned Tables"</a>.</p>
<pre>
SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLESPACE_NAME
  FROM DBA_TAB_SUBPARTITIONS
  WHERE TABLE_NAME='QUARTERLY_REGIONAL_SALES'
  ORDER BY PARTITION_NAME;

PARTITION_NAME       SUBPARTITION_NAME              TABLESPACE_NAME
-------------------- ------------------------------ ---------------
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_WEST           TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_NORTHEAST      TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_SOUTHEAST      TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_NORTHCENTRAL   TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_SOUTHCENTRAL   TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_SOUTH          TS2
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_WEST           TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_NORTHEAST      TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_SOUTHEAST      TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_NORTHCENTRAL   TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_SOUTHCENTRAL   TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_SOUTH          TS1
Q1_2000              Q1_2000_NORTHWEST              TS3
Q1_2000              Q1_2000_SOUTHWEST              TS3
Q1_2000              Q1_2000_NORTHEAST              TS3
Q1_2000              Q1_2000_SOUTHEAST              TS3
Q1_2000              Q1_2000_NORTHCENTRAL           TS3
Q1_2000              Q1_2000_SOUTHCENTRAL           TS3
Q2_1999              Q2_1999_NORTHWEST              TS4
Q2_1999              Q2_1999_SOUTHWEST              TS4
Q2_1999              Q2_1999_NORTHEAST              TS4
Q2_1999              Q2_1999_SOUTHEAST              TS4
Q2_1999              Q2_1999_NORTHCENTRAL           TS4
Q2_1999              Q2_1999_SOUTHCENTRAL           TS4
Q3_1999              Q3_1999_NORTHWEST              TS4
Q3_1999              Q3_1999_SOUTHWEST              TS4
Q3_1999              Q3_1999_NORTHEAST              TS4
Q3_1999              Q3_1999_SOUTHEAST              TS4
Q3_1999              Q3_1999_NORTHCENTRAL           TS4
Q3_1999              Q3_1999_SOUTHCENTRAL           TS4
Q4_1999              Q4_1999_NORTHWEST              TS4
Q4_1999              Q4_1999_SOUTHWEST              TS4
Q4_1999              Q4_1999_NORTHEAST              TS4
Q4_1999              Q4_1999_SOUTHEAST              TS4
Q4_1999              Q4_1999_NORTHCENTRAL           TS4
Q4_1999              Q4_1999_SOUTHCENTRAL           TS4

36 rows selected.
</pre></div>
<!-- class="sect4" -->
<a id="VLDBG1215"></a>
<div class="sect4"><a id="sthref633"></a>
<h4 class="sect4">Splitting a *-List Subpartition</h4>
<p>Splitting a list subpartition of a *-list partitioned table is similar to the description in <a href="#i1008070">"Splitting a Partition of a List-Partitioned Table"</a>, but the syntax is that of <code>SUBPARTITION</code> rather than <code>PARTITION</code>. For example, the following statement splits a subpartition of the <code>quarterly_regional_sales</code> table:</p>
<pre>
ALTER TABLE quarterly_regional_sales SPLIT SUBPARTITION q2_1999_southwest
   VALUES ('UT') INTO
      ( SUBPARTITION q2_1999_utah
           TABLESPACE ts2,
        SUBPARTITION q2_1999_southwest
           TABLESPACE ts3
      ) 
   PARALLEL;
</pre>
<p>This operation splits the subpartition <code>q2_1999_southwest</code> into two subpartitions:</p>
<ul>
<li>
<p><code>q2_1999_utah</code> with literal value list of <code>('UT')</code></p>
</li>
<li>
<p><code>q2_1999_southwest</code> which inherits the remaining literal value list of <code>('AZ','NM')</code></p>
</li>
</ul>
<p>The individual subpartitions have new physical attributes that are inherited from the subpartition being split.</p>
<p>You can only split subpartitions in an interval-list partitioned table for range partitions or materialized interval partitions. To change subpartition values for future interval partitions, you must modify the subpartition template.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="VLDBG1216"></a>
<div class="sect3"><a id="sthref634"></a>
<h3 class="sect3">Splitting a *-Range Partition</h3>
<p><a id="sthref635"></a>Splitting a partition of a *-range partitioned table is similar to the description in <a href="#i1008052">"Splitting a Partition of a Range-Partitioned Table"</a>. No subpartition range values can be specified for either of the new partitions. The new partitions inherit the subpartition descriptions from the original partition being split.</p>
<p>The following example splits the May 2007 interval partition of the interval-range partitioned <code>orders</code> table:</p>
<pre>
ALTER TABLE orders
    SPLIT PARTITION FOR(TO_DATE('01-MAY-2007','dd-MON-yyyy'))
    AT (TO_DATE('15-MAY-2007','dd-MON-yyyy'))
    INTO (PARTITION p_fh_may07,PARTITION p_sh_may2007);
</pre>
<p>This operation splits the interval partition <code>FOR('01-MAY-2007')</code> into two resulting partitions: <code>p_fh_may07</code> and <code>p_sh_may_2007</code>. Both partitions inherit their subpartition descriptions from the original partition. Any interval partitions before the June 2007 partition have been converted into range partitions, as described in <a href="#BAJCIFBH">"Merging Interval Partitions"</a>.</p>
<p>The <code>ALTER TABLE ... SPLIT PARTITION</code> statement provides no means of specifically naming subpartitions resulting from the split of a partition in a composite partitioned table. However, for those subpartitions in the parent partition with names of the form <code><span class="codeinlineitalic">partition name</span></code><code>_</code><code><span class="codeinlineitalic">subpartition name</span></code>, the database generates corresponding names in the newly created subpartitions using the new partition names. All other subpartitions are assigned system generated names of the form <code>SYS_SUBP</code><code><span class="codeinlineitalic">n</span></code>. System generated names are also assigned for the subpartitions of any partition resulting from the split for which a name is not specified. Unnamed partitions are assigned a system generated partition name of the form <code>SYS_P</code><code><span class="codeinlineitalic">n</span></code>.</p>
<p>The following query displays the subpartition names and high values resulting from the previous split partition operation on table <code>orders</code>. It also reflects the results of other operations performed on this table in preceding sections of this chapter since its creation.</p>
<pre>
BREAK ON partition_name

SELECT partition_name, subpartition_name, high_value
FROM user_tab_subpartitions
WHERE table_name = 'ORCERS'
ORDER BY partition_name, subpartition_position;

PARTITION_NAME            SUBPARTITION_NAME              HIGH_VALUE
------------------------- ------------------------------ ---------------
P_BEFORE_2007             P_BEFORE_2007_P_SMALL          1000
                          P_BEFORE_2007_P_MEDIUM         10000
                          P_BEFORE_2007_P_LARGE          100000
                          P_BEFORE_2007_P_EXTRAORDINARY  MAXVALUE
P_FH_MAY07                SYS_SUBP2985                   1000
                          SYS_SUBP2986                   10000
                          SYS_SUBP2987                   100000
                          SYS_SUBP2988                   MAXVALUE
P_PRE_MAY_2007            P_PRE_MAY_2007_P_SMALL         1000
                          P_PRE_MAY_2007_P_MEDIUM        10000
                          P_PRE_MAY_2007_P_LARGE         100000
                          P_PRE_MAY_2007_P_EXTRAORDINARY MAXVALUE
P_SH_MAY2007              SYS_SUBP2989                   1000
                          SYS_SUBP2990                   10000
                          SYS_SUBP2991                   100000
                          SYS_SUBP2992                   MAXVALUE
</pre>
<a id="VLDBG1217"></a>
<div class="sect4"><a id="sthref636"></a>
<h4 class="sect4">Splitting a *-Range Subpartition</h4>
<p>Splitting a range subpartition of a *-range partitioned table is similar to the description in <a href="#i1008052">"Splitting a Partition of a Range-Partitioned Table"</a>, but the syntax is that of <code>SUBPARTITION</code> rather than <code>PARTITION</code>. For example, the following statement splits a subpartition of the <code>orders</code> table:</p>
<pre>
ALTER TABLE orders
SPLIT SUBPARTITION p_pre_may_2007_p_large AT (50000)
INTO (SUBPARTITION p_pre_may_2007_med_large TABLESPACE TS4
     , SUBPARTITION p_pre_may_2007_large_large TABLESPACE TS5
     );
</pre>
<p>This operation splits the subpartition <code>p_pre_may_2007_p_large</code> into two subpartitions:</p>
<ul>
<li>
<p><code>p_pre_may_2007_med_large</code> with values between 10000 and 50000</p>
</li>
<li>
<p><code>p_pre_may_2007_large_large</code> with values between 50000 and 100000</p>
</li>
</ul>
<p>The individual subpartitions have new physical attributes that are inherited from the subpartition being split.</p>
<p>You can only split subpartitions in an interval-range partitioned table for range partitions or materialized interval partitions. To change subpartition boundaries for future interval partitions, you must modify the subpartition template.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1008201"></a><a id="VLDBG1218"></a>
<div class="sect3">
<h3 class="sect3">Splitting Index Partitions</h3>
<p><a id="sthref637"></a>You cannot explicitly split a partition in a local index. A local index partition is split only when you split a partition in the underlying table. However, you can split a global index partition as is done in the following example:</p>
<pre>
ALTER INDEX quon1 SPLIT 
    PARTITION canada AT ( 100 ) INTO 
    PARTITION canada1 ..., PARTITION canada2 ...);
ALTER INDEX quon1 REBUILD PARTITION canada1;
ALTER INDEX quon1 REBUILD PARTITION canada2;
</pre>
<p>The index being split can contain index data, and the resulting partitions do not require rebuilding, unless the original partition was previously marked <code>UNUSABLE</code>.</p>
</div>
<!-- class="sect3" -->
<a id="i1108213"></a><a id="VLDBG00304"></a>
<div class="sect3">
<h3 class="sect3">Optimizing SPLIT PARTITION and SPLIT SUBPARTITION Operations</h3>
<p><a id="sthref638"></a><a id="sthref639"></a>Oracle Database implements a <code>SPLIT</code> <code>PARTITION</code> operation by creating two new partitions and redistributing the rows from the partition being split into the two new partitions. This is a time-consuming operation because it is necessary to scan all the rows of the partition being split and then insert them one-by-one into the new partitions. Further if you do not use the <code>UPDATE</code> <code>INDEXES</code> clause, then both local and global indexes also require rebuilding.</p>
<p>Sometimes after a split operation, one new partition contains all of the rows from the partition being split, while the other partition contains no rows. This is often the case when splitting the first partition of a table. The database can detect such situations and can optimize the split operation. This optimization results in a fast split operation that behaves like an add partition operation.</p>
<p>Specifically, the database can optimize and speed up <code>SPLIT</code> <code>PARTITION</code> operations if all of the following conditions are met:</p>
<ul>
<li>
<p>One of the two resulting partitions must be empty.</p>
</li>
<li>
<p>The non-empty resulting partition must have storage characteristics identical to those of the partition being split. Specifically:</p>
<ul>
<li>
<p>If the partition being split is composite, then the storage characteristics of each subpartition in the new non-empty resulting partition must be identical to those of the subpartitions of the partition being split.</p>
</li>
<li>
<p>If the partition being split contains a <code>LOB</code> column, then the storage characteristics of each <code>LOB</code> (sub)partition in the new non-empty resulting partition must be identical to those of the <code>LOB</code> (sub)partitions of the partition being split.</p>
</li>
<li>
<p>If a partition of an index-organized table with overflow is being split, then the storage characteristics of each overflow (sub)partition in the new nonempty resulting partition must be identical to those of the overflow (sub)partitions of the partition being split.</p>
</li>
<li>
<p>If a partition of an index-organized table with mapping table is being split, then the storage characteristics of each mapping table (sub)partition in the new nonempty resulting partition must be identical to those of the mapping table (sub)partitions of the partition being split.</p>
</li>
</ul>
</li>
</ul>
<p>If these conditions are met after the split, then all global indexes remain usable, even if you did not specify the <code>UPDATE</code> <code>INDEXES</code> clause. Local index (sub)partitions associated with both resulting partitions remain usable if they were usable before the split. Local index (sub)partitions corresponding to the non-empty resulting partition are identical to the local index (sub)partitions of the partition that was split. The same optimization holds for <code>SPLIT</code> <code>SUBPARTITION</code> operations.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008226"></a><a id="VLDBG1219"></a>
<div class="sect2">
<h2 class="sect2">Truncating Partitions</h2>
<p><a id="sthref640"></a>Use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref641"></a><code>TRUNCATE</code> <code>PARTITION</code> statement to remove all rows from a table partition. Truncating a partition is similar to dropping a partition, except that the partition is emptied of its data, but not physically dropped.</p>
<p>You cannot truncate an index partition. However, if local indexes are defined for the table, the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref642"></a><code>TRUNCATE</code> <code>PARTITION</code> statement truncates the matching partition in each local index. Unless you specify <code>UPDATE</code> <code>INDEXES</code>, any global indexes are marked <a id="sthref643"></a><code>UNUSABLE</code> and must be rebuilt. (You cannot use <code>UPDATE</code> <code>INDEXES</code> for index-organized tables. Use <code>UPDATE</code> <code>GLOBAL</code> <code>INDEXES</code> instead.)</p>
<a id="VLDBG1220"></a>
<div class="sect3"><a id="sthref644"></a>
<h3 class="sect3">Truncating a Table Partition</h3>
<p>Use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref645"></a><code>TRUNCATE</code> <code>PARTITION</code> statement to remove all rows from a table partition, with or without reclaiming space. Truncating a partition in an interval-partitioned table does not move the transition point. You can truncate partitions and subpartitions in a reference-partitioned table.</p>
<a id="VLDBG1221"></a>
<div class="sect4"><a id="sthref646"></a>
<h4 class="sect4">Truncating Table Partitions Containing Data and Global Indexes</h4>
<p>If the partition contains data and global indexes, use one of the following methods to truncate the table partition.</p>
<p class="subhead2"><a id="VLDBG1222"></a>Method 1</p>
<p>Leave the global indexes in place during the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref647"></a><code>TRUNCATE</code> <code>PARTITION</code> statement. In this example, table <code>sales</code> has a global index <code>sales_area_ix</code>, which is rebuilt.</p>
<pre>
ALTER TABLE sales TRUNCATE PARTITION dec98;
ALTER INDEX sales_area_ix REBUILD;
</pre>
<p>This method is most appropriate for large tables where the partition being truncated contains a significant percentage of the total data in the table.</p>
<p class="subhead2"><a id="VLDBG1223"></a>Method 2</p>
<p>Run the <code>DELETE</code> statement to delete all rows from the partition before you issue the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref648"></a><code>TRUNCATE</code> <code>PARTITION</code> statement. The <code>DELETE</code> statement updates the global indexes, and also fires triggers and generates redo and undo logs.</p>
<p>For example, to truncate the first partition, run the following statements:</p>
<pre>
DELETE FROM sales PARTITION (dec98);
ALTER TABLE sales TRUNCATE PARTITION dec98;
</pre>
<p>This method is most appropriate for small tables, or for large tables when the partition being truncated contains a small percentage of the total data in the table.</p>
<p class="subhead2"><a id="VLDBG1224"></a>Method 3</p>
<p>Specify <code>UPDATE</code> <code>INDEXES</code> in the <code>ALTER TABLE</code> statement. This causes the global index to be truncated at the time the partition is truncated.</p>
<pre>
ALTER TABLE sales TRUNCATE PARTITION dec98
     UPDATE INDEXES;
</pre></div>
<!-- class="sect4" -->
<a id="VLDBG1225"></a>
<div class="sect4"><a id="sthref649"></a>
<h4 class="sect4">Truncating a Partition Containing Data and Referential Integrity Constraints</h4>
<p>If a partition contains data and has referential integrity constraints, then you cannot truncate the partition. If no other data is referencing any data in the partition to remove, then choose either of the following methods to truncate the table partition.</p>
<p class="subhead2"><a id="VLDBG1226"></a>Method 1</p>
<p>Disable the integrity constraints, run the <code>ALTER</code> <code>TABLE</code> ... <code>TRUNCATE</code> <code>PARTITION</code> statement, then re-enable the integrity constraints. This method is most appropriate for large tables where the partition being truncated contains a significant percentage of the total data in the table. If there is still referencing data in other tables, then you must remove that data to be able to re-enable the integrity constraints.</p>
<p class="subhead2"><a id="VLDBG1227"></a>Method 2</p>
<p>Issue the <code>DELETE</code> statement to delete all rows from the partition before you issue the <code>ALTER</code> <code>TABLE</code> ... <code>TRUNCATE</code> <code>PARTITION</code> statement. The <code>DELETE</code> statement enforces referential integrity constraints, and also fires triggers and generates redo and undo logs. Data in referencing tables is deleted if the foreign key constraints were created with the <code>ON DELETE CASCADE</code> option.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can substantially reduce the amount of logging by setting the <code>NOLOGGING</code> attribute (using <code>ALTER</code> <code>TABLE</code> ... <code>MODIFY</code> <code>PARTITION</code> ... <code>NOLOGGING</code>) for the partition before deleting all of its rows.</div>
<pre>
DELETE FROM sales partition (dec94);
ALTER TABLE sales TRUNCATE PARTITION dec94;
</pre>
<p>This method is most appropriate for small tables, or for large tables when the partition being truncated contains a small percentage of the total data in the table.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1009364"></a><a id="VLDBG1228"></a>
<div class="sect3">
<h3 class="sect3">Truncating a Subpartition</h3>
<p><a id="sthref650"></a>You use the <code>ALTER</code> <code>TABLE</code> ... <a id="sthref651"></a><code>TRUNCATE</code> <code>SUBPARTITION</code> statement to remove all rows from a subpartition of a composite partitioned table. Corresponding local index subpartitions are also truncated.</p>
<p>The following statement shows how to truncate data in a subpartition of a table. In this example, the space occupied by the deleted rows is made available for use by other schema objects in the tablespace.</p>
<pre>
ALTER TABLE diving
   TRUNCATE SUBPARTITION us_locations
      DROP STORAGE;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1828">
<tr>
<td class="cellalignment1837">
<table class="cellalignment1833">
<tr>
<td class="cellalignment1832"><a href="part_admin001.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1832"><a href="part_admin003.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1840">
<table class="cellalignment1831">
<tr>
<td class="cellalignment1832"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1832"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1832"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1832"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1832"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1832"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
