<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Partitioning for Availability, Manageability, and Performance</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-27T4:11:51Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database VLDB and Partitioning Guide" />
<meta name="dcterms.identifier" content="E25523-01" />
<meta name="dcterms.isVersionOf" content="VLDBG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="partition.htm" title="Previous" type="text/html" />
<link rel="Next" href="part_admin.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25523.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/27</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='part_avail'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript><a id="BJEIEDIA"></a><a id="VLDBG004"></a>
<h1 class="chapter"><span class="secnum">3</span> Partitioning for Availability, Manageability, and Performance</h1>
<p><a id="sthref121"></a>This chapter provides high-level insight into how partitioning enables availability, manageability, and performance. This chapter presents guidelines on when to use a given partitioning strategy. The main focus of this chapter is the use of table partitioning, though most of the recommendations and considerations apply to index partitioning as well.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#CACGFIGJ">Partition Pruning</a></p>
</li>
<li>
<p><a href="#CIHCDBIF">Partition-Wise Joins</a></p>
</li>
<li>
<p><a href="#CIHJCJJF">Index Partitioning</a></p>
</li>
<li>
<p><a href="#CACFFCHI">Partitioning and Table Compression</a></p>
</li>
<li>
<p><a href="#CACHHFHH">Recommendations for Choosing a Partitioning Strategy</a></p>
</li>
</ul>
<a id="CACGFIGJ"></a><a id="VLDBG00401"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Partition Pruning</h2>
<p><a id="sthref122"></a><a id="sthref123"></a><a id="sthref124"></a>Partition pruning is an essential performance feature for data warehouses. In partition pruning, the optimizer analyzes <code>FROM</code> and <code>WHERE</code> clauses in SQL statements to eliminate unneeded partitions when building the partition access list. This functionality enables Oracle Database to perform operations only on those partitions that are relevant to the SQL statement.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABFEEGH">Benefits of Partition Pruning</a></p>
</li>
<li>
<p><a href="#BABJIFFF">Information That Can Be Used for Partition Pruning</a></p>
</li>
<li>
<p><a href="#BABCDHIF">How to Identify Whether Partition Pruning Has Been Used</a></p>
</li>
<li>
<p><a href="#BABEGHBB">Static Partition Pruning</a></p>
</li>
<li>
<p><a href="#BABHCBGJ">Dynamic Partition Pruning</a></p>
</li>
<li>
<p><a href="#BJECFBJE">Partition Pruning Tips</a></p>
</li>
</ul>
<a id="BABFEEGH"></a><a id="VLDBG14026"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Benefits of Partition Pruning</h3>
<p><a id="sthref125"></a><a id="sthref126"></a>Partition pruning dramatically reduces the amount of data retrieved from disk and shortens processing time, thus improving query performance and optimizing resource utilization. If you partition the index and table on different columns (with a global partitioned index), then partition pruning also eliminates index partitions even when the partitions of the underlying table cannot be eliminated.</p>
<p>Depending upon the actual SQL statement, Oracle Database may use static or dynamic pruning. Static pruning occurs at compile-time, with the information about the partitions accessed beforehand. Dynamic pruning occurs at run-time, meaning that the exact partitions to be accessed by a statement are not known beforehand. A sample scenario for static pruning is a SQL statement containing a <code>WHERE</code> condition with a constant literal on the partition key column. An example of dynamic pruning is the use of operators or functions in the <code>WHERE</code> condition.</p>
<p>Partition pruning affects the statistics of the objects where pruning occurs and also affects the execution plan of a statement.</p>
</div>
<!-- class="sect2" -->
<a id="BABJIFFF"></a><a id="VLDBG1229"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Information That Can Be Used for Partition Pruning</h3>
<p><a id="sthref127"></a>Oracle Database prunes partitions when you use range, <code>LIKE</code>, equality, and <code>IN</code>-list predicates on the range or list partitioning columns, and when you use equality and <code>IN</code>-list predicates on the hash partitioning columns.</p>
<p>On composite partitioned objects, Oracle Database can prune at both levels using the relevant predicates. Examine the table <code>sales_range_hash</code>, which is partitioned by range on the column <code>s_saledate</code> and subpartitioned by hash on the column <code>s_productid</code> in <a href="#BABDIGFB">Example 3-1</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BABDIGFB"></a><a id="VLDBG14027"></a>Example 3-1 Creating a table with partition pruning</p>
<pre>
CREATE TABLE sales_range_hash(
  s_productid  NUMBER,
  s_saledate   DATE,
  s_custid     NUMBER,
  s_totalprice NUMBER)
PARTITION BY RANGE (s_saledate)
SUBPARTITION BY HASH (s_productid) SUBPARTITIONS 8
 (PARTITION sal99q1 VALUES LESS THAN
   (TO_DATE('01-APR-1999', 'DD-MON-YYYY')),
  PARTITION sal99q2 VALUES LESS THAN
   (TO_DATE('01-JUL-1999', 'DD-MON-YYYY')),
  PARTITION sal99q3 VALUES LESS THAN
   (TO_DATE('01-OCT-1999', 'DD-MON-YYYY')),
  PARTITION sal99q4 VALUES LESS THAN
   (TO_DATE('01-JAN-2000', 'DD-MON-YYYY')));

SELECT * FROM sales_range_hash
WHERE s_saledate BETWEEN (TO_DATE('01-JUL-1999', 'DD-MON-YYYY'))
  AND (TO_DATE('01-OCT-1999', 'DD-MON-YYYY')) AND s_productid = 1200;
</pre></div>
<!-- class="example" -->
<p>Oracle uses the predicate on the partitioning columns to perform partition pruning as follows:</p>
<ul>
<li>
<p>When using range partitioning, Oracle accesses only partitions <code>sal99q2</code> and <code>sal99q3</code>, representing the partitions for the third and fourth quarters of 1999.</p>
</li>
<li>
<p>When using hash subpartitioning, Oracle accesses only the one subpartition in each partition that stores the rows with <code>s_productid=1200</code>. The mapping between the subpartition and the predicate is calculated based on Oracle's internal hash distribution function.</p>
</li>
</ul>
<p>A reference-partitioned table can take advantage of partition pruning through the join with the referenced table. Virtual column-based partitioned tables benefit from partition pruning for statements that use the virtual column-defining expression in the SQL statement.</p>
</div>
<!-- class="sect2" -->
<a id="BABCDHIF"></a><a id="VLDBG1230"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">How to Identify Whether Partition Pruning Has Been Used</h3>
<p><a id="sthref128"></a>Whether Oracle uses partition pruning is reflected in the execution plan of a statement, either in the plan table for the <code>EXPLAIN</code> <code>PLAN</code> statement or in the shared SQL area.</p>
<p><a id="sthref129"></a><a id="sthref130"></a><a id="sthref131"></a><a id="sthref132"></a>The partition pruning information is reflected in the plan columns <code>PSTART</code> (<code>PARTITION_START</code>) and <code>PSTOP</code> (<code>PARTITION_STOP</code>). For serial statements, the pruning information is also reflected in the <code>OPERATION</code> and <code>OPTIONS</code> columns.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about <code>EXPLAIN</code> <code>PLAN</code> and how to interpret it</div>
</div>
<!-- class="sect2" -->
<a id="BABEGHBB"></a><a id="VLDBG1231"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Static Partition Pruning</h3>
<p><a id="sthref133"></a>For many cases, Oracle determines the partitions to be accessed at compile time. Static partition pruning occurs if you use static predicates, except for the following cases:</p>
<ul>
<li>
<p>Partition pruning occurs using the result of a subquery.</p>
</li>
<li>
<p>The optimizer rewrites the query with a star transformation and pruning occurs after the star transformation.</p>
</li>
<li>
<p>The most efficient execution plan is a nested loop.</p>
</li>
</ul>
<p>These three cases result in the use of dynamic pruning.</p>
<p>If at parse time Oracle can identify which contiguous set of partitions is accessed, then the <code>PSTART</code> and <code>PSTOP</code> columns in the execution plan show the begin and the end values of the partitions being accessed. Any other cases of partition pruning, including dynamic pruning, show the KEY value in <code>PSTART</code> and <code>PSTOP</code>, optionally with an additional attribute.</p>
<p>The following is an example:</p>
<pre>
SQL&gt; explain plan for select * from sales where time_id = to_date('01-jan-2001', 'dd-mon-yyyy');
Explained.

SQL&gt; select * from table(dbms_xplan.display);
PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------------------
Plan hash value: 3971874201
----------------------------------------------------------------------------------------------
| Id | Operation              | Name  | Rows | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
----------------------------------------------------------------------------------------------
|  0 | SELECT STATEMENT       |       | 673  | 19517 | 27      (8)| 00:00:01 |       |       |
|  1 |  PARTITION RANGE SINGLE|       | 673  | 19517 | 27      (8)| 00:00:01 | 17    | 17    |
|* 2 |   TABLE ACCESS FULL    | SALES | 673  | 19517 | 27      (8)| 00:00:01 | 17    | 17    |
----------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
--------------------------------------------------- 
   2 - filter("TIME_ID"=TO_DATE('2001-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss'))
</pre>
<p>This plan shows that Oracle accesses partition number 17, as shown in the <code>PSTART</code> and <code>PSTOP</code> columns. The <code>OPERATION</code> column shows <code>PARTITION RANGE SINGLE</code>, indicating that only a single partition is being accessed. If <code>OPERATION</code> shows <code>PARTITION RANGE ALL</code>, then all partitions are being accessed and effectively no pruning takes place. <code>PSTART</code> then shows the very first partition of the table and <code>PSTOP</code> shows the very last partition.</p>
<p>An execution plan with a full table scan on an interval-partitioned table shows 1 for <code>PSTART</code>, and 1048575 for <code>PSTOP</code>, regardless of how many interval partitions were created.</p>
</div>
<!-- class="sect2" -->
<a id="BABHCBGJ"></a><a id="VLDBG1232"></a>
<div class="sect2">
<h3 class="sect2">Dynamic Partition Pruning</h3>
<p><a id="sthref134"></a>Dynamic pruning occurs if pruning is possible and static pruning is not possible. The following examples show multiple dynamic pruning cases:</p>
<ul>
<li>
<p><a href="#BABFGAEC">Dynamic Pruning with Bind Variables</a></p>
</li>
<li>
<p><a href="#BABHDCJG">Dynamic Pruning with Subqueries</a></p>
</li>
<li>
<p><a href="#BABGDFGD">Dynamic Pruning with Star Transformation</a></p>
</li>
<li>
<p><a href="#BABIIAJJ">Dynamic Pruning with Nested Loop Joins</a></p>
</li>
</ul>
<a id="BABFGAEC"></a><a id="VLDBG1233"></a>
<div class="sect3">
<h4 class="sect3">Dynamic Pruning with Bind Variables</h4>
<p><a id="sthref135"></a>Statements that use bind variables against partition columns result in dynamic pruning. For example:</p>
<pre>
SQL&gt; explain plan for select * from sales s where time_id in ( :a, :b, :c, :d);
Explained.

SQL&gt; select * from table(dbms_xplan.display);
PLAN_TABLE_OUTPUT
---------------------------------------------------------------------------------------------------
Plan hash value: 513834092
---------------------------------------------------------------------------------------------------
| Id | Operation                         |    Name |Rows|Bytes|Cost (%CPU)|  Time  | Pstart| Pstop|
---------------------------------------------------------------------------------------------------
|  0 | SELECT STATEMENT                  |         |2517|72993|    292 (0)|00:00:04|       |      |
|  1 |  INLIST ITERATOR                  |         |    |     |           |        |       |      |
|  2 |   PARTITION RANGE ITERATOR        |         |2517|72993|    292 (0)|00:00:04|KEY(I) |KEY(I)|
|  3 |    TABLE ACCESS BY LOCAL INDEX ROWID| SALES |2517|72993|    292 (0)|00:00:04|KEY(I) |KEY(I)|
|  4 |     BITMAP CONVERSION TO ROWIDS   |         |    |     |           |        |       |      |
|* 5 |      BITMAP INDEX SINGLE VALUE    |SALES_TIME_BIX| |   |           |        |KEY(I) |KEY(I)|
---------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
5 - access("TIME_ID"=:A OR "TIME_ID"=:B OR "TIME_ID"=:C OR "TIME_ID"=:D)
</pre>
<p>For parallel execution plans, only the partition start and stop columns contain the partition pruning information; the operation column contains information for the parallel operation, as shown in the following example:</p>
<pre>
SQL&gt; explain plan for select * from sales where time_id in (:a, :b, :c, :d);
Explained.

SQL&gt; select * from table(dbms_xplan.display);
PLAN_TABLE_OUTPUT
-------------------------------------------------------------------------------------------------
Plan hash value: 4058105390
-------------------------------------------------------------------------------------------------
| Id| Operation          | Name  |Rows|Bytes|Cost(%CP|  Time  |Pstart| Pstop|  TQ |INOUT| PQ Dis|
-------------------------------------------------------------------------------------------------
|  0| SELECT STATEMENT   |       |2517|72993|  75(36)|00:00:01|      |      |     |     |       |
|  1|  PX COORDINATOR    |       |    |     |        |        |      |      |     |     |       |
|  2|  PX SEND QC(RANDOM)|:TQ10000|2517|72993| 75(36)|00:00:01|      |      |Q1,00| P-&gt;S|QC(RAND|
|  3|   PX BLOCK ITERATOR|       |2517|72993|  75(36)|00:00:01|KEY(I)|KEY(I)|Q1,00| PCWC|       |
|* 4|   TABLE ACCESS FULL| SALES |2517|72993|  75(36)|00:00:01|KEY(I)|KEY(I)|Q1,00| PCWP|       |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
--------------------------------------------------- 
  4 - filter("TIME_ID"=:A OR "TIME_ID"=:B OR "TIME_ID"=:C OR "TIME_ID"=:D)
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about <code>EXPLAIN PLAN</code> and how to interpret it</div>
</div>
<!-- class="sect3" -->
<a id="BABHDCJG"></a><a id="VLDBG1234"></a>
<div class="sect3">
<h4 class="sect3">Dynamic Pruning with Subqueries</h4>
<p><a id="sthref136"></a>Statements that explicitly use subqueries against partition columns result in dynamic pruning. For example:</p>
<pre>
SQL&gt; explain plan for select sum(amount_sold) from sales where time_id in
     (select time_id from times where fiscal_year = 2000);
Explained.

SQL&gt; select * from table(dbms_xplan.display);
PLAN_TABLE_OUTPUT
PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------------------------
Plan hash value: 3827742054

----------------------------------------------------------------------------------------------------
| Id  | Operation                  | Name  | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
----------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |       |     1 |    25 |   523   (5)| 00:00:07 |       |       |
|   1 |  SORT AGGREGATE            |       |     1 |    25 |            |          |       |       |
|*  2 |   HASH JOIN                |       |   191K|  4676K|   523   (5)| 00:00:07 |       |       |
|*  3 |    TABLE ACCESS FULL       | TIMES |   304 |  3648 |    18   (0)| 00:00:01 |       |       |
|   4 |    PARTITION RANGE SUBQUERY|       |   918K|    11M|   498   (4)| 00:00:06 |KEY(SQ)|KEY(SQ)|
|   5 |     TABLE ACCESS FULL      | SALES |   918K|    11M|   498   (4)| 00:00:06 |KEY(SQ)|KEY(SQ)|
----------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("TIME_ID"="TIME_ID")
   3 - filter("FISCAL_YEAR"=2000)
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about <code>EXPLAIN PLAN</code> and how to interpret it</div>
</div>
<!-- class="sect3" -->
<a id="BABGDFGD"></a><a id="VLDBG1235"></a>
<div class="sect3">
<h4 class="sect3">Dynamic Pruning with Star Transformation</h4>
<p><a id="sthref137"></a>Statements that get transformed by the database using the star transformation result in dynamic pruning. For example:</p>
<pre>
SQL&gt; explain plan for select p.prod_name, t.time_id, sum(s.amount_sold)
     from sales s, times t, products p
     where s.time_id = t.time_id and s.prod_id = p.prod_id and t.fiscal_year = 2000
     and t.fiscal_week_number = 3 and p.prod_category = 'Hardware'
     group by t.time_id, p.prod_name;
Explained.

SQL&gt; select * from table(dbms_xplan.display);
PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------
Plan hash value: 4020965003

------------------------------------------------------------------------------------------------------
| Id  | Operation                             | Name                 | Rows  | Bytes | Pstart| Pstop |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                      |                      |     1 |    79 |       |       |
|   1 |  HASH GROUP BY                        |                      |     1 |    79 |       |       |
|*  2 |   HASH JOIN                           |                      |     1 |    79 |       |       |
|*  3 |    HASH JOIN                          |                      |     2 |    64 |       |       |
|*  4 |     TABLE ACCESS FULL                 | TIMES                |     6 |    90 |       |       |
|   5 |     PARTITION RANGE SUBQUERY          |                      |   587 |  9979 |KEY(SQ)|KEY(SQ)|
|   6 |      TABLE ACCESS BY LOCAL INDEX ROWID| SALES                |   587 |  9979 |KEY(SQ)|KEY(SQ)|
|   7 |       BITMAP CONVERSION TO ROWIDS     |                      |       |       |       |       |
|   8 |        BITMAP AND                     |                      |       |       |       |       |
|   9 |         BITMAP MERGE                  |                      |       |       |       |       |
|  10 |          BITMAP KEY ITERATION         |                      |       |       |       |       |
|  11 |           BUFFER SORT                 |                      |       |       |       |       |
|* 12 |            TABLE ACCESS FULL          | TIMES                |     6 |    90 |       |       |
|* 13 |           BITMAP INDEX RANGE SCAN     | SALES_TIME_BIX       |       |       |KEY(SQ)|KEY(SQ)|
|  14 |         BITMAP MERGE                  |                      |       |       |       |       |
|  15 |          BITMAP KEY ITERATION         |                      |       |       |       |       |
|  16 |           BUFFER SORT                 |                      |       |       |       |       |
|  17 |            TABLE ACCESS BY INDEX ROWID| PRODUCTS             |    14 |   658 |       |       |
|* 18 |             INDEX RANGE SCAN          | PRODUCTS_PROD_CAT_IX |    14 |       |       |       |
|* 19 |           BITMAP INDEX RANGE SCAN     | SALES_PROD_BIX       |       |       |KEY(SQ)|KEY(SQ)|
|  20 |    TABLE ACCESS BY INDEX ROWID        | PRODUCTS             |    14 |   658 |       |       |
|* 21 |     INDEX RANGE SCAN                  | PRODUCTS_PROD_CAT_IX |    14 |       |       |       |
------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("S"."PROD_ID"="P"."PROD_ID")
   3 - access("S"."TIME_ID"="T"."TIME_ID")
   4 - filter("T"."FISCAL_WEEK_NUMBER"=3 AND "T"."FISCAL_YEAR"=2000)
  12 - filter("T"."FISCAL_WEEK_NUMBER"=3 AND "T"."FISCAL_YEAR"=2000)
  13 - access("S"."TIME_ID"="T"."TIME_ID")
  18 - access("P"."PROD_CATEGORY"='Hardware')
  19 - access("S"."PROD_ID"="P"."PROD_ID")
  21 - access("P"."PROD_CATEGORY"='Hardware')

Note
-----
   - star transformation used for this statement
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Cost (%CPU)</code> and <code>Time</code> columns were removed from the plan table output in this example.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about <code>EXPLAIN PLAN</code> and how to interpret it</div>
</div>
<!-- class="sect3" -->
<a id="BABIIAJJ"></a><a id="VLDBG1236"></a>
<div class="sect3">
<h4 class="sect3">Dynamic Pruning with Nested Loop Joins</h4>
<p><a id="sthref138"></a>Statements that are most efficiently executed using a nested loop join use dynamic pruning. For example:</p>
<pre>
SQL&gt; explain plan for select t.time_id, sum(s.amount_sold)
     from sales s, times t
     where s.time_id = t.time_id and t.fiscal_year = 2000 and t.fiscal_week_number = 3
     group by t.time_id;
Explained.

SQL&gt; select * from table(dbms_xplan.display);
PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------------------------
Plan hash value: 50737729

----------------------------------------------------------------------------------------------------
| Id  | Operation                  | Name  | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
----------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |       |     6 |   168 |   126   (4)| 00:00:02 |       |       |
|   1 |  HASH GROUP BY             |       |     6 |   168 |   126   (4)| 00:00:02 |       |       |
|   2 |   NESTED LOOPS             |       |  3683 |   100K|   125   (4)| 00:00:02 |       |       |
|*  3 |    TABLE ACCESS FULL       | TIMES |     6 |    90 |    18   (0)| 00:00:01 |       |       |
|   4 |    PARTITION RANGE ITERATOR|       |   629 |  8177 |    18   (6)| 00:00:01 |   KEY |   KEY |
|*  5 |     TABLE ACCESS FULL      | SALES |   629 |  8177 |    18   (6)| 00:00:01 |   KEY |   KEY |
----------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter("T"."FISCAL_WEEK_NUMBER"=3 AND "T"."FISCAL_YEAR"=2000)
   5 - filter("S"."TIME_ID"="T"."TIME_ID")
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about <code>EXPLAIN PLAN</code> and how to interpret it</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BJECFBJE"></a><a id="VLDBG1237"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Partition Pruning Tips</h3>
<p><a id="sthref139"></a>When using partition pruning, you should consider the following:</p>
<ul>
<li>
<p><a href="#BJEBFIDC">Data Type Conversions</a></p>
</li>
<li>
<p><a href="#BJEEFHFA">Function Calls</a></p>
</li>
<li>
<p><a href="#BABDECDG">Collection Tables</a></p>
</li>
</ul>
<a id="BJEBFIDC"></a><a id="VLDBG1238"></a>
<div class="sect3">
<h4 class="sect3">Data Type Conversions</h4>
<p><a id="sthref140"></a>To get the maximum performance benefit from partition pruning, you should avoid constructs that require the database to convert the data type you specify. Data type conversions typically result in dynamic pruning when static pruning would have otherwise been possible. SQL statements that benefit from static pruning perform better than statements that benefit from dynamic pruning.</p>
<p>A common case of data type conversions occurs when using the Oracle <code>DATE</code> data type. An Oracle <code>DATE</code> data type is not a character string but is only represented as such when querying the database; the format of the representation is defined by the NLS setting of the instance or the session. Consequently, the same reverse conversion has to happen when inserting data into a <code>DATE</code> field or when specifying a predicate on such a field.</p>
<p>A conversion can either happen implicitly or explicitly by specifying a <code>TO_DATE</code> conversion. Only a properly applied <code>TO_DATE</code> function guarantees that the database can uniquely determine the date value and using it potentially for static pruning, which is especially beneficial for single partition access.</p>
<p>Consider the following example that runs against the sample <code>SH</code> schema in an Oracle Database. You would like to know the total revenue number for the year 2000. There are multiple ways you can retrieve the answer to the query, but not every method is equally efficient.</p>
<pre>
explain plan for SELECT SUM(amount_sold) total_revenue
FROM sales,
WHERE time_id between '01-JAN-00' and '31-DEC-00';
</pre>
<p>The plan should now be similar to the following:</p>
<pre>
----------------------------------------------------------------------------------------------------
| Id  | Operation                  | Name  | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
----------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |       |     1 |    13 |   525   (8)| 00:00:07 |       |       |
|   1 |  SORT AGGREGATE            |       |     1 |    13 |            |          |       |       |
|*  2 |   FILTER                   |       |       |       |            |          |       |       |
|   3 |    PARTITION RANGE ITERATOR|       |   230K|  2932K|   525   (8)| 00:00:07 |   KEY |   KEY |
|*  4 |     TABLE ACCESS FULL      | SALES |   230K|  2932K|   525   (8)| 00:00:07 |   KEY |   KEY |
----------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter(TO_DATE('01-JAN-00')&lt;=TO_DATE('31-DEC-00'))
   4 - filter("TIME_ID"&gt;='01-JAN-00' AND "TIME_ID"&lt;='31-DEC-00') 
</pre>
<p>In this case, the keyword <code>KEY</code> for both <code>PSTART</code> and <code>PSTOP</code> means that dynamic partition pruning occurs at run-time. Consider the following case.</p>
<pre>
explain plan for select sum(amount_sold)
from sales
where time_id between '01-JAN-2000' and '31-DEC-2000' ;
</pre>
<p>The execution plan now shows the following:</p>
<pre>
----------------------------------------------------------------------------------------
| Id  | Operation                 | Name  | Rows  | Bytes | Cost (%CPU)| Pstart| Pstop |
----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT          |       |     1 |    13 |   127   (4)|       |       |
|   1 |  SORT AGGREGATE           |       |     1 |    13 |            |       |       |
|   2 |   PARTITION RANGE ITERATOR|       |   230K|  2932K|   127   (4)|    13 |    16 |
|*  3 |    TABLE ACCESS FULL      | SALES |   230K|  2932K|   127   (4)|    13 |    16 |
----------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter("TIME_ID"&lt;=TO_DATE(' 2000-12-31 00:00:00', "syyyy-mm-dd hh24:mi:ss'))
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Time</code> column was removed from the execution plan.</div>
<p>The execution plan shows static partition pruning. The query accesses a contiguous list of partitions 13 to 16. In this particular case, the way the date format was specified matches the NLS date format setting. Though this example shows the most efficient execution plan, you cannot rely on the NLS date format setting to define a certain format.</p>
<pre>
alter session set nls_date_format='fmdd Month yyyy';

explain plan for select sum(amount_sold)
from sales
where time_id between '01-JAN-2000' and '31-DEC-2000' ;
</pre>
<p>The execution plan now shows the following:</p>
<pre>
-----------------------------------------------------------------------------------------
| Id  | Operation                  | Name  | Rows  | Bytes | Cost (%CPU)| Pstart| Pstop |
-----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |       |     1 |    13 |   525   (8)|       |       |
|   1 |  SORT AGGREGATE            |       |     1 |    13 |            |       |       |
|*  2 |   FILTER                   |       |       |       |            |       |       |
|   3 |    PARTITION RANGE ITERATOR|       |   230K|  2932K|   525   (8)|   KEY |   KEY |
|*  4 |     TABLE ACCESS FULL      | SALES |   230K|  2932K|   525   (8)|   KEY |   KEY |
-----------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter(TO_DATE('01-JAN-2000')&lt;=TO_DATE('31-DEC-2000'))
   4 - filter("TIME_ID"&gt;='01-JAN-2000' AND "TIME_ID"&lt;='31-DEC-2000')
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Time</code> column was removed from the execution plan.</div>
<p>This plan, which uses dynamic pruning, again is less efficient than the static pruning execution plan. To guarantee a static partition pruning plan, you should explicitly convert data types to match the partition column data type. For example:</p>
<pre>
explain plan for select sum(amount_sold)
from sales
where time_id between to_date('01-JAN-2000','dd-MON-yyyy')
  and to_date('31-DEC-2000','dd-MON-yyyy') ;


----------------------------------------------------------------------------------------
| Id  | Operation                 | Name  | Rows  | Bytes | Cost (%CPU)| Pstart| Pstop |
----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT          |       |     1 |    13 |   127   (4)|       |       |
|   1 |  SORT AGGREGATE           |       |     1 |    13 |            |       |       |
|   2 |   PARTITION RANGE ITERATOR|       |   230K|  2932K|   127   (4)|    13 |    16 |
|*  3 |    TABLE ACCESS FULL      | SALES |   230K|  2932K|   127   (4)|    13 |    16 |
----------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter("TIME_ID"&lt;=TO_DATE(' 2000-12-31 00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Time</code> column was removed from the execution plan.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for details about the <code>DATE</code> data type</p>
</li>
<li>
<p><a class="olink NLSPG" href="../e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a> for details about NLS settings and globalization issues</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BJEEFHFA"></a><a id="VLDBG1239"></a>
<div class="sect3">
<h4 class="sect3">Function Calls</h4>
<p><a id="sthref141"></a>There are several cases when the optimizer cannot perform pruning. One common reasons is when an operator is used on top of a partitioning column. This could be an explicit operator (for example, a function) or even an implicit operator introduced by Oracle as part of the necessary data type conversion for executing the statement. For example, consider the following query:</p>
<pre>
EXPLAIN PLAN FOR
SELECT SUM(quantity_sold)
FROM sales
WHERE time_id = TO_TIMESTAMP('1-jan-2000', 'dd-mon-yyyy');
</pre>
<p>Because <code>time_id</code> is of type <code>DATE</code> and Oracle must promote it to the <code>TIMESTAMP</code> type to get the same data type, this predicate is internally rewritten as:</p>
<pre>
TO_TIMESTAMP(time_id) = TO_TIMESTAMP('1-jan-2000', 'dd-mon-yyyy')
</pre>
<p>The execution plan for this statement is as follows:</p>
<pre>
--------------------------------------------------------------------------------------------
|Id | Operation            | Name  | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
--------------------------------------------------------------------------------------------
| 0 | SELECT STATEMENT     |       |     1 |    11 |     6  (17)| 00:00:01 |       |       |
| 1 |  SORT AGGREGATE      |       |     1 |    11 |            |          |       |       |
| 2 |   PARTITION RANGE ALL|       |    10 |   110 |     6  (17)| 00:00:01 |     1 |    16 |
|*3 |    TABLE ACCESS FULL | SALES |    10 |   110 |     6  (17)| 00:00:01 |     1 |    16 |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
3 - filter(INTERNAL_FUNCTION("TIME_ID")=TO_TIMESTAMP('1-jan-2000',:B1))
 
15 rows selected
</pre>
<p>The <code>SELECT</code> statement accesses all partitions even though pruning down to a single partition could have taken place. Consider the example to find the total sales revenue number for 2000. Another way to construct the query would be:</p>
<pre>
EXPLAIN PLAN FOR
SELECT SUM(amount_sold)
FROM sales
WHERE TO_CHAR(time_id,'yyyy') = '2000';
</pre>
<p>This query applies a function call to the partition key column, which generally disables partition pruning. The execution plan shows a full table scan with no partition pruning:</p>
<pre>
----------------------------------------------------------------------------------------------
| Id  | Operation            | Name  | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |       |     1 |    13 |   527   (9)| 00:00:07 |       |       |
|   1 |  SORT AGGREGATE      |       |     1 |    13 |            |          |       |       |
|   2 |   PARTITION RANGE ALL|       |  9188 |   116K|   527   (9)| 00:00:07 |     1 |    28 |
|*  3 |    TABLE ACCESS FULL | SALES |  9188 |   116K|   527   (9)| 00:00:07 |     1 |    28 |
----------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(TO_CHAR(INTERNAL_FUNCTION("TIME_ID"),'yyyy')='2000')
</pre>
<p>Avoid using implicit or explicit functions on the partition columns. If your queries commonly use function calls, then consider using a virtual column and virtual column partitioning to benefit from partition pruning in these cases.</p>
</div>
<!-- class="sect3" -->
<a id="BABDECDG"></a><a id="VLDBG1240"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Collection Tables</h4>
<p><a id="sthref142"></a>The following example illustrates what an <code>EXPLAIN</code> <code>PLAN</code> statement might look like when it contains Collection Tables, which, for the purposes of this discussion, are ordered collection tables or nested tables. It is based on the <code>CREATE</code> <code>TABLE</code> statement in <a href="part_admin001.htm#CDCHCHBD">"Partitioning of Collections in XMLType and Objects"</a>. Note that a full table access is not performed because it is constrained to just the partition in question.</p>
<pre>
EXPLAIN PLAN FOR
SELECT p.ad_textdocs_ntab
FROM print_media_part p;
 
Explained.
 
PLAN_TABLE_OUTPUT
-----------------------------------------------------------------------
Plan hash value: 2207588228
 
-----------------------------------------------------------------------
| Id  | Operation                  | Name             | Pstart| Pstop |
-----------------------------------------------------------------------
|   0 | SELECT STATEMENT           |                  |       |       |
|   1 |  PARTITION REFERENCE SINGLE|                  |   KEY |   KEY |
|   2 |   TABLE ACCESS FULL        | TEXTDOC_NT       |   KEY |   KEY |
|   3 |  PARTITION RANGE ALL       |                  |     1 |     2 |
|   4 |   TABLE ACCESS FULL        | PRINT_MEDIA_PART |     1 |     2 |
-----------------------------------------------------------------------
 
Note
-----
  - dynamic sampling used for this statement 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHCDBIF"></a><a id="VLDBG00402"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Partition-Wise Joins</h2>
<p><a id="sthref143"></a><a id="sthref144"></a>Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. This significantly reduces response time and improves the use of both CPU and memory resources. In Oracle Real Application Clusters (Oracle RAC) environments, partition-wise joins also avoid or at least limit the data traffic over the interconnect, which is the key to achieving good scalability for massive join operations.</p>
<p>Partition-wise joins can be full or partial. Oracle Database decides which type of join to use.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABCGBBC">Full Partition-Wise Joins</a></p>
</li>
<li>
<p><a href="#BABBBBAD">Partial Partition-Wise Joins</a></p>
</li>
</ul>
<a id="BABCGBBC"></a><a id="VLDBG1241"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Full Partition-Wise Joins</h3>
<p><a id="sthref145"></a><a id="sthref146"></a><a id="sthref147"></a><a id="sthref148"></a>A full partition-wise join divides a large join into smaller joins between a pair of partitions from the two joined tables. To use this feature, you must equipartition both tables on their join keys, or use reference partitioning. For example, consider a large join between a sales table and a customer table on the column <code>cust_id</code>. The query "find the records of all customers who bought more than 100 articles in Quarter 3 of 1999" is a typical example of a SQL statement performing such a join, as shown in <a href="#BABGCCHD">Example 3-2</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BABGCCHD"></a><a id="VLDBG14028"></a>Example 3-2 Querying with a full partition-wise join</p>
<pre>
SELECT c.cust_last_name, COUNT(*)
  FROM sales s, customers c
  WHERE s.cust_id = c.cust_id AND 
        s.time_id BETWEEN TO_DATE('01-JUL-1999', 'DD-MON-YYYY') AND 
        (TO_DATE('01-OCT-1999', 'DD-MON-YYYY'))
  GROUP BY c.cust_last_name HAVING COUNT(*) &gt; 100;
</pre></div>
<!-- class="example" -->
<p>Such a large join is typical in data warehousing environments. In this case, the entire customer table is joined with one quarter of the sales data. In large data warehouse applications, this might mean joining millions of rows. The join method to use in that case is obviously a hash join. You can reduce the processing time for this hash join even more if both tables are equipartitioned on the <code>cust_id</code> column. This functionality enables a full partition-wise join.</p>
<p>When you execute a full partition-wise join in parallel, the granule of parallelism is a partition. Consequently, the degree of parallelism is limited to the number of partitions. For example, you require at least 16 partitions to set the degree of parallelism of the query to 16.</p>
<p>You can use various partitioning methods to equipartition both tables. These methods are described at a high level in the following subsections:</p>
<ul>
<li>
<p><a href="#BABIEIFB">Full Partition-Wise Joins: Single-Level - Single-Level</a></p>
</li>
<li>
<p><a href="#BABDBHCJ">Full Partition-Wise Joins: Composite - Single-Level</a></p>
</li>
<li>
<p><a href="#BABJBHIG">Full Partition-Wise Joins: Composite - Composite</a></p>
</li>
</ul>
<a id="BABIEIFB"></a><a id="VLDBG1242"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Full Partition-Wise Joins: Single-Level - Single-Level</h4>
<p><a id="sthref149"></a>This is the simplest method: two tables are both partitioned by the join column. In the example, the <code>customers</code> and <code>sales</code> tables are both partitioned on the <code>cust_id</code> columns. This partitioning method enables full partition-wise joins when the tables are joined on <code>cust_id</code>, both representing the same customer identification number. This scenario is available for range-range, list-list, and hash-hash partitioning. Interval-range and interval-interval full partition-wise joins are also supported and can be compared to range-range.</p>
<p>In serial, this join is performed between pairs of matching hash partitions, one at a time. When one partition pair has been joined, the join of another partition pair begins. The join completes when all partition pairs have been processed. To ensure a good workload distribution, you should either have many more partitions than the requested degree of parallelism or use equisize partitions with as many partitions as the requested degree of parallelism. Using hash partitioning on a unique or almost-unique column, with the number of partitions equal to a power of 2, is a good way to create equisized partitions.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>A pair of matching hash partitions is defined as one partition with the same partition number from each table. For example, with full partition-wise joins based on hash partitioning, the database joins partition 0 of <code>sales</code> with partition 0 of <code>customers</code>, partition 1 of <code>sales</code> with partition 1 of <code>customers</code>, and so on.</p>
</li>
<li>
<p>Reference partitioning is an easy way to co-partition two tables so that the optimizer can always consider a full partition-wise join if the tables are joined in a statement.</p>
</li>
</ul>
</div>
<p>Parallel execution of a full partition-wise join is a straightforward parallelization of the serial execution. Instead of joining one partition pair at a time, partition pairs are joined in parallel by the query servers. <a href="#i1006910">Figure 3-1</a> illustrates the parallel execution of a full partition-wise join.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006910"></a><a id="VLDBG1243"></a>Figure 3-1 Parallel Execution of a Full Partition-wise Join</p>
<img width="422" height="219" src="img/vldbg017.gif" alt="Description of Figure 3-1 follows" /><br />
<a id="sthref150" href="img_text/vldbg017.htm">Description of "Figure 3-1 Parallel Execution of a Full Partition-wise Join"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The following example shows the execution plan for <code>sales</code> and <code>customers</code> co-partitioned by hash with the same number of partitions. The plan shows a full partition-wise join.</p>
<pre>
explain plan for SELECT c.cust_last_name, COUNT(*)
FROM sales s, customers c
WHERE s.cust_id = c.cust_id AND 
s.time_id BETWEEN TO_DATE('01-JUL-1999', 'DD-MON-YYYY') AND 
     (TO_DATE('01-OCT-1999', 'DD-MON-YYYY'))
GROUP BY c.cust_last_name HAVING COUNT(*) &gt; 100;

---------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name      | Rows  | Bytes | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |           |    46 |  1196 |       |       |        |      |            |
|   1 |  PX COORDINATOR              |           |       |       |       |       |        |      |            |
|   2 |   PX SEND QC (RANDOM)        | :TQ10001  |    46 |  1196 |       |       |  Q1,01 | P-&gt;S | QC (RAND)  |
|*  3 |    FILTER                    |           |       |       |       |       |  Q1,01 | PCWC |            |
|   4 |     HASH GROUP BY            |           |    46 |  1196 |       |       |  Q1,01 | PCWP |            |
|   5 |      PX RECEIVE              |           |    46 |  1196 |       |       |  Q1,01 | PCWP |            |
|   6 |       PX SEND HASH           | :TQ10000  |    46 |  1196 |       |       |  Q1,00 | P-&gt;P | HASH       |
|   7 |        HASH GROUP BY         |           |    46 |  1196 |       |       |  Q1,00 | PCWP |            |
|   8 |         PX PARTITION HASH ALL|           | 59158 |  1502K|     1 |    16 |  Q1,00 | PCWC |            |
|*  9 |          HASH JOIN           |           | 59158 |  1502K|       |       |  Q1,00 | PCWP |            |
|  10 |           TABLE ACCESS FULL  | CUSTOMERS | 55500 |   704K|     1 |    16 |  Q1,00 | PCWP |            |
|* 11 |           TABLE ACCESS FULL  | SALES     | 59158 |   751K|     1 |    16 |  Q1,00 | PCWP |            |
---------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(COUNT(SYS_OP_CSR(SYS_OP_MSR(COUNT(*)),0))&gt;100)
   9 - access("S"."CUST_ID"="C"."CUST_ID")
  11 - filter("S"."TIME_ID"&lt;=TO_DATE(' 1999-10-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') AND 
"S"."TIME_ID"&gt;=TO_DATE(' 1999-07-01
              00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Cost (%CPU)</code> and <code>Time</code> columns were removed from the plan table output in this example.</div>
<p>In Oracle RAC environments running on massive parallel processing (MPP) platforms, placing partitions on nodes is critical to achieving good scalability. To avoid remote I/O, both matching partitions should have affinity to the same node. Partition pairs should be spread over all of the nodes to avoid bottlenecks and to use all CPU resources available on the system.</p>
<p>Nodes can host multiple pairs when there are more pairs than nodes. For example, with an 8-node system and 16 partition pairs, each node receives two pairs.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink RACAD" href="../../rac.112/e41960/toc.htm"><span class="italic">Oracle Real Application Clusters Administration and Deployment Guide</span></a> for more information about data affinity</div>
</div>
<!-- class="sect3" -->
<a id="BABDBHCJ"></a><a id="VLDBG1244"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Full Partition-Wise Joins: Composite - Single-Level</h4>
<p><a id="sthref151"></a>This method is a variation of the single-level - single-level method. In this scenario, one table (typically the larger table) is composite partitioned on two dimensions, using the join columns as the subpartition key. In the example, the <code>sales</code> table is a typical example of a table storing historical data. Using range partitioning is a logical initial partitioning method for a table storing historical information.</p>
<p>For example, assume you want to partition the <code>sales</code> table into eight partitions by range on the column <code>time_id</code>. Also assume you have two years and that each partition represents a quarter. Instead of using range partitioning, you can use composite partitioning to enable a full partition-wise join while preserving the partitioning on <code>time_id</code>. For example, partition the <code>sales</code> table by range on <code>time_id</code> and then subpartition each partition by hash on <code>cust_id</code> using 16 subpartitions for each partition, for a total of 128 subpartitions. The <code>customers</code> table can use hash partitioning with 16 partitions.</p>
<p>When you use the method just described, a full partition-wise join works similarly to the one created by a single-level - single-level hash-hash method. The join is still divided into 16 smaller joins between hash partition pairs from both tables. The difference is that now each hash partition in the <code>sales</code> table is composed of a set of 8 subpartitions, one from each range partition.</p>
<p><a href="#i1006952">Figure 3-2</a> illustrates how the hash partitions are formed in the <code>sales</code> table. Each cell represents a subpartition. Each row corresponds to one range partition, for a total of 8 range partitions. Each range partition has 16 subpartitions. Each column corresponds to one hash partition for a total of 16 hash partitions; each hash partition has 8 subpartitions. Note that hash partitions can be defined only if all partitions have the same number of subpartitions, in this case, 16.</p>
<p>Hash partitions are implicit in a composite table. However, Oracle does not record them in the data dictionary, and you cannot manipulate them with DDL commands as you can range or list partitions.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006952"></a><a id="VLDBG1245"></a>Figure 3-2 Range and Hash Partitions of a Composite Table</p>
<img width="510" height="459" src="img/vldbg010.gif" alt="Description of Figure 3-2 follows" /><br />
<a id="sthref152" href="img_text/vldbg010.htm">Description of "Figure 3-2 Range and Hash Partitions of a Composite Table"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The following example shows the execution plan for the full partition-wise join with the <code>sales</code> table range partitioned by <code>time_id</code>, and subpartitioned by hash on <code>cust_id</code>.</p>
<pre>
----------------------------------------------------------------------------------------------
| Id  | Operation                            | Name      | Pstart| Pstop |IN-OUT| PQ Distrib |
----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |           |       |       |      |            |
|   1 |  PX COORDINATOR                      |           |       |       |      |            |
|   2 |   PX SEND QC (RANDOM)                | :TQ10001  |       |       | P-&gt;S | QC (RAND)  |
|*  3 |    FILTER                            |           |       |       | PCWC |            |
|   4 |     HASH GROUP BY                    |           |       |       | PCWP |            |
|   5 |      PX RECEIVE                      |           |       |       | PCWP |            |
|   6 |       PX SEND HASH                   | :TQ10000  |       |       | P-&gt;P | HASH       |
|   7 |        HASH GROUP BY                 |           |       |       | PCWP |            |
|   8 |         PX PARTITION HASH ALL        |           |     1 |    16 | PCWC |            |
|*  9 |          HASH JOIN                   |           |       |       | PCWP |            |
|  10 |           TABLE ACCESS FULL          | CUSTOMERS |     1 |    16 | PCWP |            |
|  11 |           PX PARTITION RANGE ITERATOR|           |     8 |     9 | PCWC |            |
|* 12 |            TABLE ACCESS FULL         | SALES     |   113 |   144 | PCWP |            |
----------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(COUNT(SYS_OP_CSR(SYS_OP_MSR(COUNT(*)),0))&gt;100)
   9 - access("S"."CUST_ID"="C"."CUST_ID")
  12 - filter("S"."TIME_ID"&lt;=TO_DATE(' 1999-10-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') AND 
"S"."TIME_ID"&gt;=TO_DATE(' 1999-07-01
              00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Rows</code>, <code>Cost (%CPU)</code>, <code>Time</code>, and <code>TQ</code> columns were removed from the plan table output in this example.</div>
<p>Composite - single-level partitioning is effective because it enables you to combine pruning on one dimension with a full partition-wise join on another dimension. In the previous example query, pruning is achieved by scanning only the subpartitions corresponding to Q3 of 1999, in other words, row number 3 in <a href="#i1006952">Figure 3-2</a>. Oracle then joins these subpartitions with the customer table, using a full partition-wise join.</p>
<p>All characteristics of the single-level - single-level partition-wise join apply to the composite - single-level partition-wise join. In particular, for this example, these two points are common to both methods:</p>
<ul>
<li>
<p>The degree of parallelism for this full partition-wise join cannot exceed 16. Even though the <code>sales</code> table has 128 subpartitions, it has only 16 hash partitions.</p>
</li>
<li>
<p>The rules for data placement on MPP systems apply here. The only difference is that a subpartition is now a collection of subpartitions. You must ensure that all of these subpartitions are placed on the same node as the matching hash partition from the other table. For example, in <a href="#i1006952">Figure 3-2</a>, store hash partition 9 of the <code>sales</code> table shown by the eight circled subpartitions, on the same node as hash partition 9 of the <code>customers</code> table.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABJBHIG"></a><a id="VLDBG1246"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Full Partition-Wise Joins: Composite - Composite</h4>
<p><a id="sthref153"></a>If needed, you can also partition the <code>customers</code> table by the composite method. For example, you partition it by range on a postal code column to enable pruning based on postal codes. You then subpartition it by hash on <code>cust_id</code> using the same number of partitions (16) to enable a partition-wise join on the hash dimension.</p>
<p>You can get full partition-wise joins on all combinations of partition and subpartition partitions: partition - partition, partition - subpartition, subpartition - partition, and subpartition - subpartition.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABBBBAD"></a><a id="VLDBG1247"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Partial Partition-Wise Joins</h3>
<p><a id="sthref154"></a><a id="sthref155"></a>Oracle Database can perform <a id="sthref156"></a><a id="sthref157"></a><a id="sthref158"></a>partial partition-wise joins only in parallel. Unlike full partition-wise joins, partial partition-wise joins require you to partition only one table on the join key, not both tables. The partitioned table is referred to as the reference table. The other table may or may not be partitioned. Partial partition-wise joins are more common than full partition-wise joins.</p>
<p>To execute a partial partition-wise join, the database dynamically repartitions the other table based on the partitioning of the reference table. After the other table is repartitioned, the execution is similar to a full partition-wise join.</p>
<p>The performance advantage that partial partition-wise joins have over joins in nonpartitioned tables is that the reference table is not moved during the join operation. Parallel joins between nonpartitioned tables require both input tables to be redistributed on the join key. This redistribution operation involves exchanging rows between parallel execution servers. This is a CPU-intensive operation that can lead to excessive interconnect traffic in Oracle RAC environments. Partitioning large tables on a join key, either a foreign or primary key, prevents this redistribution every time the table is joined on that key. Of course, if you choose a foreign key to partition the table, which is the most common scenario, then select a foreign key that is involved in many queries.</p>
<p>To illustrate partial partition-wise joins, consider the previous <code>sales/customers</code> example. Assume that <code>customers</code> is not partitioned or is partitioned on a column other than <code>cust_id</code>. Because <code>sales</code> is often joined with <code>customers</code> on <code>cust_id</code>, and because this join dominates our application workload, partition <code>sales</code> on <code>cust_id</code> to enable partial partition-wise joins every time <code>customers</code> and <code>sales</code> are joined. As with full partition-wise joins, you have several alternatives:</p>
<ul>
<li>
<p><a href="#BABBHAEF">Partial Partition-Wise Joins: Single-Level Partitioning</a></p>
</li>
<li>
<p><a href="#BABFCFBH">Partial Partition-Wise Joins: Composite</a></p>
</li>
</ul>
<a id="BABBHAEF"></a><a id="VLDBG1248"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Partial Partition-Wise Joins: Single-Level Partitioning</h4>
<p><a id="sthref159"></a>The simplest method to enable a partial partition-wise join is to partition <code>sales</code> by hash on <code>cust_id</code>. The number of partitions determines the maximum degree of parallelism, because the partition is the smallest granule of parallelism for partial partition-wise join operations.</p>
<p>The parallel execution of a partial partition-wise join is illustrated in <a href="#i1006993">Figure 3-3</a>, which assumes that both the degree of parallelism and the number of partitions of <code>sales</code> are 16. The execution involves two sets of query servers: one set, labeled <span class="italic">set 1</span> in <a href="#i1006993">Figure 3-3</a>, scans the <code>customers</code> table in parallel. The granule of parallelism for the scan operation is a range of blocks.</p>
<p>Rows from <code>customers</code> that are selected by the first set, in this case all rows, are redistributed to the second set of query servers by hashing <code>cust_id</code>. For example, all rows in <code>customers</code> that could have matching rows in partition <code>P1</code> of <code>sales</code> are sent to query server 1 in the second set. Rows received by the second set of query servers are joined with the rows from the corresponding partitions in <code>sales</code>. Query server number 1 in the second set joins all <code>customers</code> rows that it receives with partition <code>P1</code> of <code>sales</code>.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006993"></a><a id="VLDBG1249"></a>Figure 3-3 Partial Partition-Wise Join</p>
<img width="471" height="336" src="img/vldbg011.gif" alt="Description of Figure 3-3 follows" /><br />
<a id="sthref160" href="img_text/vldbg011.htm">Description of "Figure 3-3 Partial Partition-Wise Join"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The example below shows the execution plan for the partial partition-wise join between <code>sales</code> and <code>customers</code>.</p>
<pre>
-----------------------------------------------------------------------------------------------
| Id  | Operation                             | Name      | Pstart| Pstop |IN-OUT| PQ Distrib |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                      |           |       |       |      |            |
|   1 |  PX COORDINATOR                       |           |       |       |      |            |
|   2 |   PX SEND QC (RANDOM)                 | :TQ10002  |       |       | P-&gt;S | QC (RAND)  |
|*  3 |    FILTER                             |           |       |       | PCWC |            |
|   4 |     HASH GROUP BY                     |           |       |       | PCWP |            |
|   5 |      PX RECEIVE                       |           |       |       | PCWP |            |
|   6 |       PX SEND HASH                    | :TQ10001  |       |       | P-&gt;P | HASH       |
|   7 |        HASH GROUP BY                  |           |       |       | PCWP |            |
|*  8 |         HASH JOIN                     |           |       |       | PCWP |            |
|   9 |          PART JOIN FILTER CREATE      | :BF0000   |       |       | PCWP |            |
|  10 |           PX RECEIVE                  |           |       |       | PCWP |            |
|  11 |            PX SEND PARTITION (KEY)    | :TQ10000  |       |       | P-&gt;P | PART (KEY) |
|  12 |             PX BLOCK ITERATOR         |           |       |       | PCWC |            |
|  13 |              TABLE ACCESS FULL        | CUSTOMERS |       |       | PCWP |            |
|  14 |          PX PARTITION HASH JOIN-FILTER|           |:BF0000|:BF0000| PCWC |            |
|* 15 |           TABLE ACCESS FULL           | SALES     |:BF0000|:BF0000| PCWP |            |
-----------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(COUNT(SYS_OP_CSR(SYS_OP_MSR(COUNT(*)),0))&gt;100)
   8 - access("S"."CUST_ID"="C"."CUST_ID")
  15 - filter("S"."TIME_ID"&lt;=TO_DATE(' 1999-10-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') AND 
"S"."TIME_ID"&gt;=TO_DATE(' 1999-07-01
              00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre>
<p>Note that the query runs in parallel, as you can see in the plan because there are <code>PX</code> row sources. One table is partitioned, which is the <code>SALES</code> table. You can determine this because the <code>PX PARTITION HASH</code> row source contains a nonpartitioned table <code>CUSTOMERS</code> that is distributed through <code>PX SEND PARTITION</code> to a different slave set that performs the join.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Rows</code>, <code>Cost (%CPU)</code>, <code>Time</code>, and <code>TQ</code> columns were removed from the plan table output in this example.</div>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
This section is based on hash partitioning, but it also applies for range, list, and interval partial partition-wise joins.</div>
<p>Considerations for full partition-wise joins also apply to partial partition-wise joins:</p>
<ul>
<li>
<p>The degree of parallelism does not need to equal the number of partitions. In <a href="#i1006993">Figure 3-3</a>, the query executes with two sets of 16 query servers. In this case, Oracle assigns 1 partition to each query server of the second set. Again, the number of partitions should always be a multiple of the degree of parallelism.</p>
</li>
<li>
<p>In Oracle RAC environments on MPPs, each hash partition of <code>sales</code> should preferably have affinity to only one node to avoid remote I/Os. Also, spread partitions over all nodes to avoid bottlenecks and use all CPU resources available on the system. A node can host multiple partitions when there are more partitions than nodes.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink RACAD" href="../../rac.112/e41960/toc.htm"><span class="italic">Oracle Real Application Clusters Administration and Deployment Guide</span></a> for more information about data affinity</div>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABFCFBH"></a><a id="VLDBG1250"></a>
<div class="sect3">
<h4 class="sect3">Partial Partition-Wise Joins: Composite</h4>
<p><a id="sthref161"></a>As with full partition-wise joins, the prime partitioning method for the <code>sales</code> table is to use the range method on column <code>time_id</code>. This is because <code>sales</code> is a typical example of a table that stores historical data. To enable a partial partition-wise join while preserving this range partitioning, subpartition <code>sales</code> by hash on column <code>cust_id</code> using 16 subpartitions for each partition. Both pruning and partial partition-wise joins can be used if a query joins <code>customers</code> and <code>sales</code> and if the query has a selection predicate on <code>time_id</code>.</p>
<p>When the <code>sales</code> table is composite partitioned, the granule of parallelism for a partial partition-wise join is a hash partition and not a subpartition. Refer to <a href="#i1006952">Figure 3-2</a> for an illustration of a hash partition in a composite table. Again, the number of hash partitions should be a multiple of the degree of parallelism. Also, on an MPP system, ensure that each hash partition has affinity to a single node. In the previous example, the eight subpartitions composing a hash partition should have affinity to the same node.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
This section is based on range-hash, but it also applies for all other combinations of composite partial partition-wise joins.</div>
<p>The following example shows the execution plan for the query between <code>sales</code> and <code>customers</code> with sales range partitioned by <code>time_id</code> and subpartitioned by hash on <code>cust_id</code>.</p>
<pre>
---------------------------------------------------------------------------------------------
| Id  | Operation                           | Name      | Pstart| Pstop |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |           |       |       |      |            |
|   1 |  PX COORDINATOR                     |           |       |       |      |            |
|   2 |   PX SEND QC (RANDOM)               | :TQ10002  |       |       | P-&gt;S | QC (RAND)  |
|*  3 |    FILTER                           |           |       |       | PCWC |            |
|   4 |     HASH GROUP BY                   |           |       |       | PCWP |            |
|   5 |      PX RECEIVE                     |           |       |       | PCWP |            |
|   6 |       PX SEND HASH                  | :TQ10001  |       |       | P-&gt;P | HASH       |
|   7 |        HASH GROUP BY                |           |       |       | PCWP |            |
|*  8 |         HASH JOIN                   |           |       |       | PCWP |            |
|   9 |          PART JOIN FILTER CREATE    | :BF0000   |       |       | PCWP |            |
|  10 |           PX RECEIVE                |           |       |       | PCWP |            |
|  11 |            PX SEND PARTITION (KEY)  | :TQ10000  |       |       | P-&gt;P | PART (KEY) |
|  12 |             PX BLOCK ITERATOR       |           |       |       | PCWC |            |
|  13 |              TABLE ACCESS FULL      | CUSTOMERS |       |       | PCWP |            |
|  14 |          PX PARTITION RANGE ITERATOR|           |     8 |     9 | PCWC |            |
|  15 |           PX PARTITION HASH ALL     |           |     1 |    16 | PCWC |            |
|* 16 |            TABLE ACCESS FULL        | SALES     |   113 |   144 | PCWP |            |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(COUNT(SYS_OP_CSR(SYS_OP_MSR(COUNT(*)),0))&gt;100)
   8 - access("S"."CUST_ID"="C"."CUST_ID")
  16 - filter("S"."TIME_ID"&lt;=TO_DATE(' 1999-10-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') AND 
"S"."TIME_ID"&gt;=TO_DATE(' 1999-07-01
              00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Rows</code>, <code>Cost (%CPU)</code>, <code>Time</code>, and <code>TQ</code> columns were removed from the plan table output in this example.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHJCJJF"></a><a id="VLDBG00403"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Index Partitioning</h2>
<p><a id="sthref162"></a><a id="sthref163"></a><a id="sthref164"></a>The rules for partitioning indexes are similar to those for tables:</p>
<ul>
<li>
<p>An index can be partitioned unless:</p>
<ul>
<li>
<p>The index is a cluster index.</p>
</li>
<li>
<p>The index is defined on a clustered table.</p>
</li>
</ul>
</li>
<li>
<p>You can mix partitioned and nonpartitioned indexes with partitioned and nonpartitioned tables:</p>
<ul>
<li>
<p>A partitioned table can have partitioned or nonpartitioned indexes.</p>
</li>
<li>
<p>A nonpartitioned table can have partitioned or nonpartitioned indexes.</p>
</li>
</ul>
</li>
<li>
<p>Bitmap indexes on nonpartitioned tables cannot be partitioned.</p>
</li>
<li>
<p>A bitmap index on a partitioned table must be a local index.</p>
</li>
</ul>
<p>However, partitioned indexes are more complicated than partitioned tables because there are three types of partitioned indexes:</p>
<ul>
<li>
<p>Local prefixed</p>
</li>
<li>
<p>Local nonprefixed</p>
</li>
<li>
<p>Global prefixed</p>
</li>
</ul>
<p>Oracle Database supports all three types. However, there are some restrictions. For example, a key cannot be an expression when creating a local unique index on a partitioned table.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#BABFEDIA">Local Partitioned Indexes</a></p>
</li>
<li>
<p><a href="#BABDCGFE">Global Partitioned Indexes</a></p>
</li>
<li>
<p><a href="#BABEEJEG">Summary of Partitioned Index Types</a></p>
</li>
<li>
<p><a href="#BABHAAHH">The Importance of Nonprefixed Indexes</a></p>
</li>
<li>
<p><a href="#BABCBFJF">Performance Implications of Prefixed and Nonprefixed Indexes</a></p>
</li>
<li>
<p><a href="#BABGIJJH">Guidelines for Partitioning Indexes</a></p>
</li>
<li>
<p><a href="#BABJEFDD">Physical Attributes of Index Partitions</a></p>
</li>
</ul>
<a id="BABFEDIA"></a><a id="VLDBG1251"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Local Partitioned Indexes</h3>
<p><a id="sthref165"></a><a id="sthref166"></a><a id="sthref167"></a><a id="sthref168"></a>In a local index, all keys in a particular index partition refer only to rows stored in a single underlying table partition. A local index is created by specifying the <code>LOCAL</code> attribute.</p>
<p><a id="sthref169"></a><a id="sthref170"></a><a id="sthref171"></a>Oracle constructs the local index so that it is equipartitioned with the underlying table. Oracle partitions the index on the same columns as the underlying table, creates the same number of partitions or subpartitions, and gives them the same partition bounds as corresponding partitions of the underlying table.</p>
<p>Oracle also maintains the index partitioning automatically when partitions in the underlying table are added, dropped, merged, or split, or when hash partitions or subpartitions are added or coalesced. This ensures that the index remains equipartitioned with the table.</p>
<p>A local index can be created <code>UNIQUE</code> if the partitioning columns form a subset of the index columns. This restriction guarantees that rows with identical index keys always map into the same partition, where uniqueness violations can be detected.</p>
<p>Local indexes have the following advantages:</p>
<ul>
<li>
<p>Only one index partition must be rebuilt when a maintenance operation other than <code>SPLIT</code> <code>PARTITION</code> or <code>ADD</code> <code>PARTITION</code> is performed on an underlying table partition.</p>
</li>
<li>
<p>The duration of a partition maintenance operation remains proportional to partition size if the partitioned table has only local indexes.</p>
</li>
<li>
<p>Local indexes support partition independence.</p>
</li>
<li>
<p>Local indexes support smooth roll-out of old data and roll-in of new data in historical tables.</p>
</li>
<li>
<p>Oracle can take advantage of the fact that a local index is equipartitioned with the underlying table to generate better query access plans.</p>
</li>
<li>
<p>Local indexes simplify the task of tablespace incomplete recovery. To recover a partition or subpartition of a table to a point in time, you must also recover the corresponding index entries to the same point in time. The only way to accomplish this is with a local index. Then you can recover the corresponding table and index partitions or subpartitions.</p>
</li>
</ul>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABGEDCF">Local Prefixed Indexes</a></p>
</li>
<li>
<p><a href="#BABBHEBJ">Local Nonprefixed Indexes</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS037" href="../../appdev.112/e40758/d_pclxut.htm#ARPLS037"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for a description of the <code>DBMS_PCLXUTIL</code> package</div>
<a id="BABGEDCF"></a><a id="VLDBG1252"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Local Prefixed Indexes</h4>
<p><a id="sthref172"></a><a id="sthref173"></a><a id="sthref174"></a>A local index is prefixed if it is partitioned on a left prefix of the index columns and the subpartioning key is included in the index key. Local prefixed indexes can be unique or nonunique.</p>
<p><a id="sthref175"></a><a id="sthref176"></a>For example, if the <code>sales</code> table and its local index <code>sales_ix</code> are partitioned on the <code>week_num</code> column, then index <code>sales_ix</code> is local prefixed if it is defined on the columns (<code>week_num</code>, <code>xaction_num</code>). On the other hand, if index <code>sales_ix</code> is defined on column <code>product_num</code> then it is not prefixed.</p>
<p><a href="#i1008832">Figure 3-4</a> illustrates another example of a local prefixed index.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1008832"></a><a id="VLDBG1253"></a>Figure 3-4 Local Prefixed Index</p>
<img width="650" height="303" src="img/vldbg019.gif" alt="Description of Figure 3-4 follows" /><br />
<a id="sthref177" href="img_text/vldbg019.htm">Description of "Figure 3-4 Local Prefixed Index"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="BABBHEBJ"></a><a id="VLDBG1254"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Local Nonprefixed Indexes</h4>
<p><a id="sthref178"></a><a id="sthref179"></a><a id="sthref180"></a>A local index is nonprefixed if it is not partitioned on a left prefix of the index columns or if the index key does not include the subpartitioning key. You cannot have a unique local nonprefixed index unless the partitioning key is a subset of the index key.</p>
<p><a href="#i1008834">Figure 3-5</a> illustrates an example of a local nonprefixed index.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1008834"></a><a id="VLDBG1255"></a>Figure 3-5 Local Nonprefixed Index</p>
<img width="648" height="302" src="img/vldbg018.gif" alt="Description of Figure 3-5 follows" /><br />
<a id="sthref181" href="img_text/vldbg018.htm">Description of "Figure 3-5 Local Nonprefixed Index"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDCGFE"></a><a id="VLDBG1256"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Global Partitioned Indexes</h3>
<p><a id="sthref182"></a><a id="sthref183"></a><a id="sthref184"></a><a id="sthref185"></a>In a global partitioned index, the keys in a particular index partition may refer to rows stored in multiple underlying table partitions or subpartitions. A global index can be range or hash partitioned, though it can be defined on any type of partitioned table.</p>
<p>A global index is created by specifying the <code>GLOBAL</code> attribute. The database administrator is responsible for defining the initial partitioning of a global index at creation and for maintaining the partitioning over time. Index partitions can be merged or split as necessary.</p>
<p>Normally, a global index is not equipartitioned with the underlying table. There is nothing to prevent an index from being equipartitioned with the underlying table, but Oracle does not take advantage of the equipartitioning when generating query plans or executing partition maintenance operations. So an index that is equipartitioned with the underlying table should be created as <code>LOCAL</code>.</p>
<p>A global partitioned index contains a single B-tree with entries for all rows in all partitions. Each index partition may contain keys that refer to many different partitions or subpartitions in the table.</p>
<p>The highest partition of a global index must have a partition bound that includes all values that are <code>MAXVALUE</code>. This insures that all rows in the underlying table can be represented in the index.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1008305">Prefixed and Nonprefixed Global Partitioned Indexes</a></p>
</li>
<li>
<p><a href="#BABCBCBB">Management of Global Partitioned Indexes</a></p>
</li>
</ul>
<a id="i1008305"></a><a id="VLDBG1257"></a>
<div class="sect3">
<h4 class="sect3">Prefixed and Nonprefixed Global Partitioned Indexes</h4>
<p><a id="sthref186"></a><a id="sthref187"></a><a id="sthref188"></a>A global partitioned index is prefixed if it is partitioned on a left prefix of the index columns.A global partitioned index is nonprefixed if it is not partitioned on a left prefix of the index columns. Oracle does not support global nonprefixed partitioned indexes. See <a href="#i1008961">Figure 3-6</a> for an example.</p>
<p>Global prefixed partitioned indexes can be unique or nonunique. Nonpartitioned indexes are treated as global prefixed nonpartitioned indexes.</p>
</div>
<!-- class="sect3" -->
<a id="BABCBCBB"></a><a id="VLDBG1258"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Management of Global Partitioned Indexes</h4>
<p><a id="sthref189"></a><a id="sthref190"></a><a id="sthref191"></a>Global partitioned indexes are harder to manage than local indexes because of the following:</p>
<ul>
<li>
<p>When the data in an underlying table partition is moved or removed (<code>SPLIT</code>, <code>MOVE</code>, <code>DROP</code>, or <code>TRUNCATE</code>), all partitions of a global index are affected. Consequently global indexes do not support partition independence.</p>
</li>
<li>
<p>When an underlying table partition or subpartition is recovered to a point in time, all corresponding entries in a global index must be recovered to the same point in time. Because these entries may be scattered across all partitions or subpartitions of the index, mixed with entries for other partitions or subpartitions that are not being recovered, there is no way to accomplish this except by re-creating the entire global index.</p>
</li>
</ul>
<div class="figure">
<p class="titleinfigure"><a id="i1008961"></a><a id="VLDBG1259"></a>Figure 3-6 Global Prefixed Partitioned Index</p>
<img width="620" height="270" src="img/vldbg020.gif" alt="Description of Figure 3-6 follows" /><br />
<a id="sthref192" href="img_text/vldbg020.htm">Description of "Figure 3-6 Global Prefixed Partitioned Index"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABEEJEG"></a><a id="VLDBG1260"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Summary of Partitioned Index Types</h3>
<p><a id="sthref193"></a><a id="sthref194"></a><a id="sthref195"></a><a href="#g1010065">Table 3-1</a> summarizes the types of partitioned indexes that Oracle supports. The key points are:</p>
<ul>
<li>
<p>If an index is local, then it is equipartitioned with the underlying table. Otherwise, it is global.</p>
</li>
<li>
<p>A prefixed index is partitioned on a left prefix of the index columns. Otherwise, it is nonprefixed.</p>
</li>
</ul>
<div class="tblformalwide">
<p class="titleintable"><a id="VLDBG1261"></a><a id="sthref196"></a><a id="g1010065"></a>Table 3-1 Types of Partitioned Indexes</p>
<table class="cellalignment1835" title="Types of Partitioned Indexes" summary="Types of Partitioned Indexes" >
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t22">Type of Index</th>
<th class="cellalignment1836" id="r1c2-t22">Index Equipartitioned with Table</th>
<th class="cellalignment1836" id="r1c3-t22">Index Partitioned on Left Prefix of Index Columns</th>
<th class="cellalignment1836" id="r1c4-t22">UNIQUE Attribute Allowed</th>
<th class="cellalignment1836" id="r1c5-t22">Example: Table Partitioning Key</th>
<th class="cellalignment1836" id="r1c6-t22">Example: Index Columns</th>
<th class="cellalignment1836" id="r1c7-t22">Example: Index Partitioning Key</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t22" headers="r1c1-t22">
<p>Local Prefixed (any partitioning method)</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c2-t22">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c3-t22">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c4-t22">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c5-t22">
<p>A</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c6-t22">
<p>A, B</p>
</td>
<td class="cellalignment1837" headers="r2c1-t22 r1c7-t22">
<p>A</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t22" headers="r1c1-t22">
<p>Local Nonprefixed (any partitioning method)</p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c2-t22">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c3-t22">
<p>No</p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c4-t22">
<p>Yes<a id="sthref197" href="#sthref197" onclick='footdisplay(1,"For a unique local nonprefixed index, the partitioning key must be a subset of the index key.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c5-t22">
<p>A</p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c6-t22">
<p>B, A</p>
</td>
<td class="cellalignment1837" headers="r3c1-t22 r1c7-t22">
<p>A</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r4c1-t22" headers="r1c1-t22">
<p>Global Prefixed (range partitioning only)</p>
</td>
<td class="cellalignment1837" headers="r4c1-t22 r1c2-t22">
<p>No<a id="sthref198" href="#sthref198" onclick='footdisplay(2,"Although a global partitioned index may be equipartitioned with the underlying table, Oracle does not take advantage of the partitioning or maintain equipartitioning after partition maintenance operations such as DROP or SPLIT PARTITION.")'><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a></p>
</td>
<td class="cellalignment1837" headers="r4c1-t22 r1c3-t22">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r4c1-t22 r1c4-t22">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r4c1-t22 r1c5-t22">
<p>A</p>
</td>
<td class="cellalignment1837" headers="r4c1-t22 r1c6-t22">
<p>B</p>
</td>
<td class="cellalignment1837" headers="r4c1-t22 r1c7-t22">
<p>B</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup>For a unique local nonprefixed index, the partitioning key must be a subset of the index key.</p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2&nbsp;</sup>Although a global partitioned index may be equipartitioned with the underlying table, Oracle does not take advantage of the partitioning or maintain equipartitioning after partition maintenance operations such as DROP or SPLIT PARTITION.</p>
</div>
<!-- class="sect2" -->
<a id="BABHAAHH"></a><a id="VLDBG1262"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">The Importance of Nonprefixed Indexes</h3>
<p><a id="sthref199"></a><a id="sthref200"></a><a id="sthref201"></a>Nonprefixed indexes are particularly useful in historical databases. In a table containing historical data, it is common for an index to be defined on one column to support the requirements of fast access by that column. However, the index can also be partitioned on another column (the same column as the underlying table) to support the time interval for rolling out old data and rolling in new data.</p>
<p>Consider a <code>sales</code> table partitioned by week. It contains a year's worth of data, divided into 13 partitions. It is range partitioned on <code>week_no</code>, four weeks to a partition. You might create a nonprefixed local index <code>sales_ix</code> on <code>sales</code>. The <code>sales_ix</code> index is defined on <code>acct_no</code> because there are queries that need fast access to the data by account number. However, it is partitioned on <code>week_no</code> to match the <code>sales</code> table. Every four weeks, the oldest partitions of <code>sales</code> and <code>sales_ix</code> are dropped and new ones are added.</p>
</div>
<!-- class="sect2" -->
<a id="BABCBFJF"></a><a id="VLDBG1263"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performance Implications of Prefixed and Nonprefixed Indexes</h3>
<p><a id="sthref202"></a><a id="sthref203"></a>It is more expensive to probe into a nonprefixed index than to probe into a prefixed index. <a id="sthref204"></a><a id="sthref205"></a><a id="sthref206"></a><a id="sthref207"></a>If an index is prefixed (either local or global) and Oracle is presented with a predicate involving the index columns, then partition pruning can restrict application of the predicate to a subset of the index partitions.</p>
<p>For example, in <a href="#i1008832">Figure 3-4</a>, if the predicate is <code>deptno=15</code>, the optimizer knows to apply the predicate only to the second partition of the index. (If the predicate involves a bind variable, the optimizer does not know exactly which partition but it may still know there is only one partition involved, in which case at run time, only one index partition is accessed.)</p>
<p>When an index is nonprefixed, Oracle often has to apply a predicate involving the index columns to all <code>N</code> index partitions. This is required to look up a single key, or to do an index range scan. For a range scan, Oracle must also combine information from <code>N</code> index partitions. For example, in <a href="#i1008834">Figure 3-5</a>, a local index is partitioned on <code>chkdate</code> with an index key on <code>acctno</code>. If the predicate is <code>acctno=31</code>, Oracle probes all 12 index partitions.</p>
<p>Of course, if there is also a predicate on the partitioning columns, then multiple index probes might not be necessary. Oracle takes advantage of the fact that a local index is equipartitioned with the underlying table to prune partitions based on the partition key. For example, if the predicate in <a href="#i1008832">Figure 3-4</a> is <code>chkdate&lt;3/97</code>, Oracle only has to probe two partitions.</p>
<p>So for a nonprefixed index, if the partition key is a part of the <code>WHERE</code> clause but not of the index key, then the optimizer determines which index partitions to probe based on the underlying table partition.</p>
<p>When many queries and DML statements using keys of local, nonprefixed, indexes have to probe all index partitions, this effectively reduces the degree of partition independence provided by such indexes.</p>
<div class="tblformal">
<p class="titleintable"><a id="VLDBG1264"></a><a id="sthref208"></a><a id="sthref209"></a>Table 3-2 Comparing Prefixed Local, Nonprefixed Local, and Global Indexes</p>
<table class="cellalignment1838" title="Comparing Prefixed Local, Nonprefixed Local, and Global Indexes" summary="Comparing Prefixed Local, Nonprefixed Local, and Global Indexes" dir="ltr">
<thead>
<tr class="cellalignment1829">
<th class="cellalignment1836" id="r1c1-t23">Index Characteristics</th>
<th class="cellalignment1836" id="r1c2-t23">Prefixed Local</th>
<th class="cellalignment1836" id="r1c3-t23">Nonprefixed Local</th>
<th class="cellalignment1836" id="r1c4-t23">Global</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r2c1-t23" headers="r1c1-t23">
<p>Unique possible?</p>
</td>
<td class="cellalignment1837" headers="r2c1-t23 r1c2-t23">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r2c1-t23 r1c3-t23">
<p>Yes</p>
</td>
<td class="cellalignment1837" headers="r2c1-t23 r1c4-t23">
<p>Yes. Must be global if using indexes on columns other than the partitioning columns</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r3c1-t23" headers="r1c1-t23">
<p>Manageability</p>
</td>
<td class="cellalignment1837" headers="r3c1-t23 r1c2-t23">
<p>Easy to manage</p>
</td>
<td class="cellalignment1837" headers="r3c1-t23 r1c3-t23">
<p>Easy to manage</p>
</td>
<td class="cellalignment1837" headers="r3c1-t23 r1c4-t23">
<p>Harder to manage</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r4c1-t23" headers="r1c1-t23">
<p>OLTP</p>
</td>
<td class="cellalignment1837" headers="r4c1-t23 r1c2-t23">
<p>Good</p>
</td>
<td class="cellalignment1837" headers="r4c1-t23 r1c3-t23">
<p>Bad</p>
</td>
<td class="cellalignment1837" headers="r4c1-t23 r1c4-t23">
<p>Good</p>
</td>
</tr>
<tr class="cellalignment1829">
<td class="cellalignment1837" id="r5c1-t23" headers="r1c1-t23">
<p>Long Running (DSS)</p>
</td>
<td class="cellalignment1837" headers="r5c1-t23 r1c2-t23">
<p>Good</p>
</td>
<td class="cellalignment1837" headers="r5c1-t23 r1c3-t23">
<p>Good</p>
</td>
<td class="cellalignment1837" headers="r5c1-t23 r1c4-t23">
<p>Not Good</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="BABGIJJH"></a><a id="VLDBG1265"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Guidelines for Partitioning Indexes</h3>
<p><a id="sthref210"></a><a id="sthref211"></a><a id="sthref212"></a>When deciding how to partition indexes on a table, consider the mix of applications that must access the table. There is a trade-off between performance and availability and manageability. Here are some guidelines you should consider:</p>
<ul>
<li>
<p><a id="sthref213"></a>For OLTP applications:</p>
<ul>
<li>
<p>Global indexes and local prefixed indexes provide better performance than local nonprefixed indexes because they minimize the number of index partition probes.</p>
</li>
<li>
<p>Local indexes support more availability when there are partition or subpartition maintenance operations on the table. Local nonprefixed indexes are very useful for historical databases.</p>
</li>
</ul>
</li>
<li>
<p><a id="sthref214"></a>For DSS applications, local nonprefixed indexes can improve performance because many index partitions can be scanned in parallel by range queries on the index key.</p>
<p>For example, a query using the predicate "<code>acctno</code> between 40 and 45" on the table <code>checks</code> of <a href="#i1008832">Figure 3-4</a> causes parallel scans of all the partitions of the nonprefixed index <code>ix3</code>. On the other hand, a query using the predicate <code>deptno BETWEEN 40 AND 45</code> on the table <code>deptno</code> of <a href="#i1008834">Figure 3-5</a> cannot be parallelized because it accesses a single partition of the prefixed index <code>ix1</code>.</p>
</li>
<li>
<p>For historical tables, indexes should be local if possible. This limits the effect of regularly scheduled drop partition operations.</p>
</li>
<li>
<p>Unique indexes on columns other than the partitioning columns must be global because unique local nonprefixed indexes whose keys do not contain the partitioning key are not supported.</p>
</li>
<li>
<p>Unusable indexes do not consume space. See <a class="olink ADMIN11630" href="../../server.112/e25494/tables.htm#ADMIN11630"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABJEFDD"></a><a id="VLDBG1266"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Physical Attributes of Index Partitions</h3>
<p><a id="sthref215"></a><a id="sthref216"></a><a id="sthref217"></a><a id="sthref218"></a>Default physical attributes are initially specified when a <code>CREATE</code> <code>INDEX</code> statement creates a partitioned index. Because there is no segment corresponding to the partitioned index itself, these attributes are only used in derivation of physical attributes of member partitions. Default physical attributes can later be modified using <code>ALTER</code> <code>INDEX</code> <code>MODIFY</code> <code>DEFAULT</code> <code>ATTRIBUTES</code>.</p>
<p>Physical attributes of partitions created by <code>CREATE</code> <code>INDEX</code> are determined as follows:</p>
<ul>
<li>
<p>Values of physical attributes specified (explicitly or by default) for the index are used whenever the value of a corresponding partition attribute is not specified. Handling of the <code>TABLESPACE</code> attribute of partitions of a <code>LOCAL</code> index constitutes an important exception to this rule in that without a user-specified <code>TABLESPACE</code> value (at both partition and index levels), the value of the physical attribute of the corresponding partition of the underlying table is used.</p>
</li>
<li>
<p>Physical attributes (other than <code>TABLESPACE</code>, as explained in the preceding) of partitions of local indexes created during processing <code>ALTER</code> <code>TABLE</code> <code>ADD</code> <code>PARTITION</code> are set to the default physical attributes of each index.</p>
</li>
</ul>
<p>Physical attributes (other than <code>TABLESPACE</code>) of index partitions created by <code>ALTER</code> <code>TABLE</code> <code>SPLIT</code> <code>PARTITION</code> are determined as follows:</p>
<ul>
<li>
<p>Values of physical attributes of the index partition being split are used.</p>
</li>
</ul>
<p>Physical attributes of an existing index partition can be modified by <code>ALTER</code> <code>INDEX MODIFY</code> <code>PARTITION</code> and <code>ALTER</code> <code>INDEX</code> <code>REBUILD</code> <code>PARTITION</code>. Resulting attributes are determined as follows:</p>
<ul>
<li>
<p>Values of physical attributes of the partition before the statement was issued are used whenever a new value is not specified. Note that <code>ALTER</code> <code>INDEX</code> <code>REBUILD PARTITION</code> can change the tablespace in which a partition resides.</p>
</li>
</ul>
<p>Physical attributes of global index partitions created by <code>ALTER</code> <code>INDEX</code> <code>SPLIT PARTITION</code> are determined as follows:</p>
<ul>
<li>
<p>Values of physical attributes of the partition being split are used whenever a new value is not specified.</p>
</li>
<li>
<p>Physical attributes of all partitions of an index (along with default values) may be modified by <code>ALTER</code> <code>INDEX</code>, for example, <code>ALTER</code> <code>INDEX</code> <code>indexname</code> <code>NOLOGGING</code> changes the logging mode of all partitions of <code>indexname</code> to <code>NOLOGGING</code>.</p>
</li>
</ul>
<p>For more detailed examples of adding partitions and examples of rebuilding indexes, refer to <a href="part_admin.htm#g1030303">Chapter 4, "Partition Administration"</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CACFFCHI"></a><a id="VLDBG00404"></a>
<div class="sect1">
<h2 class="sect1">Partitioning and Table Compression</h2>
<p>You can compress several partitions or a complete partitioned heap-organized table. You do this <a id="sthref219"></a><a id="sthref220"></a><a id="sthref221"></a>by either defining a complete partitioned table as being compressed, or by defining it on a per-partition level. Partitions <a id="sthref222"></a><a id="sthref223"></a>without a specific declaration inherit the attribute from the table definition or, if nothing is specified on table level, from the tablespace definition.</p>
<p>The decision whether a partition should be compressed or uncompressed adheres to the same rules as a nonpartitioned table. However, due to the capability of range and composite partitioning to separate data logically into distinct partitions, such a partitioned table is an ideal candidate for compressing parts of the data (partitions) that are mainly read-only. For example, it is beneficial in all rolling window operations as a intermediate stage before aging out old data. With data segment compression, you can keep more old data online, minimizing the burden of additional storage consumption.</p>
<p>You can also change any existing uncompressed table partition later on, add new compressed and uncompressed partitions, or change the compression attribute as part of any partition maintenance operation that requires data movement, such as <code>MERGE</code> <code>PARTITION</code>, <code>SPLIT</code> <code>PARTITION</code>, or <code>MOVE</code> <code>PARTITION</code>. The partitions can contain data or can be empty.</p>
<p>The access and maintenance of a partially or fully compressed partitioned table are the same as for a fully uncompressed partitioned table. Everything that applies to fully uncompressed partitioned tables is also valid for partially or fully compressed partitioned tables.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABDEAEA">Table Compression and Bitmap Indexes</a></p>
</li>
<li>
<p><a href="#BABDACCG">Example of Table Compression and Partitioning</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink DWHSG003" href="../../server.112/e25554/physical.htm#DWHSG003"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for a generic discussion of table compression</p>
</li>
<li>
<p><a class="olink ADMIN11630" href="../../server.112/e25494/tables.htm#ADMIN11630"><span class="italic">Oracle Database Administrator's Guide</span></a> for more detailed information</p>
</li>
<li>
<p><a class="olink PFGRF013" href="../../server.112/e41573/build_db.htm#PFGRF013"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for an example of calculating the compression ratio</p>
</li>
</ul>
</div>
<a id="BABDEAEA"></a><a id="VLDBG1267"></a>
<div class="sect2">
<h3 class="sect2">Table Compression and Bitmap Indexes</h3>
<p><a id="sthref224"></a><a id="sthref225"></a><a id="sthref226"></a>To use table compression on partitioned tables with bitmap indexes, you must do the following before you introduce the compression attribute for the first time:</p>
<ol>
<li>
<p>Mark bitmap indexes unusable.</p>
</li>
<li>
<p>Set the compression attribute.</p>
</li>
<li>
<p>Rebuild the indexes.</p>
</li>
</ol>
<p>The first time you make a compressed partition part of an existing, fully uncompressed partitioned table, you must either drop all existing bitmap indexes or mark them <code>UNUSABLE</code> before adding a compressed partition. This must be done irrespective of whether any partition contains any data. It is also independent of the operation that causes one or more compressed partitions to become part of the table. This does not apply to a partitioned table having B-tree indexes only.</p>
<p>This rebuilding of the bitmap index structures is necessary to accommodate the potentially higher number of rows stored for each data block with table compression enabled. Enabling table compression must be done only for the first time. All subsequent operations, whether they affect compressed or uncompressed partitions, or change the compression attribute, behave identically for uncompressed, partially compressed, or fully compressed partitioned tables.</p>
<p>To avoid the recreation of any bitmap index structure, Oracle recommends creating every partitioned table with at least one compressed partition whenever you plan to partially or fully compress the partitioned table in the future. This compressed partition can stay empty or even can be dropped after the partition table creation.</p>
<p>Having a partitioned table with compressed partitions can lead to slightly larger bitmap index structures for the uncompressed partitions. The bitmap index structures for the compressed partitions, however, are usually smaller than the appropriate bitmap index structure before table compression. This highly depends on the achieved compression rates.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Database raises an error if compression is introduced to an object for the first time and there are usable bitmap index segments.</div>
</div>
<!-- class="sect2" -->
<a id="BABDACCG"></a><a id="VLDBG1268"></a>
<div class="sect2">
<h3 class="sect2">Example of Table Compression and Partitioning</h3>
<p><a id="sthref227"></a><a id="sthref228"></a>The following statement moves and compresses an existing partition <code>sales_q1_1998</code> of table <code>sales</code>:</p>
<pre>
ALTER TABLE sales
  MOVE PARTITION sales_q1_1998 TABLESPACE ts_arch_q1_1998 COMPRESS;
</pre>
<p><a id="sthref229"></a><a id="sthref230"></a>Alternatively, you could choose Hybrid Columnar Compression (HCC), as in the following:</p>
<pre>
ALTER TABLE sales
  MOVE PARTITION sales_q1_1998 TABLESPACE ts_arch_q1_1998
  COMPRESS FOR ARCHIVE LOW;
</pre>
<p>If you use the <code>MOVE</code> statement, then the local indexes for partition <code>sales_q1_1998</code> become unusable. You must rebuild them afterward, as follows:</p>
<pre>
ALTER TABLE sales
  MODIFY PARTITION sales_q1_1998 REBUILD UNUSABLE LOCAL INDEXES;
</pre>
<p>You can also include the <code>UPDATE INDEXES</code> clause in the <code>MOVE</code> statement in order for the entire operation to be completed automatically without any negative effect on users accessing the table.</p>
<p>The following statement merges two existing partitions into a new, compressed partition, residing in a separate tablespace. The local bitmap indexes have to be rebuilt afterward, as in the following:</p>
<pre>
ALTER TABLE sales MERGE PARTITIONS sales_q1_1998, sales_q2_1998 
  INTO PARTITION sales_1_1998 TABLESPACE ts_arch_1_1998 
  COMPRESS FOR OLTP UPDATE INDEXES;
</pre>
<p>For more details and examples for partition management operations, refer to <a href="part_admin.htm#g1030303">Chapter 4, "Partition Administration"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for details regarding how to estimate the compression ratio when using table compression</p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for the SQL syntax</p>
</li>
<li>
<p><a class="olink CNCPT89198" href="../../server.112/e40540/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a> for more information about Hybrid Columnar Compression. Hybrid Columnar Compression is a feature of certain Oracle storage systems.</p>
</li>
<li>
<p><a class="olink ADMIN13521" href="../../server.112/e25494/tables.htm#ADMIN13521"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about changing the compression level using online redefinition</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CACHHFHH"></a><a id="VLDBG00406"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Recommendations for Choosing a Partitioning Strategy</h2>
<p><a id="sthref231"></a><a id="sthref232"></a><a id="sthref233"></a>The following sections provide recommendations for choosing a partitioning strategy:</p>
<ul>
<li>
<p><a href="#CACGFGJH">When to Use Range or Interval Partitioning</a></p>
</li>
<li>
<p><a href="#CACGEGJA">When to Use Hash Partitioning</a></p>
</li>
<li>
<p><a href="#CACFICAI">When to Use List Partitioning</a></p>
</li>
<li>
<p><a href="#BJEGIAIJ">When to Use Composite Partitioning</a></p>
</li>
<li>
<p><a href="#BJEFIFCE">When to Use Interval Partitioning</a></p>
</li>
<li>
<p><a href="#BJECHCAG">When to Use Reference Partitioning</a></p>
</li>
<li>
<p><a href="#BJEFFAGH">When to Partition on Virtual Columns</a></p>
</li>
<li>
<p><a href="#BABIEEGC">Considerations When Using Read-Only Tablespaces</a></p>
</li>
</ul>
<a id="CACGFGJH"></a><a id="VLDBG1269"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">When to Use Range or Interval Partitioning</h3>
<p><a id="sthref234"></a><a id="sthref235"></a>Range partitioning is a convenient method for partitioning historical data. The boundaries of range partitions define the ordering of the partitions in the tables or indexes.</p>
<p>Interval partitioning is an extension to range partitioning in which, beyond a point in time, partitions are defined by an interval. Interval partitions are automatically created by the database when data is inserted into the partition.</p>
<p>Range or interval partitioning is often used to organize data by time intervals on a column of type <code>DATE</code>. Thus, most SQL statements accessing range partitions focus on timeframes. An example of this is a SQL statement similar to "select data from a particular period in time". In such a scenario, if each partition represents data for one month, the query "find data of month 06-DEC" must access only the December partition of year 2006. This reduces the amount of data scanned to a fraction of the total data available, an optimization method called partition pruning.</p>
<p>Range partitioning is also ideal when you periodically load new data and purge old data, because it is easy to add or drop partitions. For example, it is common to keep a rolling window of data, keeping the past 36 months' worth of data online. Range partitioning simplifies this process. To add data from a new month, you load it into a separate table, clean it, index it, and then add it to the range-partitioned table using the <code>EXCHANGE</code> <code>PARTITION</code> statement, all while the original table remains online. After you add the new partition, you can drop the trailing month with the <code>DROP</code> <code>PARTITION</code> statement. The alternative to using the <code>DROP</code> <code>PARTITION</code> statement can be to archive the partition and make it read only, but this works only when your partitions are in separate tablespaces. You can also implement a rolling window of data using inserts into the partitioned table.</p>
<p>Interval partitioning provides an easy way for interval partitions to be automatically created as data arrives. Interval partitions can also be used for all other partition maintenance operations. Refer to <a href="part_admin.htm#g1030303">Chapter 4, "Partition Administration"</a> for more information about the partition maintenance operations on interval partitions.</p>
<p>In conclusion, consider using <a id="sthref236"></a><a id="sthref237"></a>range or interval partitioning when:</p>
<ul>
<li>
<p>Very large tables are frequently scanned by a range predicate on a good partitioning column, such as <code>ORDER_DATE</code> or <code>PURCHASE_DATE</code>. Partitioning the table on that column enables partition pruning.</p>
</li>
<li>
<p>You want to maintain a rolling window of data.</p>
</li>
<li>
<p>You cannot complete administrative operations, such as backup and restore, on large tables in an allotted time frame, but you can divide them into smaller logical pieces based on the partition range column.</p>
</li>
</ul>
<p><a href="#BABJHDBE">Example 3-3</a> creates the table <code>salestable</code> for a period of two years, 2005 and 2006, and partitions it by range according to the column <code>s_salesdate</code> to separate the data into eight quarters, each corresponding to a partition. Future partitions are created automatically through the monthly interval definition. Interval partitions are created in the provided list of tablespaces in a round-robin manner. Analysis of sales figures by a short interval can take advantage of partition pruning. The sales table also supports a rolling window approach.</p>
<div class="example">
<p class="titleinexample"><a id="BABJHDBE"></a><a id="VLDBG14029"></a>Example 3-3 Creating a table with range and interval partitioning</p>
<pre>
CREATE TABLE salestable
  (s_productid  NUMBER,
   s_saledate   DATE,
   s_custid     NUMBER,
   s_totalprice NUMBER)
PARTITION BY RANGE(s_saledate)
INTERVAL(NUMTOYMINTERVAL(1,'MONTH')) STORE IN (tbs1,tbs2,tbs3,tbs4)
 (PARTITION sal05q1 VALUES LESS THAN (TO_DATE('01-APR-2005', 'DD-MON-YYYY'))
   TABLESPACE tbs1,
  PARTITION sal05q2 VALUES LESS THAN (TO_DATE('01-JUL-2005', 'DD-MON-YYYY')) 
   TABLESPACE tbs2,
  PARTITION sal05q3 VALUES LESS THAN (TO_DATE('01-OCT-2005', 'DD-MON-YYYY')) 
   TABLESPACE tbs3,
  PARTITION sal05q4 VALUES LESS THAN (TO_DATE('01-JAN-2006', 'DD-MON-YYYY')) 
   TABLESPACE tbs4,
  PARTITION sal06q1 VALUES LESS THAN (TO_DATE('01-APR-2006', 'DD-MON-YYYY')) 
   TABLESPACE tbs1,
  PARTITION sal06q2 VALUES LESS THAN (TO_DATE('01-JUL-2006', 'DD-MON-YYYY')) 
   TABLESPACE tbs2,
  PARTITION sal06q3 VALUES LESS THAN (TO_DATE('01-OCT-2006', 'DD-MON-YYYY')) 
   TABLESPACE tbs3,
  PARTITION sal06q4 VALUES LESS THAN (TO_DATE('01-JAN-2007', 'DD-MON-YYYY')) 
   TABLESPACE tbs4);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CACGEGJA"></a><a id="VLDBG1270"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">When to Use Hash Partitioning</h3>
<p><a id="sthref238"></a><a id="sthref239"></a>There are times when it is not obvious in which partition data should reside, although the partitioning key can be identified. Rather than group similar data, there are times when it is desirable to distribute data such that it does not correspond to a business or a logical view of the data, as it does in range partitioning. With hash partitioning, a row is placed into a partition based on the result of passing the partitioning key into a hashing algorithm.</p>
<p>Using this approach, data is randomly distributed across the partitions rather than grouped. This is a good approach for some data, but may not be an effective way to manage historical data. However, hash partitions share some performance characteristics with range partitions. For example, partition pruning is limited to equality predicates. You can also use partition-wise joins, parallel index access, and parallel DML. See <a href="#CIHCDBIF">"Partition-Wise Joins"</a> for more information.</p>
<p>As a general rule, use hash partitioning for the following purposes:</p>
<ul>
<li>
<p>To enable partial or full parallel partition-wise joins with likely equisized partitions.</p>
</li>
<li>
<p>To distribute data evenly among the nodes of an MPP platform that uses Oracle Real Application Clusters. Consequently, you can minimize interconnect traffic when processing internode parallel statements.</p>
</li>
<li>
<p>To use partition pruning and partition-wise joins according to a partitioning key that is mostly constrained by a distinct value or value list.</p>
</li>
<li>
<p>To randomly distribute data to avoid I/O bottlenecks if you do not use a storage management technique that stripes and mirrors across all available devices.</p>
<p>For more information, refer to <a href="vldb_storage.htm#BABFABIH">Chapter 10, "Storage Management for VLDBs"</a>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
With hash partitioning, only equality or <code>IN</code>-list predicates are supported for partition pruning.</div>
<p>For optimal data distribution, the following requirements should be satisfied:</p>
<ul>
<li>
<p>Choose a column or combination of columns that is unique or almost unique.</p>
</li>
<li>
<p>Create multiple partitions and subpartitions for each partition that is a power of two. For example, 2, 4, 8, 16, 32, 64, 128, and so on.</p>
</li>
</ul>
<p><a href="#BABICGIB">Example 3-4</a> creates four hash partitions for the table <code>sales_hash</code> using the column <code>s_productid</code> as the partitioning key. Parallel joins with the products table can take advantage of partial or full partition-wise joins. Queries accessing sales figures for only a single product or a list of products benefit from partition pruning.</p>
<div class="example">
<p class="titleinexample"><a id="BABICGIB"></a><a id="VLDBG14030"></a>Example 3-4 Creating a table with hash partitioning</p>
<pre>
CREATE TABLE sales_hash
  (s_productid  NUMBER,
   s_saledate   DATE,
   s_custid     NUMBER,
   s_totalprice NUMBER)
PARTITION BY HASH(s_productid)
( PARTITION p1 TABLESPACE tbs1
, PARTITION p2 TABLESPACE tbs2
, PARTITION p3 TABLESPACE tbs3
, PARTITION p4 TABLESPACE tbs4
);
</pre></div>
<!-- class="example" -->
<p>If you do not explicitly specify partition names, but instead you specify the number of hash partitions, then Oracle automatically generates internal names for the partitions. Also, you can use the <code>STORE</code> <code>IN</code> clause to assign hash partitions to tablespaces in a round-robin manner. For more examples, refer to <a href="part_admin.htm#g1030303">Chapter 4, "Partition Administration"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for partitioning syntax</div>
</div>
<!-- class="sect2" -->
<a id="CACFICAI"></a><a id="VLDBG1271"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">When to Use List Partitioning</h3>
<p><a id="sthref240"></a><a id="sthref241"></a>You should use list partitioning when you want to specifically map rows to partitions based on discrete values. In <a href="#BABJAEDA">Example 3-5</a>, all the customers for states Oregon and Washington are stored in one partition and customers in other states are stored in different partitions. Account managers who analyze their accounts by region can take advantage of partition pruning.</p>
<div class="example">
<p class="titleinexample"><a id="BABJAEDA"></a><a id="VLDBG14031"></a>Example 3-5 Creating a table with list partitioning</p>
<pre>
CREATE TABLE accounts
( id             NUMBER
, account_number NUMBER
, customer_id    NUMBER
, branch_id      NUMBER
, region         VARCHAR(2)
, status         VARCHAR2(1)
)
PARTITION BY LIST (region)
( PARTITION p_northwest VALUES ('OR', 'WA')
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
, PARTITION p_southeast VALUES ('FL', 'GA')
, PARTITION p_northcentral VALUES ('SD', 'WI')
, PARTITION p_southcentral VALUES ('OK', 'TX')
);
</pre></div>
<!-- class="example" -->
<p>Unlike range and hash partitioning, multi-column partition keys are not supported for list partitioning. If a table is partitioned by list, the partitioning key can only consist of a single column of the table.</p>
</div>
<!-- class="sect2" -->
<a id="BJEGIAIJ"></a><a id="VLDBG1272"></a>
<div class="sect2">
<h3 class="sect2">When to Use Composite Partitioning</h3>
<p><a id="sthref242"></a><a id="sthref243"></a>Composite partitioning offers the benefits of partitioning on two dimensions. From a performance perspective you can take advantage of partition pruning on one or two dimensions depending on the SQL statement, and you can take advantage of the use of full or partial partition-wise joins on either dimension.</p>
<p>You can take advantage of parallel backup and recovery of a single table. Composite partitioning also increases the number of partitions significantly, which may be beneficial for efficient parallel execution. From a manageability perspective, you can implement a rolling window to support historical data and still partition on another dimension if many statements can benefit from partition pruning or partition-wise joins.</p>
<p>You can split backups of your tables and you can decide to store data differently based on identification by a partitioning key. For example, you may decide to store data for a specific product type in a read-only, compressed format, and keep other product type data uncompressed.</p>
<p>The database stores every subpartition in a composite partitioned table as a separate segment. Thus, the subpartitions may have properties that differ from the properties of the table or from the partition to which the subpartitions belong.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CACGFGJH">When to Use Range or Interval Partitioning</a></p>
</li>
<li>
<p><a href="#CACGEGJA">When to Use Hash Partitioning</a></p>
</li>
<li>
<p><a href="#CACFICAI">When to Use List Partitioning</a></p>
</li>
<li>
<p><a href="#BJEGIAIJ">When to Use Composite Partitioning</a></p>
</li>
<li>
<p><a href="#BJEFIFCE">When to Use Interval Partitioning</a></p>
</li>
<li>
<p><a href="#BJECHCAG">When to Use Reference Partitioning</a></p>
</li>
<li>
<p><a href="#BJEFFAGH">When to Partition on Virtual Columns</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for details regarding syntax and restrictions</div>
<a id="VLDBG1273"></a>
<div class="sect3"><a id="sthref244"></a>
<h4 class="sect3">When to Use Composite Range-Hash Partitioning</h4>
<p><a id="sthref245"></a><a id="sthref246"></a>Composite range-hash partitioning is particularly common for tables that store history, are very large consequently, and are frequently joined with other large tables. For these types of tables (typical of data warehouse systems), composite range-hash partitioning provides the benefit of partition pruning at the range level with the opportunity to perform parallel full or partial partition-wise joins at the hash level. Specific cases can benefit from partition pruning on both dimensions for specific SQL statements.</p>
<p>Composite range-hash partitioning can also be used for tables that traditionally use hash partitioning, but also use a rolling window approach. Over time, data can be moved from one storage tier to another storage tier, compressed, stored in a read-only tablespace, and eventually purged. Information Lifecycle Management (ILM) scenarios often use range partitions to implement a tiered storage approach. See <a href="part_lifecycle.htm#CACECAFB">Chapter 5, "Using Partitioning for Information Lifecycle Management"</a> for more details.</p>
<p><a href="#BABIJJBI">Example 3-6</a> is an example of a range-hash partitioned <code>page_history</code> table of an Internet service provider. The table definition is optimized for historical analysis for either specific <code>client_ip</code> values (in which case queries benefit from partition pruning) or for analysis across many IP addresses, in which case queries can take advantage of full or partial partition-wise joins.</p>
<div class="example">
<p class="titleinexample"><a id="BABIJJBI"></a><a id="VLDBG14032"></a>Example 3-6 Creating a table with composite range-hash partitioning</p>
<pre>
CREATE TABLE page_history
( id                NUMBER NOT NULL
, url               VARCHAR2(300) NOT NULL
, view_date         DATE NOT NULL
, client_ip         VARCHAR2(23) NOT NULL
, from_url          VARCHAR2(300)
, to_url            VARCHAR2(300)
, timing_in_seconds NUMBER
) PARTITION BY RANGE(view_date) INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY HASH(client_ip)
SUBPARTITIONS 32
(PARTITION p0 VALUES LESS THAN (TO_DATE('01-JAN-2006','dd-MON-yyyy')))
PARALLEL 32 COMPRESS;
</pre></div>
<!-- class="example" -->
<p>This example shows the use of interval partitioning. Interval partitioning can be used in addition to range partitioning in order for interval partitions to be created automatically as data is inserted into the table.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1274"></a>
<div class="sect3"><a id="sthref247"></a>
<h4 class="sect3">When to Use Composite Range-List Partitioning</h4>
<p><a id="sthref248"></a><a id="sthref249"></a>Composite range-list partitioning is commonly used for large tables that store historical data and are commonly accessed on multiple dimensions. Often the historical view of the data is one access path, but certain business cases add another categorization to the access path. For example, regional account managers are very interested in how many new customers they signed up in their region in a specific time period. ILM and its tiered storage approach is a common reason to create range-list partitioned tables so that older data can be moved and compressed, but partition pruning on the list dimension is still available.</p>
<p><a href="#BABCCGFA">Example 3-7</a> creates a range-list partitioned <code>call_detail_records</code> table. A telecommunication company can use this table to analyze specific types of calls over time. The table uses local indexes on <code>from_number</code> and <code>to_number</code>.</p>
<div class="example">
<p class="titleinexample"><a id="BABCCGFA"></a><a id="VLDBG14033"></a>Example 3-7 Creating a table with composite range-list partitioning</p>
<pre>
CREATE TABLE call_detail_records
( id NUMBER
, from_number        VARCHAR2(20)
, to_number          VARCHAR2(20)
, date_of_call       DATE
, distance           VARCHAR2(1)
, call_duration_in_s NUMBER(4)
) PARTITION BY RANGE(date_of_call)
INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY LIST(distance)
SUBPARTITION TEMPLATE
( SUBPARTITION local VALUES('L') TABLESPACE tbs1
, SUBPARTITION medium_long VALUES ('M') TABLESPACE tbs2
, SUBPARTITION long_distance VALUES ('D') TABLESPACE tbs3
, SUBPARTITION international VALUES ('I') TABLESPACE tbs4
)
(PARTITION p0 VALUES LESS THAN (TO_DATE('01-JAN-2005','dd-MON-yyyy')))
PARALLEL;

CREATE INDEX from_number_ix ON call_detail_records(from_number)
LOCAL PARALLEL NOLOGGING;

CREATE INDEX to_number_ix ON call_detail_records(to_number)
LOCAL PARALLEL NOLOGGING;
</pre></div>
<!-- class="example" -->
<p>This example shows the use of interval partitioning. Interval partitioning can be used in addition to range partitioning in order for interval partitions to be created automatically as data is inserted into the table.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1275"></a>
<div class="sect3"><a id="sthref250"></a>
<h4 class="sect3">When to Use Composite Range-Range Partitioning</h4>
<p><a id="sthref251"></a><a id="sthref252"></a>Composite range-range partitioning is useful for applications that store time-dependent data on multiple time dimensions. Often these applications do not use one particular time dimension to access the data, but rather another time dimension, or sometimes both at the same time. For example, a web retailer wants to analyze its sales data based on when orders were placed, and when orders were shipped (handed over to the shipping company).</p>
<p>Other business cases for composite range-range partitioning include ILM scenarios, and applications that store historical data and want to categorize its data by range on another dimension.</p>
<p><a href="#BABDJAJH">Example 3-8</a> shows a range-range partitioned table <code>account_balance_history</code>. A bank may use access to individual subpartitions to contact its customers for low-balance reminders or specific promotions relevant to a certain category of customers.</p>
<div class="example">
<p class="titleinexample"><a id="BABDJAJH"></a><a id="VLDBG14034"></a>Example 3-8 Creating a table with composite range-range partitioning</p>
<pre>
CREATE TABLE account_balance_history
( id                 NUMBER NOT NULL
, account_number     NUMBER NOT NULL
, customer_id        NUMBER NOT NULL
, transaction_date   DATE NOT NULL
, amount_credited    NUMBER
, amount_debited     NUMBER
, end_of_day_balance NUMBER NOT NULL
) PARTITION BY RANGE(transaction_date)
INTERVAL (NUMTODSINTERVAL(7,'DAY'))
SUBPARTITION BY RANGE(end_of_day_balance)
SUBPARTITION TEMPLATE
( SUBPARTITION unacceptable VALUES LESS THAN (-1000)
, SUBPARTITION credit VALUES LESS THAN (0)
, SUBPARTITION low VALUES LESS THAN (500)
, SUBPARTITION normal VALUES LESS THAN (5000)
, SUBPARTITION high VALUES LESS THAN (20000)
, SUBPARTITION extraordinary VALUES LESS THAN (MAXVALUE)
)
(PARTITION p0 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy')));
</pre></div>
<!-- class="example" -->
<p>This example shows the use of interval partitioning. Interval partitioning can be used in addition to range partitioning in order for interval partitions to be created automatically as data is inserted into the table. In this case 7-day (weekly) intervals are created, starting Monday, January 1, 2007.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1276"></a>
<div class="sect3"><a id="sthref253"></a>
<h4 class="sect3">When to Use Composite List-Hash Partitioning</h4>
<p><a id="sthref254"></a><a id="sthref255"></a>Composite list-hash partitioning is useful for large tables that are usually accessed on one dimension, but (due to their size) still must take advantage of parallel full or partial partition-wise joins on another dimension in joins with other large tables.</p>
<p><a href="#BABBDHAI">Example 3-9</a> shows a <code>credit_card_accounts</code> table. The table is list-partitioned on region in order for account managers to quickly access accounts in their region. The subpartitioning strategy is hash on <code>customer_id</code> so that queries against the transactions table, which is subpartitioned on <code>customer_id</code>, can take advantage of full partition-wise joins. Joins with the hash-partitioned customers table can also benefit from full partition-wise joins. The table has a local bitmap index on the <code>is_active</code> column.</p>
<div class="example">
<p class="titleinexample"><a id="BABBDHAI"></a><a id="VLDBG14035"></a>Example 3-9 Creating a table with composite list-hash partitioning</p>
<pre>
CREATE TABLE credit_card_accounts
( account_number  NUMBER(16) NOT NULL
, customer_id     NUMBER NOT NULL
, customer_region VARCHAR2(2) NOT NULL
, is_active       VARCHAR2(1) NOT NULL
, date_opened     DATE NOT NULL
) PARTITION BY LIST (customer_region)
SUBPARTITION BY HASH (customer_id)
SUBPARTITIONS 16
( PARTITION emea VALUES ('EU','ME','AF')
, PARTITION amer VALUES ('NA','LA')
, PARTITION apac VALUES ('SA','AU','NZ','IN','CH')
) PARALLEL;

CREATE BITMAP INDEX is_active_bix ON credit_card_accounts(is_active)
LOCAL PARALLEL NOLOGGING;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="VLDBG1277"></a>
<div class="sect3"><a id="sthref256"></a>
<h4 class="sect3">When to Use Composite List-List Partitioning</h4>
<p><a id="sthref257"></a><a id="sthref258"></a>Composite list-list partitioning is useful for large tables that are often accessed on different dimensions. You can specifically map rows to partitions on those dimensions based on discrete values.</p>
<p><a href="#BABDJFGA">Example 3-10</a> shows an example of a very frequently accessed <code>current_inventory</code> table. The table is constantly updated with the current inventory in the supermarket supplier's local warehouses. Potentially perishable foods are supplied from those warehouses to supermarkets, and it is important to optimize supplies and deliveries. The table has local indexes on <code>warehouse_id</code> and <code>product_id</code>.</p>
<div class="example">
<p class="titleinexample"><a id="BABDJFGA"></a><a id="VLDBG14036"></a>Example 3-10 Creating a table with composite list-list partitioning</p>
<pre>
CREATE TABLE current_inventory
( warehouse_id      NUMBER
, warehouse_region  VARCHAR2(2)
, product_id        NUMBER
, product_category  VARCHAR2(12)
, amount_in_stock   NUMBER
, unit_of_shipping  VARCHAR2(20)
, products_per_unit NUMBER
, last_updated      DATE
) PARTITION BY LIST (warehouse_region)
SUBPARTITION BY LIST (product_category)
SUBPARTITION TEMPLATE
( SUBPARTITION perishable VALUES ('DAIRY','PRODUCE','MEAT','BREAD')
, SUBPARTITION non_perishable VALUES ('CANNED','PACKAGED')
, SUBPARTITION durable VALUES ('TOYS','KITCHENWARE')
)
( PARTITION p_northwest VALUES ('OR', 'WA')
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
, PARTITION p_southeast VALUES ('FL', 'GA')
, PARTITION p_northcentral VALUES ('SD', 'WI')
, PARTITION p_southcentral VALUES ('OK', 'TX')
);

CREATE INDEX warehouse_id_ix ON current_inventory(warehouse_id)
LOCAL PARALLEL NOLOGGING;

CREATE INDEX product_id_ix ON current_inventory(product_id)
LOCAL PARALLEL NOLOGGING;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="VLDBG1278"></a>
<div class="sect3"><a id="sthref259"></a>
<h4 class="sect3">When to Use Composite List-Range Partitioning</h4>
<p><a id="sthref260"></a><a id="sthref261"></a>Composite list-range partitioning is useful for large tables that are accessed on different dimensions. For the most commonly used dimension, you can specifically map rows to partitions on discrete values. List-range partitioning is commonly used for tables that use range values within a list partition, whereas range-list partitioning is commonly used for a discrete list values within a range partition. List-range partitioning is less commonly used to store historical data, even though equivalent scenarios are all suitable. Range-list partitioning can be implemented using interval-list partitioning, whereas list-range partitioning does not support interval partitioning.</p>
<p><a href="#BABBHEII">Example 3-11</a> shows a <code>donations</code> table that stores donations in different currencies. The donations are categorized into small, medium, and high, depending on the amount. Due to currency differences, the ranges are different.</p>
<div class="example">
<p class="titleinexample"><a id="BABBHEII"></a><a id="VLDBG14037"></a>Example 3-11 Creating a table with composite list-range partitioning</p>
<pre>
CREATE TABLE donations
( id             NUMBER
, name           VARCHAR2(60)
, beneficiary    VARCHAR2(80)
, payment_method VARCHAR2(30)
, currency       VARCHAR2(3)
, amount         NUMBER
) PARTITION BY LIST (currency)
SUBPARTITION BY RANGE (amount)
( PARTITION p_eur VALUES ('EUR')
  ( SUBPARTITION p_eur_small VALUES LESS THAN (8)
  , SUBPARTITION p_eur_medium VALUES LESS THAN (80)
  , SUBPARTITION p_eur_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_gbp VALUES ('GBP')
  ( SUBPARTITION p_gbp_small VALUES LESS THAN (5)
  , SUBPARTITION p_gbp_medium VALUES LESS THAN (50)
  , SUBPARTITION p_gbp_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_aud_nzd_chf VALUES ('AUD','NZD','CHF')
  ( SUBPARTITION p_aud_nzd_chf_small VALUES LESS THAN (12)
  , SUBPARTITION p_aud_nzd_chf_medium VALUES LESS THAN (120)
  , SUBPARTITION p_aud_nzd_chf_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_jpy VALUES ('JPY')
  ( SUBPARTITION p_jpy_small VALUES LESS THAN (1200)
  , SUBPARTITION p_jpy_medium VALUES LESS THAN (12000)
  , SUBPARTITION p_jpy_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_inr VALUES ('INR')
  ( SUBPARTITION p_inr_small VALUES LESS THAN (400)
  , SUBPARTITION p_inr_medium VALUES LESS THAN (4000)
  , SUBPARTITION p_inr_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_zar VALUES ('ZAR')
  ( SUBPARTITION p_zar_small VALUES LESS THAN (70)
  , SUBPARTITION p_zar_medium VALUES LESS THAN (700)
  , SUBPARTITION p_zar_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_default VALUES (DEFAULT)
  ( SUBPARTITION p_default_small VALUES LESS THAN (10)
  , SUBPARTITION p_default_medium VALUES LESS THAN (100)
  , SUBPARTITION p_default_high VALUES LESS THAN (MAXVALUE)
  )
) ENABLE ROW MOVEMENT;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BJEFIFCE"></a><a id="VLDBG1279"></a>
<div class="sect2">
<h3 class="sect2">When to Use Interval Partitioning</h3>
<p><a id="sthref262"></a><a id="sthref263"></a>Interval partitioning can be used for every table that is range partitioned and uses fixed intervals for new partitions. The database automatically creates interval partitions as data for that partition is inserted. Until this happens, the interval partition exists but no segment is created for the partition.</p>
<p>The benefit of interval partitioning is that you do not need to create your range partitions explicitly. You should consider using interval partitioning unless you create range partitions with different intervals, or if you always set specific partition attributes when you create range partitions. Note that you can specify a list of tablespaces in the interval definition. The database creates interval partitions in the provided list of tablespaces in a round-robin manner.</p>
<p>If you upgrade your application and you use range partitioning or composite range-* partitioning, then you can easily change your existing table definition to use interval partitioning. Note that you cannot manually add partitions to an interval-partitioned table. If you have automated the creation of new partitions, then in the future you must change your application code to prevent the explicit creation of range partitions.</p>
<p>The following example shows how to change the <code>sales</code> table in the sample <code>sh</code> schema from range partitioning to start using monthly interval partitioning.</p>
<pre>
ALTER TABLE sales SET INTERVAL (NUMTOYMINTERVAL(1,'MONTH'));
</pre>
<p>You cannot use interval partitioning with reference partitioned tables.</p>
<p>Serializable transactions do not work with interval partitioning. Inserting data into a partition of an interval partitioned table that does not have a segment yet causes an error.</p>
</div>
<!-- class="sect2" -->
<a id="BJECHCAG"></a><a id="VLDBG1280"></a>
<div class="sect2">
<h3 class="sect2">When to Use Reference Partitioning</h3>
<p><a id="sthref264"></a><a id="sthref265"></a>Reference partitioning is useful in the following scenarios:</p>
<ul>
<li>
<p>If you have denormalized, or would denormalize, a column from a master table into a child table to get partition pruning benefits on both tables.</p>
<p>For example, your <code>orders</code> table stores the <code>order_date</code>, but the <code>order_items</code> table, which stores one or more items for each order, does not. To get good performance for historical analysis of orders data, you would traditionally duplicate the <code>order_date</code> column in the <code>order_items</code> table to use partition pruning on the <code>order_items</code> table.</p>
<p>You should consider reference partitioning in such a scenario and avoid having to duplicate the <code>order_date</code> column. Queries that join both tables and use a predicate on <code>order_date</code> automatically benefit from partition pruning on both tables.</p>
</li>
<li>
<p>If two large tables are joined frequently, then the tables are not partitioned on the join key, but you want to take advantage of partition-wise joins.</p>
<p>Reference partitioning implicitly enables full partition-wise joins.</p>
</li>
<li>
<p>If data in multiple tables has a related life cycle, then reference partitioning can provide significant manageability benefits.</p>
<p>Partition management operations against the master table are automatically cascaded to its descendents. For example, when you add a partition to the master table, that addition is automatically propagated to all its descendents.</p>
<p>To use reference partitioning, you must enable and enforce the foreign key relationship between the master table and the reference table in place. You can cascade reference-partitioned tables.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BJEFFAGH"></a><a id="VLDBG1281"></a>
<div class="sect2">
<h3 class="sect2">When to Partition on Virtual Columns</h3>
<p><a id="sthref266"></a><a id="sthref267"></a>Virtual column partitioning enables you to partition on an expression, which may use data from other columns, and perform calculations with these columns. PL/SQL function calls are not supported in virtual column definitions that are to be used as a partitioning key.</p>
<p>Virtual column partitioning supports all partitioning methods, plus performance and manageability features. To get partition pruning benefits, consider using virtual columns if tables are frequently accessed using a predicate that is not directly captured in a column, but can be derived. Traditionally, to get partition pruning benefits, you would have to add a separate column to capture and calculate the correct value and ensure the column is always populated correctly to ensure correct query retrieval.</p>
<p><a href="#BABFDBEE">Example 3-12</a> shows a <code>car_rentals</code> table. The customer's confirmation number contains a two-character country name as the location where the rental car is picked up. Rental car analyses usually evaluate regional patterns, so it makes sense to partition by country.</p>
<div class="example">
<p class="titleinexample"><a id="BABFDBEE"></a><a id="VLDBG14038"></a>Example 3-12 Creating a table with virtual columns for partitioning</p>
<pre>
CREATE TABLE car_rentals
( id                  NUMBER NOT NULL
 , customer_id         NUMBER NOT NULL
 , confirmation_number VARCHAR2(12) NOT NULL
 , car_id              NUMBER
 , car_type            VARCHAR2(10)
 , requested_car_type  VARCHAR2(10) NOT NULL
 , reservation_date    DATE NOT NULL
 , start_date          DATE NOT NULL
 , end_date            DATE
 , country as (substr(confirmation_number,9,2))
) PARTITION BY LIST (country)
SUBPARTITION BY HASH (customer_id)
SUBPARTITIONS 16
( PARTITION north_america VALUES ('US','CA','MX')
 , PARTITION south_america VALUES ('BR','AR','PE')
 , PARTITION europe VALUES ('GB','DE','NL','BE','FR','ES','IT','CH')
 , PARTITION apac VALUES ('NZ','AU','IN','CN')
) ENABLE ROW MOVEMENT;
</pre></div>
<!-- class="example" -->
<p>In this example, the column <code>country</code> is defined as a virtual column derived from the confirmation number. The virtual column does not require any storage. As the example illustrates, row movement is supported with virtual columns. The database migrates a row to a different partition if the virtual column evaluates to a different value in another partition.</p>
</div>
<!-- class="sect2" -->
<a id="BABIEEGC"></a><a id="VLDBG1282"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Considerations When Using Read-Only Tablespaces</h3>
<p><a id="sthref268"></a>When a referential integrity constraint is defined between parent and child tables, an index is defined on the foreign key, and the tablespace in which that index resides is made read-only. Then the integrity check for the constraint is implemented in SQL and not through consistent read buffer access.</p>
<p>The implication of this is that, if the child is partitioned, only some child partitions have their indexes in read-only tables and, if an insert is made into one nonread-only child segment, then a TM enqueue is acquired on the child table in SX mode.</p>
<p>SX mode is incompatible with S requests, so that if you try to insert into the parent, it is blocked because that insert attempts to acquire an S TM enqueue against the child.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1828">
<tr>
<td class="cellalignment1837">
<table class="cellalignment1833">
<tr>
<td class="cellalignment1832"><a href="partition.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1832"><a href="part_admin.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1840">
<table class="cellalignment1831">
<tr>
<td class="cellalignment1832"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1832"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1832"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1832"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1832"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1832"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
