<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using Partitioning in an Online Transaction Processing Environment</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-27T4:11:53Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database VLDB and Partitioning Guide" />
<meta name="dcterms.identifier" content="E25523-01" />
<meta name="dcterms.isVersionOf" content="VLDBG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="part_warehouse.htm" title="Previous" type="text/html" />
<link rel="Next" href="parallel.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25523.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/27</span> <!-- End Header --><a id="CEGECIGF"></a><a id="VLDBG006"></a>
<h1 class="chapter"><span class="secnum">7</span> Using Partitioning in an Online Transaction Processing Environment</h1>
<p><a id="sthref798"></a><a id="sthref799"></a>Partitioning was initially developed to manage the performance requirements for data warehouses. Due to the explosive growth of online transaction processing (OLTP) systems and their user populations, partitioning is particularly useful for OLTP systems.</p>
<p>Partitioning is often used for OLTP systems to reduce contention while supporting a very large user population. It also helps to address regulatory requirements facing OLTP systems, including storing larger amounts of data in a cost-effective manner.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#CEGEGHGE">What Is an OLTP System?</a></p>
</li>
<li>
<p><a href="#CEGDAHHH">Performance</a></p>
</li>
<li>
<p><a href="#CEGDDIGF">Manageability</a></p>
</li>
</ul>
<a id="CEGEGHGE"></a><a id="VLDBG1367"></a>
<div class="sect1">
<h2 class="sect1">What Is an OLTP System?</h2>
<p><a id="sthref800"></a>An OLTP system is a common data processing system in today's enterprises. Classic examples of OLTP systems are order entry, retail sales, and financial transaction systems.</p>
<p>OLTP systems are primarily characterized through a specific data usage that is different from data warehouse environments, yet some characteristics, such as having large volumes of data and lifecycle-related data usage and importance, are identical.</p>
<p>The main characteristics of an OLTP environment are:</p>
<ul>
<li>
<p>Short response time</p>
<p>The nature of OLTP environments is predominantly any kind of interactive ad hoc usage, such as telemarketers entering telephone survey results. OLTP systems require short response times in order for users to remain productive.</p>
</li>
<li>
<p>Small transactions</p>
<p>OLTP systems typically read and manipulate highly selective, small amounts of data; the data processing is mostly simple and complex joins are relatively rare. There is always a mix of queries and DML workload. For example, one of many call center employees retrieves customer details for every call and enters customer complaints while reviewing past communications with the customer.</p>
</li>
<li>
<p>Data maintenance operations</p>
<p>It is not uncommon to have reporting programs and data updating programs that must run either periodically or on an ad hoc basis. These programs, which run in the background while users continue to work on other tasks, may require a large number of data-intensive computations. For example, a university may start batch jobs assigning students to classes while students can still sign up online for classes themselves.</p>
</li>
<li>
<p>Large user populations</p>
<p>OLTP systems can have enormously large user populations where many users are trying to access the same data at the same time. For example, an online auction Web site can have hundreds of thousands (if not millions) of users accessing data on its Web site at the same time.</p>
</li>
<li>
<p>High concurrency</p>
<p>Due to the large user population, the short response times, and small transactions, the concurrency in OLTP environments is very high. A requirement for thousands of concurrent users is not uncommon.</p>
</li>
<li>
<p>Large data volumes</p>
<p>Depending on the application type, the user population, and the data retention time, OLTP systems can become very large. For example, every customer of a bank could have access to the online banking system which shows all their transactions for the last 12 months.</p>
</li>
<li>
<p>High availability</p>
<p>The availability requirements for OLTP systems are often extremely high. An unavailable OLTP system can impact a very large user population, and organizations can suffer major losses if OLTP systems are unavailable. For example, a stock exchange system has extremely high availability requirements during trading hours.</p>
</li>
<li>
<p>Lifecycle-related data usage</p>
<p>Similar to data warehousing environments, OLTP systems often experience different data access patterns over time. For example, at the end of the month, monthly interest is calculated for every active account.</p>
</li>
</ul>
<p>The following are benefits of partitioning for OLTP environments:</p>
<ul>
<li>
<p>Support for bigger databases</p>
<p>Backup and recovery, as part of a high availability strategy, can be performed on a low level of granularity to efficiently manage the size of the database. OLTP systems usually remain online during backups and users may continue to access the system while the backup is running. The backup process should not introduce major performance degradation for the online users.</p>
<p>Partitioning helps to reduce the space requirements for the OLTP system because part of a database object can be stored compressed while other parts can remain uncompressed. Update transactions against uncompressed rows are more efficient than updates on compressed data.</p>
<p>Partitioning can store data transparently on different storage tiers to lower the cost of retaining vast amounts of data.</p>
</li>
<li>
<p>Partition maintenance operations for data maintenance (instead of DML)</p>
<p>For data maintenance operations (purging being the most common operation), you can leverage partition maintenance operations with the Oracle Database capability of online index maintenance. A partition management operation generates less redo than the equivalent DML operations.</p>
</li>
<li>
<p>Potential higher concurrency through elimination of hot spots</p>
<p>A common scenario for OLTP environments is to have monotonically increasing index values that are used to enforce primary key constraints, thus creating areas of high concurrency and potential contention: every new insert tries to update the same set of index blocks. Partitioned indexes, in particular hash-partitioned indexes, can help alleviate this situation.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CEGDAHHH"></a><a id="VLDBG1368"></a>
<div class="sect1">
<h2 class="sect1">Performance</h2>
<p>Performance in OLTP environments heavily relies on efficient index access, thus the choice of the most appropriate index strategy becomes crucial. The following section discusses best practices for deciding whether to partition indexes in an OLTP environment.</p>
<a id="VLDBG1369"></a>
<div class="sect2"><a id="sthref801"></a>
<h3 class="sect2">Deciding Whether to Partition Indexes</h3>
<p><a id="sthref802"></a><a id="sthref803"></a>Due to the selectivity of queries and high concurrency of OLTP applications, the choice of the right index strategy is indisputably an important decisions for the use of partitioning in an OLTP environment. The following basic rules explain the main benefits and trade-offs for the various possible index structures:</p>
<ul>
<li>
<p>A nonpartitioned index, while larger than individual partitioned index segments, always leads to a single index probe (or scan) if an index access path is chosen; there is only one segment for a table. The data access time and number of blocks being accessed are identical for both a partitioned and a nonpartitioned table.</p>
<p>A nonpartitioned index does not provide partition autonomy and requires an index maintenance operation for every partition maintenance operation that affects rowids (for example, drop, truncate, move, merge, coalesce, or split operations).</p>
</li>
<li>
<p>With partitioned indexes, there are always multiple segments. Whenever Oracle Database cannot prune down to a single index segment, the database has to access multiple segments. This potentially leads to higher I/O requirements (<span class="italic">n</span> index segment probes compared with one probe for a nonpartitioned index) and can have an impact (measurable or not) on the run-time performance. This is true for all partitioned indexes.</p>
<p>Partitioned indexes can either be local partitioned indexes or global partitioned indexes. Local partitioned indexes always inherit the partitioning key from the table and are fully aligned with the table partitions. Consequently, any kind of partition maintenance operation requires little to no index maintenance work. For example, dropping or truncating a partition does not incur any measurable overhead for index maintenance; the local index partitions are either dropped or truncated.</p>
<p>Partitioned indexes that are not aligned with the table are called global partitioned indexes. Unlike local indexes, there is no relation between a table and an index partition. Global partitioned indexes give the flexibility to choose a partitioning key that is optimal for an efficient partition index access. Partition maintenance operations normally affect more (if not all) partitions of a global partitioned index, depending on the operation and partitioning key of the index.</p>
</li>
<li>
<p>Under some circumstances, having multiple segments for an index can be beneficial for performance. It is very common in OLTP environments to use sequences to create artificial keys. Consequently, you create key values that are monotonically increasing, which results in many insertion processes competing for the same index blocks. Introducing a global partitioned index (for example, using global hash partitioning on the key column) can alleviate this situation. If you have, for example, four hash partitions for such an index, then you now have four index segments into which you are inserting data, reducing the concurrency on these segments by a factor of four for the insertion processes.</p>
</li>
</ul>
<p>With less contention, the application can support a larger user population. <a href="#BABJFAFG">Example 7-1</a> shows the creation of a unique index on the <code>order_id</code> column of the <code>orders</code> table. The <code>order_id</code> in the OLTP application is filled using a sequence number. The unique index uses hash partitioning to reduce contention for the monotonically increasing <code>order_id</code> values. The unique key is then used to create the primary key constraint.</p>
<div class="example">
<p class="titleinexample"><a id="BABJFAFG"></a><a id="VLDBG14082"></a>Example 7-1 Creating a unique index and primary key constraint</p>
<pre>
CREATE UNIQUE INDEX orders_pk
ON orders(order_id)
GLOBAL PARTITION BY HASH (order_id)
( PARTITION p1 TABLESPACE tbs1
, PARTITION p2 TABLESPACE tbs2
, PARTITION p3 TABLESPACE tbs3
, PARTITION p4 TABLESPACE tbs4
) NOLOGGING;

ALTER TABLE orders ADD CONSTRAINT orders_pk
PRIMARY KEY (order_id)
USING INDEX;
</pre></div>
<!-- class="example" -->
<p>Enforcing uniqueness is important database functionality for OLTP environments. Uniqueness can be enforced with nonpartitioned and partitioned indexes. However, because partitioned indexes provide partition autonomy, the following requirements must be met to implement unique indexes:</p>
<ul>
<li>
<p>A nonpartitioned index can enforce uniqueness for any given column or combination of columns. The behavior of a nonpartitioned index is no different for a partitioned table compared to a nonpartitioned table.</p>
</li>
<li>
<p>Each partition of a partitioned index is considered an autonomous segment. To enforce the autonomy of these segments, you always have to include the partitioning key columns as a subset of the unique key definition.</p>
<ul>
<li>
<p>Unique global partitioned indexes must always be prefixed with the partitioning columns.</p>
</li>
<li>
<p>Unique local indexes must have the partitioning key of the table as a subset of the unique key definition.</p>
</li>
</ul>
</li>
</ul>
<a id="VLDBG1370"></a>
<div class="sect3"><a id="sthref804"></a>
<h4 class="sect3">Using Index-Organized Tables</h4>
<p>When your workload fits the use of index-organized tables, then you must consider how to use partitioning on your index-organized table and on any secondary indexes. For more information about how to create partitioned index-organized tables, refer to <a href="part_admin.htm#g1030303">Chapter 4, "Partition Administration"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about index-organized tables</div>
<p>You must decide whether to partition secondary indexes on index-organized tables based on the same considerations as indexes on regular heap tables. You can partition an index-organized table, but the partitioning key must be a subset of the primary key. A common reason to partition an index-organized table is to reduce contention; this is typically achieved using hash partitioning.</p>
<p>Another reason to partition an index-organized table is to be able to physically separate data sets based on a primary key column. For example, an application-hosting company can physically separate application instances for different customers by list partitioning on the company identifier. Queries in such a scenario can often take advantage of index partition pruning, shortening the time for the index scan. ILM scenarios with index-organized tables and partitioning are less common because they require a date column to be part of the primary key.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGDDIGF"></a><a id="VLDBG1371"></a>
<div class="sect1">
<h2 class="sect1">Manageability</h2>
<p>In addition to the performance benefits, partitioning also enables the optimal data management for large objects in an OLTP environment. Every partition maintenance operation in Oracle database can be extended to atomically include global and local index maintenance, enabling the execution of any partition maintenance operation without affecting the 24x7 availability of an OLTP environment.</p>
<p>Partition maintenance operations in OLTP systems occur often because of ILM scenarios. In these scenarios, [range | interval] partitioned tables, or [range | interval]-* composite partitioned tables, are common.</p>
<p>Some business cases for partition maintenance operations include scenarios surrounding the separation of application data. For example, a retail company runs the same application for multiple branches in a single schema. Depending on the branch revenues, the application (as separate partitions) is stored on more efficient storage. List partitioning, or list-* composite partitioning, is a common partitioning strategy for this type of business case.</p>
<p>Hash partitioning, or hash subpartitioning for tables, can be used in OLTP systems to obtain similar performance benefits to the performance benefits achieved in data warehouse environments. The majority of the daily OLTP workload consists of relatively small operations, executed serially. Periodic batch operations, however, may execute in parallel and benefit from the distribution improvements that hash partitioning and subpartitioning can provide for partition-wise joins. For example, end-of-the-month interest calculations may be executed in parallel to complete within a nightly batch window.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABFCBDF">Impact of a Partition Maintenance Operation on a Partitioned Table with Local Indexes</a></p>
</li>
<li>
<p><a href="#BABGJDEJ">Impact of a Partition Maintenance Operation on Global Indexes</a></p>
</li>
<li>
<p><a href="#BABEBFIJ">Common Partition Maintenance Operations in OLTP Environments</a></p>
</li>
</ul>
<p>For more information about the performance benefits of partitioning, refer to <a href="part_avail.htm#BJEIEDIA">Chapter 3, "Partitioning for Availability, Manageability, and Performance"</a>.</p>
<a id="BABFCBDF"></a><a id="VLDBG1372"></a>
<div class="sect2">
<h3 class="sect2">Impact of a Partition Maintenance Operation on a Partitioned Table with Local Indexes</h3>
<p><a id="sthref805"></a><a id="sthref806"></a><a id="sthref807"></a>Whenever a partition maintenance operation takes place, Oracle Database locks the affected table partitions for any DML operation. Data in the affected partitions, except a <code>DROP</code> or <code>TRUNCATE</code> operation, is still fully accessible for any <code>SELECT</code> operation. Because local indexes are logically coupled with the table (data) partitions, only the local index partitions of the affected table partitions have to be maintained as part of a partition maintenance operation, enabling optimal processing for the index maintenance.</p>
<p>For example, when you move an older partition from a high-end storage tier to a low-cost storage tier, the data and the index are always available for <code>SELECT</code> operations; the necessary index maintenance is either to update the existing index partition to reflect the new physical location of the data or, more commonly, a move and rebuild the index partition to a low cost storage tier as well. If you drop an older partition after you have archived it, then its local index partitions get dropped as well, enabling a split-second partition maintenance operation that affects only the data dictionary.</p>
</div>
<!-- class="sect2" -->
<a id="BABGJDEJ"></a><a id="VLDBG1373"></a>
<div class="sect2">
<h3 class="sect2">Impact of a Partition Maintenance Operation on Global Indexes</h3>
<p><a id="sthref808"></a><a id="sthref809"></a><a id="sthref810"></a>Whenever a global index is defined on a partitioned or nonpartitioned table, there is no correlation between a distinct table partition and the index. Consequently, any partition maintenance operation affects all global indexes or index partitions. As with tables containing local indexes, the affected partitions are locked to prevent DML operations against the affected table partitions. However, unlike the index maintenance for local indexes, any global index is still fully available for DML operations and does not affect the online availability of the OLTP system. Conceptually and technically, the index maintenance for global indexes for a partition maintenance operation is comparable to the index maintenance that would become necessary for a semantically identical DML operation.</p>
<p>For example, dropping an old partition is semantically equivalent to deleting all the records of the old partition using the SQL <code>DELETE</code> statement. In both cases, all index entries of the deleted data set have to be removed from any global index as a standard index maintenance operation, which does not affect the availability of an index for <code>SELECT</code> and DML operations. In this scenario, a drop operation represents the optimal approach: data is removed without the overhead of a conventional <code>DELETE</code> operation and the global indexes are maintained in a nonintrusive manner.</p>
</div>
<!-- class="sect2" -->
<a id="BABEBFIJ"></a><a id="VLDBG1374"></a>
<div class="sect2">
<h3 class="sect2">Common Partition Maintenance Operations in OLTP Environments</h3>
<p><a id="sthref811"></a><a id="sthref812"></a>The two most common partition maintenance operations are the removal of data and the relocation of data onto lower-cost storage tier devices.</p>
<a id="VLDBG1375"></a>
<div class="sect3"><a id="sthref813"></a>
<h4 class="sect3">Removing (Purging) Old Data</h4>
<p><a id="sthref814"></a>Using either a <code>DROP</code> or <code>TRUNCATE</code> operation removes older data based on the partitioning key criteria. The drop operation removes the data and the partition metadata, while a <code>TRUNCATE</code> operation removes only the data but preserve the metadata. All local index partitions are dropped respectively, and truncated. Standard index maintenance is done for partitioned or nonpartitioned global indexes and is fully available for select and DML operations.</p>
<p>The following example drops all data older than January 2006 from the <code>orders</code> table. Note that as part of the drop statement, an <code>UPDATE GLOBAL INDEXES</code> statement is executed, so that the global index remains usable throughout the maintenance operation. Any local index partitions are dropped as part of this operation.</p>
<pre>
ALTER TABLE orders DROP PARTITION p_before_jan_2006
UPDATE GLOBAL INDEXES;
</pre></div>
<!-- class="sect3" -->
<a id="VLDBG1376"></a>
<div class="sect3"><a id="sthref815"></a>
<h4 class="sect3">Moving or Merging Older Partitions to a Low-Cost Storage Tier Device</h4>
<p><a id="sthref816"></a><a id="sthref817"></a>Using a <code>MOVE</code> or <code>MERGE</code> operation as part of an Information Lifecycle Management (ILM) strategy, you can relocate older partitions to the most cost-effective storage tier. The data is available for a <code>SELECT</code> statement, but not for DML operations during the operation. Local indexes are maintained and you most likely will relocate those as part of the merge or move operation as well. The standard index maintenance is done for partitioned or nonpartitioned global indexes and is fully available for select and DML operations.</p>
<p>The following example shows how to merge the January 2006 and February 2006 partitions in the <code>orders</code> table, and store them in a different tablespace. Any local index partitions are also moved to the <code>ts_low_cost</code> tablespace as part of this operation. The <code>UPDATE INDEXES</code> clause ensures that all indexes remain usable throughout and after the operation, without additional rebuilds.</p>
<pre>
ALTER TABLE orders
MERGE PARTITIONS p_2006_jan,p_2006_feb
INTO PARTITION p_before_mar_2006 COMPRESS
TABLESPACE ts_low_cost
UPDATE INDEXES;
</pre>
<p>For more information about the benefits of partition maintenance operations for Information Lifecycle Management, see <a href="part_lifecycle.htm#CACECAFB">Chapter 5, "Using Partitioning for Information Lifecycle Management"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1828">
<tr>
<td class="cellalignment1837">
<table class="cellalignment1833">
<tr>
<td class="cellalignment1832"><a href="part_warehouse.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1832"><a href="parallel.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1840">
<table class="cellalignment1831">
<tr>
<td class="cellalignment1832"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1832"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1832"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1832"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1832"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1832"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
