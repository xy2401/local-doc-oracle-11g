<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using Partitioning in a Data Warehouse Environment</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-27T4:11:53Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database VLDB and Partitioning Guide" />
<meta name="dcterms.identifier" content="E25523-01" />
<meta name="dcterms.isVersionOf" content="VLDBG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="part_lifecycle.htm" title="Previous" type="text/html" />
<link rel="Next" href="part_oltp.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25523.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/27</span> <!-- End Header --><a id="g1020112"></a><a id="VLDBG005"></a><a id="i1007993"></a>
<h1 class="chapter"><span class="secnum">6</span> Using Partitioning in a Data Warehouse Environment</h1>
<p><a id="sthref748"></a><a id="sthref749"></a>This chapter describes the partitioning features that significantly enhance data access and improve overall application performance. Improvements with partitioning are especially true for applications that access tables and indexes with millions of rows and many gigabytes of data, as found in a data warehouse environment. Data warehouses often contain large tables and require techniques for managing these large tables and for providing good query performance across these large tables.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#CACCAFDH">What Is a Data Warehouse?</a></p>
</li>
<li>
<p><a href="#CACBAIAC">Scalability</a></p>
</li>
<li>
<p><a href="#CACCDFHE">Performance</a></p>
</li>
<li>
<p><a href="#CACBEICJ">Manageability</a></p>
</li>
</ul>
<a id="CACCAFDH"></a><a id="VLDBG00501"></a>
<div class="sect1">
<h2 class="sect1">What Is a Data Warehouse?</h2>
<p>A <a id="sthref750"></a>data warehouse is a relational database that is designed for query and analysis rather than for transaction processing. It usually contains historical data derived from transaction data, but can include data from other sources. Data warehouses separate analysis workload from transaction workload and enable an organization to consolidate data from several sources.</p>
<p>In addition to a relational database, a data warehouse environment can include an extraction, transformation, and loading (ETL) solution, analytical processing and data mining capabilities, client analysis tools, and other applications that manage the process of gathering data and delivering it to business users.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a></div>
</div>
<!-- class="sect1" -->
<a id="CACBAIAC"></a><a id="VLDBG00502"></a>
<div class="sect1">
<h2 class="sect1">Scalability</h2>
<p><a id="sthref751"></a><a id="sthref752"></a>Partitioning helps to scale a data warehouse by dividing database objects into smaller pieces, enabling access to smaller, more manageable objects. Having direct access to smaller objects addresses the scalability requirements of data warehouses.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CACGDCCA">Bigger Databases</a></p>
</li>
<li>
<p><a href="#CACHFIGG">Bigger Individual Tables: More Rows in Tables</a></p>
</li>
<li>
<p><a href="#CACDDDGC">More Users Querying the System</a></p>
</li>
<li>
<p><a href="#CACEADHA">More Complex Queries</a></p>
</li>
</ul>
<a id="CACGDCCA"></a><a id="VLDBG1339"></a>
<div class="sect2">
<h3 class="sect2">Bigger Databases</h3>
<p><a id="sthref753"></a>The ability to split a large database object into smaller pieces transparently simplifies efficient management of very large databases. You can identify and manipulate individual partitions and subpartitions to manage large database objects. Consider the following advantages of partitioned objects:</p>
<ul>
<li>
<p>Backup and recovery can be performed on a low level of granularity to manage the size of the database.</p>
</li>
<li>
<p>Part of a database object can be placed in compressed storage while other parts can remain uncompressed.</p>
</li>
<li>
<p>Partitioning can store data transparently on different storage tiers to lower the cost of retaining vast amounts of data. For more information, refer to <a href="part_lifecycle.htm#CACECAFB">Chapter 5, "Using Partitioning for Information Lifecycle Management"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACHFIGG"></a><a id="VLDBG1340"></a>
<div class="sect2">
<h3 class="sect2">Bigger Individual Tables: More Rows in Tables</h3>
<p><a id="sthref754"></a>It takes longer to scan a big table than it takes to scan a small table. Queries against partitioned tables may access one or more partitions that are small in contrast to the total size of the table. Similarly, queries may take advantage of partition elimination on indexes. It takes less time to read a smaller portion of an index from disk than to read the entire index. Index structures that share the partitioning strategy with the table, such as local partitioned indexes, can be accessed and maintained on a partition-by-partition basis.</p>
<p>The database can take advantage of the distinct data sets in separate partitions if you use parallel execution to speed up queries, DML, and DDL statements. Individual parallel execution servers can work on their own data sets, identified by the partition boundaries.</p>
</div>
<!-- class="sect2" -->
<a id="CACDDDGC"></a><a id="VLDBG1341"></a>
<div class="sect2">
<h3 class="sect2">More Users Querying the System</h3>
<p><a id="sthref755"></a>With partitioning, users are more likely to query on isolated and smaller data sets. Consequently, the database can return results faster than if all users queried the same and much larger data sets. Data contention is less likely.</p>
</div>
<!-- class="sect2" -->
<a id="CACEADHA"></a><a id="VLDBG1342"></a>
<div class="sect2">
<h3 class="sect2">More Complex Queries</h3>
<p><a id="sthref756"></a>You can perform complex queries faster using smaller data sets. If smaller data sets are being accessed, then complex calculations are more likely to be processed in memory, which is beneficial from a performance perspective and reduces the application's I/O requirements. A larger data set may have to be written to the temporary tablespace to complete a query, in which case additional I/O operations against the database storage occurs.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CACCDFHE"></a><a id="VLDBG1343"></a>
<div class="sect1">
<h2 class="sect1">Performance</h2>
<p>Good performance is a requirement for a successful data warehouse. Analyses run against the database should return within a reasonable amount of time, even if the queries access large amounts of data in tables that are terabytes in size. Partitioning increases the speed of data access and application processing, which results in successful data warehouses that are not prohibitively expensive.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDEFIIJ">Partition Pruning</a></p>
</li>
<li>
<p><a href="#CHDHEBBA">Partition-Wise Joins</a></p>
</li>
<li>
<p><a href="#CHDDCGJA">Indexes and Partitioned Indexes</a></p>
</li>
<li>
<p><a href="#CHDCJFDB">Materialized Views and Partitioning</a></p>
</li>
</ul>
<a id="CHDEFIIJ"></a><a id="VLDBG1344"></a>
<div class="sect2">
<h3 class="sect2">Partition Pruning</h3>
<p><a id="sthref757"></a>Partition pruning is an essential performance feature for data warehouses. In partition pruning, the optimizer analyzes <code>FROM</code> and <code>WHERE</code> clauses in SQL statements to eliminate unneeded partitions when building the partition access list. As a result, Oracle Database performs operations only on those partitions that are relevant to the SQL statement.</p>
<p>Partition pruning dramatically reduces the amount of data retrieved from disk and shortens processing time, thus improving query performance and optimizing resource utilization.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDDEHFC">Basic Partition Pruning Techniques</a></p>
</li>
<li>
<p><a href="#CHDIFHBD">Advanced Partition Pruning Techniques</a></p>
</li>
</ul>
<p>For more information about partition pruning and the difference between static and dynamic partition pruning, refer to <a href="part_avail.htm#BJEIEDIA">Chapter 3, "Partitioning for Availability, Manageability, and Performance"</a>.</p>
<a id="CHDDEHFC"></a><a id="VLDBG1345"></a>
<div class="sect3">
<h4 class="sect3">Basic Partition Pruning Techniques</h4>
<p><a id="sthref758"></a>The optimizer uses a wide variety of predicates for pruning. The three predicate types, equality, range, and <code>IN</code>-list, are the predicates most commonly used for partition pruning. As an example, consider the following query:</p>
<pre>
SELECT SUM(amount_sold) day_sales
FROM sales
WHERE time_id = TO_DATE('02-JAN-1998', 'DD-MON-YYYY');
</pre>
<p>Because there is an equality predicate on the partitioning column of <code>sales</code>, the query is pruned down to a single predicate and this is reflected in the following execution plan:</p>
<pre>
-----------------------------------------------------------------------------------------------
|  Id | Operation                | Name  | Rows| Bytes | Cost (%CPU)| Time     |Pstart| Pstop |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT         |       |     |       | 21 (100)   |          |      |       |
|   1 |  SORT AGGREGATE          |       | 1   | 13    |            |          |      |       |
|   2 |   PARTITION RANGE SINGLE |       | 485 | 6305  | 21 (10)    | 00:00:01 | 5    | 5     |
| * 3 |    TABLE ACCESS FULL     | SALES | 485 | 6305  | 21 (10)    | 00:00:01 | 5    | 5     |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
--------------------------------------------------- 
  3 - filter("TIME_ID"=TO_DATE('1998-01-02 00:00:00', 'yyyy-mm-dd hh24:mi:ss'))
</pre>
<p>Similarly, a range or an <code>IN</code>-list predicate on the <code>time_id</code> column and the optimizer would be used to prune to a set of partitions. The partitioning type plays a role in which predicates can be used. Range predicates cannot be used for pruning on hash-partitioned tables, but they can be used for all other partitioning strategies. However, on list-partitioned tables, range predicates may not map to a contiguous set of partitions. Equality and <code>IN</code>-list predicates can prune with all the partitioning methods.</p>
</div>
<!-- class="sect3" -->
<a id="CHDIFHBD"></a><a id="VLDBG1346"></a>
<div class="sect3">
<h4 class="sect3">Advanced Partition Pruning Techniques</h4>
<p><a id="sthref759"></a>The Oracle Database pruning feature effectively handles more complex predicates or SQL statements that involve partitioned tables. A common situation is when a partitioned table is joined to the subset of another table, limited by a <code>WHERE</code> condition. For example, consider the following query:</p>
<pre>
SELECT t.day_number_in_month, SUM(s.amount_sold)
  FROM sales s, times t
  WHERE s.time_id = t.time_id
    AND t.calendar_month_desc='2000-12'
  GROUP BY t.day_number_in_month;
</pre>
<p>If the database performed a nested loop join with <code>times</code> table on the right-hand side, then the query would access only the partition corresponding to this row from the <code>times</code> table, so pruning would implicitly take place. But, if the database performed a hash or sort merge join, this would not be possible. If the table with the <code>WHERE</code> predicate is relatively small compared to the partitioned table, and the expected reduction of records or partitions for the partitioned table is significant, then the database performs dynamic partition pruning using a recursive subquery. The decision whether to invoke subquery pruning is an internal cost-based decision of the optimizer.</p>
<p>A sample execution plan using a hash join operation would look like the following:</p>
<pre>
--------------------------------------------------------------------------------------------------
| Id| Operation                    |  Name |  Rows | Bytes| Cost (%CPU)|  Time  | Pstart | Pstop |
--------------------------------------------------------------------------------------------------
|  0| SELECT STATEMENT             |       |       |      | 761 (100)  |        |        |       |
|  1|  HASH GROUP BY               |       |    20 | 640  | 761 (41)   |00:00:10|        |       |
|* 2|   HASH JOIN                  |       | 19153 | 598K | 749 (40)   |00:00:09|        |       |
|* 3|    TABLE ACCESS FULL         | TIMES |    30 |  570 |  17 (6)    |00:00:01|        |       |
|  4|     PARTITION RANGE SUBQUERY |       |  918K | 11M  |   655 (33) |00:00:08| KEY(SQ)|KEY(SQ)|
|  5|      TABLE ACCESS FULL       | SALES |   918 | 11M  |   655 (33) |00:00:08| KEY(SQ)|KEY(SQ)|
--------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------------
  2 - access("S"."TIME_ID"="T"."TIME_ID") 
  3 - filter("T"."CALENDAR_MONTH_DESC"='2000-12')
</pre>
<p>This execution plan shows that dynamic partition pruning occurred on the <code>sales</code> table using a subquery, as shown by the <code>KEY(SQ)</code> value in the <code>PSTART</code> and <code>PSTOP</code> columns.</p>
<p><a href="#CHDEECBJ">Example 6-1</a> shows an example of advanced pruning using an <code>OR</code> predicate.</p>
<div class="example">
<p class="titleinexample"><a id="CHDEECBJ"></a><a id="VLDBG14078"></a>Example 6-1 Advanced pruning using an OR predicate</p>
<pre>
SELECT p.promo_name promo_name, (s.profit - p.promo_cost) profit
FROM
   promotions p,
   (SELECT
      promo_id,
      SUM(sales.QUANTITY_SOLD * (costs.UNIT_PRICE - costs.UNIT_COST)) profit
   FROM
      sales, costs
   WHERE
      ((sales.time_id BETWEEN TO_DATE('01-JAN-1998','DD-MON-YYYY',
                  'NLS_DATE_LANGUAGE = American') AND
      TO_DATE('01-JAN-1999','DD-MON-YYYY', 'NLS_DATE_LANGUAGE = American')
OR
      (sales.time_id BETWEEN TO_DATE('01-JAN-2001','DD-MON-YYYY',
                  'NLS_DATE_LANGUAGE = American') AND
      TO_DATE('01-JAN-2002','DD-MON-YYYY', 'NLS_DATE_LANGUAGE = American')))
      AND sales.time_id = costs.time_id
      AND sales.prod_id = costs.prod_id
   GROUP BY
      promo_id) s
WHERE s.promo_id = p.promo_id
ORDER BY profit
DESC;
</pre></div>
<!-- class="example" -->
<p>This query joins the <code>sales</code> and <code>costs</code> tables in the <code>sh</code> sample schema. The <code>sales</code> table is partitioned by range on the column <code>time_id</code>. One condition in the query is two predicates on <code>time_id</code>, which are combined with an <code>OR</code> operator. This <code>OR</code> predicate is used to prune the partitions in the <code>sales</code> table and a single join between the <code>sales</code> and <code>costs</code> table is performed. The execution plan is as follows:</p>
<pre>
--------------------------------------------------------------------------------------------------
| Id| Operation               |  Name    |Rows |Bytes |TmpSp|Cost(%CPU)| Time    | Pstart| Pstop |
--------------------------------------------------------------------------------------------------
|  0| SELECT STATEMENT        |          | 4   |  200 |     | 3556 (14)| 00:00:43|       |       |
|  1|  SORT ORDER BY          |          | 4   |  200 |     | 3556 (14)| 00:00:43|       |       |
|* 2|   HASH JOIN             |          | 4   |  200 |     | 3555 (14)| 00:00:43|       |       |
|  3|    TABLE ACCESS FULL    |PROMOTIONS| 503 | 16599|     |    16 (0)| 00:00:01|       |       |
|  4|    VIEW                 |          |   4 |   68 |     | 3538 (14)| 00:00:43|       |       |
|  5|     HASH GROUP BY       |          |   4 |  164 |     | 3538 (14)| 00:00:43|       |       |
|  6|      PARTITION RANGE OR |          | 314K|   12M|     |  3321 (9)| 00:00:40|KEY(OR)|KEY(OR)|
|* 7|       HASH JOIN         |          | 314K|   12M| 440K|  3321 (9)| 00:00:40|       |       |
|* 8|        TABLE ACCESS FULL| SALES    | 402K| 7467K|     |  400 (39)| 00:00:05|KEY(OR)|KEY(OR)|
|  9| TABLE ACCESS FULL       | COSTS    |82112| 1764K|     |   77 (24)| 00:00:01|KEY(OR)|KEY(OR)|
--------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
--------------------------------------------------- 
  2 - access("S"."PROMO_ID"="P"."PROMO_ID") 
  7 - access("SALES"."TIME_ID"="COSTS"."TIME_ID" AND "SALES"."PROD_ID"="COSTS"."PROD_ID") 
  8 - filter("SALES"."TIME_ID"&lt;=TO_DATE('1999-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') AND 
      "SALES"."TIME_ID"&gt;=TO_DATE('1998-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') OR 
      "SALES"."TIME_ID"&gt;=TO_DATE('2001-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') AND 
      "SALES"."TIME_ID"&lt;=TO_DATE('2002-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss'))
</pre>
<p>The database also does additional pruning when a column is range-partitioned on multiple columns. As long as the database can guarantee that a particular predicate cannot be satisfied in a particular partition, the partition is skipped. This allows the database to optimize cases where there are range predicates on multiple columns or in the case where there are no predicates on a prefix of the partitioning columns.</p>
<p>For tips on partition pruning, refer to <a href="part_avail.htm#BJECFBJE">"Partition Pruning Tips"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDHEBBA"></a><a id="VLDBG1347"></a>
<div class="sect2">
<h3 class="sect2">Partition-Wise Joins</h3>
<p><a id="sthref760"></a>Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. This significantly reduces response time and improves the use of both CPU and memory resources.</p>
<p>Partition-wise joins can be full or partial. Oracle Database decides which type of join to use.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDBFJFI">Full Partition-Wise Joins</a></p>
</li>
<li>
<p><a href="#CHDGDICE">Partial Partition-Wise Joins</a></p>
</li>
<li>
<p><a href="#CHDIEDGF">Benefits of Partition-Wise Joins</a></p>
</li>
<li>
<p><a href="#CHDEHGCE">Performance Considerations for Parallel Partition-Wise Joins</a></p>
</li>
</ul>
<a id="CHDBFJFI"></a><a id="VLDBG1348"></a>
<div class="sect3">
<h4 class="sect3">Full Partition-Wise Joins</h4>
<p><a id="sthref761"></a><a id="sthref762"></a><a id="sthref763"></a>Full partition-wise joins can occur if two tables that are co-partitioned on the same key are joined in a query. The tables can be co-partitioned at the partition level, or at the subpartition level, or at a combination of partition and subpartition levels. Reference partitioning is an easy way to guarantee co-partitioning. Full partition-wise joins can be executed serially and in parallel.</p>
<p>For more information about partition-wise joins, refer to <a href="part_avail.htm#BJEIEDIA">Chapter 3, "Partitioning for Availability, Manageability, and Performance"</a>.</p>
<p><a href="#CHDBIDJF">Example 6-2</a> shows a full partition-wise join on the <code>orders</code> and <code>order_items</code> tables, in which the <code>order_items</code> table is reference-partitioned.</p>
<div class="example">
<p class="titleinexample"><a id="CHDBIDJF"></a><a id="VLDBG14079"></a>Example 6-2 Full partition-wise join with a reference-partitioned table</p>
<pre>
CREATE TABLE orders
( order_id     NUMBER(12) NOT NULL
, order_date   DATE NOT NULL
, order_mode   VARCHAR2(8)
, order_status VARCHAR2(1)
, CONSTRAINT orders_pk PRIMARY KEY (order_id)
)
PARTITION BY RANGE (order_date)
( PARTITION p_before_jan_2006 VALUES LESS THAN (TO_DATE('01-JAN-2006','dd-MON-yyyy'))
, PARTITION p_2006_jan VALUES LESS THAN (TO_DATE('01-FEB-2006','dd-MON-yyyy'))
, PARTITION p_2006_feb VALUES LESS THAN (TO_DATE('01-MAR-2006','dd-MON-yyyy'))
, PARTITION p_2006_mar VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy'))
, PARTITION p_2006_apr VALUES LESS THAN (TO_DATE('01-MAY-2006','dd-MON-yyyy'))
, PARTITION p_2006_may VALUES LESS THAN (TO_DATE('01-JUN-2006','dd-MON-yyyy'))
, PARTITION p_2006_jun VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy'))
, PARTITION p_2006_jul VALUES LESS THAN (TO_DATE('01-AUG-2006','dd-MON-yyyy'))
, PARTITION p_2006_aug VALUES LESS THAN (TO_DATE('01-SEP-2006','dd-MON-yyyy'))
, PARTITION p_2006_sep VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
, PARTITION p_2006_oct VALUES LESS THAN (TO_DATE('01-NOV-2006','dd-MON-yyyy'))
, PARTITION p_2006_nov VALUES LESS THAN (TO_DATE('01-DEC-2006','dd-MON-yyyy'))
, PARTITION p_2006_dec VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
)
PARALLEL;

CREATE TABLE order_items
( order_id NUMBER(12) NOT NULL
, product_id NUMBER NOT NULL
, quantity NUMBER NOT NULL
, sales_amount NUMBER NOT NULL
, CONSTRAINT order_items_orders_fk FOREIGN KEY (order_id) REFERENCES 
orders(order_id)
)
PARTITION BY REFERENCE (order_items_orders_fk)
PARALLEL;
</pre></div>
<!-- class="example" -->
<p>A typical data warehouse query would scan a large amount of data. Note that in the underlying execution plan, the columns <code>Rows</code>, <code>Bytes</code>, <code>Cost (%CPU)</code>, <code>Time</code>, and <code>TQ</code> have been removed.</p>
<pre>
EXPLAIN PLAN FOR
SELECT o.order_date
, sum(oi.sales_amount) sum_sales
FROM orders o
, order_items oi
WHERE o.order_id = oi.order_id
AND o.order_date BETWEEN TO_DATE('01-FEB-2006','DD-MON-YYYY')
                     AND TO_DATE('31-MAY-2006','DD-MON-YYYY')
GROUP BY o.order_id
, o.order_date
ORDER BY o.order_date;

---------------------------------------------------------------------------------------------
| Id  | Operation                         | Name        | Pstart| Pstop |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |             |       |       |      |            |
|   1 |  PX COORDINATOR                   |             |       |       |      |            |
|   2 |   PX SEND QC (ORDER)              | :TQ10001    |       |       | P-&gt;S | QC (ORDER) |
|   3 |    SORT GROUP BY                  |             |       |       | PCWP |            |
|   4 |     PX RECEIVE                    |             |       |       | PCWP |            |
|   5 |      PX SEND RANGE                | :TQ10000    |       |       | P-&gt;P | RANGE      |
|   6 |       SORT GROUP BY               |             |       |       | PCWP |            |
|   7 |        PX PARTITION RANGE ITERATOR|             |     3 |     6 | PCWC |            |
|*  8 |         HASH JOIN                 |             |       |       | PCWP |            |
|*  9 |          TABLE ACCESS FULL        | ORDERS      |     3 |     6 | PCWP |            |
|  10 |          TABLE ACCESS FULL        | ORDER_ITEMS |     3 |     6 | PCWP |            |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   8 - access("O"."ORDER_ID"="OI"."ORDER_ID")
   9 - filter("O"."ORDER_DATE"&lt;=TO_DATE(' 2006-05-31 00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre></div>
<!-- class="sect3" -->
<a id="CHDGDICE"></a><a id="VLDBG1349"></a>
<div class="sect3">
<h4 class="sect3">Partial Partition-Wise Joins</h4>
<p><a id="sthref764"></a><a id="sthref765"></a><a id="sthref766"></a>Oracle Database can perform partial partition-wise joins only in parallel. Unlike full partition-wise joins, partial partition-wise joins require you to partition only one table on the join key, not both tables. The partitioned table is referred to as the reference table. The other table may or may not be partitioned. Partial partition-wise joins are more common than full partition-wise joins.</p>
<p>To execute a partial partition-wise join, the database dynamically partitions or repartitions the other table based on the partitioning of the reference table. After the other table is repartitioned, the execution is similar to a full partition-wise join.</p>
<p><a href="#CHDFIAFH">Example 6-3</a> shows a call detail records table, <code>cdrs</code>, in a typical data warehouse scenario. The table is interval-hash partitioned.</p>
<div class="example">
<p class="titleinexample"><a id="CHDFIAFH"></a><a id="VLDBG14080"></a>Example 6-3 Partial partition-wise join on an interval-hash partitioned table</p>
<pre>
CREATE TABLE cdrs
( id                 NUMBER
, cust_id            NUMBER
, from_number        VARCHAR2(20)
, to_number          VARCHAR2(20)
, date_of_call       DATE
, distance           VARCHAR2(1)
, call_duration_in_s NUMBER(4)
) PARTITION BY RANGE(date_of_call)
INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY HASH(cust_id)
SUBPARTITIONS 16
(PARTITION p0 VALUES LESS THAN (TO_DATE('01-JAN-2005','dd-MON-yyyy')))
PARALLEL;
</pre></div>
<!-- class="example" -->
<p>The <code>cdrs</code> table is joined with the nonpartitioned <code>callers</code> table on the <code>cust_id</code> column to rank the customers who spent the most time making calls.</p>
<pre>
EXPLAIN PLAN FOR
SELECT c.cust_id
,      c.cust_last_name
,      c.cust_first_name
,      AVG(call_duration_in_s)
,      COUNT(1)
,      DENSE_RANK() OVER
       (ORDER BY (AVG(call_duration_in_s) * COUNT(1)) DESC) ranking
FROM   callers c
,      cdrs    cdr
WHERE cdr.cust_id = c.cust_id
AND cdr.date_of_call BETWEEN TO_DATE('01-JAN-2006','dd-MON-yyyy')
                         AND TO_DATE('31-DEC-2006','dd-MON-yyyy')  
GROUP BY c.cust_id
, c.cust_last_name
, c.cust_first_name
ORDER BY ranking;
</pre>
<p>The execution plans shows a partial partition-wise join. Note that the columns <code>Rows</code>, <code>Bytes</code>, <code>Cost (%CPU)</code>, <code>Time</code>, and <code>TQ</code> have been removed.</p>
<pre>
--------------------------------------------------------------------------------------------
| Id  | Operation                           | Name     | Pstart| Pstop |IN-OUT| PQ Distrib |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |          |       |       |      |            |
|   1 |  WINDOW NOSORT                      |          |       |       |      |            |
|   2 |   PX COORDINATOR                    |          |       |       |      |            |
|   3 |    PX SEND QC (ORDER)               | :TQ10002 |       |       | P-&gt;S | QC (ORDER) |
|   4 |     SORT ORDER BY                   |          |       |       | PCWP |            |
|   5 |      PX RECEIVE                     |          |       |       | PCWP |            |
|   6 |       PX SEND RANGE                 | :TQ10001 |       |       | P-&gt;P | RANGE      |
|   7 |        HASH GROUP BY                |          |       |       | PCWP |            |
|*  8 |         HASH JOIN                   |          |       |       | PCWP |            |
|   9 |          PART JOIN FILTER CREATE    | :BF0000  |       |       | PCWP |            |
|  10 |           BUFFER SORT               |          |       |       | PCWC |            |
|  11 |            PX RECEIVE               |          |       |       | PCWP |            |
|  12 |             PX SEND PARTITION (KEY) | :TQ10000 |       |       | S-&gt;P | PART (KEY) |
|  13 |              TABLE ACCESS FULL      | CALLERS  |       |       |      |            |
|  14 |          PX PARTITION RANGE ITERATOR|          |   367 |   731 | PCWC |            |
|  15 |           PX PARTITION HASH ALL     |          |     1 |    16 | PCWC |            |
|* 16 |            TABLE ACCESS FULL        | CDRS     |  5857 | 11696 | PCWP |            |
--------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   8 - access("CDR"."CUST_ID"="C"."CUST_ID")
  16 - filter("CDR"."DATE_OF_CALL"&gt;=TO_DATE(' 2006-01-01 00:00:00', 'syyyy-mm-dd 
hh24:mi:ss') AND "CDR"."DATE_OF_CALL"&lt;=TO_DATE('
              2006-12-31 00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre></div>
<!-- class="sect3" -->
<a id="CHDIEDGF"></a><a id="VLDBG1350"></a>
<div class="sect3">
<h4 class="sect3">Benefits of Partition-Wise Joins</h4>
<p><a id="sthref767"></a>Partition-wise joins offer benefits described in the following topics:</p>
<ul>
<li>
<p><a href="#CACEEBAI">Reduction of Communications Overhead</a></p>
</li>
<li>
<p><a href="#CACBFEHJ">Reduction of Memory Requirements</a></p>
</li>
</ul>
<a id="CACEEBAI"></a><a id="VLDBG1351"></a>
<div class="sect4">
<h5 class="sect4">Reduction of Communications Overhead</h5>
<p>When executed in parallel, partition-wise joins reduce communications overhead. This is because, in the default case, parallel execution of a join operation by a set of parallel execution servers requires the redistribution of each table on the join column into disjoint subsets of rows. These disjoint subsets of rows are then joined pair-wise by a single parallel execution server.</p>
<p>The database can avoid redistributing the partitions because the two tables are partitioned on the join column. This functionality enables each parallel execution server to join a pair of matching partitions. This improved performance from using parallel execution is even more noticeable in Oracle Real Application Clusters configurations with internode parallel execution.</p>
<p>Partition-wise joins dramatically reduce interconnect traffic. Using this feature is key for large decision support systems (DSS) configurations that use Oracle Real Application Clusters. Currently, most Oracle Real Application Clusters platforms, such as massively parallel processing (MPP) and symmetric multiprocessing (SMP) clusters, provide limited interconnect bandwidths compared to their processing powers. Ideally, interconnect bandwidth should be comparable to disk bandwidth, but this is seldom the case. Consequently, most join operations in Oracle Real Application Clusters experience high interconnect latencies without parallel execution of partition-wise joins.</p>
</div>
<!-- class="sect4" -->
<a id="CACBFEHJ"></a><a id="VLDBG1352"></a>
<div class="sect4">
<h5 class="sect4">Reduction of Memory Requirements</h5>
<p>Partition-wise joins require less memory than the equivalent join operation of the complete data set of the tables being joined. For serial joins, the join is performed at the same time on a pair of matching partitions. If data is evenly distributed across partitions, then the memory requirement is divided by the number of partitions. There is no skew.</p>
<p>For parallel joins, memory requirements depend on the number of partition pairs that are joined in parallel. For example, if the degree of parallelism is 20 and the number of partitions is 100, then 5 times less memory is required because only 20 joins of two partitions each are performed at the same time. The fact that partition-wise joins require less memory has a direct beneficial effect on performance. For example, the join probably does not need to write blocks to disk during the build phase of a hash join.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDEHGCE"></a><a id="VLDBG1353"></a>
<div class="sect3">
<h4 class="sect3">Performance Considerations for Parallel Partition-Wise Joins</h4>
<p><a id="sthref768"></a><a id="sthref769"></a>The optimizer weighs the advantages and disadvantages when deciding whether to use partition-wise joins based on the following:</p>
<ul>
<li>
<p>In range partitioning where partition sizes differ, data skew increases response time; some parallel execution servers take longer than others to finish their joins. Oracle recommends the use of hash partitioning and subpartitioning to enable partition-wise joins because hash partitioning, if the number of partitions is a power of two, limits the risk of skew. Ideally, the hash partitioning key is unique to minimize the risk of skew.</p>
</li>
<li>
<p>The number of partitions used for partition-wise joins should, if possible, be a multiple of the number of query servers. With a degree of parallelism of 16, for example, you can have 16, 32, or even 64 partitions. If there is an odd number of partitions, then some parallel execution servers are used less than others. For example, if there are 17 evenly distributed partition pairs, only one pair works on the last join, while the other pair has to wait. This is because, in the beginning of the execution, each parallel execution server works on a different partition pair. After this first phase, only one pair remains. Thus, a single parallel execution server joins this remaining pair while all other parallel execution servers are idle.</p>
</li>
</ul>
<p>In some situations, parallel joins can cause remote I/O operations. For example, on Oracle Real Application Clusters environments running on MPP configurations, if a pair of matching partitions is not collocated on the same node, a partition-wise join requires extra internode communication due to remote I/O. This is because Oracle Database must transfer at least one partition to the node where the join is performed. In this case, it is better to explicitly redistribute the data than to use a partition-wise join.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDDCGJA"></a><a id="VLDBG1354"></a>
<div class="sect2">
<h3 class="sect2">Indexes and Partitioned Indexes</h3>
<p><a id="sthref770"></a><a id="sthref771"></a>Indexes are optional structures associated with tables that allow SQL statements to execute more quickly against a table. Even though table scans are very common in many data warehouses, indexes can often speed up queries. B-tree and bitmap indexes are the most commonly used indexes in a data warehouse.</p>
<p>Both B-tree and bitmap indexes can be created as local indexes on a partitioned table, in which case they inherit the table's partitioning strategy. B-tree indexes can be created as global partitioned indexes on partitioned and nonpartitioned tables.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDGGBDJ">Local Partitioned Indexes</a></p>
</li>
<li>
<p><a href="#CHDJIHFA">Nonpartitioned Indexes</a></p>
</li>
<li>
<p><a href="#CHDFAFBH">Global Partitioned Indexes</a></p>
</li>
</ul>
<p>For more information about partitioned indexes, refer to <a href="part_avail.htm#BJEIEDIA">Chapter 3, "Partitioning for Availability, Manageability, and Performance"</a>.</p>
<a id="CHDGGBDJ"></a><a id="VLDBG1355"></a>
<div class="sect3">
<h4 class="sect3">Local Partitioned Indexes</h4>
<p><a id="sthref772"></a><a id="sthref773"></a>In a local index, all keys in a particular index partition refer only to rows stored in a single underlying table partition. A local index is equipartitioned with the underlying table. Oracle Database partitions the index on the same columns as the underlying table, creates the same number of partitions or subpartitions, and gives them the same partition boundaries as corresponding partitions of the underlying table.</p>
<p>Oracle Database also maintains the index partitioning automatically when partitions in the underlying table are added, dropped, merged, or split, or when hash partitions or subpartitions are added or coalesced. This ensures that the index remains equipartitioned with the table.</p>
<p>For data warehouse applications, local nonprefixed indexes can improve performance because many index partitions can be scanned in parallel by range queries on the index key. The following example creates a local B-tree index on a partitioned <code>customers</code> table:</p>
<pre>
ALTER SESSION enable parallel ddl;

CREATE INDEX cust_last_name_ix
ON customers(last_name) LOCAL
PARALLEL NOLOGGING ;
</pre>
<p>Bitmap indexes use a very efficient storage mechanism for low cardinality columns. Bitmap indexes are commonly used in data warehouses, especially in data warehouses that implement <span class="italic">star</span> <span class="italic">schemas</span>. A single star schema consists of a central large fact table and multiple smaller dimension tables that describe the data in the fact table.</p>
<p>For example, the <code>sales</code> table in the sample <code>sh</code> schema in Oracle Database is a fact table, that is described by dimension tables <code>customers</code>, <code>products</code>, <code>promotions</code>, <code>times</code>, and <code>channels</code>. Bitmap indexes enable the star transformation, an optimization for fast query retrieval against star or star look-a-like schemas.</p>
<p>Fact table foreign key columns are ideal candidates for bitmap indexes, because generally there are few distinct values relative to the total number of rows. Fact tables are often range or range-* partitioned, in which case you must create local bitmap indexes. Global bitmap indexes on partitioned tables are not supported.</p>
<p>The following example creates a local partitioned bitmap index on the <code>sales</code> table:</p>
<pre>
ALTER SESSION enable parallel ddl;

CREATE BITMAP INDEX prod_id_ix
ON sales(prod_id) LOCAL
PARALLEL NOLOGGING;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information about the star transformation</div>
</div>
<!-- class="sect3" -->
<a id="CHDJIHFA"></a><a id="VLDBG1356"></a>
<div class="sect3">
<h4 class="sect3">Nonpartitioned Indexes</h4>
<p><a id="sthref774"></a><a id="sthref775"></a>You can create nonpartitioned indexes on nonpartitioned and partitioned tables. Nonpartitioned indexes are primarily used on nonpartitioned tables in data warehouse environments. You can use a nonpartitioned global index on a partitioned table to enforce a primary or unique key. A nonpartitioned (global) index can be useful for queries that commonly retrieve very few rows based on equality predicates or <code>IN</code>-list on a column or set of columns that is not included in the partitioning key. In those cases, it can be faster to scan a single index than to scan many index partitions to find all matching rows.</p>
<p>Unique indexes on columns other than the partitioning columns must be global because unique local nonprefixed indexes whose keys do not contain the partitioning keys are not supported. Unique keys are not always enforced in data warehouses due to the controlled data load processes and the performance cost of enforcing the unique constraint. Global indexes can grow very large on tables with billions of rows.</p>
<p>The following example creates a global unique index on the <code>sales</code> table:</p>
<pre>
ALTER SESSION enable parallel ddl;

CREATE UNIQUE INDEX sales_unique_ix
ON sales(cust_id, prod_id, promo_id, channel_id, time_id)
PARALLEL NOLOGGING;
</pre>
<p>Note that very few queries benefit from this index. In systems with a very limited data load window, consider not creating and maintaining it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Most partition maintenance operations invalidate nonpartitioned indexes, forcing an index rebuild.</div>
</div>
<!-- class="sect3" -->
<a id="CHDFAFBH"></a><a id="VLDBG1357"></a>
<div class="sect3">
<h4 class="sect3">Global Partitioned Indexes</h4>
<p><a id="sthref776"></a><a id="sthref777"></a>You can create global partitioned indexes on nonpartitioned and partitioned tables. In a global partitioned index, the keys in a particular index partition may refer to rows stored in multiple underlying table partitions or subpartitions. A global index can be range- or hash-partitioned, though it can be defined on any type of partitioned table.</p>
<p>A global index is created by specifying the <code>GLOBAL</code> attribute. The database administrator is responsible for defining the initial partitioning of a global index at creation and for maintaining the partitioning over time. Index partitions can be merged or split as necessary.</p>
<p>Global indexes can be useful if there is a class of queries that uses an access path to the table to retrieve a few rows through an index, and by partitioning the index you can eliminate large portions of the index for the majority of its queries. On a partitioned table, you would consider a global partitioned index if the column or columns included to achieve partition pruning do not include the table partitioning key.</p>
<p>The following example creates a global hash-partitioned index on the <code>sales</code> table:</p>
<pre>
CREATE INDEX cust_id_prod_id_global_ix
ON sales(cust_id,prod_id)
GLOBAL PARTITION BY HASH (cust_id)
( PARTITION p1 TABLESPACE tbs1
, PARTITION p2 TABLESPACE tbs2
, PARTITION p3 TABLESPACE tbs3
, PARTITION p4 TABLESPACE tbs4
)
PARALLEL NOLOGGING;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Most partition maintenance operations invalidate global partitioned indexes, forcing an index rebuild.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDCJFDB"></a><a id="VLDBG1359"></a>
<div class="sect2">
<h3 class="sect2">Materialized Views and Partitioning</h3>
<p><a id="sthref778"></a><a id="sthref779"></a>One technique employed in data warehouses to improve performance is the creation of summaries. Summaries are special types of aggregate views that improve query execution times by precalculating expensive joins and aggregation operations before execution and storing the results in a table in the database. For example, you can create a summary table to contain the sums of sales by region and by product.</p>
<p>The summaries or aggregates that are referred to in this guide and in literature on data warehousing are created in Oracle Database using a schema object called a materialized view. Materialized views in a data warehouse speed up query performance.</p>
<p>The database supports transparent rewrites against materialized views, so that you do not need to modify the original queries to take advantage of precalculated results in materialized views. Instead of executing the query, the database retrieves precalculated results from one or more materialized views, performs any necessary additional operations on the data, and returns the query results. The database guarantees correct results based on your setting of the <code>QUERY_REWRITE_INTEGRITY</code> initialization parameter.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a></div>
<a id="VLDBG1360"></a>
<div class="sect3"><a id="sthref780"></a>
<h4 class="sect3">Partitioned Materialized Views</h4>
<p><a id="sthref781"></a><a id="sthref782"></a>The underlying storage for a materialized view is a table structure. You can partition materialized views like you can partition tables. When the database rewrites a query to run against materialized views, the query can take advantage of the same performance features from which queries running against tables directly benefit. The rewritten query may eliminate materialized view partitions. If joins back to tables or with other materialized views are necessary to retrieve the query result, then the rewritten query can take advantage of partition-wise joins.</p>
<p><a href="#CHDHDFFE">Example 6-4</a> shows how to create a compressed partitioned materialized view that aggregates sales results to country level. This materialized view benefits from queries that summarize sales numbers by country level or higher to subregion or region level.</p>
<div class="example">
<p class="titleinexample"><a id="CHDHDFFE"></a><a id="VLDBG14081"></a>Example 6-4 Creating a compressed partitioned materialized view</p>
<pre>
ALTER SESSION ENABLE PARALLEL DDL;

CREATE MATERIALIZED VIEW country_sales
PARTITION BY HASH (country_id)
PARTITIONS 16
COMPRESS FOR OLTP
PARALLEL NOLOGGING
ENABLE QUERY REWRITE
AS SELECT co.country_id
, co.country_name
, co.country_subregion
, co.country_region
, sum(sa.quantity_sold) country_quantity_sold
, sum(sa.amount_sold) country_amount_sold
FROM sales sa
, customers cu
, countries co
WHERE sa.cust_id = cu.cust_id
AND cu.country_id = co.country_id
GROUP BY co.country_id
, co.country_name
, co.country_subregion
, co.country_region;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CACBEICJ"></a><a id="VLDBG00504"></a>
<div class="sect1">
<h2 class="sect1">Manageability</h2>
<p><a id="sthref783"></a><a id="sthref784"></a>Data warehouses store historical data. Important parts of a data warehouse are the data loading and purging. Partitioning is powerful technology that can help data management for data warehouses.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDGHGEI">Partition Exchange Load</a></p>
</li>
<li>
<p><a href="#CHDBACCJ">Partitioning and Indexes</a></p>
</li>
<li>
<p><a href="#CHDDEADD">Partitioning and Materialized View Refresh Strategies</a></p>
</li>
<li>
<p><a href="#CHDFEEFF">Removing Data from Tables</a></p>
</li>
<li>
<p><a href="#CHDCBDHB">Partitioning and Data Compression</a></p>
</li>
<li>
<p><a href="#CHDIJFCG">Gathering Statistics on Large Partitioned Tables</a></p>
</li>
</ul>
<a id="CHDGHGEI"></a><a id="VLDBG1361"></a>
<div class="sect2">
<h3 class="sect2">Partition Exchange Load</h3>
<p><a id="sthref785"></a><a id="sthref786"></a>Partitions can be added using partition exchange load (PEL). When you use PEL, you create a separate table that looks exactly like a single partition, including the same indexes and constraints, if any. If you use a composite partitioned table, then your separate table must use a partitioning strategy that matches the subpartitioning strategy of your composite partitioned table. You can then exchange an existing table partition with this separate table. In a data load scenario, data can be loaded into the separate table. Build indexes and implement constraints on the separate table, without impacting the table users query. Then perform the PEL, which is a very low-impact transaction compared to the data load. Daily loads, with a range partition strategy by day, are common in data warehouse environments.</p>
<p>The following example shows a partition exchange load for the <code>sales</code> table:</p>
<pre>
ALTER TABLE sales ADD PARTITION p_sales_jun_2007
VALUES LESS THAN (TO_DATE('01-FEB-2007','dd-MON-yyyy'));

CREATE TABLE sales_jun_2007 COMPRESS FOR OLTP
AS SELECT * FROM sales WHERE 1=0;
</pre>
<p>Next, populate table <code>sales_jun_2007</code> with sales numbers for June 2007, and create the equivalent bitmap indexes and constraints that have been implemented on the <code>sales</code> table:</p>
<pre>
CREATE BITMAP INDEX time_id_jun_2007_bix ON sales_jun_2007(time_id) 
NOLOGGING;
CREATE BITMAP INDEX cust_id_jun_2007_bix ON sales_jun_2007(cust_id) 
NOLOGGING;
CREATE BITMAP INDEX prod_id_jun_2007_bix ON sales_jun_2007(prod_id) 
NOLOGGING;
CREATE BITMAP INDEX promo_id_jun_2007_bix ON sales_jun_2007(promo_id) 
NOLOGGING;
CREATE BITMAP INDEX channel_id_jun_2007_bix ON sales_jun_2007(channel_id) 
NOLOGGING;

ALTER TABLE sales_jun_2007 ADD CONSTRAINT prod_id_fk FOREIGN KEY (prod_id) 
REFERENCES products(prod_id);
ALTER TABLE sales_jun_2007 ADD CONSTRAINT cust_id_fk FOREIGN KEY (cust_id) 
REFERENCES customers(cust_id);
ALTER TABLE sales_jun_2007 ADD CONSTRAINT promo_id_fk FOREIGN KEY (promo_id) 
REFERENCES promotions(promo_id);
ALTER TABLE sales_jun_2007 ADD CONSTRAINT time_id_fk FOREIGN KEY (time_id) 
REFERENCES times(time_id);
ALTER TABLE sales_jun_2007 ADD CONSTRAINT channel_id_fk FOREIGN KEY 
(channel_id) REFERENCES channels(channel_id);
</pre>
<p>Next, exchange the partition:</p>
<pre>
ALTER TABLE sales
EXCHANGE PARTITION p_sales_jun_2007
WITH TABLE sales_jun_2007
INCLUDING INDEXES;
</pre>
<p>For more information about partition exchange load, refer to <a href="part_admin.htm#g1030303">Chapter 4, "Partition Administration"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBACCJ"></a><a id="VLDBG1362"></a>
<div class="sect2">
<h3 class="sect2">Partitioning and Indexes</h3>
<p><a id="sthref787"></a><a id="sthref788"></a>Partition maintenance operations are most easily performed on local indexes. Local indexes do not invalidate a global index when partition management takes place. Use <code>INCLUDING INDEXES</code> in the PEL statement to exchange the local indexes with the equivalent indexes on the separate table so that no index partitions get invalidated. For PEL, you can update global indexes as part of the load. Use the <code>UPDATE GLOBAL INDEXES</code> extension to the PEL statement. If an index requires updating, then the PEL takes much longer.</p>
</div>
<!-- class="sect2" -->
<a id="CHDDEADD"></a><a id="VLDBG1363"></a>
<div class="sect2">
<h3 class="sect2">Partitioning and Materialized View Refresh Strategies</h3>
<p><a id="sthref789"></a><a id="sthref790"></a>There are different ways to keep materialized views updated:</p>
<ul>
<li>
<p>Full refresh</p>
</li>
<li>
<p>Fast (incremental) refresh based on materialized view logs against the underlying tables</p>
</li>
<li>
<p>Manually using DML, followed by <code>ALTER MATERIALIZED VIEW CONSIDER FRESH</code></p>
</li>
</ul>
<p>To enable query rewrites, set the <code>QUERY_REWRITE_INTEGRITY</code> initialization parameter. If you manually keep materialized views up-to-date, then you must set <code>QUERY_REWRITE_INTEGRITY</code> to either <code>TRUSTED</code> or <code>STALE_TOLERATED</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a></div>
<p>If your materialized views and underlying tables use comparable partitioning strategies, then PEL can be an extremely powerful way to keep materialized views up-to-date manually. For example, if both your underlying table and your materialized view use range partitioning, then you can consider PEL to keep your underlying table and materialized view up-to-date. The total data refresh scenario would work as follows:</p>
<ul>
<li>
<p>Create tables to enable PEL against the tables and materialized views.</p>
</li>
<li>
<p>Load data into the tables, build the indexes, and implement any constraints.</p>
</li>
<li>
<p>Update the base tables using PEL.</p>
</li>
<li>
<p>Update the materialized views using PEL.</p>
</li>
<li>
<p>Execute <code>ALTER MATERIALIZED VIEW CONSIDER FRESH</code> for every materialized view you updated using this strategy.</p>
</li>
</ul>
<p>Note that this strategy implies a short interval, in between PEL against the underlying table and PEL against the materialized view, in which the materialized view does not reflect the current data in the underlying tables. Consider the <code>QUERY_REWRITE_INTEGRITY</code> setting and the activity on your system to identify whether you can manage this situation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink TDPDW" href="../../server.112/e25555/toc.htm"><span class="italic">Oracle Database 2 Day + Data Warehousing Guide</span></a> for an example of this refresh scenario</div>
</div>
<!-- class="sect2" -->
<a id="CHDFEEFF"></a><a id="VLDBG1364"></a>
<div class="sect2">
<h3 class="sect2">Removing Data from Tables</h3>
<p><a id="sthref791"></a><a id="sthref792"></a>Data warehouses commonly keep a time window of data. For example, three years of historical data is stored.</p>
<p>Partitioning makes it very easy to purge data from a table. You can use the <code>DROP PARTITION</code> or <code>TRUNCATE PARTITION</code> statements to purge data. Common strategies also include using a partition exchange load to unload the data from the table and replacing the partition with an empty table before dropping the partition. Archive the separate table you exchanged before emptying or dropping it.</p>
<p>Note that a drop or truncate operation would invalidate a global index or a global partitioned index. Local indexes remain valid. The local index partition is dropped when you drop the table partition.</p>
<p>The following example shows how to drop partition <code>sales_1995</code> from the <code>sales</code> table:</p>
<pre>
ALTER TABLE sales
DROP PARTITION sales_1995
UPDATE GLOBAL INDEXES PARALLEL;
</pre></div>
<!-- class="sect2" -->
<a id="CHDCBDHB"></a><a id="VLDBG1365"></a>
<div class="sect2">
<h3 class="sect2">Partitioning and Data Compression</h3>
<p><a id="sthref793"></a><a id="sthref794"></a>Data in a partitioned table can be compressed on a partition-by-partition basis. Using compressed data is most efficient for data that does not change frequently. Common data warehouse scenarios often see few data changes as data ages and other scenarios only insert data. Using the partition management features, you can compress data on a partition-by-partition basis. Although Oracle Database supports compression for all DML operations, it is still more efficient to modify data in a noncompressed table.</p>
<p>Note that altering a partition to enable compression applies only to future data to be inserted into the partition. To compress the existing data in the partition, you must move the partition. Enabling compression and moving a partition can be done in a single operation.</p>
<p>To use table compression on partitioned tables with bitmap indexes, you must do the following before you introduce the compression attribute for the first time:</p>
<ol>
<li>
<p>Mark bitmap indexes <code>UNUSABLE</code>.</p>
</li>
<li>
<p>Set the compression attribute.</p>
</li>
<li>
<p>Rebuild the indexes.</p>
</li>
</ol>
<p>The first time you make a compressed partition part of an existing, fully uncompressed partitioned table, you must either drop all existing bitmap indexes or mark them <code>UNUSABLE</code> before adding a compressed partition. This must be done regardless of whether any partition contains data. It is also independent of the operation that causes one or more compressed partitions to become part of the table. This does not apply to a partitioned table having only B-tree indexes.</p>
<p>The following example shows how to compress the <code>SALES_1995</code> partition in the <code>sales</code> table:</p>
<pre>
ALTER SESSION enable parallel ddl;

ALTER TABLE sales
MOVE PARTITION sales_1995
COMPRESS FOR OLTP
PARALLEL NOLOGGING;
</pre>
<p>If a table or a partition takes less space on disk, then the performance of large table scans in an I/O-constraint environment may improve.</p>
</div>
<!-- class="sect2" -->
<a id="CHDIJFCG"></a><a id="VLDBG1366"></a>
<div class="sect2">
<h3 class="sect2">Gathering Statistics on Large Partitioned Tables</h3>
<p><a id="sthref795"></a><a id="sthref796"></a>To get obtain SQL execution plans, it is important to have reliable table statistics. Oracle Database automatically gathers statistics using the statistics job that is activated upon database installation, or you can manually gather statistics using the <code>DBMS_STATS</code> package. Managing statistics on large tables is more challenging than managing statistics on smaller tables.</p>
<p>If a query accesses only a single table partition, then it is best to have partition-level statistics. If queries perform some partition elimination, but not down to a single partition, then you should gather both partition-level statistics and global statistics. Oracle Database 11<span class="italic">g</span> can maintain global statistics for a partitioned table incrementally. Only partitions that have changed are scanned, not the entire table.</p>
<p>A typical scenario for <a id="sthref797"></a>statistics management on a partitioned table is the use of partition exchange load (PEL). If you add data using PEL and you do not plan to update the global-level statistics as part of the data load, then you should gather statistics on the table into which the data was initially loaded, before you exchange it with the partition. Your global-level statistics become stale after the partition exchange. When you gather the global-level statistics again, or when the automatic statistics gathering job gathers the global-level statistics again, only the new partition, and not the entire table, is scanned.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1828">
<tr>
<td class="cellalignment1837">
<table class="cellalignment1833">
<tr>
<td class="cellalignment1832"><a href="part_lifecycle.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1832"><a href="part_oltp.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1840">
<table class="cellalignment1831">
<tr>
<td class="cellalignment1832"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1832"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1832"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1832"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1832"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1832"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
