<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Advanced Materialized Views</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 070" />
<meta name="dcterms.created" content="2013-07-04T23:23:16Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Warehousing Guide" />
<meta name="dcterms.identifier" content="E25554-02" />
<meta name="dcterms.isVersionOf" content="DWHSG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="basicmv.htm" title="Previous" type="text/html" />
<link rel="Next" href="dimen.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25554.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/35</span> <!-- End Header --><a id="g1014110"></a><a id="DWHSG009"></a><a id="i1007694"></a>
<h1 class="chapter"><span class="secnum">10</span> Advanced Materialized Views</h1>
<p>This chapter discusses advanced topics in using materialized views. It contains the following topics:</p>
<ul>
<li>
<p><a href="#i1006635">Partitioning and Materialized Views</a></p>
</li>
<li>
<p><a href="#i1006814">Materialized Views in Analytic Processing Environments</a></p>
</li>
<li>
<p><a href="#i1008530">Materialized Views and Models</a></p>
</li>
<li>
<p><a href="#i1007082">Invalidating Materialized Views</a></p>
</li>
<li>
<p><a href="#i1007090">Security Issues with Materialized Views</a></p>
</li>
<li>
<p><a href="#i1007099">Altering Materialized Views</a></p>
</li>
</ul>
<a id="i1006635"></a><a id="DWHSG8227"></a>
<div class="sect1">
<h2 class="sect1">Partitioning and Materialized Views</h2>
<p><a id="sthref268"></a><a id="sthref269"></a>Because of the large volume of data held in a data warehouse, partitioning is an extremely useful option when designing a database. Partitioning the fact tables improves scalability, simplifies system administration, and makes it possible to define local indexes that can be efficiently rebuilt. Partitioning the fact tables also improves the opportunity of fast refreshing the materialized view because this may enable Partition Change Tracking (PCT) refresh on the materialized view. Partitioning a materialized view also has benefits for refresh, because the refresh procedure can then use parallel DML in more scenarios and PCT-based refresh can use truncate partition to efficiently maintain the materialized view. See <a class="olink VLDBG" href="../e25523/toc.htm"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for further details about partitioning.</p>
<a id="i1006649"></a><a id="DWHSG00324"></a>
<div class="sect2">
<h3 class="sect2">Partition Change Tracking</h3>
<p>It is <a id="sthref270"></a><a id="sthref271"></a>possible and advantageous to track freshness to a finer grain than the entire materialized view. The ability to identify which rows in a materialized view are affected by a certain detail table partition, is known as Partition Change Tracking. When one or more of the detail tables are partitioned, it may be possible to identify the specific rows in the materialized view that correspond to a modified detail partition(s); those rows become stale when a partition is modified while all other rows remain fresh.</p>
<p>You can use PCT to identify which materialized view rows correspond to a particular partition. PCT is also used to support fast refresh after partition maintenance operations on detail tables. For instance, if a detail table partition is truncated or dropped, the affected rows in the materialized view are identified and deleted.</p>
<p>Identifying which materialized view rows are fresh or stale, rather than considering the entire materialized view as stale, allows query rewrite to use those rows that are fresh while in <code>QUERY_REWRITE_INTEGRITY</code> = <code>ENFORCED</code> or <code>TRUSTED</code> modes. Several views, such as <code>DBA_MVIEW_DETAIL_PARTITION</code>, detail which partitions are stale or fresh. Oracle does not rewrite against partial stale materialized views if partition change tracking on the changed table is enabled by the presence of join dependent expression in the materialized view. See <a href="#i1009012">"Join Dependent Expression"</a> for more information.</p>
<p>To support PCT, a materialized view must satisfy the following requirements:</p>
<ul>
<li>
<p>At least one of the detail tables referenced by the materialized view must be partitioned.</p>
</li>
<li>
<p>Partitioned tables must use either range, list or composite partitioning.</p>
</li>
<li>
<p>The top level partition key must consist of only a single column.</p>
</li>
<li>
<p>The materialized view must contain either the partition key column or a partition marker or <code>ROWID</code> or join dependent expression of the detail table. See <a class="olink ARPLS027" href="../../appdev.112/e40758/d_mview.htm#ARPLS027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details regarding the <code>DBMS_MVIEW.PMARKER</code> function.</p>
</li>
<li>
<p>If you use a <code>GROUP</code> <code>BY</code> clause, the partition key column or the partition marker or <code>ROWID</code> or join dependent expression must be present in the <code>GROUP</code> <code>BY</code> clause.</p>
</li>
<li>
<p>If you use an analytic window function or the <code>MODEL</code> clause, the partition key column or the partition marker or <code>ROWID</code> or join dependent expression must be present in their respective <code>PARTITION</code> <code>BY</code> subclauses.</p>
</li>
<li>
<p>Data modifications can only occur on the partitioned table. If PCT refresh is being done for a table which has join dependent expression in the materialized view, then data modifications should not have occurred in any of the join dependent tables.</p>
</li>
<li>
<p>The <code>COMPATIBILITY</code> initialization parameter must be a minimum of 9.0.0.0.0.</p>
</li>
<li>
<p>PCT is not supported for a materialized view that refers to views, remote tables, or outer joins.</p>
</li>
</ul>
<a id="DWHSG8228"></a>
<div class="sect3"><a id="sthref272"></a>
<h4 class="sect3">Partition Key</h4>
<p>Partition change tracking requires sufficient information in the materialized view to be able to correlate a detail row in the source partitioned detail table to the corresponding materialized view row. This can be accomplished by including the detail table partition key columns in the <code>SELECT</code> list and, if <code>GROUP</code> <code>BY</code> is used, in the <code>GROUP</code> <code>BY</code> list.</p>
<p>Consider an example of a materialized view storing daily customer sales. The following example uses the <code>sh</code> sample schema and the three detail tables <code>sales</code>, <code>products</code>, and <code>times</code> to create the materialized view. <code>sales</code> table is partitioned by <code>time_id</code> column and <code>products</code> is partitioned by the <code>prod_id</code> column. <code>times</code> is not a partitioned table.</p>
<div class="example">
<p class="titleinexample"><a id="i1009112"></a><a id="DWHSG8229"></a>Example 10-1 Partition Key</p>
<p>The following is an example:</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON SALES WITH ROWID
   (prod_id, time_id, quantity_sold, amount_sold) INCLUDING NEW VALUES;
CREATE MATERIALIZED VIEW LOG ON PRODUCTS WITH ROWID
   (prod_id, prod_name, prod_desc) INCLUDING NEW VALUES;
CREATE MATERIALIZED VIEW LOG ON TIMES WITH ROWID
   (time_id, calendar_month_name, calendar_year) INCLUDING NEW VALUES;


CREATE MATERIALIZED VIEW cust_dly_sales_mv
BUILD DEFERRED REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.time_id, p.prod_id, p.prod_name, COUNT(*),
         SUM(s.quantity_sold), SUM(s.amount_sold),
         COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY s.time_id, p.prod_id, p.prod_name;
</pre>
<p>For <code>cust_dly_sales_mv</code>, PCT is enabled on both the <code>sales</code> table and <code>products</code> table because their respective partitioning key columns <code>time_id</code> and <code>prod_id</code> are in the materialized view.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i1009012"></a><a id="DWHSG8230"></a>
<div class="sect3">
<h4 class="sect3">Join Dependent Expression</h4>
<p>An expression consisting of columns from tables directly or indirectly joined through equijoins to the partitioned detail table on the partitioning key and which is either a dimensional attribute or a dimension hierarchical parent of the joining key is called a join dependent expression. The set of tables in the path to detail table are called join dependent tables. Consider the following:</p>
<pre>
SELECT s.time_id, t.calendar_month_name 
FROM sales s, times t WHERE s.time_id = t.time_id;
</pre>
<p>In this query, <code>times</code> table is a join dependent table since it is joined to <code>sales</code> table on the partitioning key column <code>time_id</code>. Moreover, <code>calendar_month_name</code> is a dimension hierarchical attribute of <code>times.time_id</code>, because <code>calendar_month_name</code> is an attribute of <code>times.mon_id</code> and <code>times.mon_id</code> is a dimension hierarchical parent of <code>times.time_id</code>. Hence, the expression <code>calendar_month_name</code> from <code>times</code> tables is a join dependent expression. Let's consider another example:</p>
<pre>
SELECT s.time_id, y.calendar_year_name
FROM sales s, times_d d, times_m m, times_y y
WHERE s.time_id = d.time_id AND d.day_id = m.day_id AND m.mon_id = y.mon_id;
</pre>
<p>Here, <code>times</code> table is denormalized into <code>times_d</code>, <code>times_m</code> and <code>times_y</code> tables. The expression <code>calendar_year_name</code> from <code>times_y</code> table is a join dependent expression and the tables <code>times_d</code>, <code>times_m</code> and <code>times_y</code> are join dependent tables. This is because <code>times_y</code> table is joined indirectly through <code>times_m</code> and <code>times_d</code> tables to sales table on its partitioning key column <code>time_id</code>.</p>
<p>This lets users create materialized views containing aggregates on some level higher than the partitioning key of the detail table. Consider the following example of materialized view storing monthly customer sales.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8231"></a><a id="sthref273"></a>Example 10-2 Join Dependent Expression</p>
<p>Assuming the presence of materialized view logs defined earlier, the materialized view can be created using the following DDL:</p>
<pre>
CREATE MATERIALIZED VIEW cust_mth_sales_mv
BUILD DEFERRED REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT t.calendar_month_name, p.prod_id, p.prod_name, COUNT(*),
    SUM(s.quantity_sold), SUM(s.amount_sold),
    COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY t.calendar_month_name, p.prod_id, p.prod_name;
</pre>
<p>Here, you can correlate a detail table row to its corresponding materialized view row using the join dependent table <code>times</code> and the relationship that <code>times.calendar_month_name</code> is a dimensional attribute determined by <code>times.time_id</code>. This enables partition change tracking on <code>sales</code> table. In addition to this, PCT is enabled on products table because of presence of its partitioning key column <code>prod_id</code> in the materialized view.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="DWHSG8232"></a>
<div class="sect3"><a id="sthref274"></a>
<h4 class="sect3">Partition Marker</h4>
<p>The <code>DBMS_MVIEW.PMARKER</code> function is designed to significantly reduce the cardinality of the materialized view (see <a href="#i1009199">Example 10-3</a> for an example). The function returns a partition identifier that uniquely identifies the partition for a specified row within a specified partition table. Therefore, the <code>DBMS_MVIEW.PMARKER</code> function is used instead of the partition key column in the <code>SELECT</code> and <code>GROUP</code> <code>BY</code> clauses.</p>
<p>Unlike the general case of a PL/SQL function in a materialized view, use of the <code>DBMS_MVIEW.PMARKER</code> does not prevent rewrite with that materialized view even when the rewrite mode is <code>QUERY_REWRITE_INTEGRITY = ENFORCED</code>.</p>
<p>As an example of using the <code>PMARKER</code> function, consider calculating a typical number, such as revenue generated by a product category during a given year. If there were 1000 different products sold each month, it would result in 12,000 rows in the materialized view.</p>
<div class="example">
<p class="titleinexample"><a id="i1009199"></a><a id="DWHSG8233"></a>Example 10-3 Partition Marker</p>
<p>Consider an example of a materialized view storing the yearly sales revenue for each product category. With approximately hundreds of different products in each product category, including the partitioning key column <code>prod_id</code> of the <code>products</code> table in the materialized view would substantially increase the cardinality. Instead, this materialized view uses the <code>DBMS_MVIEW.PMARKER</code> function, which increases the cardinality of materialized view by a factor of the number of partitions in the <code>products</code> table.</p>
<pre>
CREATE MATERIALIZED VIEW prod_yr_sales_mv
BUILD DEFERRED
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT DBMS_MVIEW.PMARKER(p.rowid), p.prod_category, t.calendar_year, COUNT(*),
       SUM(s.amount_sold), SUM(s.quantity_sold),
       COUNT(s.amount_sold), COUNT(s.quantity_sold)
FROM   sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY  DBMS_MVIEW.PMARKER (p.rowid), p.prod_category, t.calendar_year;
</pre>
<p><code>prod_yr_sales_mv</code> includes the <code>DBMS_MVIEW.PMARKER</code> function on the <code>products</code> table in its <code>SELECT</code> list. This enables partition change tracking on <code>products</code> table with significantly less cardinality impact than grouping by the partition key column <code>prod_id</code>. In this example, the desired level of aggregation for the <code>prod_yr_sales_mv</code> is to group by <code>products.prod_category</code>. Using the <code>DBMS_MVIEW.PMARKER</code> function, the materialized view cardinality is increased only by a factor of the number of partitions in the <code>products</code> table. This would generally be significantly less than the cardinality impact of including the partition key columns.</p>
<p>Note that partition change tracking is enabled on <code>sales</code> table because of presence of join dependent expression <code>calendar_year</code> in the <code>SELECT</code> list.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="DWHSG8234"></a>
<div class="sect3"><a id="sthref275"></a>
<h4 class="sect3">Partial Rewrite</h4>
<p>A subsequent <code>INSERT</code> statement adds a new row to the <code>sales_part3</code> partition of table <code>sales</code>. At this point, because <code>cust_dly_sales_mv</code> has PCT available on table <code>sales</code> using a partition key, Oracle can identify the stale rows in the materialized view <code>cust_dly_sales_mv</code> corresponding to <code>sales_part3</code> partition (The other rows are unchanged in their freshness state). Query rewrite cannot identify the fresh portion of materialized views <code>cust_mth_sales_mv</code> and <code>prod_yr_sales_mv</code> because PCT is available on table sales using join dependent expressions. Query rewrite can determine the fresh portion of a materialized view on changes to a detail table only if PCT is available on the detail table using a partition key or partition marker.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006729"></a><a id="DWHSG8235"></a>
<div class="sect2">
<h3 class="sect2">Partitioning a Materialized View</h3>
<p>Partitioning a materialized view involves defining the materialized view with the standard Oracle partitioning clauses, as illustrated in the following example. This statement creates a materialized view called <code>part_sales_mv</code>, which uses three partitions, can be fast refreshed, and is eligible for query rewrite:</p>
<pre>
CREATE MATERIALIZED VIEW part_sales_mv
PARALLEL PARTITION BY RANGE (time_id)
(PARTITION month1
      VALUES LESS THAN (TO_DATE('31-12-1998', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf1,
 PARTITION month2
      VALUES LESS THAN (TO_DATE('31-12-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf2,
 PARTITION month3
      VALUES LESS THAN (TO_DATE('31-12-2000', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf3)
BUILD DEFERRED
REFRESH FAST
ENABLE QUERY REWRITE AS
SELECT s.cust_id, s.time_id,
  SUM(s.amount_sold) AS sum_dol_sales, SUM(s.quantity_sold) AS sum_unit_sales
  FROM sales s GROUP BY s.time_id, s.cust_id;
</pre></div>
<!-- class="sect2" -->
<a id="i1006757"></a><a id="DWHSG8236"></a>
<div class="sect2">
<h3 class="sect2">Partitioning a Prebuilt Table</h3>
<p><a id="sthref276"></a>Alternatively, a materialized view can be registered to a partitioned prebuilt table as illustrated in the following example:</p>
<pre>
CREATE TABLE part_sales_tab_mv(time_id, cust_id, sum_dollar_sales, sum_unit_sale)
PARALLEL PARTITION BY RANGE (time_id)
(PARTITION month1
      VALUES LESS THAN (TO_DATE('31-12-1998', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf1,
 PARTITION month2
      VALUES LESS THAN (TO_DATE('31-12-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf2,
PARTITION month3
      VALUES LESS THAN (TO_DATE('31-12-2000', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf3)  AS
SELECT s.time_id, s.cust_id, SUM(s.amount_sold) AS sum_dollar_sales, 
  SUM(s.quantity_sold) AS sum_unit_sales
FROM sales s GROUP BY s.time_id, s.cust_id;

CREATE MATERIALIZED VIEW part_sales_tab_mv
ON PREBUILT TABLE
ENABLE QUERY REWRITE AS 
SELECT s.time_id,  s.cust_id, SUM(s.amount_sold) AS sum_dollar_sales, 
     SUM(s.quantity_sold) AS sum_unit_sales 
FROM sales s GROUP BY s.time_id, s.cust_id;
</pre>
<p>In this example, the table <code>part_sales_tab_mv</code> has been partitioned over three months and then the materialized view was registered to use the prebuilt table. This materialized view is eligible for query rewrite because the <code>ENABLE</code> <code>QUERY</code> <code>REWRITE</code> clause has been included.</p>
<a id="i1009128"></a><a id="DWHSG8237"></a>
<div class="sect3">
<h4 class="sect3">Benefits of Partitioning a Materialized View</h4>
<p>When a materialized view is partitioned on the partitioning key column or join dependent expressions of the detail table, it is more efficient to use a <code>TRUNCATE</code> <code>PARTITION</code> statement to remove one or more partitions of the materialized view during refresh and then repopulate the partition with new data. Oracle Database uses this variant of fast refresh (called PCT refresh) with partition truncation if the following conditions are satisfied in addition to other conditions described in <a href="#i1006649">"Partition Change Tracking"</a>.</p>
<ul>
<li>
<p>The materialized view is partitioned on the partitioning key column or join dependent expressions of the detail table.</p>
</li>
<li>
<p>If PCT is enabled using either the partitioning key column or join expressions, the materialized view should be range or list partitioned.</p>
</li>
<li>
<p>PCT refresh is nonatomic.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DWHSG8238"></a>
<div class="sect2"><a id="sthref277"></a>
<h3 class="sect2">Rolling Materialized Views</h3>
<p>When a data warehouse or data mart contains a time dimension, it is often desirable to archive the oldest information and then reuse the storage for new information. This is called the rolling window scenario. If the fact tables or materialized views include a time dimension and are horizontally partitioned by the time attribute, then management of rolling materialized views can be reduced to a few fast partition maintenance operations provided the unit of data that is rolled out equals, or is at least aligned with, the range partitions.</p>
<p>If you plan to have rolling materialized views in your data warehouse, you should determine how frequently you plan to perform partition maintenance operations, and you should plan to partition fact tables and materialized views to reduce the amount of system administration overhead required when old data is aged out. An additional consideration is that you might want to use data compression on your infrequently updated partitions.</p>
<p>You are not restricted to using range partitions. For example, a composite partition using both a time value and a key value could result in a good partition solution for your data.</p>
<p>See <a href="refresh.htm#g1018554">Chapter 16, "Maintaining the Data Warehouse"</a> for further details regarding <code>CONSIDER</code> <code>FRESH</code> and for details regarding compression.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006814"></a><a id="DWHSG8239"></a>
<div class="sect1">
<h2 class="sect1">Materialized Views in Analytic Processing <a id="sthref278"></a><a id="sthref279"></a>Environments</h2>
<p>This section discusses the concepts used by analytic SQL and how relational databases can handle these types of queries. It also illustrates the best approach for creating materialized views using a common scenario.</p>
<a id="DWHSG8240"></a>
<div class="sect2"><a id="sthref280"></a>
<h3 class="sect2"><a id="sthref281"></a><a id="sthref282"></a>Cubes</h3>
<p>While data warehouse environments typically view data in the form of a star schema, for analytical SQL queries, data is held in the form of a hierarchical cube. A hierarchical cube includes the data aggregated along the rollup hierarchy of each of its dimensions and these aggregations are combined across dimensions. It includes the typical set of aggregations needed for business intelligence queries.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8241"></a><a id="sthref283"></a>Example 10-4 Hierarchical Cube</p>
<p>Consider a sales data set with<a id="sthref284"></a><a id="sthref285"></a> two dimensions, each of which has a 4-level hierarchy:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>Time, which contains (all times), year, quarter, and month.</p>
</li>
<li>
<p>Product, which contains (all products), division, brand, and item.</p>
</li>
</ul>
<p>This means there are 16 aggregate groups in the hierarchical cube. This is because the four levels of time are multiplied by four levels of product to produce the cube. <a href="#i1006832">Table 10-1</a> shows the four levels of each dimension.</p>
<div class="tblformal">
<p class="titleintable"><a id="DWHSG8242"></a><a id="sthref286"></a><a id="sthref287"></a>Table 10-1 <a id="i1006832"></a><span class="bolditalic">ROLLUP By Time and Product</span></p>
<table class="cellalignment1381" title="ROLLUP By Time and Product" summary="ROLLUP By Time and Product" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t2">ROLLUP By Time</th>
<th class="cellalignment1382" id="r1c2-t2">ROLLUP By Product</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t2" headers="r1c1-t2">
<p>year, quarter, month</p>
</td>
<td class="cellalignment1378" headers="r2c1-t2 r1c2-t2">
<p>division, brand, item</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t2" headers="r1c1-t2">
<p>year, quarter</p>
</td>
<td class="cellalignment1378" headers="r3c1-t2 r1c2-t2">
<p>division, brand</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t2" headers="r1c1-t2">
<p>year</p>
</td>
<td class="cellalignment1378" headers="r4c1-t2 r1c2-t2">
<p>division</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t2" headers="r1c1-t2">
<p>all times</p>
</td>
<td class="cellalignment1378" headers="r5c1-t2 r1c2-t2">
<p>all products</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Note that as you increase the number of dimensions and levels, the number of groups to calculate increases dramatically. This example involves 16 groups, but if you were to add just two more dimensions with the same number of levels, you would have 4 x 4 x 4 x 4 = 256 different groups. Also, consider that a similar increase in groups occurs if you have multiple hierarchies in your dimensions. For example, the time dimension might have an additional hierarchy of fiscal month rolling up to fiscal quarter and then fiscal year. Handling the explosion of groups has historically been the major challenge in data storage for online analytical processing systems.</p>
<p>Typical online analytical queries <a href="glossary.htm#i997101"><span class="xrefglossterm">slice and dice</span></a> different parts of the cube comparing aggregations from one level to aggregation from another level. For instance, a query might find sales of the grocery division for the month of January, 2002 and compare them with total sales of the grocery division for all of 2001.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8243"></a>
<div class="sect2"><a id="sthref288"></a>
<h3 class="sect2">Benefits of Partitioning Materialized Views</h3>
<p>Materialized views with multiple aggregate groups give their best performance for refresh and query rewrite when partitioned appropriately.</p>
<p>PCT refresh in a rolling window scenario requires partitioning at the top level on some level from the time dimension. And, partition pruning for queries rewritten against this materialized view requires partitioning on <code>GROUPING_ID</code> column. Hence, the most effective partitioning scheme for these materialized views is to use composite partitioning (range-list on (<code>time</code>, <code>GROUPING_ID</code>) columns). By partitioning the materialized views this way, you enable:</p>
<ul>
<li>
<p>PCT refresh, thereby improving refresh performance.</p>
</li>
<li>
<p>Partition pruning: only relevant aggregate groups are accessed, thereby greatly reducing the query processing cost.</p>
</li>
</ul>
<p>If you do not want to use PCT refresh, you can just partition by list on <code>GROUPING_ID</code> column.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8244"></a>
<div class="sect2"><a id="sthref289"></a>
<h3 class="sect2">Compressing Materialized Views</h3>
<p>You should consider data compression when using highly redundant data, such as tables with many foreign keys. In particular, materialized views created with the <code>ROLLUP</code> clause are likely candidates. See <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for data compression syntax and restrictions and <a href="basicmv.htm#i1006854">"Storage And Table Compression"</a> for details regarding compression.</p>
</div>
<!-- class="sect2" -->
<a id="i1007002"></a><a id="DWHSG8245"></a>
<div class="sect2">
<h3 class="sect2">Materialized Views with Set Operators</h3>
<p>Oracle Database provides support for <a id="sthref290"></a><a id="sthref291"></a>materialized views whose defining query involves set operators. Materialized views with set operators can now be created enabled for query rewrite. You can refresh the materialized view using either <code>ON</code> <code>COMMIT</code> or <code>ON</code> <code>DEMAND</code> refresh.</p>
<p>Fast refresh is supported if the defining query has the <code>UNION</code> <code>ALL</code> operator at the top level and each query block in the <code>UNION</code> <code>ALL</code>, meets the requirements of a materialized view with aggregates or materialized view with joins only. Further, the materialized view must include a constant column (known as a <code>UNION</code> <code>ALL</code> marker) that has a distinct value in each query block, which, in the following example, is columns <code>1 marker</code> and <code>2 marker</code>.</p>
<p>See <a href="basicmv.htm#CACBHGIJ">"Restrictions on Fast Refresh on Materialized Views with UNION ALL"</a> for detailed restrictions on fast refresh for materialized views with <code>UNION</code> <code>ALL</code>.</p>
<a id="DWHSG8246"></a>
<div class="sect3"><a id="sthref292"></a>
<h4 class="sect3">Examples of Materialized Views Using UNION ALL</h4>
<p>The following examples illustrate creation of fast refreshable materialized views involving <code>UNION</code> <code>ALL</code>.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8247"></a><a id="sthref293"></a>Example 10-5 Materialized View Using UNION ALL with Two Join Views</p>
<p>To create a <code>UNION</code> <code>ALL</code> materialized view with two join views, the materialized view logs must have the rowid column and, in the following example, the <code>UNION</code> <code>ALL</code> marker is the columns, <code>1 marker</code> and <code>2 marker</code>.</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;

CREATE MATERIALIZED VIEW unionall_sales_cust_joins_mv
REFRESH FAST ON COMMIT 
ENABLE QUERY REWRITE AS
(SELECT c.rowid crid, s.rowid srid, c.cust_id, s.amount_sold, 1 marker
FROM sales s, customers c
WHERE s.cust_id = c.cust_id AND c.cust_last_name = 'Smith')
UNION ALL
(SELECT c.rowid crid, s.rowid srid, c.cust_id, s.amount_sold, 2 marker
FROM sales s, customers c
WHERE s.cust_id = c.cust_id AND c.cust_last_name = 'Brown');
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8248"></a><a id="sthref294"></a>Example 10-6 Materialized View Using UNION ALL with Joins and Aggregates</p>
<p>The following example shows a <code>UNION</code> <code>ALL</code> of a materialized view with joins and a materialized view with aggregates. A couple of things can be noted in this example. Nulls or constants can be used to ensure that the data types of the corresponding <code>SELECT</code> list columns match. Also, the <code>UNION</code> <code>ALL</code> marker column can be a string literal, which is <code>'Year' umarker</code>, <code>'Quarter' umarker</code>, or <code>'Daily' umarker</code> in the following example:</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID, SEQUENCE
(amount_sold, time_id)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW LOG ON times WITH ROWID, SEQUENCE 
  (time_id, fiscal_year, fiscal_quarter_number, day_number_in_week) 
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW unionall_sales_mix_mv
REFRESH FAST ON DEMAND AS
(SELECT 'Year' umarker, NULL, NULL, t.fiscal_year, 
        SUM(s.amount_sold) amt, COUNT(s.amount_sold), COUNT(*)
 FROM sales s, times t
 WHERE s.time_id = t.time_id 
 GROUP BY t.fiscal_year)
UNION ALL
(SELECT 'Quarter' umarker, NULL, NULL, t.fiscal_quarter_number, 
        SUM(s.amount_sold) amt, COUNT(s.amount_sold), COUNT(*)
FROM sales s, times t 
WHERE s.time_id = t.time_id and t.fiscal_year = 2001
GROUP BY t.fiscal_quarter_number)
UNION ALL
(SELECT 'Daily' umarker, s.rowid rid, t.rowid rid2, t.day_number_in_week,
        s.amount_sold amt, 1, 1
FROM sales s, times t
WHERE s.time_id = t.time_id 
AND t.time_id between '01-Jan-01' AND '01-Dec-31');
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008530"></a><a id="DWHSG8249"></a>
<div class="sect1">
<h2 class="sect1">Materialized Views and Models</h2>
<p>Models, which provide array-based computations in SQL, can be used in materialized views. Because the <code>MODEL</code> clause calculations can be expensive, you may want to use two separate materialized views: one for the model calculations and one for the <code>SELECT</code> ... <code>GROUP</code> <code>BY</code> query. For example, instead of using one, long materialized view, you could create the following materialized views:</p>
<pre>
CREATE MATERIALIZED VIEW my_groupby_mv
REFRESH FAST
ENABLE QUERY REWRITE AS
SELECT country_name country, prod_name prod, calendar_year year,
  SUM(amount_sold) sale, COUNT(amount_sold) cnt, COUNT(*) cntstr 
FROM sales, times, customers, countries, products
WHERE sales.time_id = times.time_id AND
      sales.prod_id = products.prod_id AND
      sales.cust_id = customers.cust_id AND
      customers.country_id = countries.country_id
GROUP BY country_name, prod_name, calendar_year;

CREATE MATERIALIZED VIEW my_model_mv
ENABLE QUERY REWRITE AS
SELECT country, prod, year, sale, cnt
FROM my_groupby_mv
MODEL PARTITION BY(country) DIMENSION BY(prod, year)
   MEASURES(sale s) IGNORE NAV
(s['Shorts', 2000] =  0.2 * AVG(s)[CV(), year BETWEEN 1996 AND 1999],
s['Kids Pajama', 2000] = 0.5 * AVG(s)[CV(), year BETWEEN 1995 AND 1999],
s['Boys Pajama', 2000] = 0.6 * AVG(s)[CV(), year BETWEEN 1994 AND 1999],
...
&lt;hundreds of other update rules&gt;);
</pre>
<p>By using two materialized views, you can incrementally maintain the materialized view <code>my_groupby_mv</code>. The materialized view <code>my_model_mv</code> is on a much smaller data set because it is built on <code>my_groupby_mv</code> and can be maintained by a complete refresh.</p>
<p>Materialized views with models can use complete refresh or PCT refresh only, and are available for partial text query rewrite only.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="sqlmodel.htm#g1042989">Chapter 23, "SQL for Modeling"</a> for further details about model calculations</div>
</div>
<!-- class="sect1" -->
<a id="i1007082"></a><a id="DWHSG8250"></a>
<div class="sect1">
<h2 class="sect1">Invalidating Materialized Views</h2>
<p><a id="sthref295"></a><a id="sthref296"></a>Dependencies related to materialized views are automatically maintained to ensure correct operation. When a materialized view is created, the materialized view depends on the detail tables referenced in its definition. Any DML operation, such as an <code>INSERT</code>, or <code>DELETE</code>, <code>UPDATE</code>, or DDL operation on any dependency in the materialized view will cause it to become invalid. To revalidate a materialized view, use the <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> <code>COMPILE</code> statement.</p>
<p>A materialized view is automatically revalidated when it is referenced. In many cases, the materialized view will be successfully and transparently revalidated. However, if a column has been dropped in a table referenced by a materialized view or the owner of the materialized view did not have one of the query rewrite privileges and that privilege has now been granted to the owner, you should use the following statement to revalidate the materialized view:</p>
<pre>
ALTER MATERIALIZED VIEW mview_name COMPILE;
</pre>
<p>The state of a materialized view can be checked by querying the data dictionary views <code>USER_MVIEWS</code> or <code>ALL_MVIEWS</code>. The column <code>STALENESS</code> will show one of the values <code>FRESH</code>, <code>STALE</code>, <code>UNUSABLE</code>, <code>UNKNOWN</code>, <code>UNDEFINED</code>, or <code>NEEDS_COMPILE</code> to indicate whether the materialized view can be used. The state is maintained automatically. However, if the staleness of a materialized view is marked as <code>NEEDS_COMPILE</code>, you could issue an <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> ... <code>COMPILE</code> statement to validate the materialized view and get the correct staleness state. If the state of a materialized view is <code>UNUSABLE</code>, you must perform a complete refresh to bring the materialized view back to the <code>FRESH</code> state. If the materialized view is based on a prebuilt table that you never refresh, you must drop and re-create the materialized view. The staleness of remote materialized views is not tracked. Thus, if you use remote materialized views for rewrite, they are considered to be trusted.</p>
</div>
<!-- class="sect1" -->
<a id="i1007090"></a><a id="DWHSG8251"></a>
<div class="sect1">
<h2 class="sect1">Security Issues with Materialized Views</h2>
<p><a id="sthref297"></a>To create a <a id="sthref298"></a>materialized view in your own schema, you must have the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> privilege and the <code>SELECT</code> privilege to any tables referenced that are in another schema. To create a materialized view in another schema, you must have the <code>CREATE</code> <code>ANY</code> <code>MATERIALIZED</code> <code>VIEW</code> privilege and the owner of the materialized view needs <code>SELECT</code> privileges to the tables referenced if they are from another schema. Moreover, if you enable query rewrite on a materialized view that references tables outside your schema, you must have the <code>GLOBAL</code> <code>QUERY</code> <code>REWRITE</code> privilege or the <code>QUERY</code> <code>REWRITE</code> object privilege on each table outside your schema.</p>
<p>If the materialized view is on a prebuilt container, the creator, if different from the owner, must have <code>SELECT</code> <code>WITH</code> <code>GRANT</code> privilege on the container table.</p>
<p>If you continue to get a privilege error while trying to create a materialized view and you believe that all the required privileges have been granted, then the problem is most likely due to a privilege not being granted explicitly and trying to inherit the privilege from a role instead. The owner of the materialized view must have explicitly been granted <code>SELECT</code> access to the referenced tables if the tables are in a different schema.</p>
<p>If the materialized view is being created with <code>ON</code> <code>COMMIT</code> <code>REFRESH</code> specified, then the owner of the materialized view requires an additional privilege if any of the tables in the defining query are outside the owner's schema. In that case, the owner requires the <code>ON</code> <code>COMMIT</code> <code>REFRESH</code> system privilege or the <code>ON</code> <code>COMMIT</code> <code>REFRESH</code> object privilege on each table outside the owner's schema.</p>
<a id="DWHSG8252"></a>
<div class="sect2"><a id="sthref299"></a>
<h3 class="sect2">Querying Materialized Views with Virtual Private Database (VPD)</h3>
<p>For<a id="sthref300"></a><a id="sthref301"></a> all security concerns, a materialized view serves as a view that happens to be materialized when you are directly querying the materialized view. When creating a view or materialized view, the owner must have the necessary permissions to access the underlying base relations of the view or materialized view that they are creating. With these permissions, the owner can publish a view or materialized view that other users can access, assuming they have been granted access to the view or materialized view.</p>
<p>Using materialized views with Virtual Private Database is similar. When you create a materialized view, there must not be any VPD policies in effect against the base relations of the materialized view for the owner of the materialized view. However, the owner of the materialized view may establish a VPD policy on the new materialized view. Users who access the materialized view are subject to the VPD policy on the materialized view. However, they are not additionally subject to the VPD policies of the underlying base relations of the materialized view, since security processing of the underlying base relations is performed against the owner of the materialized view.</p>
<a id="DWHSG8253"></a>
<div class="sect3"><a id="sthref302"></a>
<h4 class="sect3">Using Query Rewrite with Virtual Private Database</h4>
<p>When you <a id="sthref303"></a>access a materialized view using query rewrite, the materialized view serves as an access structure much like an index. As such, the security implications for materialized views accessed in this way are much the same as for indexes: all security checks are performed against the relations specified in the request query. The index or materialized view is used to speed the performance of accessing the data, not provide any additional security checks. Thus, the presence of the index or materialized view presents no additional security checking.</p>
<p>This holds true when you are accessing a materialized view using query rewrite in the presence of VPD. The request query is subject to any VPD policies that are present against the relations specified in the query. Query rewrite may rewrite the query to use a materialize view instead of accessing the detail relations, but only if it can guarantee to deliver exactly the same rows as if the rewrite had not occurred. Specifically, query rewrite must retain and respect any VPD policies against the relations specified in the request query. However, any VPD policies against the materialized view itself do not have effect when the materialized view is accessed using query rewrite. This is because the data is already protected by the VPD policies against the relations in the request query.</p>
</div>
<!-- class="sect3" -->
<a id="BADJACCJ"></a><a id="DWHSG8254"></a>
<div class="sect3">
<h4 class="sect3">Restrictions with Materialized Views and Virtual Private Database</h4>
<p>Query <a id="sthref304"></a>rewrite does not use its full and partial text match modes with request queries that include relations with active VPD policies, but it does use general rewrite methods. This is because VPD transparently transforms the request query to affect the VPD policy. If query rewrite were to perform a text match transformation against a request query with a VPD policy, the effect would be to negate the VPD policy.</p>
<p>In addition, when you create or refresh a materialized view, the owner of the materialized view must not have any active VPD policies in effect against the base relations of the materialized view, or an error is returned. The materialized view owner must either have no such VPD policies, or any such policy must return <code>NULL</code>. This is because VPD would transparently modify the defining query of the materialized view such that the set of rows contained by the materialized view would not match the set of rows indicated by the materialized view definition.</p>
<p>One way to work around this restriction yet still create a materialized view containing the desired VPD-specified subset of rows is to create the materialized view in a user account that has no active VPD policies against the detail relations of the materialized view. In addition, you can include a predicate in the <code>WHERE</code> clause of the materialized view that embodies the effect of the VPD policy. When query rewrite attempts to rewrite a request query that has that VPD policy, it matches up the VPD-generated predicate on the request query with the predicate you directly specify when you create the materialized view.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007099"></a><a id="DWHSG8255"></a>
<div class="sect1">
<h2 class="sect1">Altering Materialized Views</h2>
<p><a id="sthref305"></a>Six modifications can be made to a materialized view. You can:</p>
<ul>
<li>
<p>Change its refresh option (<code>FAST/FORCE/COMPLETE/NEVER</code>).</p>
</li>
<li>
<p>Change its refresh mode (<code>ON</code> <code>COMMIT/ON</code> <code>DEMAND</code>).</p>
</li>
<li>
<p>Recompile it.</p>
</li>
<li>
<p>Enable or disable its use for query rewrite.</p>
</li>
<li>
<p>Consider it fresh.</p>
</li>
<li>
<p>Partition maintenance operations.</p>
</li>
</ul>
<p>All other changes are achieved by dropping and then re-creating the materialized view.</p>
<p>The <code>COMPILE</code> clause of the <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> statement can be used when the materialized view has been invalidated. This compile process is quick, and allows the materialized view to be used by query rewrite again.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF009" href="../../server.112/e41084/statements_2.htm#SQLRF009"><span class="italic">Oracle Database SQL Language Reference</span></a> for further information about the <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> statement</p>
</li>
<li>
<p><a href="#i1007082">"Invalidating Materialized Views"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1371">
<tr>
<td class="cellalignment1378">
<table class="cellalignment1376">
<tr>
<td class="cellalignment1375"><a href="basicmv.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1375"><a href="dimen.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1380">
<table class="cellalignment1374">
<tr>
<td class="cellalignment1375"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1375"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1375"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1375"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1375"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1375"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
