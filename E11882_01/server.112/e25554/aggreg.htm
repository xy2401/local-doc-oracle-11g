<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>SQL for Aggregation in Data Warehouses</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 070" />
<meta name="dcterms.created" content="2013-07-04T23:23:22Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Warehousing Guide" />
<meta name="dcterms.identifier" content="E25554-02" />
<meta name="dcterms.isVersionOf" content="DWHSG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="schemas.htm" title="Previous" type="text/html" />
<link rel="Next" href="analysis.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25554.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">30/35</span> <!-- End Header --><a id="g1023942"></a><a id="DWHSG020"></a><a id="i1007462"></a>
<h1 class="chapter"><span class="secnum">21</span> SQL for Aggregation in Data Warehouses</h1>
<p>This chapter discusses aggregation of SQL, a basic aspect of data warehousing. It contains these topics:</p>
<ul>
<li>
<p><a href="#CHDGJEBG">Overview of SQL for Aggregation in Data Warehouses</a></p>
</li>
<li>
<p><a href="#i1007413">ROLLUP Extension to GROUP BY</a></p>
</li>
<li>
<p><a href="#i1007428">CUBE Extension to GROUP BY</a></p>
</li>
<li>
<p><a href="#i1007434">GROUPING Functions</a></p>
</li>
<li>
<p><a href="#i1006842">GROUPING SETS Expression</a></p>
</li>
<li>
<p><a href="#i1006951">Composite Columns</a></p>
</li>
<li>
<p><a href="#i1007021">Concatenated Groupings</a></p>
</li>
<li>
<p><a href="#i1007169">Considerations when Using Aggregation</a></p>
</li>
<li>
<p><a href="#i1007241">Computation Using the WITH Clause</a></p>
</li>
<li>
<p><a href="#i1012749">Working with Hierarchical Cubes in SQL</a></p>
</li>
</ul>
<a id="CHDGJEBG"></a><a id="DWHSG8600"></a>
<div class="sect1">
<h2 class="sect1">Overview of SQL for Aggregation in Data Warehouses</h2>
<p>Aggregation is a fundamental part of data warehousing. To improve aggregation performance in your warehouse, Oracle Database provides the following functionality:</p>
<ul>
<li>
<p><code>CUBE</code> and <code>ROLLUP</code> extensions to the <code>GROUP</code> <code>BY</code> clause</p>
</li>
<li>
<p>Three <code>GROUPING</code> functions</p>
</li>
<li>
<p><code>GROUPING</code> <code>SETS</code> expression</p>
</li>
<li>
<p>Pivoting operations</p>
</li>
</ul>
<p>The <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING</code> <code>SETS</code> extensions to SQL make querying and reporting easier and faster. <code>CUBE</code>, <code>ROLLUP</code>, and grouping sets produce a single result set that is equivalent to a <code>UNION</code> <code>ALL</code> of differently grouped rows. <code>ROLLUP</code> calculates aggregations such as <code>SUM</code>, <code>COUNT</code>, <code>MAX</code>, <code>MIN</code>, and <code>AVG</code> at increasing levels of aggregation, from the most detailed up to a grand total. <code>CUBE</code> is an extension similar to <code>ROLLUP</code>, enabling a single statement to calculate all possible combinations of aggregations. The <code>CUBE</code>, <code>ROLLUP</code>, and the <code>GROUPING</code> <code>SETS</code> extension lets you specify just the groupings needed in the <code>GROUP</code> <code>BY</code> clause. This allows efficient analysis across multiple dimensions without performing a <code>CUBE</code> operation. Computing a <code>CUBE</code> creates a heavy processing load, so replacing cubes with grouping sets can significantly increase performance.</p>
<p>To enhance performance, <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING</code> <code>SETS</code> can be parallelized: multiple processes can simultaneously execute all of these statements. These capabilities make aggregate calculations more efficient, thereby enhancing database performance, and scalability.</p>
<p>The three <code>GROUPING</code> functions help you identify the group each row belongs to and enable sorting subtotal rows and filtering results.</p>
<a id="DWHSG8601"></a>
<div class="sect2"><a id="sthref1047"></a>
<h3 class="sect2">Analyzing Across Multiple Dimensions</h3>
<p><a id="sthref1048"></a><a id="sthref1049"></a>One of the key concepts in decision support systems is multidimensional analysis: examining the enterprise from all necessary combinations of dimensions. We use the term <a href="glossary.htm#i996878"><span class="xrefglossterm">dimension</span></a> to mean any category used in specifying questions. Among the most commonly specified dimensions are time, geography, product, department, and distribution channel, but the potential dimensions are as endless as the varieties of enterprise activity. The events or entities associated with a particular set of dimension values are usually referred to as facts. The facts might be sales in units or local currency, profits, customer counts, production volumes, or anything else worth tracking.</p>
<p>Here are some examples of multidimensional requests:</p>
<ul>
<li>
<p>Show total sales across all products at increasing aggregation levels for a geography dimension, from state to country to region, for 1999 and 2000.</p>
</li>
<li>
<p>Create a cross-tabular analysis of our operations showing expenses by territory in South America for 1999 and 2000. Include all possible subtotals.</p>
</li>
<li>
<p>List the top 10 sales representatives in Asia according to 2000 sales revenue for automotive products, and rank their commissions.</p>
</li>
</ul>
<p>All these requests involve multiple dimensions. Many multidimensional questions require aggregated data and comparisons of data sets, often across time, geography or budgets.</p>
<p>To visualize data that has many dimensions, analysts commonly use the analogy of a data cube, that is, a space where facts are stored at the intersection of n dimensions. <a href="#i1012453">Figure 21-1</a> shows a data cube and how it can be used differently by various groups. The cube stores sales data organized by the dimensions of product, market, sales, and time. Note that this is only a metaphor: the actual data is physically stored in normal tables. The cube data consists of both detail and aggregated data.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1012453"></a><a id="DWHSG8602"></a>Figure 21-1 Logical Cubes and Views by Different Users</p>
<img width="598" height="340" src="./dwhsg087.gif" alt="Description of Figure 21-1 follows" /><br />
<a id="sthref1050" href="./img_text/dwhsg087.htm">Description of "Figure 21-1 Logical Cubes and Views by Different Users"</a><br />
<br /></div>
<!-- class="figure" -->
<p>You can retrieve slices of data from the cube. These correspond to cross-tabular reports such as the one shown in <a href="#g1014032">Table 21-1</a>. Regional managers might study the data by comparing slices of the cube applicable to different markets. In contrast, product managers might compare slices that apply to different products. An ad hoc user might work with a wide variety of constraints, working in a subset cube.</p>
<p>Answering multidimensional questions often involves accessing and querying huge quantities of data, sometimes in millions of rows. Because the flood of detailed data generated by large organizations cannot be interpreted at the lowest level, aggregated views of the information are essential. Aggregations, such as sums and counts, across many dimensions are vital to multidimensional analyses. Therefore, analytical tasks require convenient and efficient data aggregation.</p>
</div>
<!-- class="sect2" -->
<a id="i1006264"></a><a id="DWHSG8603"></a>
<div class="sect2">
<h3 class="sect2">Optimized Performance</h3>
<p>Not only multidimensional issues, but all types of processing can benefit from enhanced aggregation facilities. Transaction processing, financial and manufacturing systems&shy;&mdash;all of these generate large numbers of production reports needing substantial system resources. Improved efficiency when creating these reports will reduce system load. In fact, any computer process that aggregates data from details to higher levels will benefit from optimized aggregation performance.</p>
<p>These extensions provide aggregation features and bring many benefits, including:</p>
<ul>
<li>
<p>Simplified programming requiring less SQL code for many tasks.</p>
</li>
<li>
<p>Quicker and more efficient query processing.</p>
</li>
<li>
<p>Reduced client processing loads and network traffic because aggregation work is shifted to servers.</p>
</li>
<li>
<p>Opportunities for caching aggregations because similar queries can leverage existing work.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006272"></a><a id="DWHSG8604"></a>
<div class="sect2">
<h3 class="sect2">An Aggregate Scenario</h3>
<p>To illustrate the use of the <code>GROUP</code> <code>BY</code> extension, this chapter uses the <code>sh</code> data of the sample schema. All the examples refer to data from this scenario. The hypothetical company has sales across the world and tracks sales by both dollars and quantities information. Because there are many rows of data, the queries shown here typically have tight constraints on their <code>WHERE</code> clauses to limit the results to a small number of rows.</p>
<div class="example">
<p class="titleinexample"><a id="CHDJEFEA"></a><a id="DWHSG8605"></a>Example 21-1 Simple Cross-Tabular Report With Subtotals</p>
<p><a href="#g1014032">Table 21-1</a> is a sample cross-tabular report showing the total sales by <code>country_id</code> and <code>channel_desc</code> for the US and France through the Internet and direct sales in September 2000.</p>
</div>
<!-- class="example" -->
<div class="tblformal">
<p class="titleintable"><a id="DWHSG8606"></a><a id="sthref1051"></a><a id="g1014032"></a>Table 21-1 Simple Cross-Tabular Report With Subtotals</p>
<table class="cellalignment1381" title="Simple Cross-Tabular Report With Subtotals" summary="Simple Cross-Tabular Report With Subtotals" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t2">Channel</th>
<th class="cellalignment1382" id="r1c2-t2">Country</th>
<th class="cellalignment1382" id="r1c3-t2"><br /></th>
<th class="cellalignment1382" id="r1c4-t2"><br /></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t2" headers="r1c1-t2">&nbsp;</td>
<td class="cellalignment1378" headers="r2c1-t2 r1c2-t2">
<p>France</p>
</td>
<td class="cellalignment1378" headers="r2c1-t2 r1c3-t2">
<p>US</p>
</td>
<td class="cellalignment1378" headers="r2c1-t2 r1c4-t2">
<p>Total</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t2" headers="r1c1-t2">
<p>Internet</p>
</td>
<td class="cellalignment1378" headers="r3c1-t2 r1c2-t2">
<p>9,597</p>
</td>
<td class="cellalignment1378" headers="r3c1-t2 r1c3-t2">
<p>124,224</p>
</td>
<td class="cellalignment1378" headers="r3c1-t2 r1c4-t2">
<p>133,821</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t2" headers="r1c1-t2">
<p>Direct Sales</p>
</td>
<td class="cellalignment1378" headers="r4c1-t2 r1c2-t2">
<p>61,202</p>
</td>
<td class="cellalignment1378" headers="r4c1-t2 r1c3-t2">
<p>638,201</p>
</td>
<td class="cellalignment1378" headers="r4c1-t2 r1c4-t2">
<p>699,403</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t2" headers="r1c1-t2">
<p>Total</p>
</td>
<td class="cellalignment1378" headers="r5c1-t2 r1c2-t2">
<p>70,799</p>
</td>
<td class="cellalignment1378" headers="r5c1-t2 r1c3-t2">
<p>762,425</p>
</td>
<td class="cellalignment1378" headers="r5c1-t2 r1c4-t2">
<p>833,224</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Consider that even a simple report such as this, with just nine values in its grid, generates four subtotals and a grand total. Half of the values needed for this report would not be calculated with a query that requested <code>SUM(amount_sold)</code> and did a <code>GROUP BY(channel_desc, country_id)</code>. To get the higher-level aggregates would require additional queries. Database commands that offer improved calculation of subtotals bring major benefits to querying, reporting, and analytical operations.</p>
<pre>
SELECT channels.channel_desc, countries.country_iso_code,
  TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id AND channels.channel_desc IN
  ('Direct Sales', 'Internet') AND times.calendar_month_desc='2000-09'
  AND customers.country_id=countries.country_id
  AND countries.country_iso_code IN ('US','FR')
GROUP BY CUBE(channels.channel_desc, countries.country_iso_code);

CHANNEL_DESC         CO SALES$
-------------------- -- --------------
                               833,224
                     FR         70,799
                     US        762,425
Internet                       133,821
Internet             FR          9,597
Internet             US        124,224
Direct Sales                   699,403
Direct Sales         FR         61,202
Direct Sales         US        638,201
</pre></div>
<!-- class="sect2" -->
<a id="DWHSG8607"></a>
<div class="sect2"><a id="sthref1052"></a>
<h3 class="sect2">Interpreting NULLs in Examples</h3>
<p><code>NULLs</code> returned by the <code>GROUP</code> <code>BY</code> extensions are not always the traditional null meaning value unknown. Instead, a <code>NULL</code> may indicate that its row is a subtotal. To avoid introducing another non-value in the database system, these subtotal values are not given a special tag.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007434">"GROUPING Functions"</a> for details on how the nulls representing subtotals are distinguished from nulls stored in the data</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007413"></a><a id="DWHSG8608"></a>
<div class="sect1">
<h2 class="sect1">ROLLUP Extension to GROUP BY</h2>
<p><a id="i1006367"></a><a id="sthref1053"></a><code>ROLLUP</code> enables a <code>SELECT</code> statement to calculate multiple levels of subtotals across a specified group of dimensions. It also calculates a grand total. <code>ROLLUP</code> is a simple extension to the <code>GROUP</code> <code>BY</code> clause, so its syntax is extremely easy to use. The <code>ROLLUP</code> extension is highly efficient, adding minimal overhead to a query.</p>
<p>The action of <code>ROLLUP</code> is straightforward: it creates subtotals that roll up from the most detailed level to a grand total, following a grouping list specified in the <code>ROLLUP</code> clause. <code>ROLLUP</code> takes as its argument an ordered list of grouping columns. First, it calculates the standard aggregate values specified in the <code>GROUP</code> <code>BY</code> clause. Then, it creates progressively higher-level subtotals, moving from right to left through the list of grouping columns. Finally, it creates a grand total.</p>
<p><code>ROLLUP</code> creates subtotals at n+1 levels, where n is the number of grouping columns. For instance, if a query specifies <code>ROLLUP</code> on grouping columns of <code>time</code>, <code>region</code>, and <code>department(n=3)</code>, the result set will include rows at four aggregation levels.</p>
<p>You might want to compress your data when using <code>ROLLUP</code>. This is particularly useful when there are few updates to older partitions.</p>
<a id="DWHSG8609"></a>
<div class="sect2"><a id="sthref1054"></a>
<h3 class="sect2">When to Use ROLLUP</h3>
<p><a id="sthref1055"></a>Use the <code>ROLLUP</code> extension in tasks involving subtotals.</p>
<ul>
<li>
<p>It is very helpful for subtotaling along a hierarchical dimension such as time or geography. For instance, a query could specify a <code>ROLLUP(y,</code> <code>m,</code> <code>day)</code> or <code>ROLLUP(country,</code> <code>state,</code> <code>city)</code>.</p>
</li>
<li>
<p>For data warehouse administrators using summary tables, <code>ROLLUP</code> can simplify and speed up the maintenance of summary tables.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="DWHSG8610"></a>
<div class="sect2"><a id="sthref1056"></a>
<h3 class="sect2">ROLLUP Syntax</h3>
<p><code>ROLLUP</code> appears in the <code>GROUP</code> <code>BY</code> clause in a <code>SELECT</code> statement. Its form is:</p>
<pre>
SELECT &hellip; GROUP BY ROLLUP(grouping_column_reference_list)
</pre>
<div class="example">
<p class="titleinexample"><a id="DWHSG8611"></a><a id="sthref1057"></a>Example 21-2 ROLLUP</p>
<p>This example uses the data in the <code>sh</code> sample schema data, the same data as was used in <a href="#i1012453">Figure 21-1</a>. The <code>ROLLUP</code> is across three dimensions.</p>
<pre>
SELECT channels.channel_desc, calendar_month_desc, 
       countries.country_iso_code,
       TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id 
  AND sales.cust_id=customers.cust_id 
  AND customers.country_id = countries.country_id
  AND sales.channel_id = channels.channel_id 
  AND channels.channel_desc IN ('Direct Sales', 'Internet') 
  AND times.calendar_month_desc IN ('2000-09', '2000-10') 
  AND countries.country_iso_code IN ('GB', 'US')
GROUP BY 
  ROLLUP(channels.channel_desc, calendar_month_desc, countries.country_iso_code);

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
Internet             2000-09  GB         16,569
Internet             2000-09  US        124,224
Internet             2000-09            140,793
Internet             2000-10  GB         14,539
Internet             2000-10  US        137,054
Internet             2000-10            151,593
Internet                                292,387
Direct Sales         2000-09  GB         85,223
Direct Sales         2000-09  US        638,201
Direct Sales         2000-09            723,424
Direct Sales         2000-10  GB         91,925
Direct Sales         2000-10  US        682,297
Direct Sales         2000-10            774,222
Direct Sales                          1,497,646
                                      1,790,032
</pre>
<p>Note that results do not always add up due to rounding.</p>
<p>This query returns the following sets of rows:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>Regular aggregation rows that would be produced by <code>GROUP</code> <code>BY</code> without using <code>ROLLUP</code>.</p>
</li>
<li>
<p>First-level subtotals aggregating across <code>country_id</code> for each combination of <code>channel_desc</code> and <code>calendar_month</code>.</p>
</li>
<li>
<p>Second-level subtotals aggregating across <code>calendar_month_desc</code> and <code>country_id</code> for each <code>channel_desc</code> value.</p>
</li>
<li>
<p>A grand total row.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="DWHSG8612"></a>
<div class="sect2"><a id="sthref1058"></a>
<h3 class="sect2">Partial Rollup</h3>
<p><a id="sthref1059"></a>You can also roll up so that only some of the sub-totals will be included. This partial rollup uses the following syntax:</p>
<pre>
GROUP BY expr1, ROLLUP(expr2, expr3);
</pre>
<p>In this case, the <code>GROUP</code> <code>BY</code> clause creates subtotals at (2+1=3) aggregation levels. That is, at level (<code>expr1</code>, <code>expr2</code>, <code>expr3</code>), (<code>expr1</code>, <code>expr2</code>), and (<code>expr1</code>).</p>
<div class="example">
<p class="titleinexample"><a id="CHDHHCEA"></a><a id="DWHSG8613"></a>Example 21-3 Partial ROLLUP</p>
<pre>
SELECT channel_desc, calendar_month_desc, countries.country_iso_code,
   TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN ('Direct Sales', 'Internet') 
  AND times.calendar_month_desc IN ('2000-09', '2000-10') 
  AND countries.country_iso_code IN ('GB', 'US')
GROUP BY channel_desc, ROLLUP(calendar_month_desc, countries.country_iso_code);

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
Internet             2000-09  GB         16,569
Internet             2000-09  US        124,224
Internet             2000-09            140,793
Internet             2000-10  GB         14,539
Internet             2000-10  US        137,054
Internet             2000-10            151,593
Internet                                292,387
Direct Sales         2000-09  GB         85,223
Direct Sales         2000-09  US        638,201
Direct Sales         2000-09            723,424
Direct Sales         2000-10  GB         91,925
Direct Sales         2000-10  US        682,297
Direct Sales         2000-10            774,222
Direct Sales                          1,497,646
</pre>
<p>This query returns the following sets of rows:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>Regular aggregation rows that would be produced by <code>GROUP</code> <code>BY</code> without using <code>ROLLUP</code>.</p>
</li>
<li>
<p>First-level subtotals aggregating across <code>country_id</code> for each combination of <code>channel_desc</code> and <code>calendar_month_desc</code>.</p>
</li>
<li>
<p>Second-level subtotals aggregating across <code>calendar_month_desc</code> and <code>country_id</code> for each <code>channel_desc</code> value.</p>
</li>
<li>
<p>It does not produce a grand total row.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007428"></a><a id="DWHSG8614"></a>
<div class="sect1">
<h2 class="sect1">CUBE Extension to GROUP BY</h2>
<p><a id="sthref1060"></a><code>CUBE</code> takes a specified set of grouping columns and creates subtotals for all of their possible combinations. In terms of multidimensional analysis, <code>CUBE</code> generates all the subtotals that could be calculated for a data cube with the specified dimensions. If you have specified <code>CUBE(time</code>, <code>region</code>, <code>department)</code>, the result set will include all the values that would be included in an equivalent <code>ROLLUP</code> statement plus additional combinations. For instance, in <a href="#i1012453">Figure 21-1</a>, the departmental totals across regions (279,000 and 319,000) would not be calculated by a <code>ROLLUP(time</code>, <code>region</code>, <code>department)</code> clause, but they would be calculated by a <code>CUBE(time</code>, <code>region</code>, <code>department)</code> clause. If <span class="italic">n</span> columns are specified for a <code>CUBE</code>, there will be 2 to the <span class="italic">n</span> combinations of subtotals returned. <a href="#i1011609">Example 21-4</a> gives an example of a three-dimension cube.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax and restrictions</div>
<a id="DWHSG8615"></a>
<div class="sect2"><a id="sthref1061"></a>
<h3 class="sect2">When to Use CUBE</h3>
<p>Consider <a id="sthref1062"></a>Using <code>CUBE</code> in any situation requiring cross-tabular reports. The data needed for cross-tabular reports can be generated with a single <code>SELECT</code> using <code>CUBE</code>. Like <code>ROLLUP</code>, <code>CUBE</code> can be helpful in generating summary tables. Note that population of summary tables is even faster if the <code>CUBE</code> query executes in parallel.</p>
<p><code>CUBE</code> is typically most suitable in queries that use columns from multiple dimensions rather than columns representing different levels of a single dimension. For instance, a commonly requested cross-tabulation might need subtotals for all the combinations of month, state, and product. These are three independent dimensions, and analysis of all possible subtotal combinations is commonplace. In contrast, a cross-tabulation showing all possible combinations of year, month, and day would have several values of limited interest, because there is a natural hierarchy in the time dimension. Subtotals such as profit by day of month summed across year would be unnecessary in most analyses. Relatively few users need to ask "What were the total sales for the 16th of each month across the year?" See <a href="#i1007192">"Hierarchy Handling in ROLLUP and CUBE"</a> for an example of handling rollup calculations efficiently.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8616"></a>
<div class="sect2"><a id="sthref1063"></a>
<h3 class="sect2">CUBE Syntax</h3>
<p><code>CUBE</code> appears in the <code>GROUP</code> <code>BY</code> clause in a <code>SELECT</code> statement. Its form is:</p>
<pre>
SELECT &hellip;  GROUP BY CUBE (grouping_column_reference_list)
</pre>
<div class="example">
<p class="titleinexample"><a id="i1011609"></a><a id="DWHSG8617"></a>Example 21-4 CUBE</p>
<pre>
SELECT channel_desc, calendar_month_desc, countries.country_iso_code,
      TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id
 AND customers.country_id = countries.country_id
 AND channels.channel_desc IN
  ('Direct Sales', 'Internet') AND times.calendar_month_desc IN
  ('2000-09', '2000-10') AND countries.country_iso_code IN ('GB', 'US')
GROUP BY CUBE(channel_desc, calendar_month_desc, countries.country_iso_code); 

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
                                      1,790,032
                              GB        208,257
                              US      1,581,775
                     2000-09            864,217
                     2000-09  GB        101,792
                     2000-09  US        762,425
                     2000-10            925,815
                     2000-10  GB        106,465
                     2000-10  US        819,351
Internet                                292,387
Internet                      GB         31,109
Internet                      US        261,278
Internet             2000-09            140,793
Internet             2000-09  GB         16,569
Internet             2000-09  US        124,224
Internet             2000-10            151,593
Internet             2000-10  GB         14,539
Internet             2000-10  US        137,054
Direct Sales                          1,497,646
Direct Sales                  GB        177,148
Direct Sales                  US      1,320,497
Direct Sales         2000-09            723,424
Direct Sales         2000-09  GB         85,223
Direct Sales         2000-09  US        638,201
Direct Sales         2000-10            774,222
Direct Sales         2000-10  GB         91,925
Direct Sales         2000-10  US        682,297
</pre>
<p>This query illustrates <code>CUBE</code> aggregation across three dimensions.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="DWHSG8618"></a>
<div class="sect2"><a id="sthref1064"></a>
<h3 class="sect2">Partial CUBE</h3>
<p><a id="sthref1065"></a>Partial <code>CUBE</code> resembles partial <code>ROLLUP</code> in that you can limit it to certain dimensions and precede it with columns outside the <code>CUBE</code> operator. In this case, subtotals of all possible combinations are limited to the dimensions within the cube list (in parentheses), and they are combined with the preceding items in the <code>GROUP</code> <code>BY</code> list.</p>
<p>The syntax for partial <code>CUBE</code> is as follows:</p>
<pre>
GROUP BY expr1, CUBE(expr2, expr3)
</pre>
<p>This syntax example calculates 2*2, or 4, subtotals. That is:</p>
<ul>
<li>
<p>(<code>expr1</code>, <code>expr2</code>, <code>expr3</code>)</p>
</li>
<li>
<p>(<code>expr1</code>, <code>expr2</code>)</p>
</li>
<li>
<p>(<code>expr1</code>, <code>expr3</code>)</p>
</li>
<li>
<p>(<code>expr1</code>)</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="DWHSG8619"></a><a id="sthref1066"></a>Example 21-5 Partial CUBE</p>
<p>Using the <code>sales</code> database, you can issue the following statement:</p>
<pre>
SELECT channel_desc, calendar_month_desc, countries.country_iso_code,
       TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id = times.time_id 
  AND sales.cust_id = customers.cust_id 
  AND customers.country_id=countries.country_id 
  AND sales.channel_id = channels.channel_id 
  AND channels.channel_desc IN ('Direct Sales', 'Internet') 
  AND times.calendar_month_desc IN ('2000-09', '2000-10') 
  AND countries.country_iso_code IN ('GB', 'US')
GROUP BY channel_desc, CUBE(calendar_month_desc, countries.country_iso_code);

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
Internet                                292,387
Internet                      GB         31,109
Internet                      US        261,278
Internet             2000-09            140,793
Internet             2000-09  GB         16,569
Internet             2000-09  US        124,224
Internet             2000-10            151,593
Internet             2000-10  GB         14,539
Internet             2000-10  US        137,054
Direct Sales                          1,497,646
Direct Sales                  GB        177,148
Direct Sales                  US      1,320,497
Direct Sales         2000-09            723,424
Direct Sales         2000-09  GB         85,223
Direct Sales         2000-09  US        638,201
Direct Sales         2000-10            774,222
Direct Sales         2000-10  GB         91,925
Direct Sales         2000-10  US        682,297
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="DWHSG8620"></a>
<div class="sect2"><a id="sthref1067"></a>
<h3 class="sect2">Calculating Subtotals Without CUBE</h3>
<p>Just as for <code>ROLLUP</code>, multiple <code>SELECT</code> statements combined with <code>UNION</code> <code>ALL</code> statements could provide the same information gathered through <code>CUBE</code>. However, this might require many <code>SELECT</code> statements. For an n-dimensional cube, 2 to the <span class="italic">n</span> <code>SELECT</code> statements are needed. In the three-dimension example, this would mean issuing <code>SELECT</code> statements linked with <code>UNION</code> <code>ALL</code>. So many <code>SELECT</code> statements yield inefficient processing and very lengthy SQL.</p>
<p>Consider the impact of adding just one more dimension when calculating all possible combinations: the number of <code>SELECT</code> statements would double to 16. The more columns used in a <code>CUBE</code> clause, the greater the savings compared to the <code>UNION</code> <code>ALL</code> approach.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007434"></a><a id="DWHSG8621"></a>
<div class="sect1">
<h2 class="sect1">GROUPING Functions</h2>
<p><a id="sthref1068"></a><a id="sthref1069"></a>Two challenges arise with the use of <code>ROLLUP</code> and <code>CUBE</code>. First, how can you programmatically determine which result set rows are subtotals, and how do you find the exact level of aggregation for a given subtotal? You often need to use subtotals in calculations such as percent-of-totals, so you need an easy way to determine which rows are the subtotals. Second, what happens if query results contain both stored <code>NULL</code> values and "NULL" values created by a <code>ROLLUP</code> or <code>CUBE</code>? How can you differentiate between the two? This section discusses some of these situations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax and restrictions</div>
<a id="DWHSG8622"></a>
<div class="sect2"><a id="sthref1070"></a>
<h3 class="sect2">GROUPING Function</h3>
<p><code>GROUPING</code> handles these problems. Using a single column as its argument, <code>GROUPING</code> returns 1 when it encounters a <code>NULL</code> value created by a <code>ROLLUP</code> or <code>CUBE</code> operation. That is, if the <code>NULL</code> indicates the row is a subtotal, <code>GROUPING</code> returns a 1. Any other type of value, including a stored <code>NULL</code>, returns a 0.</p>
<p><code>GROUPING</code> appears in the selection list portion of a <code>SELECT</code> statement. Its form is:</p>
<pre>
SELECT &hellip;  [GROUPING(dimension_column)&hellip;]  &hellip; 
  GROUP BY &hellip;    {CUBE | ROLLUP| GROUPING SETS}  (dimension_column)
</pre>
<div class="example">
<p class="titleinexample"><a id="DWHSG8623"></a><a id="sthref1071"></a>Example 21-6 GROUPING to Mask Columns</p>
<p>This example uses <code>GROUPING</code> to create a set of mask columns for the result set shown in <a href="#CHDHHCEA">Example 21-3</a>. The mask columns are easy to analyze programmatically.</p>
<pre>
SELECT channel_desc, calendar_month_desc, country_iso_code, 
TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$, GROUPING(channel_desc) AS Ch,
   GROUPING(calendar_month_desc) AS Mo, GROUPING(country_iso_code) AS Co
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id 
  AND sales.cust_id=customers.cust_id
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN ('Direct Sales', 'Internet') 
  AND times.calendar_month_desc IN ('2000-09', '2000-10') 
  AND countries.country_iso_code IN ('GB', 'US')
GROUP BY ROLLUP(channel_desc, calendar_month_desc, countries.country_iso_code);

CHANNEL_DESC         CALENDAR CO SALES$                 CH         MO         CO
-------------------- -------- -- -------------- ---------- ---------- ----------
Internet             2000-09  GB         16,569          0          0          0
Internet             2000-09  US        124,224          0          0          0
Internet             2000-09            140,793          0          0          1
Internet             2000-10  GB         14,539          0          0          0
Internet             2000-10  US        137,054          0          0          0
Internet             2000-10            151,593          0          0          1
Internet                                292,387          0          1          1
Direct Sales         2000-09  GB         85,223          0          0          0
Direct Sales         2000-09  US        638,201          0          0          0
Direct Sales         2000-09            723,424          0          0          1
Direct Sales         2000-10  GB         91,925          0          0          0
Direct Sales         2000-10  US        682,297          0          0          0
Direct Sales         2000-10            774,222          0          0          1
Direct Sales                          1,497,646          0          1          1
                                      1,790,032          1          1          1
</pre>
<p>A program can easily identify the detail rows by a mask of "0 0 0" on the T, R, and D columns. The first level subtotal rows have a mask of "0 0 1", the second level subtotal rows have a mask of "0 1 1", and the overall total row has a mask of "1 1 1".</p>
<p>You can improve the readability of result sets by using the <code>GROUPING</code> and <code>DECODE</code> functions as shown in <a href="#i1006669">Example 21-7</a>.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="i1006669"></a><a id="DWHSG8624"></a>Example 21-7 GROUPING For Readability</p>
<pre>
SELECT DECODE(GROUPING(channel_desc), 1, 'Multi-channel sum', channel_desc) AS
 Channel, DECODE (GROUPING (country_iso_code), 1, 'Multi-country sum',
 country_iso_code) AS Country, TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id 
  AND sales.cust_id=customers.cust_id 
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN ('Direct Sales', 'Internet') 
  AND times.calendar_month_desc= '2000-09'
  AND country_iso_code IN ('GB', 'US')
GROUP BY CUBE(channel_desc, country_iso_code);

CHANNEL              COUNTRY           SALES$
-------------------- ----------------- --------------
Multi-channel sum    Multi-country sum        864,217
Multi-channel sum    GB                       101,792
Multi-channel sum    US                       762,425
Internet             Multi-country sum        140,793
Internet             GB                        16,569
Internet             US                       124,224
Direct Sales         Multi-country sum        723,424
Direct Sales         GB                        85,223
Direct Sales         US                       638,201
</pre>
<p>To understand the previous statement, note its first column specification, which handles the channel_desc column. Consider the first line of the previous statement:</p>
<pre>
SELECT DECODE(GROUPING(channel_desc), 1, 'All Channels', channel_desc)AS Channel
</pre>
<p>In this, the <code>channel_desc</code> value is determined with a <code>DECODE</code> function that contains a <code>GROUPING</code> function. The <code>GROUPING</code> function returns a 1 if a row value is an aggregate created by <code>ROLLUP</code> or <code>CUBE</code>, otherwise it returns a 0. The <code>DECODE</code> function then operates on the <code>GROUPING</code> function's results. It returns the text "All Channels" if it receives a 1 and the <code>channel_desc</code> value from the database if it receives a 0. Values from the database will be either a real value such as "Internet" or a stored <code>NULL</code>. The second column specification, displaying <code>country_id</code>, works the same way.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="DWHSG8625"></a>
<div class="sect2"><a id="sthref1072"></a>
<h3 class="sect2">When to Use GROUPING</h3>
<p><a id="sthref1073"></a>The <code>GROUPING</code> function is not only useful for identifying <code>NULLs</code>, it also enables sorting subtotal rows and filtering results. In <a href="#i1006706">Example 21-8</a>, you retrieve a subset of the subtotals created by a <code>CUBE</code> and none of the base-level aggregations. The <code>HAVING</code> clause constrains columns that use <code>GROUPING</code> functions.</p>
<div class="example">
<p class="titleinexample"><a id="i1006706"></a><a id="DWHSG8626"></a>Example 21-8 GROUPING Combined with HAVING</p>
<pre>
SELECT channel_desc, calendar_month_desc, country_iso_code, TO_CHAR(
SUM(amount_sold), '9,999,999,999') SALES$, GROUPING(channel_desc) CH, GROUPING
  (calendar_month_desc)  MO, GROUPING(country_iso_code) CO
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id 
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN ('Direct Sales', 'Internet') 
  AND times.calendar_month_desc IN ('2000-09', '2000-10') 
  AND country_iso_code IN ('GB', 'US')
GROUP BY CUBE(channel_desc, calendar_month_desc, country_iso_code)
HAVING (GROUPING(channel_desc)=1 AND GROUPING(calendar_month_desc)= 1 
  AND GROUPING(country_iso_code)=1) OR (GROUPING(channel_desc)=1 
  AND GROUPING (calendar_month_desc)= 1) OR (GROUPING(country_iso_code)=1
  AND GROUPING(calendar_month_desc)= 1);

CHANNEL_DESC         C CO SALES$                 CH         MO         CO
-------------------- - -- -------------- ---------- ---------- ----------
                       US      1,581,775          1          1          0
                       GB        208,257          1          1          0
Direct Sales                   1,497,646          0          1          1
Internet                         292,387          0          1          1
                               1,790,032          1          1          1
</pre>
<p>Compare the result set of <a href="#i1006706">Example 21-8</a> with that in <a href="#CHDHHCEA">Example 21-3</a> to see how <a href="#i1006706">Example 21-8</a> is a precisely specified group: it contains only the yearly totals, regional totals aggregated over time and department, and the grand total.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="DWHSG8627"></a>
<div class="sect2"><a id="sthref1074"></a>
<h3 class="sect2">GROUPING_ID <a id="sthref1075"></a><a id="sthref1076"></a>Function</h3>
<p>To find the <code>GROUP</code> <code>BY</code> level of a particular row, a query must return <code>GROUPING</code> function information for each of the <code>GROUP</code> <code>BY</code> columns. If we do this using the <code>GROUPING</code> function, every <code>GROUP</code> <code>BY</code> column requires another column using the <code>GROUPING</code> function. For instance, a four-column <code>GROUP</code> <code>BY</code> clause must be analyzed with four <code>GROUPING</code> functions. This is inconvenient to write in SQL and increases the number of columns required in the query. When you want to store the query result sets in tables, as with materialized views, the extra columns waste storage space.</p>
<p>To address these problems, you can use the <code>GROUPING_ID</code> function. <code>GROUPING_ID</code> returns a single number that enables you to determine the exact <code>GROUP</code> <code>BY</code> level. For each row, <code>GROUPING_ID</code> takes the set of 1's and 0's that would be generated if you used the appropriate <code>GROUPING</code> functions and concatenates them, forming a bit vector. The bit vector is treated as a binary number, and the number's base-10 value is returned by the <code>GROUPING_ID</code> function. For instance, if you group with the expression <code>CUBE(a</code>, <code>b)</code> the possible values are as shown in <a href="#g1014093">Table 21-2</a>.</p>
<div class="tblformal">
<p class="titleintable"><a id="DWHSG8628"></a><a id="sthref1077"></a><a id="g1014093"></a>Table 21-2 GROUPING_ID Example for CUBE(a, b)</p>
<table class="cellalignment1381" title="GROUPING_ID Example for CUBE(a, b)" summary="GROUPING_ID Example for CUBE(a, b)" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t6">Aggregation Level</th>
<th class="cellalignment1382" id="r1c2-t6">Bit Vector</th>
<th class="cellalignment1382" id="r1c3-t6">GROUPING_ID</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t6" headers="r1c1-t6">
<p>a, b</p>
</td>
<td class="cellalignment1378" headers="r2c1-t6 r1c2-t6">
<p>0 0</p>
</td>
<td class="cellalignment1378" headers="r2c1-t6 r1c3-t6">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t6" headers="r1c1-t6">
<p>a</p>
</td>
<td class="cellalignment1378" headers="r3c1-t6 r1c2-t6">
<p>0 1</p>
</td>
<td class="cellalignment1378" headers="r3c1-t6 r1c3-t6">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t6" headers="r1c1-t6">
<p>b</p>
</td>
<td class="cellalignment1378" headers="r4c1-t6 r1c2-t6">
<p>1 0</p>
</td>
<td class="cellalignment1378" headers="r4c1-t6 r1c3-t6">
<p>2</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t6" headers="r1c1-t6">
<p>Grand Total</p>
</td>
<td class="cellalignment1378" headers="r5c1-t6 r1c2-t6">
<p>1 1</p>
</td>
<td class="cellalignment1378" headers="r5c1-t6 r1c3-t6">
<p>3</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><code>GROUPING_ID</code> clearly distinguishes groupings created by grouping set specification, and it is very useful during refresh and rewrite of materialized views.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8629"></a>
<div class="sect2"><a id="sthref1078"></a>
<h3 class="sect2">GROUP_ID Function</h3>
<p>While <a id="sthref1079"></a><a id="sthref1080"></a>the extensions to <code>GROUP</code> <code>BY</code> offer power and flexibility, they also allow complex result sets that can include duplicate groupings. The <code>GROUP_ID</code> function lets you distinguish among duplicate groupings. If there are multiple sets of rows calculated for a given level, <code>GROUP_ID</code> assigns the value of 0 to all the rows in the first set. All other sets of duplicate rows for a particular grouping are assigned higher values, starting with 1. For example, consider the following query, which generates a duplicate grouping:</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8630"></a><a id="sthref1081"></a>Example 21-9 GROUP_ID</p>
<pre>
SELECT country_iso_code, SUBSTR(cust_state_province,1,12), SUM(amount_sold),
  GROUPING_ID(country_iso_code, cust_state_province) GROUPING_ID, GROUP_ID()
FROM sales, customers, times, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id 
  AND customers.country_id=countries.country_id AND times.time_id= '30-OCT-00'
  AND country_iso_code IN ('FR', 'ES')
GROUP BY GROUPING SETS (country_iso_code,
ROLLUP(country_iso_code, cust_state_province));

CO SUBSTR(CUST_ SUM(AMOUNT_SOLD) GROUPING_ID GROUP_ID()
-- ------------ ---------------- ----------- ----------
ES Alicante               135.32           0          0
ES Valencia              4133.56           0          0
ES Barcelona               24.22           0          0
FR Centre                   74.3           0          0
FR Aquitaine              231.97           0          0
FR Rhtne-Alpes           1624.69           0          0
FR Ile-de-Franc          1860.59           0          0
FR Languedoc-Ro           4287.4           0          0
                        12372.05           3          0
ES                        4293.1           1          0
FR                       8078.95           1          0
ES                        4293.1           1          1
FR                       8078.95           1          1
</pre>
<p>This query generates the following groupings: (<code>country_id</code>, <code>cust_state_province</code>), (<code>country_id</code>), (<code>country_id</code>), and (). Note that the grouping (<code>country_id</code>) is repeated twice. The syntax for <code>GROUPING</code> <code>SETS</code> is explained in <a href="#i1006842">"GROUPING SETS Expression"</a>.</p>
<p>This function helps you filter out duplicate groupings from the result. For example, you can filter out duplicate (<code>region</code>) groupings from the previous example by adding a <code>HAVING</code> clause condition <code>GROUP_ID()=0</code> to the query.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006842"></a><a id="DWHSG8631"></a>
<div class="sect1">
<h2 class="sect1">GROUPING SETS Expression</h2>
<p>You can s<a id="sthref1082"></a>electively specify the set of groups that you want to create using a <code>GROUPING</code> <code>SETS</code> expression within a <code>GROUP</code> <code>BY</code> clause. This allows precise specification across multiple dimensions without computing the whole <code>CUBE</code>. For example, you can say:</p>
<pre>
SELECT channel_desc, calendar_month_desc, country_iso_code,
       TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id AND channels.channel_desc IN
 ('Direct Sales', 'Internet') AND times.calendar_month_desc IN
 ('2000-09', '2000-10') AND country_iso_code IN ('GB', 'US')
GROUP BY GROUPING SETS((channel_desc, calendar_month_desc, country_iso_code),
    (channel_desc, country_iso_code), (calendar_month_desc, country_iso_code));
</pre>
<p>Note that this statement uses composite columns, described in <a href="#i1006951">"Composite Columns"</a>. This statement calculates aggregates over three groupings:</p>
<ul>
<li>
<p><code>(channel_desc, calendar_month_desc, country_iso_code)</code></p>
</li>
<li>
<p><code>(channel_desc, country_iso_code)</code></p>
</li>
<li>
<p><code>(calendar_month_desc, country_iso_code)</code></p>
</li>
</ul>
<p>Compare the previous statement with the following alternative, which uses the <code>CUBE</code> operation and the <code>GROUPING_ID</code> function to return the desired rows:</p>
<pre>
SELECT channel_desc, calendar_month_desc, country_iso_code,
       TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$,
       GROUPING_ID(channel_desc, calendar_month_desc, country_iso_code) gid
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id AND channels.channel_desc IN
 ('Direct Sales', 'Internet') AND times.calendar_month_desc IN
 ('2000-09', '2000-10') AND country_iso_code IN ('GB', 'US')
GROUP BY CUBE(channel_desc, calendar_month_desc, country_iso_code)
HAVING GROUPING_ID(channel_desc, calendar_month_desc, country_iso_code)=0
  OR GROUPING_ID(channel_desc, calendar_month_desc, country_iso_code)=2
  OR GROUPING_ID(channel_desc, calendar_month_desc, country_iso_code)=4;
</pre>
<p>This statement computes all the 8 (2 *2 *2) groupings, though only the previous 3 groups are of interest to you.</p>
<p>Another alternative is the following statement, which is lengthy due to several unions. This statement requires three scans of the base table, making it inefficient. <code>CUBE</code> and <code>ROLLUP</code> can be thought of as grouping sets with very specific semantics. For example, consider the following statement:</p>
<pre>
CUBE(a, b, c)
</pre>
<p>This statement is equivalent to:</p>
<pre>
GROUPING SETS ((a, b, c), (a, b), (a, c), (b, c), (a), (b), (c), ())
ROLLUP(a, b, c)
</pre>
<p>And this statement is equivalent to:</p>
<pre>
GROUPING SETS ((a, b, c), (a, b), ())
</pre>
<a id="DWHSG8632"></a>
<div class="sect2"><a id="sthref1083"></a>
<h3 class="sect2">GROUPING SETS Syntax</h3>
<p><code>GROUPING</code> <code>SETS</code> syntax lets you define multiple groupings in the same query. <code>GROUP</code> <code>BY</code> computes all the groupings specified and combines them with <code>UNION</code> <code>ALL</code>. For example, consider the following statement:</p>
<pre>
GROUP BY GROUPING sets (channel_desc, calendar_month_desc, country_id )
</pre>
<p>This statement is equivalent to:</p>
<pre>
GROUP BY channel_desc UNION ALL
GROUP BY calendar_month_desc UNION ALL GROUP BY country_id
</pre>
<p><a href="#g1014117">Table 21-3</a> shows grouping sets specification and equivalent <code>GROUP</code> <code>BY</code> specification. Note that some examples use composite columns.</p>
<div class="tblformal">
<p class="titleintable"><a id="DWHSG8633"></a><a id="sthref1084"></a><a id="g1014117"></a>Table 21-3 GROUPING SETS Statements and Equivalent GROUP BY</p>
<table class="cellalignment1381" title="GROUPING SETS Statements and Equivalent GROUP BY" summary="GROUPING_SETS Statements and Equivalent GROUP BY" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t7">GROUPING SETS Statement</th>
<th class="cellalignment1382" id="r1c2-t7">Equivalent GROUP BY Statement</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t7" headers="r1c1-t7">
<p><code>GROUP BY GROUPING SETS(a, b, c)</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t7 r1c2-t7">
<p><code>GROUP BY a UNION ALL GROUP BY b UNION ALL GROUP BY c</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t7" headers="r1c1-t7">
<p><code>GROUP BY GROUPING SETS(a, b, (b, c))</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t7 r1c2-t7">
<p><code>GROUP BY a UNION ALL GROUP BY b UNION ALL GROUP BY b, c</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t7" headers="r1c1-t7">
<p><code>GROUP BY GROUPING SETS((a, b, c))</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t7 r1c2-t7">
<p><code>GROUP BY a, b, c</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t7" headers="r1c1-t7">
<p><code>GROUP BY GROUPING SETS(a, (b), ())</code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t7 r1c2-t7">
<p><code>GROUP BY a UNION ALL GROUP BY b UNION ALL GROUP BY ()</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r6c1-t7" headers="r1c1-t7">
<p><code>GROUP BY GROUPING SETS(a, ROLLUP(b, c))</code></p>
</td>
<td class="cellalignment1378" headers="r6c1-t7 r1c2-t7">
<p><code>GROUP BY a UNION ALL GROUP BY ROLLUP(b, c)</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>In the absence of an optimizer that looks across query blocks to generate the execution plan, a query based on <code>UNION</code> would need multiple scans of the base table, sales. This could be very inefficient as fact tables will normally be huge. Using <code>GROUPING</code> <code>SETS</code> statements, all the groupings of interest are available in the same query block.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006951"></a><a id="DWHSG8634"></a>
<div class="sect1">
<h2 class="sect1">Composite Columns</h2>
<p>A composite <a id="sthref1085"></a>column is a collection of columns that are treated as a unit during the computation of groupings. You specify the columns in parentheses as in the following statement:</p>
<pre>
ROLLUP (year, (quarter, month), day)
</pre>
<p>In this statement, the data is not rolled up across year and quarter, but is instead equivalent to the following groupings of a <code>UNION</code> <code>ALL</code>:</p>
<ul>
<li>
<p>(<code>year</code>, <code>quarter</code>, <code>month</code>, <code>day</code>),</p>
</li>
<li>
<p>(<code>year</code>, <code>quarter</code>, <code>month</code>),</p>
</li>
<li>
<p>(<code>year</code>)</p>
</li>
<li>
<p>()</p>
</li>
</ul>
<p>Here, (<code>quarter</code>, <code>month</code>) form a composite column and are treated as a unit. In general, composite columns are useful in <code>ROLLUP</code>, <code>CUBE</code>, <code>GROUPING</code> <code>SETS</code>, and concatenated groupings. For example, in <code>CUBE</code> or <code>ROLLUP</code>, composite columns would mean skipping aggregation across certain levels. That is, the following statement:</p>
<pre>
GROUP BY ROLLUP(a, (b, c))
</pre>
<p>This is equivalent to:</p>
<pre>
GROUP BY a, b, c UNION ALL
GROUP BY a UNION ALL
GROUP BY ()
</pre>
<p>Here, <code>(b</code>, <code>c)</code> are treated as a unit and rollup will not be applied across <code>(b</code>, <code>c)</code>. It is as if you have an alias, for example z, for <code>(b</code>, <code>c)</code> and the <code>GROUP</code> <code>BY</code> expression reduces to <code>GROUP</code> <code>BY</code> <code>ROLLUP(a</code>, <code>z)</code>. Compare this with the normal rollup as in the following:</p>
<pre>
GROUP BY ROLLUP(a, b, c)
</pre>
<p>This would be the following:</p>
<pre>
GROUP BY a, b, c UNION ALL
GROUP BY a, b UNION ALL
GROUP BY a UNION ALL
GROUP BY ().
</pre>
<p>Similarly, the following statement is equivalent to the four <code>GROUP</code> <code>BY</code>s:</p>
<pre>
GROUP BY CUBE((a, b), c)

GROUP BY a, b, c UNION ALL
GROUP BY a, b UNION ALL
GROUP BY c UNION ALL
GROUP By ()
</pre>
<p>In <code>GROUPING</code> <code>SETS</code>, a composite column is used to denote a particular level of <code>GROUP</code> <code>BY</code>. See <a href="#g1014117">Table 21-3</a> for more examples of composite columns.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8635"></a><a id="sthref1086"></a>Example 21-10 Composite Columns</p>
<p>You do not have full control over what aggregation levels you want with <code>CUBE</code> and <code>ROLLUP</code>. For example, consider the following statement:</p>
<pre>
SELECT channel_desc, calendar_month_desc, country_iso_code,
 TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id 
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN ('Direct Sales', 'Internet') 
  AND times.calendar_month_desc IN ('2000-09', '2000-10') 
  AND country_iso_code IN ('GB', 'US')
GROUP BY ROLLUP(channel_desc, calendar_month_desc, country_iso_code);
</pre>
<p>This statement results in Oracle computing the following groupings:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p><code>(channel_desc, calendar_month_desc, country_iso_code)</code></p>
</li>
<li>
<p><code>(channel_desc, calendar_month_desc)</code></p>
</li>
<li>
<p><code>(channel_desc)</code></p>
</li>
<li>
<p><code>()</code></p>
</li>
</ul>
<p>If you are just interested in the first, third, and fourth of these groupings, you cannot limit the calculation to those groupings without using composite columns. With composite columns, this is possible by treating month and country as a single unit while rolling up. Columns enclosed in parentheses are treated as a unit while computing <code>CUBE</code> and <code>ROLLUP</code>. Thus, you would say:</p>
<pre>
SELECT channel_desc, calendar_month_desc, country_iso_code,
    TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
      sales.channel_id= channels.channel_id  AND channels.channel_desc IN
 ('Direct Sales', 'Internet') AND times.calendar_month_desc IN
 ('2000-09', '2000-10') AND country_iso_code IN ('GB', 'US')
GROUP BY ROLLUP(channel_desc, (calendar_month_desc, country_iso_code));

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
Internet             2000-09  GB        228,241
Internet             2000-09  US        228,241
Internet             2000-10  GB        239,236
Internet             2000-10  US        239,236
Internet                                934,955
Direct Sales         2000-09  GB      1,217,808
Direct Sales         2000-09  US      1,217,808
Direct Sales         2000-10  GB      1,225,584
Direct Sales         2000-10  US      1,225,584
Direct Sales                          4,886,784
                                      5,821,739
</pre></div>
<!-- class="sect1" -->
<a id="i1007021"></a><a id="DWHSG8636"></a>
<div class="sect1">
<h2 class="sect1">Concatenated Groupings</h2>
<p>Concatenated <a id="sthref1087"></a>groupings offer a concise way to generate useful combinations of groupings. Groupings specified with concatenated groupings yield the cross-product of groupings from each grouping set. The cross-product operation enables even a small number of concatenated groupings to generate a large number of final groups. The concatenated groupings are specified simply by listing multiple grouping sets, cubes, and rollups, and separating them with commas. Here is an example of concatenated grouping sets:</p>
<pre>
GROUP BY GROUPING SETS(a, b), GROUPING SETS(c, d)
</pre>
<p>This SQL defines the following groupings:</p>
<pre>
(a, c), (a, d), (b, c), (b, d)
</pre>
<p>Concatenation of grouping sets is very helpful for these reasons:</p>
<ul>
<li>
<p>Ease of query development</p>
<p>You need not enumerate all groupings manually.</p>
</li>
<li>
<p>Use by applications</p>
<p>SQL generated by analytical applications often involves concatenation of grouping sets, with each grouping set defining groupings needed for a dimension.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="DWHSG8637"></a><a id="sthref1088"></a>Example 21-11 Concatenated Groupings</p>
<p>You can also specify more than one grouping in the <code>GROUP</code> <code>BY</code> clause. For example, if you want aggregated sales values for each product rolled up across all levels in the <code>time</code> dimension (<code>year</code>, <code>month</code> and <code>day</code>), and across all levels in the <code>geography</code> dimension (<code>region</code>), you can issue the following statement:</p>
<pre>
SELECT channel_desc, calendar_year, calendar_quarter_desc, country_iso_code,
  cust_state_province, TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id 
 AND sales.channel_id = channels.channel_id AND countries.country_id =
    customers.country_id AND channels.channel_desc IN
   ('Direct Sales', 'Internet') AND times.calendar_month_desc IN ('2000-09',
 '2000-10') AND countries.country_iso_code IN ('GB', 'FR')
GROUP BY channel_desc, GROUPING SETS (ROLLUP(calendar_year,
   calendar_quarter_desc),
ROLLUP(country_iso_code, cust_state_province));
</pre>
<p>This results in the following groupings:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>(<code>channel_desc</code>, <code>calendar_year</code>, <code>calendar_quarter_desc</code>)</p>
</li>
<li>
<p>(<code>channel_desc</code>, <code>calendar_year</code>)</p>
</li>
<li>
<p>(<code>channel_desc</code>)</p>
</li>
<li>
<p>(<code>channel_desc</code>, <code>country_iso_code</code>, <code>cust_state_province</code>)</p>
</li>
<li>
<p>(<code>channel_desc</code>, <code>country_iso_code</code>)</p>
</li>
<li>
<p>(<code>channel_desc</code>)</p>
</li>
</ul>
<p>This is the cross-product of the following:</p>
<ul>
<li>
<p>The expression, <code>channel_desc</code></p>
</li>
<li>
<p><code>ROLLUP</code>(<code>calendar_year</code>, <code>calendar_quarter_desc</code>), which is equivalent to ((<code>calendar_year</code>, <code>calendar_quarter_desc</code>), (<code>calendar_year</code>), ())</p>
</li>
<li>
<p><code>ROLLUP(country_iso_code, cust_state_province)</code>, which is equivalent to ((<code>country_iso_code</code>, <code>cust_state_province</code>), (<code>country_iso_code</code>), ())</p>
</li>
</ul>
<p>Note that the output contains two occurrences of (<code>channel_desc</code>) group. To filter out the extra (<code>channel_desc</code>) group, the query could use a <code>GROUP_ID</code> function.</p>
<p>Another concatenated join example is <a href="#CHDJHEJJ">Example 21-12</a>, showing the cross product of two grouping sets.</p>
<div class="example">
<p class="titleinexample"><a id="CHDJHEJJ"></a><a id="DWHSG8638"></a>Example 21-12 Concatenated Groupings (Cross-Product of Two Grouping Sets)</p>
<pre>
SELECT country_iso_code, cust_state_province, calendar_year, 
calendar_quarter_desc, TO_CHAR(SUM(amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
 countries.country_id=customers.country_id  AND
  sales.channel_id= channels.channel_id AND channels.channel_desc IN
 ('Direct Sales', 'Internet') AND times.calendar_month_desc IN
 ('2000-09', '2000-10') AND country_iso_code IN ('GB', 'FR')
GROUP BY GROUPING SETS (country_iso_code, cust_state_province),
         GROUPING SETS (calendar_year, calendar_quarter_desc);
</pre>
<p>This statement results in the computation of groupings:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>(<code>country_iso_code</code>, <code>year</code>), (<code>country_iso_code</code>, <code>calendar_quarter_desc</code>), (<code>cust_state_province</code>, <code>year</code>) and (<code>cust_state_province</code>, <code>calendar_quarter_desc</code>)</p>
</li>
</ul>
<a id="DWHSG8639"></a>
<div class="sect2"><a id="sthref1089"></a>
<h3 class="sect2">Concatenated Groupings and Hierarchical Data Cubes</h3>
<p>One of the most importan<a id="sthref1090"></a>t uses for concatenated groupings is to generate the aggregates needed for a hierarchical cube of data. A hierarchical cube is a data set where the data is aggregated along the rollup hierarchy of each of its dimensions and these aggregations are combined across dimensions. It includes the typical set of aggregations needed for business intelligence queries. By using concatenated groupings, you can generate all the aggregations needed by a hierarchical cube with just <span class="italic">n</span> <code>ROLLUP</code>s (where <span class="italic">n</span> is the number of dimensions), and avoid generating unwanted aggregations.</p>
<p>Consider just three of the dimensions in the <code>sh</code> sample schema data set, each of which has a multilevel hierarchy:</p>
<ul>
<li>
<p>time: <code>year</code>, <code>quarter</code>, <code>month</code>, <code>day</code> (<code>week</code> is in a separate hierarchy)</p>
</li>
<li>
<p>product: <code>category</code>, <code>subcategory</code>, <code>prod_name</code></p>
</li>
<li>
<p>geography: <code>region</code>, <code>subregion</code>, <code>country</code>, <code>state</code>, <code>city</code></p>
</li>
</ul>
<p>This data is represented using a column for each level of the hierarchies, creating a total of twelve columns for dimensions, plus the columns holding sales figures.</p>
<p>For our business intelligence needs, we would like to calculate and store certain aggregates of the various combinations of dimensions. In <a href="#i1007098">Example 21-13</a>, we create the aggregates for all levels, except for "day", which would create too many rows. In particular, we want to use <code>ROLLUP</code> within each dimension to generate useful aggregates. Once we have the <code>ROLLUP</code>-based aggregates within each dimension, we want to combine them with the other dimensions. This will generate our hierarchical cube. Note that this is not at all the same as a <code>CUBE</code> using all twelve of the dimension columns: that would create 2 to the 12th power (4,096) aggregation groups, of which we need only a small fraction. Concatenated grouping sets make it easy to generate exactly the aggregations we need. <a href="#i1007098">Example 21-13</a> shows where a <code>GROUP</code> <code>BY</code> clause is needed.</p>
<div class="example">
<p class="titleinexample"><a id="i1007098"></a><a id="DWHSG8640"></a>Example 21-13 Concatenated Groupings and Hierarchical Cubes</p>
<pre>
SELECT calendar_year, calendar_quarter_desc, calendar_month_desc,
  country_region, country_subregion, countries.country_iso_code, 
 cust_state_province, cust_city, prod_category_desc, prod_subcategory_desc, 
 prod_name, TO_CHAR(SUM (amount_sold), '9,999,999,999') SALES$
FROM sales, customers, times, channels, countries, products
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id AND sales.prod_id=products.prod_id AND
  customers.country_id=countries.country_id AND channels.channel_desc IN
 ('Direct Sales', 'Internet') AND times.calendar_month_desc IN
 ('2000-09', '2000-10') AND prod_name IN ('Envoy Ambassador',
 'Mouse Pad') AND countries.country_iso_code IN ('GB', 'US')
GROUP BY ROLLUP(calendar_year, calendar_quarter_desc, calendar_month_desc),
  ROLLUP(country_region, country_subregion, countries.country_iso_code,
         cust_state_province, cust_city),
  ROLLUP(prod_category_desc, prod_subcategory_desc, prod_name);
</pre>
<p>The rollups in the <code>GROUP</code> <code>BY</code> specification generate the following groups, four for each dimension.</p>
</div>
<!-- class="example" -->
<div class="tblformalwidemax">
<p class="titleintable"><a id="DWHSG8641"></a><a id="sthref1091"></a><a id="BABEHGHD"></a>Table 21-4 Hierarchical CUBE Example</p>
<table class="cellalignment1383" title="Hierarchical CUBE Example" summary="Hierarchical CUBE Examples" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t8">ROLLUP By Time</th>
<th class="cellalignment1382" id="r1c2-t8">ROLLUP By Product</th>
<th class="cellalignment1382" id="r1c3-t8">ROLLUP By Geography</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t8" headers="r1c1-t8">
<p><code>year, quarter, month</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t8 r1c2-t8">
<p><code>category, subcategory, name</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t8 r1c3-t8">
<p><code>region, subregion, country, state, city</code></p>
<p><code>region, subregion, country, state</code></p>
<p><code>region, subregion, country</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t8" headers="r1c1-t8">
<p><code>year, quarter</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t8 r1c2-t8">
<p><code>category, subcategory</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t8 r1c3-t8">
<p><code>region, subregion</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t8" headers="r1c1-t8">
<p><code>year</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t8 r1c2-t8">
<p><code>category</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t8 r1c3-t8">
<p><code>region</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t8" headers="r1c1-t8">
<p><code>all times</code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t8 r1c2-t8">
<p><code>all products</code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t8 r1c3-t8">
<p><code>all geographies</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p>The concatenated grouping sets specified in the previous SQL will take the <code>ROLLUP</code> aggregations listed in the table and perform a cross-product on them. The cross-product will create the 96 (4x4x6) aggregate groups needed for a hierarchical cube of the data. There are major advantages in using three <code>ROLLUP</code> expressions to replace what would otherwise require 96 grouping set expressions: the concise SQL is far less error-prone to develop and far easier to maintain, and it enables much better query optimization. You can picture how a cube with more dimensions and more levels would make the use of concatenated groupings even more advantageous.</p>
<p>See <a href="#i1012749">"Working with Hierarchical Cubes in SQL"</a> for more information regarding hierarchical cubes.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007169"></a><a id="DWHSG8642"></a>
<div class="sect1">
<h2 class="sect1">Considerations when Using Aggregation</h2>
<p>This section discusses the following topics.</p>
<ul>
<li>
<p><a href="#i1007192">Hierarchy Handling in ROLLUP and CUBE</a></p>
</li>
<li>
<p><a href="#i1007222">Column Capacity in ROLLUP and CUBE</a></p>
</li>
<li>
<p><a href="#i1007225">HAVING Clause Used with GROUP BY Extensions</a></p>
</li>
<li>
<p><a href="#i1007234">ORDER BY Clause Used with GROUP BY Extensions</a></p>
</li>
<li>
<p><a href="#i1007238">Using Other Aggregate Functions with ROLLUP and CUBE</a></p>
</li>
</ul>
<a id="i1007192"></a><a id="DWHSG8643"></a>
<div class="sect2">
<h3 class="sect2">Hierarchy Handling in ROLLUP and CUBE</h3>
<p>The <code>ROLLUP</code> and <code>CUBE</code> extensions work independently of any hierarchy metadata in your system. Their calculations are based entirely on the columns specified in the <code>SELECT</code> statement in which they appear. This approach enables <code>CUBE</code> and <code>ROLLUP</code> to be used whether or not hierarchy metadata is available. The simplest way to handle levels in hierarchical dimensions is by using the <code>ROLLUP</code> extension and indicating levels explicitly through separate columns. The following code shows a simple example of this with months rolled up to quarters and quarters rolled up to years.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8644"></a><a id="sthref1092"></a>Example 21-14 ROLLUP and CUBE Hierarchy Handling</p>
<pre>
SELECT calendar_year, calendar_quarter_number,
    calendar_month_number, SUM(amount_sold)
FROM sales, times, products, customers, countries
WHERE sales.time_id=times.time_id 
  AND sales.prod_id=products.prod_id 
  AND customers.country_id = countries.country_id 
  AND sales.cust_id=customers.cust_id 
  AND prod_name IN ('Envoy Ambassador', 'Mouse Pad') 
  AND country_iso_code = 'GB' AND calendar_year=1999
GROUP BY ROLLUP(calendar_year, calendar_quarter_number, calendar_month_number);

CALENDAR_YEAR CALENDAR_QUARTER_NUMBER CALENDAR_MONTH_NUMBER SUM(AMOUNT_SOLD)
------------- ----------------------- --------------------- ----------------
         1999                       1                     1          5521.34
         1999                       1                     2         22232.95
         1999                       1                     3         10672.63
         1999                       1                               38426.92
         1999                       2                     4         23658.05
         1999                       2                     5          5766.31
         1999                       2                     6         23939.32
         1999                       2                               53363.68
         1999                       3                     7         12132.18
         1999                       3                     8         13128.96
         1999                       3                     9         19571.96
         1999                       3                                44833.1
         1999                       4                    10         15752.18
         1999                       4                    11          7011.21
         1999                       4                    12          14257.5
         1999                       4                               37020.89
         1999                                                      173644.59
                                                                   173644.59
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1007222"></a><a id="DWHSG8645"></a>
<div class="sect2">
<h3 class="sect2">Column Capacity in ROLLUP and CUBE</h3>
<p><code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING</code> <code>SETS</code> do not restrict the <code>GROUP</code> <code>BY</code> clause column capacity. The <code>GROUP</code> <code>BY</code> clause, with or without the extensions, can work with up to 255 columns. However, the combinatorial explosion of <code>CUBE</code> makes it unwise to specify a large number of columns with the <code>CUBE</code> extension. Consider that a 20-column list for <code>CUBE</code> would create 2 to the 20 combinations in the result set. A very large <code>CUBE</code> list could strain system resources, so any such query must be tested carefully for performance and the load it places on the system.</p>
</div>
<!-- class="sect2" -->
<a id="i1007225"></a><a id="DWHSG8646"></a>
<div class="sect2">
<h3 class="sect2">HAVING Clause Used with GROUP BY Extensions</h3>
<p>The <code>HAVING</code> clause of <code>SELECT</code> statements is unaffected by the use of <code>GROUP</code> <code>BY</code>. Note that the conditions specified in the <code>HAVING</code> clause apply to both the subtotal and non-subtotal rows of the result set. In some cases a query may need to exclude the subtotal rows or the non-subtotal rows from the <code>HAVING</code> clause. This can be achieved by using a <code>GROUPING</code> or <code>GROUPING_ID</code> function together with the <code>HAVING</code> clause. See <a href="#i1006706">Example 21-8</a> and its associated SQL statement for an example.</p>
</div>
<!-- class="sect2" -->
<a id="i1007234"></a><a id="DWHSG8647"></a>
<div class="sect2">
<h3 class="sect2">ORDER BY Clause Used with GROUP BY Extensions</h3>
<p>In many cases, a query must order the rows in a certain way, and this is done with the <code>ORDER</code> <code>BY</code> clause. The <code>ORDER</code> <code>BY</code> clause of a <code>SELECT</code> statement is unaffected by the use of <code>GROUP</code> <code>BY</code>, since the <code>ORDER</code> <code>BY</code> clause is applied after the <code>GROUP</code> <code>BY</code> calculations are complete.</p>
<p>Note that the <code>ORDER</code> <code>BY</code> specification makes no distinction between aggregate and non-aggregate rows of the result set. For instance, you might wish to list sales figures in declining order, but still have the subtotals at the end of each group. Simply ordering sales figures in descending sequence will not be sufficient, since that will place the subtotals (the largest values) at the start of each group. Therefore, it is essential that the columns in the <code>ORDER</code> <code>BY</code> clause include columns that differentiate aggregate from non-aggregate columns. This requirement means that queries using <code>ORDER</code> <code>BY</code> along with aggregation extensions to <code>GROUP</code> <code>BY</code> will generally need to use one or more of the <code>GROUPING</code> functions.</p>
</div>
<!-- class="sect2" -->
<a id="i1007238"></a><a id="DWHSG8648"></a>
<div class="sect2">
<h3 class="sect2">Using Other Aggregate Functions with ROLLUP and CUBE</h3>
<p>The examples in this chapter show <code>ROLLUP</code> and <code>CUBE</code> used with the <code>SUM</code> function. While this is the most common type of aggregation, these extensions can also be used with all other functions available to the <code>GROUP</code> <code>BY</code> clause, for example, <code>COUNT</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code>, <code>STDDEV</code>, and <code>VARIANCE</code>. <code>COUNT</code>, which is often needed in cross-tabular analyses, is likely to be the second most commonly used function.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007241"></a><a id="DWHSG8649"></a>
<div class="sect1">
<h2 class="sect1">Computation Using the WITH Clause</h2>
<p>The <code>WITH</code> clause (formally known as <code>subquery_factoring_clause</code>) enables you to reuse the same query block in a <code>SELECT</code> statement when it occurs more than once within a complex query. <code>WITH</code> is a part of the SQL-99 standard. This is particularly useful when a query has multiple references to the same query block and there are joins and aggregations. Using the <code>WITH</code> clause, Oracle retrieves the results of a query block and stores them in the user's temporary tablespace. Note that Oracle Database does not support recursive use of the <code>WITH</code> clause. Note that Oracle Database supports recursive use of the <code>WITH</code> clause that may be used for such queries as are used with a bill of materials or expansion of parent-child hierarchies to parent-descendant hierarchies. See <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
<p>The following query is an example of where you can improve performance and write SQL more simply by using the <code>WITH</code> clause. The query calculates the sum of sales for each channel and holds it under the name <code>channel_summary</code>. Then it checks each channel's sales total to see if any channel's sales are greater than one third of the total sales. By using the <code>WITH</code> clause, the <code>channel_summary</code> data is calculated just once, avoiding an extra scan through the large sales table.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8650"></a><a id="sthref1093"></a>Example 21-15 WITH Clause</p>
<pre>
WITH channel_summary AS (SELECT channels.channel_desc, SUM(amount_sold)
AS channel_total FROM sales, channels
WHERE sales.channel_id = channels.channel_id GROUP BY channels.channel_desc)
SELECT channel_desc, channel_total
FROM channel_summary WHERE channel_total &gt; (SELECT SUM(channel_total) * 1/3
FROM channel_summary);

CHANNEL_DESC         CHANNEL_TOTAL
-------------------- -------------
Direct Sales            57875260.6
</pre>
<p>Note that this example could also be performed efficiently using the reporting aggregate functions described in <a href="analysis.htm#g1030987">Chapter 22, "SQL for Analysis and Reporting"</a>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i1012749"></a><a id="DWHSG8651"></a>
<div class="sect1">
<h2 class="sect1">Working with Hierarchical Cubes in SQL</h2>
<p>This section illustrates<a id="sthref1094"></a> examples of working with hierarchical cubes.</p>
<a id="DWHSG8652"></a>
<div class="sect2"><a id="sthref1095"></a>
<h3 class="sect2">Specifying Hierarchical Cubes in SQL</h3>
<p>Oracle <a id="sthref1096"></a>Database can specify hierarchical cubes in a simple and efficient SQL query. These hierarchical cubes represent the logical cubes referred to in many analytical SQL products. To specify data in the form of hierarchical cubes, you can use one of the extensions to the <code>GROUP</code> <code>BY</code> clause, concatenated grouping sets, to generate the aggregates needed for a hierarchical cube of data. By using concatenated rollup (rolling up along the hierarchy of each dimension and then concatenate them across multiple dimensions), you can generate all the aggregations needed by a hierarchical cube.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8653"></a><a id="sthref1097"></a>Example 21-16 Concatenated ROLLUP</p>
<p>The following <a id="sthref1098"></a><a id="sthref1099"></a>shows the <code>GROUP</code> <code>BY</code> clause needed to create a hierarchical cube for a 2-dimensional example similar to <a href="#i1007098">Example 21-13</a>. The following simple syntax performs a concatenated rollup:</p>
<pre>
GROUP BY ROLLUP(year, quarter, month), ROLLUP(Division, brand, item)
</pre>
<p>This concatenated rollup takes the <code>ROLLUP</code> aggregations similar to those listed in <a href="#BABEHGHD">Table 21-4, "Hierarchical CUBE Example"</a> in the prior section and performs a cross-product on them. The cross-product will create the 16 (4x4) aggregate groups needed for a hierarchical cube of the data.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="DWHSG8654"></a>
<div class="sect2"><a id="sthref1100"></a>
<h3 class="sect2">Querying Hierarchical Cubes in SQL</h3>
<p>Analytic applications treat data as cubes, but they want only certain slices and regions of the cube. Concatenated rollup (hierarchical cube) enables relational data to be treated as cubes. To handle complex analytic queries, the fundamental technique is to enclose a hierarchical cube query in an outer query that specifies the exact slice needed from the cube. Oracle Database optimizes the processing of hierarchical cubes nested inside slicing queries. By applying many powerful algorithms, these queries can be processed at unprecedented speed and scale. This enables SQL analytical tools and applications to use a consistent style of queries to handle the most complex questions.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8655"></a><a id="sthref1101"></a>Example 21-17 Hierarchical Cube Query</p>
<p>Consider the following analytic query. It consists of a hierarchical cube query nested in a slicing query.</p>
<pre>
SELECT month, division, sum_sales FROM
  (SELECT year, quarter, month, division, brand, item, SUM(sales) sum_sales,
      GROUPING_ID(<span class="italic">grouping-columns</span>) gid
   FROM sales, products, time
   WHERE <span class="italic">join-condition</span>
   GROUP BY ROLLUP(year, quarter, month),
            ROLLUP(division, brand, item))
WHERE division = 25 AND month = 200201 AND gid = <span class="italic">gid-for-Division-Month</span>;
</pre>
<p>The inner hierarchical cube specified defines a simple cube, with two dimensions and four levels in each dimension. It would generate 16 groups (4 Time levels * 4 Product levels). The <code>GROUPING_ID</code> function in the query identifies the specific group each row belongs to, based on the aggregation level of the <span class="italic">grouping-columns</span> in its argument.</p>
<p>The outer query applies the constraints needed for our specific query, limiting Division to a value of 25 and Month to a value of 200201 (representing January 2002 in this case). In conceptual terms, it slices a small chunk of data from the cube. The outer query's constraint on the <code>GID</code> column, indicated in the query by <span class="italic">gid-for-division-month</span> would be the value of a key indicating that the data is grouped as a combination of <code>division</code> and <code>month</code>. The <code>GID</code> constraint selects only those rows that are aggregated at the level of a <code>GROUP</code> <code>BY</code> month, division clause.</p>
<p>Oracle Database removes unneeded aggregation groups from query processing based on the outer query conditions. The outer conditions of the previous query limit the result set to a single group aggregating <code>division</code> and <code>month</code>. Any other groups involving <code>year</code>, <code>month</code>, <code>brand</code>, and <code>item</code> are unnecessary here. The group pruning optimization recognizes this and transforms the query into:</p>
<pre>
SELECT month, division, sum_sales
FROM (SELECT  <span class="bold">null</span>, <span class="bold">null</span>,  month, division, <span class="bold">null</span>, <span class="bold">null</span>, SUM(sales) sum_sales,
      GROUPING_ID(<span class="italic">grouping-columns</span>) gid
      FROM sales, products, time WHERE <span class="italic">join-condition</span>
   <span class="bold">GROUP BY month</span>, <span class="bold">division</span>)
WHERE division = 25 AND month = 200201 AND gid = <span class="italic">gid-for-Division-Month</span>;
</pre>
<p>The bold items highlight the changed SQL. The inner query now has a simple <code>GROUP</code> <code>BY</code> clause of <code>month</code>, <code>division</code>. The columns <code>year</code>, <code>quarter</code>, <code>brand</code>, and <code>item</code> have been converted to null to match the simplified <code>GROUP</code> <code>BY</code> clause. Because the query now requests just one group, fifteen out of sixteen groups are removed from the processing, greatly reducing the work. For a cube with more dimensions and more levels, the savings possible through group pruning can be far greater. Note that the group pruning transformation works with all the <code>GROUP</code> <code>BY</code> extensions: <code>ROLLUP</code>, <code>CUBE</code>, and <code>GROUPING</code> <code>SETS</code>.</p>
<p>While the optimizer has simplified the previous query to a simple <code>GROUP</code> <code>BY</code>, faster response times can be achieved if the group is precomputed and stored in a materialized view. Because online analytical queries can ask for any slice of the cube many groups may need to be precomputed and stored in a materialized view. This is discussed in the next section.</p>
</div>
<!-- class="example" -->
<a id="DWHSG8656"></a>
<div class="sect3"><a id="sthref1102"></a>
<h4 class="sect3">SQL for Creating Materialized Views to Store Hierarchical Cubes</h4>
<p>Analytical SQL requires fast response times for multiple users, and this in turn demands that significant parts of a cube be precomputed and held in materialized views.</p>
<p>Data warehouse designers can choose exactly how much data to materialize. A data warehouse can have the full hierarchical cube materialized. While this will take the most storage space, it ensures quick response for any query within the cube. Alternatively, a data warehouse could have just partial materialization, saving storage space, but allowing only a subset of possible queries to be answered at highest speed. If the queries cover the full range of aggregate groupings possible in its data set, it may be best to materialize the whole hierarchical cube.</p>
<p>This means that each dimension's aggregation hierarchy is precomputed in combination with each of the other dimensions. Naturally, precomputing a full hierarchical cube requires more disk space and higher creation and refresh times than a small set of aggregate groups. The trade-off in processing time and disk space versus query performance must be considered before deciding to create it. An additional possibility you could consider is to use data compression to lessen your disk space requirements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for table compression syntax and restrictions</p>
</li>
<li>
<p><a class="olink ADMIN11630" href="../../server.112/e25494/tables.htm#ADMIN11630"><span class="italic">Oracle Database Administrator's Guide</span></a> for further details about table compression</p>
</li>
<li>
<p><a href="basicmv.htm#i1006854">"Storage And Table Compression"</a> for details regarding table compression</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1012592"></a><a id="DWHSG8657"></a>
<div class="sect3">
<h4 class="sect3">Examples of Hierarchical Cube Materialized Views</h4>
<p>This section shows complete and partial hierarchical cube materialized views. Many of the examples are meant to illustrate capabilities, and do not actually run.</p>
<p>In a data warehouse where rolling window scenario is very common, it is recommended that you store the hierarchical cube in multiple materialized views - one for each level of time you are interested in. Hence, a complete hierarchical cube will be stored in four materialized views: <code>sales_hierarchical_mon_cube_mv</code>, <code>sales_hierarchical_qtr_cube_mv</code>, <code>sales_hierarchical_yr_cube_mv</code>, and <code>sales_hierarchical_all_cube_mv</code>.</p>
<p>The following statements create a complete hierarchical cube stored in a set of three composite partitioned and one list partitioned materialized view.</p>
<div class="example">
<p class="titleinexample"><a id="i1012598"></a><a id="DWHSG8658"></a>Example 21-18 Complete Hierarchical Cube Materialized View</p>
<pre>
CREATE MATERIALIZED VIEW sales_hierarchical_mon_cube_mv
PARTITION BY RANGE (mon)
SUBPARTITION BY LIST (gid)
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, calendar_quarter_desc qtr, calendar_month_desc mon,
    country_id, cust_state_province, cust_city,
    prod_category, prod_subcategory, prod_name,
    GROUPING_ID(calendar_year, calendar_quarter_desc, calendar_month_desc,
                country_id, cust_state_province, cust_city,
                prod_category, prod_subcategory, prod_name) gid,
    SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales,
    COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_year, calendar_quarter_desc, calendar_month_desc,
  ROLLUP(country_id, cust_state_province, cust_city),
  ROLLUP(prod_category, prod_subcategory, prod_name),
...;

CREATE MATERIALIZED VIEW sales_hierarchical_qtr_cube_mv
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, calendar_quarter_desc qtr,
    country_id, cust_state_province, cust_city, 
    prod_category, prod_subcategory, prod_name, 
    GROUPING_ID(calendar_year, calendar_quarter_desc,
                country_id, cust_state_province, cust_city,
                prod_category, prod_subcategory, prod_name) gid,
    SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales,
    COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id 
      AND s.time_id = t.time_id
GROUP BY calendar_year, calendar_quarter_desc,
  ROLLUP(country_id, cust_state_province, cust_city),
  ROLLUP(prod_category, prod_subcategory, prod_name),
PARTITION BY RANGE (qtr)
 SUBPARTITION BY LIST (gid)
...;

CREATE MATERIALIZED VIEW sales_hierarchical_yr_cube_mv
PARTITION BY RANGE (year)
SUBPARTITION BY LIST (gid)
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, country_id, cust_state_province, cust_city, 
    prod_category, prod_subcategory, prod_name, 
    GROUPING_ID(calendar_year, country_id, cust_state_province, cust_city,
                prod_category, prod_subcategory, prod_name) gid,
    SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_year,
  ROLLUP(country_id, cust_state_province, cust_city),
  ROLLUP(prod_category, prod_subcategory, prod_name),
...;

CREATE MATERIALIZED VIEW sales_hierarchical_all_cube_mv
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT country_id, cust_state_province, cust_city, 
    prod_category, prod_subcategory, prod_name, 
    GROUPING_ID(country_id, cust_state_province, cust_city,
                prod_category, prod_subcategory, prod_name) gid,
    SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
GROUP BY ROLLUP(country_id, cust_state_province, cust_city),
         ROLLUP(prod_category, prod_subcategory, prod_name),
PARTITION BY LIST (gid)
...;
</pre>
<p>This allows use of PCT refresh on the materialized views <code>sales_hierarchical_mon_cube_mv</code>, <code>sales_hierarchical_qtr_cube_mv</code>, and <code>sales_hierarchical_yr_cube_mv</code> on partition maintenance operations to sales table. PCT refresh can also be used when there have been significant changes to the base table and log based fast refresh is estimated to be slower than PCT refresh. You can just specify the method as force (<code>method =&gt;</code> '<code>?</code>') in to refresh sub-programs in the <code>DBMS_MVIEW</code> package and Oracle Database will pick the best method of refresh. See <a href="refresh.htm#i1008584">"Partition Change Tracking (PCT) Refresh"</a> for more information regarding PCT refresh.</p>
<p>Because <code>sales_hierarchical_qtr_cube_mv</code> does not contain any column from <code>times</code> table, PCT refresh is not enabled on it. But, you can still call refresh sub-programs in the <code>DBMS_MVIEW</code> package with method as force (<code>method =&gt;</code> '<code>?</code>') and Oracle Database will pick the best method of refresh.</p>
<p>If you are interested in a partial cube (that is, a subset of groupings from the complete cube), then Oracle recommends storing the cube as a "federated cube". A federated cube stores each grouping of interest in a separate materialized view.</p>
<pre>
CREATE MATERIALIZED VIEW sales_mon_city_prod_mv
PARTITION BY RANGE (mon)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_month_desc mon, cust_city, prod_name, SUM(amount_sold) s_sales,
       COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id 
AND s.time_id = t.time_id
GROUP BY calendar_month_desc, cust_city, prod_name;

CREATE MATERIALIZED VIEW sales_qtr_city_prod_mv
PARTITION BY RANGE (qtr)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_quarter_desc qtr, cust_city, prod_name,SUM(amount_sold) s_sales, 
COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id =p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_quarter_desc, cust_city, prod_name;

CREATE MATERIALIZED VIEW sales_yr_city_prod_mv
PARTITION BY RANGE (yr)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, cust_city, prod_name, SUM(amount_sold) s_sales,
       COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id =p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_year, cust_city, prod_name;

CREATE MATERIALIZED VIEW sales_mon_city_scat_mv
PARTITION BY RANGE (mon)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_month_desc mon, cust_city, prod_subcategory,
       SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id =p.prod_id AND s.time_id =t.time_id
GROUP BY calendar_month_desc, cust_city, prod_subcategory;

CREATE MATERIALIZED VIEW sales_qtr_city_cat_mv
PARTITION BY RANGE (qtr)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_quarter_desc qtr, cust_city, prod_category cat,
       SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id =p.prod_id AND s.time_id =t.time_id
GROUP BY calendar_quarter_desc, cust_city, prod_category;

CREATE MATERIALIZED VIEW sales_yr_city_all_mv
PARTITION BY RANGE (yr)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, cust_city, SUM(amount_sold) s_sales, 
       COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_year, cust_city;
</pre>
<p>These materialized views can be created as <code>BUILD</code> <code>DEFERRED</code> and then, you can execute <code>DBMS_MVIEW.REFRESH_DEPENDENT(number_of_failures, 'SALES', 'C' ...)</code> so that the complete refresh of each of the materialized views defined on the detail table <code>sales</code> is scheduled in the most efficient order. See <a href="refresh.htm#i1007785">"Scheduling Refresh"</a> for more information.</p>
<p>Because each of these materialized views is partitioned on the time level (month, quarter, or year) present in the <code>SELECT</code> list, PCT is enabled on <code>sales</code> table for each one of them, thus providing an opportunity to apply PCT refresh method in addition to <code>FAST</code> and <code>COMPLETE</code> refresh methods.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1371">
<tr>
<td class="cellalignment1378">
<table class="cellalignment1376">
<tr>
<td class="cellalignment1375"><a href="schemas.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1375"><a href="analysis.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1380">
<table class="cellalignment1374">
<tr>
<td class="cellalignment1375"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1375"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1375"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1375"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1375"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1375"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
