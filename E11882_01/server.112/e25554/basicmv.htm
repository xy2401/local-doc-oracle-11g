<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Basic Materialized Views</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 070" />
<meta name="dcterms.created" content="2013-07-04T23:23:15Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Warehousing Guide" />
<meta name="dcterms.identifier" content="E25554-02" />
<meta name="dcterms.isVersionOf" content="DWHSG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="constra.htm" title="Previous" type="text/html" />
<link rel="Next" href="advmv.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25554.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/35</span> <!-- End Header --><a id="g1028195"></a><a id="DWHSG008"></a><a id="i1007299"></a>
<h1 class="chapter"><span class="secnum">9</span> Basic Materialized Views</h1>
<p>This chapter describes the use of materialized views. It contains the following topics:</p>
<ul>
<li>
<p><a href="#i1006193">Overview of Data Warehousing with Materialized Views</a></p>
</li>
<li>
<p><a href="#i1007880">Types of Materialized Views</a></p>
</li>
<li>
<p><a href="#i1006803">Creating Materialized Views</a></p>
</li>
<li>
<p><a href="#i1008170">Registering Existing Materialized Views</a></p>
</li>
<li>
<p><a href="#i1012761">Choosing Indexes for Materialized Views</a></p>
</li>
<li>
<p><a href="#i1008721">Dropping Materialized Views</a></p>
</li>
<li>
<p><a href="#i1008271">Analyzing Materialized View Capabilities</a></p>
</li>
</ul>
<a id="i1006193"></a><a id="DWHSG0081"></a>
<div class="sect1">
<h2 class="sect1">Overview of Data Warehousing with Materialized Views</h2>
<p><a id="sthref143"></a><a id="sthref144"></a><a id="sthref145"></a>Typically, data flows from one or more online transaction processing (OLTP) database into a data warehouse on a monthly, weekly, or daily basis. The data is normally processed in a<a id="sthref146"></a> <a href="glossary.htm#i997125"><span class="xrefglossterm">staging file</span></a> before being added to the data warehouse. Data warehouses commonly range in size from tens of gigabytes to a few terabytes. Usually, the vast majority of the data is stored in a few very large fact tables.</p>
<p>One technique employed in data warehouses to improve performance is the creation of summaries. Summaries are special types of aggregate views that improve query execution times by precalculating expensive joins and aggregation operations prior to execution and storing the results in a table in the database. For example, you can create a summary table to contain the sums of sales by region and by product.</p>
<p>The summaries or aggregates that are referred to in this book and in literature on data warehousing are created in Oracle Database using a schema object called<a id="sthref147"></a> a <a href="glossary.htm#i997008"><span class="xrefglossterm">materialized view</span></a>. Materialized views can perform a number of roles, such as improving query performance or providing replicated data.</p>
<p>In the past, organizations using summaries spent a significant amount of time and effort creating summaries manually, identifying which summaries to create, indexing the summaries, updating them, and advising their users on which ones to use. The introduction of summary management eased the workload of the database administrator and meant the user no longer needed to be aware of the summaries that had been defined. The database administrator creates one or more materialized views, which are the equivalent of a summary. The end user queries the tables and views at the detail data level. The query rewrite mechanism in the Oracle server automatically rewrites the SQL query to use the summary tables. This mechanism reduces response time for returning results from the query. Materialized views within the data warehouse are transparent to the end user or to the database application.</p>
<p>Although materialized views are usually accessed through the query rewrite mechanism, an end user or database application can construct queries that directly access the materialized views. However, serious consideration should be given to whether users should be allowed to do this because any change to the materialized views affects the queries that reference them.</p>
<a id="DWHSG8161"></a>
<div class="sect2"><a id="sthref148"></a>
<h3 class="sect2">Materialized Views for Data Warehouses</h3>
<p>In data warehouses, you can use materialized views to precompute and store aggregated data such as the sum of sales. Materialized views in these environments are often referred to as summaries, because they store summarized data. They can also be used to precompute joins with or without aggregations. A materialized view eliminates the overhead associated with expensive joins and aggregations for a large or important class of queries.</p>
</div>
<!-- class="sect2" -->
<a id="i1006212"></a><a id="DWHSG8162"></a>
<div class="sect2">
<h3 class="sect2">Materialized Views for Distributed Computing</h3>
<p>In distributed environments, you can use materialized views to replicate data at distributed sites and to synchronize updates done at those sites with conflict resolution methods. These replica materialized views provide local access to data that otherwise would have to be accessed from remote sites. Materialized views are also useful in remote data marts. See <a class="olink REPLN" href="../e10706/toc.htm"><span class="italic">Oracle Database Advanced Replication</span></a> and <a class="olink HETER" href="../../server.112/e11050/toc.htm"><span class="italic">Oracle Database Heterogeneous Connectivity Administrator's Guide</span></a> for details on distributed and mobile computing.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8163"></a>
<div class="sect2"><a id="sthref149"></a>
<h3 class="sect2">Materialized Views for Mobile Computing</h3>
<p>You can also use materialized views to download a subset of data from central servers to mobile clients, with periodic refreshes and updates between clients and the central servers.</p>
<p>This chapter focuses on the use of materialized views in data warehouses. See <a class="olink REPLN" href="../e10706/toc.htm"><span class="italic">Oracle Database Advanced Replication</span></a> and <a class="olink HETER" href="../../server.112/e11050/toc.htm"><span class="italic">Oracle Database Heterogeneous Connectivity Administrator's Guide</span></a> for details on distributed and mobile computing.</p>
</div>
<!-- class="sect2" -->
<a id="i1006249"></a><a id="DWHSG8164"></a>
<div class="sect2">
<h3 class="sect2">The Need for Materialized Views</h3>
<p>You can use materialized views to increase the speed of queries on very large databases. Queries to large databases often involve joins between tables, aggregations such as <code>SUM</code>, or both. These operations are expensive in terms of time and processing power. The type of materialized view you create determines how the materialized view is refreshed and used by query rewrite.</p>
<p>Materialized views improve query performance by precalculating expensive join and aggregation operations on the database prior to execution and storing the results in the database. The query optimizer automatically recognizes when an existing materialized view can and should be used to satisfy a request. It then transparently rewrites the request to use the materialized view. Queries go directly to the materialized view and not to the underlying detail tables. In general, rewriting queries to use materialized views rather than detail tables improves response time. <a href="#CACGIDEI">Figure 9-1</a> illustrates how query rewrite works.</p>
<div class="figure">
<p class="titleinfigure"><a id="CACGIDEI"></a><a id="DWHSG8165"></a>Figure 9-1 Transparent Query Rewrite</p>
<img width="595" height="302" src="./dwhsg027.gif" alt="Description of Figure 9-1 follows" /><br />
<a id="sthref150" href="./img_text/dwhsg027.htm">Description of "Figure 9-1 Transparent Query Rewrite"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When using query rewrite, create materialized views that satisfy the largest number of queries. For example, if you identify 20 queries that are commonly applied to the detail or fact tables, then you might be able to satisfy them with five or six well-written materialized views. A materialized view definition can include any number of aggregations (<code>SUM</code>, <code>COUNT(x)</code>, <code>COUNT(*)</code>, <code>COUNT(DISTINCT&nbsp;x)</code>, <code>AVG</code>, <code>VARIANCE</code>, <code>STDDEV</code>, <code>MIN</code>, and <code>MAX</code>). It can also include any number of joins. If you are unsure of which materialized views to create, Oracle provides the SQL Access Advisor, which is a set of advisory procedure<a id="sthref151"></a>s in the <code>DBMS_ADVISOR</code> package to help in designing and evaluating materialized views for query rewrite.</p>
<p>If a materialized view is to be used by query rewrite, it must be stored in the same database as the detail tables on which it relies. A materialized view can be partitioned, and you can define a materialized view on a partitioned table. You can also define one or more indexes on the materialized view.</p>
<p>Unlike indexes, materialized views can be accessed directly using a <code>SELECT</code> statement. However, it is recommended that you try to avoid writing SQL statements that directly reference the materialized view, because then it is difficult to change them without affecting the application. Instead, let query rewrite transparently rewrite your query to use the materialized view.</p>
<p>Note that the techniques shown in this chapter illustrate how to use materialized views in data warehouses. Materialized views can also be used by Oracle Replication. See <a class="olink REPLN" href="../e10706/toc.htm"><span class="italic">Oracle Database Advanced Replication</span></a> for further information.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8166"></a>
<div class="sect2"><a id="sthref152"></a>
<h3 class="sect2">Components of Summary Management</h3>
<p>Summary <a id="sthref153"></a>management consists of:</p>
<ul>
<li>
<p>Mechanisms to define materialized views and dimensions.</p>
</li>
<li>
<p>A refresh mechanism to ensure that all materialized views contain the latest data.</p>
</li>
<li>
<p>A query rewrite capability to transparently rewrite a query to use a materialized view.</p>
</li>
<li>
<p>The SQL Access Advisor, which recommends materialized views, partitions, and indexes to create.</p>
</li>
<li>
<p><code>TUNE_MVIEW</code>, which shows you how to make your materialized view fast refreshable and use general query rewrite.</p>
</li>
</ul>
<p>The use of summary management features imposes no schema restrictions, and can enable some existing DSS database applications to improve performance without the need to redesign the database or the application.</p>
<p><a href="#i1012580">Figure 9-2</a> illustrates the use of summary management in the warehousing cycle. After the data has been transformed, staged, and loaded into the detail data in the warehouse, you can invoke the summary management process. First, use the SQL Access Advisor to plan how you will use materialized views. Then, create materialized views and design how queries will be rewritten. If you are having problems trying to get your materialized views to work then use <code>TUNE_MVIEW</code> to obtain an optimized materialized view.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1012580"></a><a id="DWHSG8167"></a>Figure 9-2 Overview of Summary Management</p>
<img width="388" height="552" src="./dwhsg071.gif" alt="Description of Figure 9-2 follows" /><br />
<a id="sthref154" href="./img_text/dwhsg071.htm">Description of "Figure 9-2 Overview of Summary Management"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Understanding the summary management process during the earliest stages of data warehouse design can yield large dividends later in the form of higher performance, lower summary administration costs, and reduced storage requirements.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8168"></a>
<div class="sect2"><a id="sthref155"></a>
<h3 class="sect2">Data Warehousing Terminology</h3>
<p>Some basic data warehousing terms are defined as follows:</p>
<ul>
<li>
<p><span class="bold"><a id="sthref156"></a><a id="sthref157"></a><a id="sthref158"></a><a id="sthref159"></a>Dimension</span> <span class="bold">tables</span> describe the business entities of an enterprise, represented as hierarchical, categorical information such as time, departments, locations, and products. Dimension tables are sometimes called<a id="sthref160"></a> lookup or <a id="sthref161"></a>reference tables.</p>
<p>Dimension tables usually change slowly over time and are not modified on a periodic schedule. They are used in long-running decision support queries to aggregate the data returned from the query into appropriate levels of the dimension hierarchy.</p>
</li>
<li>
<p><span class="bold">Hierarchies</span> describe the business relationships and common access patterns in the database. An analysis of the dimensions, combined with an understanding of the typical work load, can be used to create materialized views. See <a href="dimen.htm#g1011059">Chapter 11, "Dimensions"</a> for more information.</p>
</li>
<li>
<p><span class="bold"><a id="sthref162"></a><a id="sthref163"></a><a id="sthref164"></a>Fact</span> <span class="bold">tables</span> describe the business transactions of an enterprise.</p>
<p>The vast majority of data in a data warehouse is stored in a few very large fact tables that are updated periodically with data from one or more operational OLTP databases.</p>
<p>Fact tables includ<a id="sthref165"></a>e facts (also called measures) such as sales, units, and inventory.</p>
<ul>
<li>
<p>A simple measure is a numeric or character column of one table such as <code>fact.sales</code>.</p>
</li>
<li>
<p>A computed measure is an expression involving measures of one table, for example, <code>fact.revenues</code> - <code>fact.expenses</code>.</p>
</li>
<li>
<p>A multitable measure is a computed measure defined on multiple tables, for example, <code>fact_a.revenues</code> - <code>fact_b.expenses</code>.</p>
</li>
</ul>
<p>Fact tables also contain one or more foreign <a id="sthref166"></a>keys that organize the business transactions by the relevant business entities such as time, product, and market. In most cases, these foreign keys are non-null, form a unique compound key of the fact table, and each foreign key joins with exactly one row of a<a id="sthref167"></a> <a href="glossary.htm#i996883"><span class="xrefglossterm">dimension table</span></a>.</p>
</li>
<li>
<p>A materialized view is a precomputed table comprising aggregated and joined data from fact and possibly from dimension tables. Among builders of data warehouses, a materialized view is also known as a <a href="glossary.htm#i997158"><span class="xrefglossterm">summary</span></a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006354"></a><a id="DWHSG8169"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref168"></a><a id="sthref169"></a>Materialized View Schema Design</h3>
<p>Summary management<a id="sthref170"></a> can perform many useful functions, including query rewrite and materialized view refresh, even if your data warehouse design does not follow these guidelines. However, you realize significantly greater query execution performance and materialized view refresh performance benefits and you require fewer materialized views if your schema design complies with these guidelines.</p>
<p>A materialized view definition includes any number of aggregates, as well as any number of joins. In several ways, a materialized view behaves like an index:</p>
<ul>
<li>
<p>The purpose of a materialized view is to increase query execution performance.</p>
</li>
<li>
<p>The existence of a materialized view is transparent to SQL applications, so that a database administrator can create or drop materialized views at any time without affecting the validity of SQL applications.</p>
</li>
<li>
<p>A materialized view consumes storage space.</p>
</li>
<li>
<p>The contents of the materialized view must be updated when the underlying detail tables are modified.</p>
</li>
</ul>
<a id="DWHSG8170"></a>
<div class="sect3"><a id="sthref171"></a>
<h4 class="sect3">Schemas and Dimension Tables</h4>
<p>In the case of normalized or partially normalized dimension tables (a dimension that is stored in multiple tables), identify how these tables are joined. Note whether the joins between the dimension tables can guarantee that each child-side row joins with one and only one parent-side row. In the case of denormalized dimensions, determine whether the child-side columns uniquely determine the parent-side (or attribute) columns. These relationships can be enabled with constraints, using the <code>NOVALIDATE</code> and <code>RELY</code> options if the relationships represented by the constraints are guaranteed by other means. Note that if the joins between fact and dimension tables do not support the parent-child relationship described previously, you still gain significant performance advantages from defining the dimension with the <code>CREATE</code> <code>DIMENSION</code> statement. Another alternative, subject to some restrictions, is to use outer joins in the materialized view definition (that is, in the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement).</p>
<p>You must not create dimensions in any schema that does not satisfy these relationships. Incorrect results can be returned from queries otherwise.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8171"></a>
<div class="sect3"><a id="sthref172"></a>
<h4 class="sect3">Materialized View Schema Design Guidelines</h4>
<p>Before starting to define and use the various components of summary management, you should review your schema design to abide by the following guidelines wherever possible.</p>
<p>Guidelines 1 and 2 are more important than guideline 3. If your schema design does not follow guidelines 1 and 2, it does not then matter whether it follows guideline 3. Guidelines 1, 2, and 3 affect both query rewrite performance and materialized view refresh performance.</p>
<div class="tblformalwidemax">
<p class="titleintable"><a id="DWHSG8172"></a><a id="sthref173"></a><a id="sthref174"></a>Table 9-1 Schema Design Guidelines</p>
<table class="cellalignment1383" title="Schema Design Guidelines" summary="Schema Design Guidelines" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t2">Schema Guideline</th>
<th class="cellalignment1382" id="r1c2-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t2" headers="r1c1-t2">
<p>Guideline 1</p>
<p>Dimensions</p>
</td>
<td class="cellalignment1378" headers="r2c1-t2 r1c2-t2">
<p>Dimensions should either be denormalized (each dimension contained in one table) or the joins between tables in a normalized or partially normalized dimension should guarantee that each child-side row joins with exactly one parent-side row. The benefits of maintaining this condition are described in <a href="dimen.htm#i1006266">"Creating Dimensions"</a>.</p>
<p>You can enforce this condition by adding <code>FOREIGN</code> <code>KEY</code> and <code>NOT NULL</code> constraints on the child-side join keys and <code>PRIMARY</code> <code>KEY</code> constraints on the parent-side join keys.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t2" headers="r1c1-t2">
<p>Guideline 2</p>
<p>Dimensions</p>
</td>
<td class="cellalignment1378" headers="r3c1-t2 r1c2-t2">
<p>If dimensions are denormalized or partially denormalized, hierarchical integrity must be maintained between the key columns of the dimension table. Each child key value must uniquely identify its parent key value, even if the dimension table is denormalized. Hierarchical integrity in a denormalized dimension can be verified by calling the <code>VALIDATE_DIMENSION</code> procedure of the <code>DBMS_DIMENSION</code> package.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t2" headers="r1c1-t2">
<p>Guideline 3</p>
<p>Dimensions</p>
</td>
<td class="cellalignment1378" headers="r4c1-t2 r1c2-t2">
<p>Fact and dimension tables should similarly guarantee that each fact table row joins with exactly one dimension table row. This condition must be declared, and optionally enforced, by adding <code>FOREIGN</code> <code>KEY</code> and <code>NOT</code> <code>NULL</code> constraints on the fact key column(s) and <code>PRIMARY</code> <code>KEY</code> constraints on the dimension key column(s), or by using outer joins. In a data warehouse, constraints are typically enabled with the <code>NOVALIDATE</code> and <code>RELY</code> clauses to avoid constraint enforcement performance overhead. See <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for further details.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t2" headers="r1c1-t2">
<p>Guideline 4</p>
<p>Incremental Loads</p>
</td>
<td class="cellalignment1378" headers="r5c1-t2 r1c2-t2">
<p>Incremental loads of your detail data should be done using the SQL*Loader direct-path option, or any bulk loader utility that uses Oracle's direct-path interface. This includes <code>INSERT</code> ... <code>AS SELECT</code> with the <code>APPEND</code> or <code>PARALLEL</code> hints, where the hints cause the direct loader log to be used during the insert. See <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a href="#i1007880">"Types of Materialized Views"</a> for more information.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r6c1-t2" headers="r1c1-t2">
<p>Guideline 5</p>
<p>Partitions</p>
</td>
<td class="cellalignment1378" headers="r6c1-t2 r1c2-t2">
<p>Range/composite partition your tables by a monotonically increasing time column if possible (preferably of type <code>DATE</code>).</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r7c1-t2" headers="r1c1-t2">
<p>Guideline 6</p>
<p>Dimensions</p>
</td>
<td class="cellalignment1378" headers="r7c1-t2 r1c2-t2">
<p>After each load and before refreshing your materialized view, use the <code>VALIDATE_DIMENSION</code> procedure of the <code>DBMS_DIMENSION</code> package to incrementally verify dimensional integrity.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r8c1-t2" headers="r1c1-t2">
<p>Guideline 7</p>
<p>Time Dimensions</p>
</td>
<td class="cellalignment1378" headers="r8c1-t2 r1c2-t2">
<p>If a time dimension appears in the materialized view as a time column, partition and index the materialized view in the same manner as you have the fact tables.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p>If you are concerned with the time required to enable constraints and whether any constraints might be violated, then use the <code>ENABLE</code> <code>NOVALIDATE</code> with the <code>RELY</code> clause to turn on constraint checking without validating any of the existing constraints. The risk with this approach is that incorrect query results could occur if any constraints are broken. Therefore, as the designer, you must determine how clean the data is and whether the risk of incorrect results is too great.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DWHSG8173"></a>
<div class="sect2"><a id="sthref175"></a>
<h3 class="sect2">Loading Data into Data Warehouses</h3>
<p>A popular and efficient way to load data into a data warehouse or data mart is to use SQL*Loader with the <code>DIRECT</code> or <code>PARALLEL</code> option, Data Pump, or to use another loader tool that uses the Oracle direct-path API. See <a class="olink SUTIL003" href="../../server.112/e22490/ldr_concepts.htm#SUTIL003"><span class="italic">Oracle Database Utilities</span></a> for the restrictions and considerations when using SQL*Loader with the <code>DIRECT</code> or <code>PARALLEL</code> keywords.</p>
<p>Loading strategies can be classified as one-phase or two-phase. In one-phase loading, data is loaded directly into the target table, quality assurance tests are performed, and errors are resolved by performing DML operations prior to refreshing materialized views. If a large number of deletions are possible, then storage utilization can be adversely affected, but temporary space requirements and load time are minimized.</p>
<p>In a two-phase loading process:</p>
<ul>
<li>
<p>Data is first loaded into a temporary table in the warehouse.</p>
</li>
<li>
<p>Quality assurance procedures are applied to the data.</p>
</li>
<li>
<p>Referential integrity constraints on the target table are disabled, and the local index in the target partition is marked unusable.</p>
</li>
<li>
<p>The data is copied from the temporary area into the appropriate partition of the target table using <code>INSERT</code> <code>AS</code> <code>SELECT</code> with the <code>PARALLEL</code> or <code>APPEND</code> hint. The temporary table is then dropped. Alternatively, if the target table is partitioned, you can create a new (empty) partition in the target table and use <code>ALTER TABLE ... EXCHANGE PARTITION</code> to incorporate the temporary table into the target table. See <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
</li>
<li>
<p>The constraints are enabled, usually with the <code>NOVALIDATE</code> option.</p>
</li>
</ul>
<p>Immediately after loading the detail data and updating the indexes on the detail data, the database can be opened for operation, if desired. You can disable query rewrite at the system level by issuing an <code>ALTER</code> <code>SYSTEM</code> <code>SET</code> <code>QUERY_REWRITE_ENABLED</code> = <code>FALSE</code> statement until all the materialized views are refreshed.</p>
<p>If <code>QUERY_REWRITE_INTEGRITY</code> is set to <code>STALE_TOLERATED</code>, access to the materialized view can be allowed at the session level to any users who do not require the materialized views to reflect the data from the latest load by issuing an <code>ALTER</code> <code>SESSION</code> <code>SET</code> <code>QUERY_REWRITE_ENABLED</code> = <code>TRUE</code> statement. This scenario does not apply when <code>QUERY_REWRITE_INTEGRITY</code> is either <code>ENFORCED</code> or <code>TRUSTED</code> because the system ensures in these modes that only materialized views with updated data participate in a query rewrite.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8174"></a>
<div class="sect2"><a id="sthref176"></a>
<h3 class="sect2">Overview of Materialized View Management Tasks</h3>
<p>The motivation for using materialized views is to improve performance, but the overhead associated with materialized view management can become a significant system management problem. When reviewing or evaluating some of the necessary materialized view management activities, consider some of the following:</p>
<ul>
<li>
<p>Identifying what materialized views to create initially.</p>
</li>
<li>
<p>Indexing the materialized views.</p>
</li>
<li>
<p>Ensuring that all materialized views and materialized view indexes are refreshed properly each time the database is updated.</p>
</li>
<li>
<p>Checking which materialized views have been used.</p>
</li>
<li>
<p>Determining how effective each materialized view has been on workload performance.</p>
</li>
<li>
<p>Measuring the space being used by materialized views.</p>
</li>
<li>
<p>Determining which new materialized views should be created.</p>
</li>
<li>
<p>Determining which existing materialized views should be dropped.</p>
</li>
<li>
<p>Archiving old detail and materialized view data that is no longer useful.</p>
</li>
</ul>
<p>After the initial effort of creating and populating the data warehouse or data mart, the major administration overhead is the update process, which involves:</p>
<ul>
<li>
<p>Periodic extraction of incremental changes from the operational systems.</p>
</li>
<li>
<p>Transforming the data.</p>
</li>
<li>
<p>Verifying that the incremental changes are correct, consistent, and complete.</p>
</li>
<li>
<p>Bulk-loading the data into the warehouse.</p>
</li>
<li>
<p>Refreshing indexes and materialized views so that they are consistent with the detail data.</p>
</li>
</ul>
<p>The update process must generally be performed within a limited period of time known as the <a id="sthref177"></a><a href="glossary.htm#i997213"><span class="xrefglossterm">update window</span></a>. The update window depends on the <a id="sthref178"></a><a href="glossary.htm#i997216"><span class="xrefglossterm">update frequency</span></a> (such as daily or weekly) and the nature of the business. For a daily update frequency, an update window of two to six hours might be typical.</p>
<p>You need to know your update window for the following activities:</p>
<ul>
<li>
<p>Loading the detail data</p>
</li>
<li>
<p>Updating or rebuilding the indexes on the detail data</p>
</li>
<li>
<p>Performing quality assurance tests on the data</p>
</li>
<li>
<p>Refreshing the materialized views</p>
</li>
<li>
<p>Updating the indexes on the materialized views</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007880"></a><a id="DWHSG0082"></a>
<div class="sect1">
<h2 class="sect1">Types of Materialized Views</h2>
<p><a id="sthref179"></a>The <code>SELECT</code> clause in the materialized view creation statement defines the data that the materialized view is to contain. Only a few restrictions limit what can be specified. Any number of tables can be joined together. Besides tables, other elements such as views, inline views (subqueries in the <code>FROM</code> clause of a <code>SELECT</code> statement), subqueries, and materialized views can all be joined or referenced in the <code>SELECT</code> clause. You cannot, however, define a materialized view with a subquery in the <code>SELECT</code> list of the defining query. You can, however, include subqueries elsewhere in the defining query, such as in the <code>WHERE</code> clause.</p>
<p>The types of materialized views are:</p>
<ul>
<li>
<p><a href="#i1006519">Materialized Views with Aggregates</a></p>
</li>
<li>
<p><a href="#i1006674">Materialized Views Containing Only Joins</a></p>
</li>
<li>
<p><a href="#i1006734">Nested Materialized Views</a></p>
</li>
</ul>
<a id="i1006519"></a><a id="DWHSG8175"></a>
<div class="sect2">
<h3 class="sect2">Materialized Views with<a id="sthref180"></a> Aggregates</h3>
<p>In<a id="sthref181"></a> data warehouses, materialized views normally contain aggregates as shown in <a href="#i1006540">Example 9-1</a>. For fast refresh to be possible, the <code>SELECT</code> list must contain all of the <code>GROUP</code> <code>BY</code> columns (if present), and there must be a <code>COUNT(*)</code> and a <code>COUNT(column)</code> on any aggregated columns. Also, materialized view logs must be present on all tables referenced in the query that defines the materialized view. The valid aggregate functions are: <code>SUM</code>, <code>COUNT(x)</code>, <code>COUNT(*)</code>, <code>AVG</code>, <code>VARIANCE</code>, <code>STDDEV</code>, <code>MIN</code>, and <code>MAX</code>, and the expression to be aggregated can be any SQL value expression. See <a href="#i1007028">"Restrictions on Fast Refresh on Materialized Views with Aggregates"</a>.</p>
<p>Fast refresh for a materialized view containing joins and aggregates is possible after any type of DML to the base tables (direct load or conventional <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>). It can be defined to be refreshed <code>ON</code> <code>COMMIT</code> or <code>ON</code> <code>DEMAND</code>. A <code>REFRESH ON</code> <code>COMMIT</code> materialized view is refreshed automatically when a transaction that does DML to one of the materialized view's detail tables commits. The time taken to complete the commit may be slightly longer than usual when this method is chosen. This is because the refresh operation is performed as part of the commit process. Therefore, this method may not be suitable if many users are concurrently changing the tables upon which the materialized view is based.</p>
<p>Here are some examples of materialized views with aggregates. Note that materialized view logs are only created because this materialized view is fast refreshed.</p>
<div class="example">
<p class="titleinexample"><a id="i1006540"></a><a id="DWHSG8176"></a>Example 9-1 <span class="bold">Example 1: Creating a Materialized View</span></p>
<pre>
CREATE MATERIALIZED VIEW LOG ON products WITH SEQUENCE, ROWID
(prod_id, prod_name, prod_desc, prod_subcategory, prod_subcategory_desc, 
prod_category, prod_category_desc, prod_weight_class, prod_unit_of_measure,
 prod_pack_size, supplier_id, prod_status, prod_list_price, prod_min_price)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW LOG ON sales
WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW product_sales_mv
PCTFREE 0  TABLESPACE demo
STORAGE (INITIAL 8M)
BUILD IMMEDIATE
REFRESH FAST
ENABLE QUERY REWRITE
AS SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales,
COUNT(*) AS cnt, COUNT(s.amount_sold) AS cnt_amt
FROM sales s, products p
WHERE s.prod_id = p.prod_id GROUP BY p.prod_name;
</pre>
<p>This example creates a materialized view <code>product_sales_mv</code> that computes total number and value of sales for a product. It is derived by joining the tables <code>sales</code> and <code>products</code> on the column <code>prod_id</code>. The materialized view is populated with data immediately because the build method is immediate and it is available for use by query rewrite. In this example, the default refresh method is <code>FAST</code>, which is allowed because the appropriate materialized view logs have been created on tables <code>products</code> and <code>sales</code>.</p>
<p>You can achieve better fast refresh performance for local materialized views if you use a materialized view log that contains a <code>WITH</code> <code>COMMIT</code> <code>SCN</code> clause. An example is the following:</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID(prod_id, cust_id, time_id),
  COMMIT SCN INCLUDING NEW VALUES;
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="i1006568"></a><a id="DWHSG8177"></a>Example 9-2 Example 2: <span class="bold">Creating a Materialized View</span></p>
<pre>
CREATE MATERIALIZED VIEW product_sales_mv
PCTFREE 0 TABLESPACE demo
STORAGE (INITIAL 8M)
BUILD DEFERRED
REFRESH COMPLETE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales
FROM sales s, products p WHERE s.prod_id = p.prod_id
GROUP BY p.prod_name;
</pre>
<p>This example creates a materialized view <code>product_sales_mv</code> that computes the sum of sales by <code>prod_name</code>. It is derived by joining the tables <code>sales</code> and <code>products</code> on the column <code>prod_id</code>. The materialized view does not initially contain any data, because the build method is <code>DEFERRED</code>. A complete refresh is required for the first refresh of a build deferred materialized view. When it is refreshed and once populated, this materialized view can be used by query rewrite.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="i1006588"></a><a id="DWHSG8178"></a>Example 9-3 Example 3: <span class="bold">Creating a Materialized View</span></p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW sum_sales
PARALLEL
BUILD IMMEDIATE  
REFRESH FAST ON COMMIT AS  
SELECT s.prod_id, s.time_id, COUNT(*) AS count_grp,
   SUM(s.amount_sold) AS sum_dollar_sales,
   COUNT(s.amount_sold) AS count_dollar_sales,
   SUM(s.quantity_sold) AS sum_quantity_sales,
   COUNT(s.quantity_sold) AS count_quantity_sales
FROM sales s
GROUP BY s.prod_id, s.time_id;
</pre>
<p>This example creates a materialized view that contains aggregates on a single table. Because the materialized view log has been created with all referenced columns in the materialized view's defining query, the materialized view is fast refreshable. If DML is applied against the <code>sales</code> table, then the changes are reflected in the materialized view when the commit is issued.</p>
</div>
<!-- class="example" -->
<a id="DWHSG8179"></a>
<div class="sect3"><a id="sthref182"></a>
<h4 class="sect3">Requirements for Using Materialized Views with Aggregates</h4>
<p><a href="#g1014280">Table 9-2</a> illustrates the aggregate requirements for materialized views. If aggregate <code>X</code> is present, aggregate <code>Y</code> is required and aggregate <code>Z</code> is optional.</p>
<div class="tblformal">
<p class="titleintable"><a id="DWHSG8180"></a><a id="sthref183"></a><a id="g1014280"></a>Table 9-2 Requirements for Materialized Views with Aggregates</p>
<table class="cellalignment1381" title="Requirements for Materialized Views with Aggregates" summary="Requirements for Materialized Views with Aggregates" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t3">X</th>
<th class="cellalignment1382" id="r1c2-t3">Y</th>
<th class="cellalignment1382" id="r1c3-t3">Z</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t3" headers="r1c1-t3">
<p><code>COUNT(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t3 r1c2-t3">
<p><code>-</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t3 r1c3-t3">
<p><code>-</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t3" headers="r1c1-t3">
<p><code>MIN(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t3 r1c2-t3">
<p><code>-</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t3 r1c3-t3">
<p><code>-</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t3" headers="r1c1-t3">
<p><code>MAX(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t3 r1c2-t3">
<p><code>-</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t3 r1c3-t3">
<p><code>-</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t3" headers="r1c1-t3">
<p><code>SUM(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t3 r1c2-t3">
<p><code>COUNT(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t3 r1c3-t3">
<p><code>-</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r6c1-t3" headers="r1c1-t3">
<p><code>SUM(col)</code>, <code>col</code> has <code>NOT</code> <code>NULL</code> constraint</p>
</td>
<td class="cellalignment1378" headers="r6c1-t3 r1c2-t3">
<p><code>-</code></p>
</td>
<td class="cellalignment1378" headers="r6c1-t3 r1c3-t3">
<p><code>-</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r7c1-t3" headers="r1c1-t3">
<p><code>AVG(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r7c1-t3 r1c2-t3">
<p><code>COUNT(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r7c1-t3 r1c3-t3">
<p><code>SUM(expr)</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r8c1-t3" headers="r1c1-t3">
<p><code>STDDEV(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r8c1-t3 r1c2-t3">
<p><code>COUNT(expr) SUM(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r8c1-t3 r1c3-t3">
<p><code>SUM(expr * expr)</code></p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r9c1-t3" headers="r1c1-t3">
<p><code>VARIANCE(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r9c1-t3 r1c2-t3">
<p><code>COUNT(expr) SUM(expr)</code></p>
</td>
<td class="cellalignment1378" headers="r9c1-t3 r1c3-t3">
<p><code>SUM(expr * expr)</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Note that <code>COUNT(*)</code> must always be present to guarantee all types of fast refresh. Otherwise, you may be limited to fast refresh after inserts only. Oracle recommends that you include the optional aggregates in column <code>Z</code> in the materialized view in order to obtain the most efficient and accurate fast refresh of the aggregates.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006674"></a><a id="DWHSG8181"></a>
<div class="sect2">
<h3 class="sect2">Materialized Views <a id="sthref184"></a>Containing Only Joins</h3>
<p>Some materialized views contain only joins and no aggregates, such as in <a href="#i1006694">Example 9-4</a>, where a materialized view is created that joins the <code>sales</code> table to the <code>times</code> and <code>customers</code> tables. The advantage of creating this type of materialized view is that expensive joins are precalculated.</p>
<p>Fast refresh for a materialized view containing only joins is possible after any type of DML to the base tables (direct-path or conventional <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>).</p>
<p>A materialized view containing only joins can be defined to be refreshed <code>ON COMMIT</code> or <code>ON</code> <code>DEMAND</code>. If it is <code>ON</code> <code>COMMIT</code>, the refresh is performed at commit time of the transaction that does DML on the materialized view's detail table.</p>
<p>If you specify <code>REFRESH</code> <code>FAST</code>, Oracle performs further verification of the query definition to ensure that fast refresh can be performed if any of the detail tables change. These additional checks are:</p>
<ul>
<li>
<p>A materialized view log must be present for each detail table unless the table supports PCT. Also, when a materialized view log is required, the <code>ROWID</code> column must be present in each materialized view log.</p>
</li>
<li>
<p>The rowids of all the detail tables must appear in the <code>SELECT</code> list of the materialized view query definition.</p>
</li>
</ul>
<p>If some of these restrictions are not met, you can create the materialized view as <code>REFRESH</code> <code>FORCE</code> to take advantage of fast refresh when it is possible. If one of the tables did not meet all of the criteria, but the other tables did, the materialized view would still be fast refreshable with respect to the other tables for which all the criteria are met.</p>
<p>To achieve an optimally efficient refresh, you should ensure that the defining query does not use an outer join that behaves like an inner join. If the defining query contains such a join, consider rewriting the defining query to contain an inner join. See <a href="#i1007013">"Restrictions on Fast Refresh on Materialized Views with Joins Only"</a> for more information regarding the conditions that cause refresh performance to degrade.</p>
<a id="DWHSG8182"></a>
<div class="sect3"><a id="sthref185"></a>
<h4 class="sect3">Materialized Join Views FROM Clause Considerations</h4>
<p>If the materialized view contains only joins, the <code>ROWID</code> columns for each table (and each instance of a table that occurs multiple times in the <code>FROM</code> list) must be present in the <code>SELECT</code> list of the materialized view.</p>
<p>If the materialized view has remote tables in the <code>FROM</code> clause, all tables in the <code>FROM</code> clause must be located on that same site. Further, <code>ON</code> <code>COMMIT</code> refresh is not supported for materialized view with remote tables. Except for SCN-based materialized view logs, materialized view logs must be present on the remote site for each detail table of the materialized view and <code>ROWID</code> columns must be present in the <code>SELECT</code> list of the materialized view, as shown in the following example.</p>
<div class="example">
<p class="titleinexample"><a id="i1006694"></a><a id="DWHSG8183"></a>Example 9-4 Materialized View Containing Only Joins</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON times WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;
CREATE MATERIALIZED VIEW detail_sales_mv 
PARALLEL BUILD IMMEDIATE
REFRESH FAST AS
SELECT s.rowid "sales_rid", t.rowid "times_rid", c.rowid "customers_rid",
       c.cust_id, c.cust_last_name, s.amount_sold, s.quantity_sold, s.time_id
FROM sales s, times t, customers c 
WHERE  s.cust_id = c.cust_id(+) AND s.time_id = t.time_id(+);
</pre>
<p>Alternatively, if the previous example did not include the columns <code>times_rid</code> and <code>customers_rid</code>, and if the refresh method was <code>REFRESH</code> <code>FORCE</code>, then this materialized view would be fast refreshable only if the sales table was updated but not if the tables <code>times</code> or <code>customers</code> were updated.</p>
<pre>
CREATE MATERIALIZED VIEW detail_sales_mv 
PARALLEL
BUILD IMMEDIATE
REFRESH FORCE AS
SELECT s.rowid "sales_rid", c.cust_id, c.cust_last_name, s.amount_sold,
   s.quantity_sold, s.time_id
FROM sales s, times t, customers c 
WHERE s.cust_id = c.cust_id(+) AND s.time_id = t.time_id(+);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006734"></a><a id="DWHSG8184"></a>
<div class="sect2">
<h3 class="sect2">Nested Materialized Views</h3>
<p><a id="sthref186"></a><a id="sthref187"></a>A nested materialized view is a materialized view whose definition is based on another materialized view. A nested materialized view can reference other relations in the database in addition to referencing materialized views.</p>
<a id="DWHSG8185"></a>
<div class="sect3"><a id="sthref188"></a>
<h4 class="sect3">Why Use Nested Materialized Views?</h4>
<p>In a data warehouse, you typically create many aggregate views on a single join (for example, rollups along different dimensions). Incrementally maintaining these distinct materialized aggregate views can take a long time, because the underlying join has to be performed many times.</p>
<p>Using nested materialized views, you can create multiple single-table materialized views based on a joins-only materialized view and the join is performed just once. In addition, optimizations can be performed for this class of single-table aggregate materialized view and thus refresh is very efficient.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8186"></a><a id="sthref189"></a>Example 9-5 Nested Materialized View</p>
<p>You can create a nested materialized view on materialized views, but all parent and base materialized views must contain joins or aggregates. If the defining queries for a materialized view do not contain joins or aggregates, it cannot be nested. All the underlying objects (materialized views or tables) on which the materialized view is defined must have a materialized view log. All the underlying objects are treated as if they were tables. In addition, you can use all the existing options for materialized views.</p>
<p>Using the tables and their columns from the <code>sh</code> sample schema, the following materialized views illustrate how nested materialized views can be created.</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON times WITH ROWID;

/*create materialized view join_sales_cust_time as fast refreshable at
   COMMIT time */
CREATE MATERIALIZED VIEW join_sales_cust_time 
REFRESH FAST ON COMMIT AS
SELECT c.cust_id, c.cust_last_name, s.amount_sold, t.time_id,
       t.day_number_in_week, s.rowid srid, t.rowid trid, c.rowid crid 
FROM sales s, customers c, times t
WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id;
</pre>
<p>To create a nested materialized view on the table <code>join_sales_cust_time</code><span class="italic">,</span> you would have to create a materialized view log on the table. Because this will be a single-table aggregate materialized view on <code>join_sales_cust_time</code>, you must log all the necessary columns and use the <code>INCLUDING</code> <code>NEW</code> <code>VALUES</code> clause.</p>
<pre>
/* create materialized view log on join_sales_cust_time */
CREATE MATERIALIZED VIEW LOG ON join_sales_cust_time 
WITH ROWID (cust_last_name, day_number_in_week, amount_sold),
INCLUDING NEW VALUES;

/* create the single-table aggregate materialized view sum_sales_cust_time 
on join_sales_cust_time as fast refreshable at COMMIT time */
CREATE MATERIALIZED VIEW sum_sales_cust_time 
REFRESH FAST ON COMMIT AS
SELECT COUNT(*) cnt_all, SUM(amount_sold) sum_sales, COUNT(amount_sold)
       cnt_sales, cust_last_name, day_number_in_week
FROM join_sales_cust_time
GROUP BY cust_last_name, day_number_in_week;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDIDDEJ"></a><a id="DWHSG8187"></a>
<div class="sect3">
<h4 class="sect3">Nesting Materialized Views with Joins and Aggregates</h4>
<p>Some types of nested materialized views cannot be fast refreshed. Use <code>EXPLAIN_MVIEW</code> to identify those types of materialized views. You can refresh a tree of nested materialized views in the appropriate dependency order by specifying the <code>nested = TRUE</code> parameter with the <code>DBMS_MVIEW.REFRESH</code> parameter. For example, if you call <code>DBMS_MVIEW.REFRESH ('SUM_SALES_CUST_TIME', nested =&gt; TRUE)</code>, the <code>REFRESH</code> procedure will first refresh the <code>join_sales_cust_time</code> materialized view, and then refresh the <code>sum_sales_cust_time</code> materialized view.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8188"></a>
<div class="sect3"><a id="sthref190"></a>
<h4 class="sect3">Nested Materialized View Usage Guidelines</h4>
<p>You should keep the following in mind when deciding whether to use nested materialized views:</p>
<ul>
<li>
<p>If you want to use fast refresh, you should fast refresh all the materialized views along any chain.</p>
</li>
<li>
<p>If you want the highest level materialized view to be fresh with respect to the detail tables, you must ensure that all materialized views in a tree are refreshed in the correct dependency order before refreshing the highest-level. You can automatically refresh intermediate materialized views in a nested hierarchy using the <code>nested = TRUE</code> parameter, as described in <a href="#CHDIDDEJ">"Nesting Materialized Views with Joins and Aggregates"</a>. If you do not specify <code>nested = TRUE</code> and the materialized views under the highest-level materialized view are stale, refreshing only the highest-level will succeed, but makes it fresh only with respect to its underlying materialized view, not the detail tables at the base of the tree.</p>
</li>
<li>
<p>When refreshing materialized views, you must ensure that all materialized views in a tree are refreshed. If you only refresh the highest-level materialized view, the materialized views under it will be stale and you must explicitly refresh them. If you use the <code>REFRESH</code> procedure with the <code>nested</code> parameter value set to <code>TRUE</code>, only specified materialized views and their child materialized views in the tree are refreshed, and not their top-level materialized views. Use the <code>REFRESH_DEPENDENT</code> procedure with the nested parameter value set to <code>TRUE</code> if you want to ensure that all materialized views in a tree are refreshed.</p>
</li>
<li>
<p>Freshness of a materialized view is calculated relative to the objects directly referenced by the materialized view. When a materialized view references another materialized view, the freshness of the topmost materialized view is calculated relative to changes in the materialized view it directly references, not relative to changes in the tables referenced by the materialized view it references.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="DWHSG8189"></a>
<div class="sect3"><a id="sthref191"></a>
<h4 class="sect3">Restrictions When Using Nested Materialized Views</h4>
<p><a id="sthref192"></a><a id="sthref193"></a>You cannot create both a materialized view and a prebuilt materialized view on the same table. For example, If you have a table <code>costs</code> with a materialized view <code>cost_mv</code> based on it, you cannot then create a prebuilt materialized view on table <code>costs</code>. The result would make <code>cost_mv</code> a nested materialized view and this method of conversion is not supported.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006803"></a><a id="DWHSG0083"></a>
<div class="sect1">
<h2 class="sect1">Creating Materialized Views</h2>
<p><a id="sthref194"></a>A materialized view can be created with the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement or using Enterprise Manager. <a href="#i1006810">Example 9-6</a> illustrates creating an materialized view called <code>cust_sales_mv</code>.</p>
<div class="example">
<p class="titleinexample"><a id="i1006810"></a><a id="DWHSG8190"></a>Example 9-6 Creating a Materialized View</p>
<pre>
CREATE MATERIALIZED VIEW cust_sales_mv
PCTFREE 0 TABLESPACE demo
STORAGE (INITIAL 8M)
PARALLEL
BUILD IMMEDIATE
REFRESH COMPLETE
ENABLE QUERY REWRITE AS
SELECT  c.cust_last_name, SUM(amount_sold) AS sum_amount_sold
FROM customers c, sales s WHERE s.cust_id = c.cust_id
GROUP BY c.cust_last_name;
</pre>
<p>It is not uncommon in a data warehouse to have already created summary or aggregation tables, and you might not wish to repeat this work by building a new materialized view. In this case, the table that already exists in the database can be registered as a<a id="sthref195"></a><a id="sthref196"></a> prebuilt materialized view. This technique is described in <a href="#i1008170">"Registering Existing Materialized Views"</a>.</p>
<p>Once you have selected the materialized views you want to create, follow these steps for each materialized view.</p>
</div>
<!-- class="example" -->
<ol>
<li>
<p>Design the materialized view. Existing user-defined materialized views do not require this step. If the materialized view contains many rows, then, if appropriate, the materialized view should be partitioned (if possible) and should match the partitioning of the largest or most frequently updated detail or fact table (if possible). Refresh performance benefits from partitioning, because it can take advantage of parallel DML capabilities and possible PCT-based refresh.</p>
</li>
<li>
<p>Use the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement to create and, optionally, populate the materialized view. If a user-defined materialized view already exists, then use the <code>ON</code> <code>PREBUILT</code> <code>TABLE</code> clause in the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement. Otherwise, use the <code>BUILD</code> <code>IMMEDIATE</code> clause to populate the materialized view immediately, or the <code>BUILD</code> <code>DEFERRED</code> clause to populate the materialized view later. A <code>BUILD</code> <code>DEFERRED</code> materialized view is disabled for use by query rewrite until the first <code>COMPLETE</code> <code>REFRESH</code>, after which it is automatically enabled, provided the <code>ENABLE</code> <code>QUERY</code> <code>REWRITE</code> clause has been specified.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a id="sthref197"></a><a id="sthref198"></a><a id="sthref199"></a><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for descriptions of the SQL statements <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code>, <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code>, and <code>DROP</code> <code>MATERIALIZED</code> <code>VIEW</code></div>
</li>
</ol>
<a id="DWHSG00831"></a>
<div class="sect2"><a id="sthref200"></a>
<h3 class="sect2">Creating Materialized Views with Column Alias Lists</h3>
<p>Currently, when a materialized view is created, if its defining query contains same-name columns in the <code>SELECT</code> list, the name conflicts need to be resolved by specifying unique aliases for those columns. Otherwise, the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement fails with the error messages of columns ambiguously defined. However, the standard method of attaching aliases in the <code>SELECT</code> clause for name resolution restricts the use of the full text match query rewrite and it will occur only when the text of the materialized view's defining query and the text of user input query are identical. Thus, if the user specifies select aliases in the materialized view's defining query while there is no alias in the query, the full text match comparison fails. This is particularly a problem for queries from Discoverer, which makes extensive use of column aliases.</p>
<p>The following is an example of the problem. <code>sales_mv</code> is created with column aliases in the <code>SELECT</code> clause but the input query <code>Q1</code> does not have the aliases. The full text match rewrite fails. The materialized view is as follows:</p>
<pre>
CREATE MATERIALIZED VIEW sales_mv
ENABLE QUERY REWRITE AS
SELECT s.time_id sales_tid, c.time_id costs_tid
FROM sales s, products p, costs c
WHERE s.prod_id = p.prod_id AND c.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre>
<p>Input query statement <code>Q1</code> is as follows:</p>
<pre>
SELECT s.time_id, c1.time_id
FROM sales s, products p, costs c1
WHERE s.prod_id = p.prod_id AND c1.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre>
<p>Even though the materialized view's defining query is almost identical and logically equivalent to the user's input query, query rewrite does not happen because of the failure of full text match that is the only rewrite possibility for some queries (for example, a subquery in the <code>WHERE</code> clause).</p>
<p>You can add a column alias list to a <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement. The column alias list explicitly resolves any column name conflict without attaching aliases in the <code>SELECT</code> clause of the materialized view. The syntax of the materialized view column alias list is illustrated in the following example:</p>
<pre>
CREATE MATERIALIZED VIEW sales_mv (sales_tid, costs_tid)
ENABLE QUERY REWRITE AS
SELECT s.time_id, c.time_id
FROM sales s, products p, costs c
WHERE s.prod_id = p.prod_id AND c.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre>
<p>In this example, the defining query of <code>sales_mv</code> now matches exactly with the user query <code>Q1</code>, so full text match rewrite takes place.</p>
<p>Note that when aliases are specified in both the <code>SELECT</code> clause and the new alias list clause, the alias list clause supersedes the ones in the <code>SELECT</code> clause.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG00832"></a>
<div class="sect2"><a id="sthref201"></a>
<h3 class="sect2">Naming Materialized Views</h3>
<p><a id="sthref202"></a>The name of a materialized view must conform to standard Oracle naming conventions. However, if the materialized view is based on a user-defined prebuilt table, then the name of the materialized view must exactly match that table name.</p>
<p>If you already have a naming convention for tables and indexes, you might consider extending this naming scheme to the materialized views so that they are easily identifiable. For example, instead of naming the materialized view <code>sum_of_sales</code>, it could be called <code>sum_of_sales_mv</code> to denote that this is a materialized view and not a table or view.</p>
</div>
<!-- class="sect2" -->
<a id="i1006854"></a><a id="DWHSG00833"></a>
<div class="sect2">
<h3 class="sect2">Storage And Table Compression</h3>
<p><a id="sthref203"></a>Unless the materialized view is based on <a id="sthref204"></a><a id="sthref205"></a><a id="sthref206"></a><a id="sthref207"></a>a user-defined prebuilt table, it requires and occupies storage space inside the database. Therefore, the storage needs for the materialized view should be specified in terms of the tablespace where it is to reside and the size of the extents.</p>
<p>If you do not know how much space the materialized view requires, then the <code>DBMS_MVIEW.ESTIMATE_MVIEW_SIZE</code> package can estimate the number of bytes required to store this uncompressed materialized view. This information can then assist the design team in determining the tablespace in which the materialized view should reside.</p>
<p>You should use table compression with highly redundant data, such as tables with many foreign keys. This is particularly useful for materialized views created with the <code>ROLLUP</code> clause. Table compression reduces disk use and memory use (specifically, the buffer cache), often leading to a better scaleup for read-only operations. Table compression can also speed up query execution at the expense of update cost.</p>
<p>Table compression has been extended in this release with Hybrid Columnar Compression. Hybrid Columnar Compression, a feature of certain Oracle storage systems, utilizes a combination of both row and columnar methods for storing data. When data is loaded, groups of rows are stored in columnar format, with the values for a given column stored and compressed together. Storing column data together, with the same data type and similar characteristics, drastically increases the storage savings achieved from compression. Hybrid Columnar Compression provides multiple levels of compression and is best suited for tables or partitions with minimal update activity.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink VLDBG004" href="../../server.112/e25523/part_avail.htm#VLDBG004"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about table compression</p>
</li>
<li>
<p><a class="olink ADMIN11630" href="../../server.112/e25494/tables.htm#ADMIN11630"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about table compression</p>
</li>
<li>
<p><a class="olink SQLRF017" href="../../server.112/e41084/statements_10.htm#SQLRF017"><span class="italic">Oracle Database SQL Language Reference</span></a> for a complete description of <code>STORAGE</code> semantics</p>
</li>
<li>
<p><a class="olink CNCPT" href="../e40540/toc.htm"></a><span class="italic">Oracle Database Concepts</span> for more information about Hybrid Columnar Compression</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="DWHSG8191"></a>
<div class="sect2"><a id="sthref208"></a>
<h3 class="sect2">Build Methods</h3>
<p><a id="sthref209"></a><a id="sthref210"></a>Two build methods are available for creating the materialized view, as shown in <a href="#g1014320">Table 9-3</a>. If you select <code>BUILD</code> <code>IMMEDIATE</code>, the materialized view definition is added to the schema objects in the data dictionary, and then the fact or detail tables are scanned according to the <code>SELECT</code> expression and the results are stored in the materialized view. Depending on the size of the tables to be scanned, this build process can take a considerable amount of time.</p>
<p>An alternative approach is to use the <code>BUILD</code> <code>DEFERRED</code> clause, which creates the materialized view without data, thereby enabling it to be populated at a later date using the <code>DBMS_MVIEW.REFRESH</code> package described in <a href="refresh.htm#g1018554">Chapter 16, "Maintaining the Data Warehouse"</a>.</p>
<div class="tblformal">
<p class="titleintable"><a id="DWHSG8192"></a><a id="sthref211"></a><a id="g1014320"></a>Table 9-3 Build Methods</p>
<table class="cellalignment1381" title="Build Methods" summary="Build Methods" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t6">Build Method</th>
<th class="cellalignment1382" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t6" headers="r1c1-t6">
<p><code>BUILD</code> <code>IMMEDIATE</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t6 r1c2-t6">
<p>Create the materialized view and then populate it with data.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t6" headers="r1c1-t6">
<p><code>BUILD</code> <code>DEFERRED</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t6 r1c2-t6">
<p>Create the materialized view definition but do not populate it with data.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="DWHSG8193"></a>
<div class="sect2"><a id="sthref212"></a>
<h3 class="sect2">Enabling Query Rewrite</h3>
<p>Before <a id="sthref213"></a>creating a materialized view, you can verify what types of query rewrite are possible by calling the procedure <code>DBMS_MVIEW.EXPLAIN_MVIEW</code>, or use <code>DBMS_ADVISOR.TUNE_MVIEW</code> to optimize the materialized view so that many types of query rewrite are possible. Once the materialized view has been created, you can use <code>DBMS_MVIEW.EXPLAIN_REWRITE</code> to find out if (or why not) it will rewrite a specific query.</p>
<p>Even though a materialized view is defined, it will not automatically be used by the query rewrite facility. Even though query rewrite is enabled by default, you also must specify the <code>ENABLE</code> <code>QUERY</code> <code>REWRITE</code> clause if the materialized view is to be considered available for rewriting queries.</p>
<p>If this clause is omitted or specified as <code>DISABLE</code> <code>QUERY</code> <code>REWRITE</code> when the materialized view is created, the materialized view can subsequently be enabled for query rewrite with the <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> statement.</p>
<p>If you define a materialized view as <code>BUILD</code> <code>DEFERRED</code>, it is not eligible for query rewrite until it is populated with data through a complete refresh.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8194"></a>
<div class="sect2"><a id="sthref214"></a>
<h3 class="sect2">Query Rewrite Restrictions</h3>
<p><a id="sthref215"></a><a id="sthref216"></a><a id="sthref217"></a><a id="sthref218"></a>Query rewrite is not possible with all materialized views. If query rewrite is not occurring when expected, <code>DBMS_MVIEW.EXPLAIN_REWRITE</code> can help provide reasons why a specific query is not eligible for rewrite. If this shows that not all types of query rewrite are possible, use the procedure <code>DBMS_ADVISOR.TUNE_MVIEW</code> to see if the materialized view can be defined differently so that query rewrite is possible. Also, check to see if your materialized view satisfies all of the following conditions.</p>
<a id="DWHSG8195"></a>
<div class="sect3"><a id="sthref219"></a>
<h4 class="sect3">Materialized View Restrictions<a id="sthref220"></a></h4>
<p>You should keep in mind the following restrictions:</p>
<ul>
<li>
<p>The defining query of the materialized view cannot contain any non-repeatable expressions (<code>ROWNUM</code>, <code>SYSDATE</code>, non-repeatable PL/SQL functions, and so on).</p>
</li>
<li>
<p>The query cannot contain any references to <code>LONG</code> or <code>LONG</code> <code>RAW</code> datatypes or object <code>REF</code>s.</p>
</li>
<li>
<p>If the materialized view was registered as <code>PREBUILT</code>, the precision of the columns must agree with the precision of the corresponding <code>SELECT</code> expressions unless overridden by the <code>WITH</code> <code>REDUCED</code> <code>PRECISION</code> clause.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="qradv.htm#g1045552">Chapter 19, "Advanced Query Rewrite"</a></p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="DWHSG8196"></a>
<div class="sect3"><a id="sthref221"></a>
<h4 class="sect3">General Query Rewrite Restrictio<a id="sthref222"></a><a id="sthref223"></a>ns</h4>
<p>You should keep in mind the following restrictions:</p>
<ul>
<li>
<p>A query can reference both local and remote tables. Such a query can be rewritten as long as an eligible materialized view referencing the same tables is available locally.</p>
</li>
<li>
<p>Neither the detail tables nor the materialized view can be owned by <code>SYS</code>.</p>
</li>
<li>
<p>If a column or expression is present in the <code>GROUP</code> <code>BY</code> clause of the materialized view, it must also be present in the <code>SELECT</code> list.</p>
</li>
<li>
<p>Aggregate functions must occur only as the outermost part of the expression. That is, aggregates such as <code>AVG(AVG(x))</code> or <code>AVG(x)</code>+ <code>AVG(x)</code> are not allowed.</p>
</li>
<li>
<p><code>CONNECT</code> <code>BY</code> clauses are not allowed.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="qradv.htm#g1045552">Chapter 19, "Advanced Query Rewrite"</a></p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DWHSG8197"></a>
<div class="sect2"><a id="sthref224"></a>
<h3 class="sect2">Refresh Options</h3>
<p><a id="sthref225"></a>When you define a materialized view, you can specify three refresh options: how to refresh, what type of refresh, and can trusted constraints be used. If unspecified, the defaults are assumed as <code>ON</code> <code>DEMAND</code>, <code>FORCE</code>, and <code>ENFORCED</code> constraints respectively.</p>
<p>The two refresh execution modes are <code>ON</code> <code>COMMIT</code> and <code>ON</code> <code>DEMAND</code>. Depending on the materialized view you create, some options may not be available. <a href="#g1014263">Table 9-4</a> describes the refresh modes.</p>
<div class="tblformalwidemax">
<p class="titleintable"><a id="DWHSG8198"></a><a id="sthref226"></a><a id="g1014263"></a>Table 9-4 Refresh Modes</p>
<table class="cellalignment1383" title="Refresh Modes" summary="Refresh Modes" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t9">Refresh Mode</th>
<th class="cellalignment1382" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t9" headers="r1c1-t9">
<p><code>ON COMMIT</code><a id="sthref227"></a></p>
</td>
<td class="cellalignment1378" headers="r2c1-t9 r1c2-t9">
<p>Refresh occurs automatically when a transaction that modified one of the materialized view's detail tables commits. This can be specified as long as the materialized view is fast refreshable (in other words, not complex). The <code>ON</code> <code>COMMIT</code> privilege is necessary to use this mode.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t9" headers="r1c1-t9">
<p><code>ON DEMAND</code><a id="sthref228"></a></p>
</td>
<td class="cellalignment1378" headers="r3c1-t9 r1c2-t9">
<p>Refresh occurs when a user manually executes one of the available refresh procedures contained in the <code>DBMS_MVIEW</code> package (<code>REFRESH</code>, <code>REFRESH_ALL_MVIEWS</code>, <code>REFRESH_DEPENDENT</code>).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p>When a materialized view is maintained using the <code>ON</code> <code>COMMIT</code> method, the time required to complete the commit may be slightly longer than usual. This is because the refresh operation is performed as part of the commit process. Therefore this method may not be suitable if many users are concurrently changing the tables upon which the materialized view is based.</p>
<p>If you anticipate performing insert, update or delete operations on tables referenced by a materialized view concurrently with the refresh of that materialized view, and that materialized view includes joins and aggregation, Oracle recommends you use <code>ON</code> <code>COMMIT</code> fast refresh rather than <code>ON</code> <code>DEMAND</code> fast refresh.</p>
<p>If you think the materialized view did not refresh, check the alert log or trace file.</p>
<p>If a materialized view fails during refresh at <code>COMMIT</code> time, you must explicitly invoke the refresh procedure using the <code>DBMS_MVIEW</code> package after addressing the errors specified in the trace files. Until this is done, the materialized view will no longer be refreshed automatically at commit time.</p>
<p>You can specify how you want your <a id="sthref229"></a>materialized views to be refreshed from the detail tables by selecting one of four options: <code>COMPLETE</code>, <code>FAST</code>, <code>FORCE</code>, and <code>NEVER</code>. <a href="#g1014333">Table 9-5</a> describes the refresh options.</p>
<div class="tblformalwidemax">
<p class="titleintable"><a id="DWHSG8199"></a><a id="sthref230"></a><a id="g1014333"></a>Table 9-5 Refresh Options</p>
<table class="cellalignment1383" title="Refresh Options" summary="Refresh Options" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t10">Refresh Option</th>
<th class="cellalignment1382" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t10" headers="r1c1-t10">
<p><code>COMPLETE<a id="sthref231"></a></code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t10 r1c2-t10">
<p>Refreshes by recalculating the materialized view's defining query.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t10" headers="r1c1-t10">
<p><code>FAST<a id="sthref232"></a></code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t10 r1c2-t10">
<p>Applies incremental changes to refresh the materialized view using the information logged in the materialized view logs, or from a SQL*Loader direct-path or a partition maintenance operation.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t10" headers="r1c1-t10">
<p><code>FORCE<a id="sthref233"></a></code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t10 r1c2-t10">
<p>Applies <code>FAST</code> refresh if possible; otherwise, it applies <code>COMPLETE</code> refresh.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t10" headers="r1c1-t10">
<p><code>NEVER<a id="sthref234"></a></code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t10 r1c2-t10">
<p>Indicates that the materialized view will not be refreshed with refresh mechanisms.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p>Whether the fast refresh option is available depends upon the type of materialized view. You can call the procedure <code>DBMS_MVIEW.EXPLAIN_MVIEW</code> to determine whether fast refresh is possible.</p>
<p>You can also specify if it is acceptable to use trusted constraints and <code>QUERY_REWRITE_INTEGRITY = TRUSTED</code> during refresh. Any nonvalidated <code>RELY</code> constraint is a trusted constraint. For example, nonvalidated foreign key/primary key relationships, functional dependencies defined in dimensions or a materialized view in the <code>UNKNOWN</code> state. If query rewrite is enabled during refresh, these can improve the performance of refresh by enabling more performant query rewrites. Any materialized view that can use <code>TRUSTED</code> constraints for refresh is left in a state of trusted freshness (the <code>UNKNOWN</code> state) after refresh.</p>
<p>This is reflected in the column <code>STALENESS</code> in the view <code>USER_MVIEWS</code>. The column <code>UNKNOWN_TRUSTED_FD</code> in the same view is also set to <code>Y</code>, which means yes.</p>
<p>You can define this property of the materialized view either during create time by specifying <code>REFRESH</code> <code>USING</code> <code>TRUSTED</code> <code>[ENFORCED]</code> <code>CONSTRAINTS</code> or by using <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> DDL.</p>
<div class="tblformalwidemax">
<p class="titleintable"><a id="DWHSG8200"></a><a id="sthref235"></a><a id="sthref236"></a>Table 9-6 Constraints</p>
<table class="cellalignment1383" title="Constraints" summary="Constraints" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t11">Constraints to Use</th>
<th class="cellalignment1382" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t11" headers="r1c1-t11">
<pre>
TRUSTED CONSTRAINTS
</pre></td>
<td class="cellalignment1378" headers="r2c1-t11 r1c2-t11">
<p>Refresh can use trusted constraints and <code>QUERY_REWRITE_INTEGRITY</code> <code>= TRUSTED</code> during refresh.This allows use of non-validated <code>RELY</code> constraints and rewrite against materialized views in <code>UNKNOWN</code> or <code>FRESH</code> state during refresh.</p>
<p>The <code>USING</code> <code>TRUSTED</code> <code>CONSTRAINTS</code> clause enables you to create a materialized view on top of a table that has a non-NULL Virtual Private Database (VPD) policy on it. In this case, ensure that the materialized view behaves correctly. Materialized view results are computed based on the rows and columns filtered by VPD policy. Therefore, you must coordinate the materialized view definition with the VPD policy to ensure the correct results. Without the <code>USING</code> <code>TRUSTED</code> <code>CONSTRAINTS</code> clause, any VPD policy on a base table will prevent a materialized view from being created.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t11" headers="r1c1-t11">
<pre>
ENFORCED CONSTRAINTS
</pre></td>
<td class="cellalignment1378" headers="r3c1-t11 r1c2-t11">
<p>Refresh can use validated constraints and <code>QUERY_REWRITE_INTEGRITY = ENFORCED</code> during refresh. This allows use of only validated, enforced constraints and rewrite against materialized views in <code>FRESH</code> state during refresh.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p>The fast refresh of a materialized view is optimized using the available primary and foreign key constraints on the join columns. This foreign key/primary key optimization can significantly improve refresh performance. For example, for a materialized view that contains a join between a fact table and a dimension table, if only new rows were inserted into the dimension table with no change to the fact table since the last refresh, then there will be nothing to refresh for this materialized view. The reason is that, because of the primary key constraint on the join column(s) of the dimension table and foreign key constraint on the join column(s) of the fact table, the new rows inserted into the dimension table will not join with any fact table rows, thus there is nothing to refresh. Another example of this refresh optimization is when both the fact and dimension tables have inserts since the last refresh. In this case, Oracle Database will only perform a join of delta fact table with the dimension table. Without the foreign key/primary key optimization, two joins during the refresh would be required, a join of delta fact with the dimension table, plus a join of delta dimension with an image of the fact table from before the inserts.</p>
<p>Note that this optimized fast refresh using primary and foreign key constraints on the join columns is available with and without constraint enforcement. In the first case, primary and foreign key constraints are enforced by the Oracle Database. This, however, incurs the cost of constraint maintenance. In the second case, the application guarantees primary and foreign key relationships so the constraints are declared <code>RELY</code> <code>NOVALIDATE</code> and the materialized view is defined with the <code>REFRESH</code> <code>FAST</code> <code>USING</code> <code>TRUSTED</code> <code>CONSTRAINTS</code> option.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more detailed information regarding refresh restrictions</div>
<a id="i1007007"></a><a id="DWHSG8201"></a>
<div class="sect3">
<h4 class="sect3">General Restrictions on <a id="sthref237"></a><a id="sthref238"></a>Fast Refresh</h4>
<p>The defining query of the materialized view is restricted as follows:</p>
<ul>
<li>
<p>The materialized view must not contain references to non-repeating expressions like <code>SYSDATE</code> and <code>ROWNUM</code>.</p>
</li>
<li>
<p>The materialized view must not contain references to <code>RAW</code> or <code>LONG</code> <code>RAW</code> data types.</p>
</li>
<li>
<p>It cannot contain a <code>SELECT</code> list subquery.</p>
</li>
<li>
<p>It cannot contain analytic functions (for example, <code>RANK</code>) in the <code>SELECT</code> clause.</p>
</li>
<li>
<p>It cannot contain a <code>MODEL</code> clause.</p>
</li>
<li>
<p>It cannot contain a <code>HAVING</code> clause with a subquery.</p>
</li>
<li>
<p>It cannot contain nested queries that have <code>ANY</code>, <code>ALL</code>, or <code>NOT</code> <code>EXISTS</code>.</p>
</li>
<li>
<p>It cannot contain a <code>[START WITH &hellip;] CONNECT BY</code> clause.</p>
</li>
<li>
<p>It cannot contain multiple detail tables at different sites.</p>
</li>
<li>
<p><code>ON</code> <code>COMMIT</code> materialized views cannot have remote detail tables.</p>
</li>
<li>
<p>Nested materialized views must have a join or aggregate.</p>
</li>
<li>
<p>Materialized join views and materialized aggregate views with a <code>GROUP</code> <code>BY</code> clause cannot select from an index-organized table.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1007013"></a><a id="DWHSG8202"></a>
<div class="sect3">
<h4 class="sect3">Restrictions on Fast Refresh on Materialized Views with Joins Only</h4>
<p>Defining queries for materialized views with joins only and no aggregates have the following restrictions on fast refresh:</p>
<ul>
<li>
<p>All restrictions from <a href="#i1007007">"General Restrictions on Fast Refresh"</a>.</p>
</li>
<li>
<p>They cannot have <code>GROUP</code> <code>BY</code> clauses or aggregates.</p>
</li>
<li>
<p>Rowids of all the tables in the <code>FROM</code> list must appear in the <code>SELECT</code> list of the query.</p>
</li>
<li>
<p>Materialized view logs must exist with rowids for all the base tables in the <code>FROM</code> list of the query.</p>
</li>
<li>
<p>You cannot create a fast refreshable materialized view from multiple tables with simple joins that include an object type column in the <code>SELECT</code> statement.</p>
</li>
</ul>
<p>Also, the refresh method you choose will not be optimally efficient if:</p>
<ul>
<li>
<p>The defining query uses an outer join that behaves like an inner join. If the defining query contains such a join, consider rewriting the defining query to contain an inner join.</p>
</li>
<li>
<p>The <code>SELECT</code> list of the materialized view contains expressions on columns from multiple tables.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1007028"></a><a id="DWHSG8203"></a>
<div class="sect3">
<h4 class="sect3">Restrictions on Fast Refresh on Materialized Views with Aggregates</h4>
<p>Defining queries for materialized views with aggregates or joins have the following restrictions on fast refresh:</p>
<ul>
<li>
<p>All restrictions from <a href="#i1007007">"General Restrictions on Fast Refresh"</a>.</p>
</li>
</ul>
<p>Fast refresh is supported for both <code>ON</code> <code>COMMIT</code> and <code>ON</code> <code>DEMAND</code> materialized views, however the following restrictions apply:</p>
<ul>
<li>
<p>All tables in the materialized view must have materialized view logs, and the materialized view logs must:</p>
<ul>
<li>
<p>Contain all columns from the table referenced in the materialized view. However, none of these columns in the base table can be encrypted.</p>
</li>
<li>
<p>Specify with <code>ROWID</code> and <code>INCLUDING</code> <code>NEW</code> <code>VALUES</code>.</p>
</li>
<li>
<p>Specify the <code>SEQUENCE</code> clause if the table is expected to have a mix of inserts/direct-loads, deletes, and updates.</p>
</li>
</ul>
</li>
<li>
<p>Only <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>, <code>STDDEV</code>, <code>VARIANCE</code>, <code>MIN</code> and <code>MAX</code> are supported for fast refresh.</p>
</li>
<li>
<p><code>COUNT(*)</code> must be specified.</p>
</li>
<li>
<p>Aggregate functions must occur only as the outermost part of the expression. That is, aggregates such as <code>AVG(AVG(x))</code> or <code>AVG(x)</code>+ <code>AVG(x)</code> are not allowed.</p>
</li>
<li>
<p>For each aggregate such as <code>AVG(expr)</code>, the corresponding <code>COUNT(expr)</code> must be present. Oracle recommends that <code>SUM(expr)</code> be specified. See <a href="#g1014280">Table 9-2</a> for further details.</p>
</li>
<li>
<p>If <code>VARIANCE(expr)</code> or <code>STDDEV(expr</code>) is specified, <code>COUNT(expr)</code> and <code>SUM(expr)</code> must be specified. Oracle recommends that <code>SUM(expr *expr)</code> be specified. See <a href="#g1014280">Table 9-2</a> for further details.</p>
</li>
<li>
<p>The <code>SELECT</code> column in the defining query cannot be a complex expression with columns from multiple base tables. A possible workaround to this is to use a nested materialized view.</p>
</li>
<li>
<p>The <code>SELECT</code> list must contain all <code>GROUP</code> <code>BY</code> columns.</p>
</li>
<li>
<p>If you use a <code>CHAR</code> data type in the filter columns of a materialized view log, the character sets of the master site and the materialized view must be the same.</p>
</li>
<li>
<p>If the materialized view has one of the following, then fast refresh is supported only on conventional DML inserts and direct loads.</p>
<ul>
<li>
<p>Materialized views with <code>MIN</code> or <code>MAX</code> aggregates</p>
</li>
<li>
<p>Materialized views which have <code>SUM(expr)</code> but no <code>COUNT(expr)</code></p>
</li>
<li>
<p>Materialized views without <code>COUNT(*)</code></p>
</li>
</ul>
<p>Such a materialized view is called an insert-only materialized view.</p>
</li>
<li>
<p>A materialized view with <code>MAX</code> or <code>MIN</code> is fast refreshable after delete or mixed DML statements if it does not have a <code>WHERE</code> clause.</p>
</li>
<li>
<p>Materialized views with named views or subqueries in the <code>FROM</code> clause can be fast refreshed provided the views can be completely merged. For information on which views will merge, refer to the <a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.</p>
</li>
<li>
<p>If there are no outer joins, you may have arbitrary selections and joins in the <code>WHERE</code> clause.</p>
</li>
<li>
<p>Materialized aggregate views with outer joins are fast refreshable after conventional DML and direct loads, provided only the outer table has been modified. Also, unique constraints must exist on the join columns of the inner join table. If there are outer joins, all the joins must be connected by <code>AND</code>s and must use the equality (<code>=</code>) operator.</p>
</li>
<li>
<p>For materialized views with <code>CUBE</code>, <code>ROLLUP</code>, grouping sets, or concatenation of them, the following restrictions apply:</p>
<ul>
<li>
<p>The <code>SELECT</code> list should contain grouping distinguisher that can either be a <code>GROUPING_ID</code> function on all <code>GROUP</code> <code>BY</code> expressions or <code>GROUPING</code> functions one for each <code>GROUP</code> <code>BY</code> expression. For example, if the <code>GROUP</code> <code>BY</code> clause of the materialized view is "<code>GROUP</code> <code>BY</code> <code>CUBE(a, b)</code>", then the <code>SELECT</code> list should contain either "<code>GROUPING_ID(a, b)</code>" or "<code>GROUPING(a)</code> <code>AND</code> <code>GROUPING(b)</code>" for the materialized view to be fast refreshable.</p>
</li>
<li>
<p><code>GROUP</code> <code>BY</code> should not result in any duplicate groupings. For example, "<code>GROUP BY a, ROLLUP(a, b)</code>" is not fast refreshable because it results in duplicate groupings "<code>(a), (a, b), AND (a)</code>".</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CACBHGIJ"></a><a id="DWHSG8204"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Restrictions on Fast Refresh on Materialized Views with UNION ALL</h4>
<p>Materialized views with the <code>UNION</code> <code>ALL</code> set operator support the <code>REFRESH</code> <code>FAST</code> option if the following conditions are satisfied:</p>
<ul>
<li>
<p>The defining query must have the <code>UNION</code> <code>ALL</code> operator at the top level.</p>
<p>The <code>UNION</code> <code>ALL</code> operator cannot be embedded inside a subquery, with one exception: The <code>UNION</code> <code>ALL</code> can be in a subquery in the <code>FROM</code> clause provided the defining query is of the form <code>SELECT * FROM</code> (view or subquery with <code>UNION</code> <code>ALL</code>) as in the following example:</p>
<pre>
CREATE VIEW view_with_unionall AS
(SELECT c.rowid crid, c.cust_id, 2 umarker
 FROM customers c WHERE c.cust_last_name = 'Smith'
 UNION ALL
 SELECT c.rowid crid, c.cust_id, 3 umarker
 FROM customers c WHERE c.cust_last_name = 'Jones');

CREATE MATERIALIZED VIEW unionall_inside_view_mv
REFRESH FAST ON DEMAND AS
SELECT * FROM view_with_unionall;
</pre>
<p>Note that the view <code>view_with_unionall</code> satisfies the requirements for fast refresh.</p>
</li>
<li>
<p>Each query block in the <code>UNION</code> <code>ALL</code> query must satisfy the requirements of a fast refreshable materialized view with aggregates or a fast refreshable materialized view with joins.</p>
<p>The appropriate materialized view logs must be created on the tables as required for the corresponding type of fast refreshable materialized view.</p>
<p>Note that the Oracle Database also allows the special case of a single table materialized view with joins only provided the <code>ROWID</code> column has been included in the <code>SELECT</code> list and in the materialized view log. This is shown in the defining query of the view <code>view_with_unionall</code>.</p>
</li>
<li>
<p>The <code>SELECT</code> list of each query must include a <code>UNION</code> <code>ALL</code> marker, and the <code>UNION</code> <code>ALL</code> column must have a distinct constant numeric or string value in each <code>UNION</code> <code>ALL</code> branch. Further, the marker column must appear in the same ordinal position in the <code>SELECT</code> list of each query block. See <a href="qradv.htm#BABEAHIA">"UNION ALL Marker"</a> for more information regarding <code>UNION</code> <code>ALL</code> markers.</p>
</li>
<li>
<p>Some features such as outer joins, insert-only aggregate materialized view queries and remote tables are not supported for materialized views with <code>UNION</code> <code>ALL</code>. Note, however, that materialized views used in replication, which do not contain joins or aggregates, can be fast refreshed when <code>UNION</code> <code>ALL</code> or remote tables are used.</p>
</li>
<li>
<p>The compatibility initialization parameter must be set to 9.2.0 or higher to create a fast refreshable materialized view with <code>UNION</code> <code>ALL</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="DWHSG8205"></a>
<div class="sect3"><a id="sthref239"></a>
<h4 class="sect3">Achieving Refresh Goals</h4>
<p>In addition to the <code>EXPLAIN_MVIEW</code> procedure, which is discussed throughout this chapter, you can use the <code>DBMS_ADVISOR.TUNE_MVIEW</code> procedure to optimize a <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement to achieve <code>REFRESH</code> <code>FAST</code> and <code>ENABLE</code> <code>QUERY</code> <code>REWRITE</code> goals.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8206"></a>
<div class="sect3"><a id="sthref240"></a>
<h4 class="sect3">Refreshing Nested Materialized Views</h4>
<p>A nested materialized view is considered to be fresh as long as its data is synchronized with the data in its detail tables, even if some of its detail tables could be stale materialized views.</p>
<p>You can refresh nested materialized views in two ways: <code>DBMS_MVIEW.REFRESH</code> with the <code>nested</code> flag set to <code>TRUE</code> and <code>REFRESH_DEPENDENT</code> with the <code>nested</code> flag set to <code>TRUE</code> on the base tables. If you use <code>DBMS_MVIEW.REFRESH</code>, the entire materialized view chain is refreshed and the coverage starting from the specified materialized view in top-down fashion. That is, the specified materialized view and all its child materialized views in the dependency hierarchy are refreshed in order. With <code>DBMS_MVIEW.REFRESH_DEPENDENT</code>, the entire chain is refreshed from the bottom up. That is, all the parent materialized views in the dependency hierarchy starting from the specified table are refreshed in order.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8207"></a><a id="sthref241"></a>Example 9-7 Example of Refreshing a Nested Materialized View</p>
<p>The following statement shows an example of refreshing a nested materialized view:</p>
<pre>
DBMS_MVIEW.REFRESH('SALES_MV,COST_MV', nested =&gt; TRUE);
</pre>
<p>This statement will first refresh all child materialized views of <code>sales_mv</code> and <code>cost_mv</code> based on the dependency analysis and then refresh the two specified materialized views.</p>
<p>You can query the <code>STALE_SINCE</code> column in the <code>*_MVIEWS</code> views to find out when a materialized view became stale.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DWHSG8208"></a>
<div class="sect2"><a id="sthref242"></a>
<h3 class="sect2">ORDER BY Clause</h3>
<p><a id="sthref243"></a>An <code>ORDER</code> <code>BY</code> clause is allowed in the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement. It is used only during the initial creation of the materialized view. It is not used during a full refresh or a fast refresh.</p>
<p>To improve the performance of queries against large materialized views, store the rows in the materialized view in the order specified in the <code>ORDER</code> <code>BY</code> clause. This initial ordering provides physical clustering of the data. If indexes are built on the columns by which the materialized view is ordered, accessing the rows of the materialized view using the index often reduces the time for disk I/O due to the physical clustering.</p>
<p>The <code>ORDER</code> <code>BY</code> clause is not considered part of the materialized view definition. As a result, there is no difference in the manner in which Oracle Database detects the various types of materialized views (for example, materialized join views with no aggregates). For the same reason, query rewrite is not affected by the <code>ORDER</code> <code>BY</code> clause. This feature is similar to the <code>CREATE</code> <code>TABLE</code> ... <code>ORDER</code> <code>BY</code> capability.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8209"></a>
<div class="sect2"><a id="sthref244"></a>
<h3 class="sect2">Materialized View Logs</h3>
<p>Materialized view<a id="sthref245"></a><a id="sthref246"></a> logs are required if you want to use fast refresh, with the exception of PCT refresh. That is, if a detail table supports PCT for a materialized view, the materialized view log on that detail table is not required in order to do fast refresh on that materialized view. As a general rule, though, you should create materialized view logs if you want to use fast refresh. Materialized view logs are defined using a <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> <code>LOG</code> statement on the base table that is to be changed. They are not created on the materialized view unless there is another materialized view on top of that materialized view, which is the case with nested materialized views. For fast refresh of materialized views, the definition of the materialized view logs must normally specify the <code>ROWID</code> clause. In addition, for aggregate materialized views, it must also contain every column in the table referenced in the materialized view, the <code>INCLUDING</code> <code>NEW</code> <code>VALUES</code> clause and the <code>SEQUENCE</code> clause. You can typically achieve better fast refresh performance of local materialized views containing aggregates or joins by using a <code>WITH</code> <code>COMMIT</code> <code>SCN</code> clause.</p>
<p>An example of a materialized view log is shown as follows where one is created on the table <code>sales</code>:</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;
</pre>
<p>Alternatively, you could create a commit SCN-based materialized view log as follows:</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID
 (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold),
COMMIT SCN INCLUDING NEW VALUES;
</pre>
<p>Oracle recommends that the keyword <code>SEQUENCE</code> be included in your materialized view log statement unless you are sure that you will never perform a mixed DML operation (a combination of <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> operations on multiple tables). The <code>SEQUENCE</code> column is required in the materialized view log to support fast refresh with a combination of <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements on multiple tables. You can, however, add the <code>SEQUENCE</code> number to the materialized view log after it has been created.</p>
<p>The boundary of a mixed DML operation is determined by whether the materialized view is <code>ON</code> <code>COMMIT</code> or <code>ON</code> <code>DEMAND</code>.</p>
<ul>
<li>
<p>For <code>ON</code> <code>COMMIT</code>, the mixed DML statements occur within the same transaction because the refresh of the materialized view will occur upon commit of this transaction.</p>
</li>
<li>
<p>For <code>ON</code> <code>DEMAND</code>, the mixed DML statements occur between refreshes. The following example of a materialized view log illustrates where one is created on the table <code>sales</code> that includes the <code>SEQUENCE</code> keyword:</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, 
 quantity_sold, amount_sold) INCLUDING NEW VALUES;
</pre></li>
</ul>
<a id="DWHSG8210"></a>
<div class="sect3"><a id="sthref247"></a>
<h4 class="sect3">Using the FORCE Option with Materialized View Logs</h4>
<p>If you specify <code>FORCE</code> and any items specified with the <code>ADD</code> clause have already been specified for the materialized view log, Oracle does not return an error, but silently ignores the existing elements and adds to the materialized view log any items that do not already exist in the log. For example, if you used a filter column such as <code>cust_id</code> and this column already existed, Oracle Database ignores the redundancy and does not return an error.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8211"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref248"></a>
<h4 class="sect3">Materialized View Log Purging</h4>
<p>Purging materialized view logs can be done during the materialized view refresh process or deferred until later, thus improving refresh performance time. You can choose different options for when the purge will occur, using a <code>PURGE</code> clause, as in the following:</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales
PURGE START WITH sysdate NEXT sysdate+1
WITH ROWID
 (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;
</pre>
<p>You can also query <code>USER_MVIEW_LOGS</code> for purge information, as in the following:</p>
<pre>
SELECT PURGE_DEFERRED, PURGE_INTERVAL, LAST_PURGE_DATE, LAST_PURGE_STATUS
FROM USER_MVIEW_LOGS
WHERE LOG_OWNER "SH" AND MASTER = 'SALES';
</pre>
<p>In addition to setting the purge when creating a materialized view log, you can also modify an existing materialized view log by issuing a statement resembling the following:</p>
<pre>
ALTER MATERIALIZED VIEW LOG ON sales PURGE IMMEDIATE;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information regarding materialized view log syntax</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DWHSG8212"></a>
<div class="sect2"><a id="sthref249"></a>
<h3 class="sect2">Using Oracle Enterprise Manager</h3>
<p>A materialized view can also be created using Enterprise Manager by selecting the materialized view object type. There is no difference in the information required if this approach is used.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8213"></a>
<div class="sect2"><a id="sthref250"></a>
<h3 class="sect2">Using Materialized Views with NLS Parameters</h3>
<p>When using certain materialized views, you must ensure that your NLS parameters are the same as when you created the materialized view. Materialized views with this restriction are as follows:</p>
<ul>
<li>
<p>Expressions that may return different values, depending on NLS parameter settings. For example, (<code>date &gt; "01/02/03"</code>) or (<code>rate &lt;= "2.150"</code>) are NLS parameter dependent expressions.</p>
</li>
<li>
<p>Equijoins where one side of the join is character data. The result of this equijoin depends on collation and this can change on a session basis, giving an incorrect result in the case of query rewrite or an inconsistent materialized view after a refresh operation.</p>
</li>
<li>
<p>Expressions that generate internal conversion to character data in the <code>SELECT</code> list of a materialized view, or inside an aggregate of a materialized aggregate view. This restriction does not apply to expressions that involve only numeric data, for example, <code>a+b</code> where <code>a</code> and <code>b</code> are numeric fields.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="DWHSG8214"></a>
<div class="sect2"><a id="sthref251"></a>
<h3 class="sect2">Adding Comments to Materialized Views</h3>
<p>You can add a comment to a materialized view. For example, the following statement adds a comment to data dictionary views for the existing materialized view:</p>
<pre>
COMMENT ON MATERIALIZED VIEW sales_mv IS 'sales materialized view';
</pre>
<p>To view the comment after the preceding statement execution, the user can query the catalog views, <code>{USER</code>, <code>DBA}</code> <code>ALL_MVIEW_COMMENTS</code>. For example, consider the following example:</p>
<pre>
SELECT MVIEW_NAME, COMMENTS
FROM USER_MVIEW_COMMENTS WHERE MVIEW_NAME = 'SALES_MV';
</pre>
<p>The output will resemble the following:</p>
<pre>
MVIEW_NAME                      COMMENTS
-----------      -----------------------
SALES_MV         sales materialized view
</pre>
<p>Note: If the compatibility is set to 10.0.1 or higher, <code>COMMENT</code> <code>ON</code> <code>TABLE</code> will not be allowed for the materialized view container table. The following error message will be thrown if it is issued.</p>
<pre>
ORA-12098: cannot comment on the materialized view.
</pre>
<p>In the case of a prebuilt table, if it has an existing comment, the comment will be inherited by the materialized view after it has been created. The existing comment will be prefixed with <code>'(from table)'</code>. For example, table <code>sales_summary</code> was created to contain sales summary information. An existing comment <code>'Sales summary data'</code> was associated with the table. A materialized view of the same name is created to use the prebuilt table as its container table. After the materialized view creation, the comment becomes <code>'(from table) Sales summary data'</code>.</p>
<p>However, if the prebuilt table, <code>sales_summary</code>, does not have any comment, the following comment is added: <code>'Sales summary data'</code>. Then, if we drop the materialized view, the comment will be passed to the prebuilt table with the comment: <code>'(from materialized view) Sales summary data'</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008170"></a><a id="DWHSG8215"></a>
<div class="sect1">
<h2 class="sect1">Registering Existing Materialized Views</h2>
<p><a id="sthref252"></a>Some data warehouses have implemented materialized views in ordinary user tables. Although this solution provides the performance benefits of materialized views, it does not:</p>
<ul>
<li>
<p>Provide query rewrite to all SQL applications.</p>
</li>
<li>
<p>Enable materialized views defined in one application to be transparently accessed in another application.</p>
</li>
<li>
<p>Generally support fast parallel or fast materialized view refresh.</p>
</li>
</ul>
<p>Because of these limitations, and because existing materialized views can be extremely large and expensive to rebuild, you should register your existing materialized view tables whenever possible. You can register a user-defined materialized view with the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> ... <code>ON</code> <code>PREBUILT</code> <code>TABLE</code> statement. Once registered, the materialized view can be used for query rewrites or maintained by one of the refresh methods, or both.</p>
<p>The contents of the table must reflect the materialization of the defining query at the time you register it as a materialized view, and each column in the defining query must correspond to a column in the table that has a matching datatype. However, you can specify <code>WITH</code> <code>REDUCED</code> <code>PRECISION</code> to allow the precision of columns in the defining query to be different from that of the table columns.</p>
<p>The table and the materialized view must have the same name, but the table retains its identity as a table and can contain columns that are not referenced in the defining query of the materialized view. These extra columns are known as unmanaged columns. If rows are inserted during a refresh operation, each unmanaged column of the row is set to its default value. Therefore, the unmanaged columns cannot have <code>NOT</code> <code>NULL</code> constraints unless they also have default values.</p>
<p>Materialized views based on prebuilt tables are eligible for selection by query rewrite provided the parameter <code>QUERY_REWRITE_INTEGRITY</code> is set to <code>STALE_TOLERATED</code> or <code>TRUSTED</code>. See <a href="qrbasic.htm#g1045551">Chapter 18, "Basic Query Rewrite"</a> for details about integrity levels.</p>
<p><a id="sthref253"></a><a id="sthref254"></a>When you drop a materialized view that was created on a prebuilt table, the table still exists&mdash;only the materialized view is dropped.</p>
<p>The following example illustrates the two steps required to register a user-defined table. First, the table is created, then the materialized view is defined using exactly the same name as the table. This materialized view <code>sum_sales_tab_mv</code> is eligible for use in query rewrite.</p>
<pre>
CREATE TABLE sum_sales_tab
PCTFREE 0  TABLESPACE demo
STORAGE (INITIAL 8M) AS
SELECT s.prod_id, SUM(amount_sold) AS dollar_sales,
       SUM(quantity_sold) AS unit_sales
FROM sales s GROUP BY s.prod_id;

CREATE MATERIALIZED VIEW sum_sales_tab_mv
ON PREBUILT TABLE WITHOUT REDUCED PRECISION
ENABLE QUERY REWRITE AS
SELECT s.prod_id, SUM(amount_sold) AS dollar_sales,
    SUM(quantity_sold) AS unit_sales
FROM sales s GROUP BY s.prod_id;
</pre>
<p>You could have compressed this table to save space. See <a href="#i1006854">"Storage And Table Compression"</a> for details regarding table compression.</p>
<p>In some cases, user-defined materialized views are refreshed on a schedule that is longer than the update cycle. For example, a monthly materialized view might be updated only at the end of each month, and the materialized view values always refer to complete time periods. Reports written directly against these materialized views implicitly select only data that is not in the current (incomplete) time period. If a user-defined materialized view already contains a time dimension:</p>
<ul>
<li>
<p>It should be registered and then fast refreshed each update cycle.</p>
</li>
<li>
<p>You can create a view that selects the complete time period of interest.</p>
</li>
<li>
<p>The reports should be modified to refer to the view instead of referring directly to the user-defined materialized view.</p>
</li>
</ul>
<p>If the user-defined materialized view does not contain a time dimension, then:</p>
<ul>
<li>
<p>Create a new materialized view that does include the time dimension (if possible).</p>
</li>
<li>
<p>The view should aggregate over the time column in the new materialized view.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1012761"></a><a id="DWHSG8216"></a>
<div class="sect1">
<h2 class="sect1">Choosing Indexes for Materialized Views</h2>
<p>The two most common operations on a materialized view are query execution and fast refresh, and each operation has different performance requirements. Query execution might need to access any subset of the materialized view key columns, and might need to join and aggregate over a subset of those columns. Consequently, query execution usually performs best if a single-column bitmap index is defined on each materialized view key column.</p>
<p>In the case of materialized views containing only joins using fast refresh, Oracle recommends that indexes be created on the columns that contain the rowids to improve the performance of the refresh operation.</p>
<p>If a materialized view using aggregates is fast refreshable, then an index appropriate for the fast refresh procedure is created unless <code>USING</code> <code>NO</code> <code>INDEX</code> is specified in the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement.</p>
<p>If the materialized view is partitioned, then, after doing a partition maintenance operation on the materialized view, the indexes become unusable, and they need to be rebuilt for fast refresh to work.</p>
<p>See <a class="olink PFGRF008" href="../../server.112/e41573/advisor.htm#PFGRF008"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information on using the SQL Access Advisor to determine what indexes are appropriate for your materialized view.</p>
</div>
<!-- class="sect1" -->
<a id="i1008721"></a><a id="DWHSG8217"></a>
<div class="sect1">
<h2 class="sect1">Dropping Materialized Views</h2>
<p>Use the <code>DROP</code> <code>MATERIALIZED</code> <code>VIEW</code> statement to drop a <a id="sthref255"></a><a id="sthref256"></a>materialized view. For example, consider the following statement:</p>
<pre>
DROP MATERIALIZED VIEW sales_sum_mv;
</pre>
<p>This statement drops the materialized view <code>sales_sum_mv</code>. If the materialized view was prebuilt on a table, then the table is not dropped, but it can no longer be maintained with the refresh mechanism or used by query rewrite. Alternatively, you can drop a materialized view using Oracle Enterprise Manager.</p>
</div>
<!-- class="sect1" -->
<a id="i1008271"></a><a id="DWHSG8218"></a>
<div class="sect1">
<h2 class="sect1">Analyzing Materialized View Capabilities</h2>
<p>You can use the <code>DBMS_MVIEW</code>.<code>EXPLAIN_MVIEW</code> procedure to learn what is possible with a materialized view or potential materialized view. In particular, this procedure enables you to determine:</p>
<ul>
<li>
<p>If a materialized view is fast refreshable</p>
</li>
<li>
<p>What types of query rewrite you can perform with this materialized view</p>
</li>
<li>
<p>Whether PCT refresh is possible</p>
</li>
</ul>
<p>Using this procedure is straightforward. You simply call <code>DBMS_MVIEW.EXPLAIN_MVIEW</code>, passing in as a single parameter the schema and materialized view name for an existing materialized view. Alternatively, you can specify the <code>SELECT</code> string for a potential materialized view or the complete <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement. The materialized view or potential materialized view is then analyzed and the results are written into either a table called <code>MV_CAPABILITIES_TABLE</code>, which is the default, or to an array called <code>MSG_ARRAY</code>.</p>
<p>Note that you must run the <code>utlxmv.sql</code> script prior to calling <code>EXPLAIN_MVIEW</code> except when you are placing the results in <code>MSG_ARRAY</code>. The script is found in the <code>admin</code> directory. It is to create the <code>MV_CAPABILITIES_TABLE</code> in the current schema. An explanation of the various capabilities is in <a href="#g1014360">Table 9-7</a>, and all the possible messages are listed in <a href="#g1014409">Table 9-8</a>.</p>
<a id="DWHSG8219"></a>
<div class="sect2"><a id="sthref257"></a>
<h3 class="sect2">Using the DBMS_MVIEW.EXPLAIN_MVIEW Procedure</h3>
<p>The <code>EXPLAIN_MVIEW</code> proc<a id="sthref258"></a>edure has the following parameters:</p>
<ul>
<li>
<p><code>stmt_id</code></p>
<p>An optional parameter. A client-supplied unique identifier to associate output rows with specific invocations of <code>EXPLAIN_MVIEW</code>.</p>
</li>
<li>
<p><code>mv</code></p>
<p>The name of an existing materialized view or the query definition or the entire <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement of a potential materialized view you want to analyze.</p>
</li>
<li>
<p><code>msg-array</code></p>
<p>The PL/SQL <code>VARRAY</code> that receives the output.</p>
</li>
</ul>
<p><code>EXPLAIN_MVIEW</code> analyzes the specified materialized view in terms of its refresh and rewrite capabilities and inserts its results (in the form of multiple rows) into <code>MV_CAPABILITIES_TABLE</code> or <code>MSG_ARRAY</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS027" href="../../appdev.112/e40758/d_mview.htm#ARPLS027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for further information about the <code>DBMS_MVIEW</code> package</div>
<a id="DWHSG8220"></a>
<div class="sect3"><a id="sthref259"></a>
<h4 class="sect3">DBMS_MVIEW.EXPLAIN_MVIEW Declarations</h4>
<p>The following <a id="sthref260"></a>PL/SQL declarations that are made for you in the <code>DBMS_MVIEW</code> package show the order and datatypes of these parameters for explaining an existing materialized view and a potential materialized view with output to a table and to a <code>VARRAY</code>.</p>
<p>Explain an existing or potential materialized view with output to <code>MV_CAPABILITIES_TABLE</code>:</p>
<pre>
DBMS_MVIEW.EXPLAIN_MVIEW (mv           IN VARCHAR2,
                          stmt_id IN VARCHAR2:= NULL);
</pre>
<p>Explain an existing or potential materialized view with output to a <code>VARRAY</code>:</p>
<pre>
DBMS_MVIEW.EXPLAIN_MVIEW (mv          IN VARCHAR2,
                          msg_array   OUT SYS.ExplainMVArrayType);
</pre></div>
<!-- class="sect3" -->
<a id="DWHSG8221"></a>
<div class="sect3"><a id="sthref261"></a>
<h4 class="sect3">Using MV_CAPABILITIES_TABLE</h4>
<p>One of the simplest ways to use <code>DBMS_MVIEW.EXPLAIN_MVIEW</code> is <a id="sthref262"></a>with the <code>MV_CAPABILITIES_TABLE</code>, which has the following structure:</p>
<pre>
CREATE TABLE MV_CAPABILITIES_TABLE 
(STATEMENT_ID      VARCHAR(30),   -- Client-supplied unique statement identifier
 MVOWNER           VARCHAR(30),   -- NULL for SELECT based EXPLAIN_MVIEW
 MVNAME            VARCHAR(30),   -- NULL for SELECT based EXPLAIN_MVIEW
 CAPABILITY_NAME   VARCHAR(30),   -- A descriptive name of the particular
                                  -- capability:
                                  -- REWRITE
                                  --   Can do at least full text match
                                  --   rewrite
                                  -- REWRITE_PARTIAL_TEXT_MATCH
                                  --   Can do at leat full and partial
                                  --   text match rewrite
                                  -- REWRITE_GENERAL
                                  --   Can do all forms of rewrite
                                  -- REFRESH
                                  --   Can do at least complete refresh
                                  -- REFRESH_FROM_LOG_AFTER_INSERT
                                  --   Can do fast refresh from an mv log
                                  --   or change capture table at least
                                  --   when update operations are
                                  --   restricted to INSERT
                                  -- REFRESH_FROM_LOG_AFTER_ANY
                                  --   can do fast refresh from an mv log
                                  --   or change capture table after any
                                  --   combination of updates
                                  -- PCT
                                  --   Can do Enhanced Update Tracking on
                                  --   the table named in the RELATED_NAME
                                  --   column.  EUT is needed for fast
                                  --   refresh after partitioned
                                  --   maintenance operations on the table
                                  --   named in the RELATED_NAME column
                                  --   and to do non-stale tolerated
                                  --   rewrite when the mv is partially
                                  --   stale with respect to the table
                                  --   named in the RELATED_NAME column.
                                  --   EUT can also sometimes enable fast
                                  --   refresh of updates to the table
                                  --   named in the RELATED_NAME column
                                  --   when fast refresh from an mv log
                                  --   or change capture table is not
                                  --   possible.
                                  -- See <a href="#g1014360">Table 9-7</a>
 POSSIBLE          CHARACTER(1),  -- T = capability is possible
                                  -- F = capability is not possible
 RELATED_TEXT      VARCHAR(2000), -- Owner.table.column, alias name, and so on
                                  -- related to this message. The specific 
                                  -- meaning of this column depends on the 
                                  -- NSGNO column. See the documentation for
                                  -- DBMS_MVIEW.EXPLAIN_MVIEW() for details.
 RELATED_NUM       NUMBER,        -- When there is a numeric value 
                                  -- associated with a row, it goes here.
 MSGNO             INTEGER,       -- When available, QSM message # explaining
                                  -- why disabled or more details when
                                  -- enabled.
 MSGTXT            VARCHAR(2000), -- Text associated with MSGNO.
 SEQ               NUMBER);       -- Useful in ORDER BY clause when 
                                  -- selecting from this table.
</pre>
<p>You can use the <code>utlxmv.sql</code> script found in the <code>admin</code> directory to create <code>MV_CAPABILITIES_TABLE</code>.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8222"></a><a id="sthref263"></a>Example 9-8 DBMS_MVIEW.EXPLAIN_MVIEW</p>
<p>First, create the materialized view. Alternatively, you can use <code>EXPLAIN_MVIEW</code> on a potential materialized view using its <code>SELECT</code> statement or the complete <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement.</p>
<pre>
CREATE MATERIALIZED VIEW cal_month_sales_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS
SELECT t.calendar_month_desc,  SUM(s.amount_sold) AS dollars
FROM sales s,  times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
</pre>
<p>Then, you invoke <code>EXPLAIN_MVIEW</code> with the materialized view to explain. You need to use the <code>SEQ</code> column in an <code>ORDER</code> <code>BY</code> clause so the rows will display in a logical order. If a capability is not possible, <code>N</code> will appear in the <code>P</code> column and an explanation in the <code>MSGTXT</code> column. If a capability is not possible for multiple reasons, a row is displayed for each reason.</p>
<pre>
EXECUTE DBMS_MVIEW.EXPLAIN_MVIEW ('SH.CAL_MONTH_SALES_MV');

SELECT capability_name,  possible, SUBSTR(related_text,1,8)
  AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
FROM MV_CAPABILITIES_TABLE
ORDER BY seq;

</pre>
<pre>
CAPABILITY_NAME                 P    REL_TEXT     MSGTXT
---------------                 -    --------     ------
PCT                             N
REFRESH_COMPLETE                Y
REFRESH_FAST                    N
REWRITE                         Y 
PCT_TABLE                       N    SALES        no partition key or PMARKER in select list  
PCT_TABLE                       N    TIMES        relation is not a partitioned table 
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log must have new values  
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log must have ROWID 
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log does not have all necessary columns  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log must have new values  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log must have ROWID  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log does not have all necessary columns 
REFRESH_FAST_AFTER_ONETAB_DML   N    DOLLARS      SUM(expr) without COUNT(expr) 
REFRESH_FAST_AFTER_ONETAB_DML   N                 see the reason why
                                                  REFRESH_FAST_AFTER_INSERT is disabled
REFRESH_FAST_AFTER_ONETAB_DML   N                 COUNT(*) is not present in the select list 
REFRESH_FAST_AFTER_ONETAB_DML   N                 SUM(expr) without COUNT(expr)
REFRESH_FAST_AFTER_ANY_DML      N                 see the reason why 
                                                  REFRESH_FAST_AFTER_ONETAB_DML is disabled 
REFRESH_FAST_AFTER_ANY_DML      N    SH.TIMES     mv log must have sequence
REFRESH_FAST_AFTER_ANY_DML      N    SH.SALES     mv log must have sequence
REFRESH_PCT                     N                 PCT is not possible on any of the detail
                                                  tables in the materialized view
REWRITE_FULL_TEXT_MATCH         Y      
REWRITE_PARTIAL_TEXT_MATCH      Y  
REWRITE_GENERAL                 Y   
REWRITE_PCT                     N                 PCT is not possible on any detail tables
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="refresh.htm#g1018554">Chapter 16, "Maintaining the Data Warehouse"</a> for further details about PCT</p>
</li>
<li>
<p><a href="qradv.htm#g1045552">Chapter 19, "Advanced Query Rewrite"</a> for further details about PCT</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="DWHSG8223"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref264"></a>
<h4 class="sect3">MV_CAPABILITIES_TABLE.CAPABILITY_NAME Details</h4>
<p><a href="#g1014360">Table 9-7</a> lists explanations for values in the <code>CAPABILITY_NAME</code> column.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="DWHSG8224"></a><a id="sthref265"></a><a id="g1014360"></a>Table 9-7 CAPABILITY_NAME Column Details</p>
<table class="cellalignment1383" title="CAPABILITY_NAME Column Details" summary="CAPABILITY_NAME Column Details" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t16">CAPABILITY_NAME</th>
<th class="cellalignment1382" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t16" headers="r1c1-t16">
<p><code>PCT</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t16 r1c2-t16">
<p>If this capability is possible, Partition Change Tracking (PCT) is possible on at least one detail relation. If this capability is not possible, PCT is not possible with any detail relation referenced by the materialized view.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t16" headers="r1c1-t16">
<p><code>REFRESH_COMPLETE</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t16 r1c2-t16">
<p>If this capability is possible, complete refresh of the materialized view is possible.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t16" headers="r1c1-t16">
<p><code>REFRESH_FAST</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t16 r1c2-t16">
<p>If this capability is possible, fast refresh is possible at least under certain circumstances.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t16" headers="r1c1-t16">
<p><code>REWRITE</code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t16 r1c2-t16">
<p>If this capability is possible, at least full text match query rewrite is possible. If this capability is not possible, no form of query rewrite is possible.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r6c1-t16" headers="r1c1-t16">
<p><code>PCT_TABLE</code></p>
</td>
<td class="cellalignment1378" headers="r6c1-t16 r1c2-t16">
<p>If this capability is possible, it is possible with respect to a particular partitioned table in the top level <code>FROM</code> list. When possible, PCT applies to the partitioned table named in the <code>RELATED_TEXT</code> column.</p>
<p>PCT is needed to support fast fresh after partition maintenance operations on the table named in the <code>RELATED_TEXT</code> column.</p>
<p>PCT may also support fast refresh with regard to updates to the table named in the <code>RELATED_TEXT</code> column when fast refresh from a materialized view log is not possible.</p>
<p>PCT is also needed to support query rewrite in the presence of partial staleness of the materialized view with regard to the table named in the <code>RELATED_TEXT</code> column.</p>
<p>When disabled, PCT does not apply to the table named in the <code>RELATED_TEXT</code> column. In this case, fast refresh is not possible after partition maintenance operations on the table named in the <code>RELATED_TEXT</code> column. In addition, PCT-based refresh of updates to the table named in the <code>RELATED_TEXT</code> column is not possible. Finally, query rewrite cannot be supported in the presence of partial staleness of the materialized view with regard to the table named in the <code>RELATED_TEXT</code> column.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r7c1-t16" headers="r1c1-t16">
<p><code>PCT_TABLE_REWRITE</code></p>
</td>
<td class="cellalignment1378" headers="r7c1-t16 r1c2-t16">
<p>If this capability is possible, it is possible with respect to a particular partitioned table in the top level <code>FROM</code> list. When possible, PCT applies to the partitioned table named in the <code>RELATED_TEXT</code> column.</p>
<p>This capability is needed to support query rewrite against this materialized view in partial stale state with regard to the table named in the <code>RELATED_TEXT</code> column.</p>
<p>When disabled, query rewrite cannot be supported if this materialized view is in partial stale state with regard to the table named in the <code>RELATED_TEXT</code> column.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r8c1-t16" headers="r1c1-t16">
<p><code>REFRESH_FAST_AFTER_INSERT</code></p>
</td>
<td class="cellalignment1378" headers="r8c1-t16 r1c2-t16">
<p>If this capability is possible, fast refresh from a materialized view log is possible at least in the case where the updates are restricted to <code>INSERT</code> operations; complete refresh is also possible. If this capability is not possible, no form of fast refresh from a materialized view log is possible.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r9c1-t16" headers="r1c1-t16">
<p><code>REFRESH_FAST_AFTER_ONETAB_DML</code></p>
</td>
<td class="cellalignment1378" headers="r9c1-t16 r1c2-t16">
<p>If this capability is possible, fast refresh from a materialized view log is possible regardless of the type of update operation, provided all update operations are performed on a single table. If this capability is not possible, fast refresh from a materialized view log may not be possible when the update operations are performed on multiple tables.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r10c1-t16" headers="r1c1-t16">
<p><code>REFRESH_FAST_AFTER_ANY_DML</code></p>
</td>
<td class="cellalignment1378" headers="r10c1-t16 r1c2-t16">
<p>If this capability is possible, fast refresh from a materialized view log is possible regardless of the type of update operation or the number of tables updated. If this capability is not possible, fast refresh from a materialized view log may not be possible when the update operations (other than <code>INSERT</code>) affect multiple tables.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r11c1-t16" headers="r1c1-t16">
<p><code>REFRESH_FAST_PCT</code></p>
</td>
<td class="cellalignment1378" headers="r11c1-t16 r1c2-t16">
<p>If this capability is possible, fast refresh using PCT is possible. Generally, this means that refresh is possible after partition maintenance operations on those detail tables where PCT is indicated as possible.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r12c1-t16" headers="r1c1-t16">
<p><code>REWRITE_FULL_TEXT_MATCH</code></p>
</td>
<td class="cellalignment1378" headers="r12c1-t16 r1c2-t16">
<p>If this capability is possible, full text match query rewrite is possible. If this capability is not possible, full text match query rewrite is not possible.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r13c1-t16" headers="r1c1-t16">
<p><code>REWRITE_PARTIAL_TEXT_MATCH</code></p>
</td>
<td class="cellalignment1378" headers="r13c1-t16 r1c2-t16">
<p>If this capability is possible, at least full and partial text match query rewrite are possible. If this capability is not possible, at least partial text match query rewrite and general query rewrite are not possible.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r14c1-t16" headers="r1c1-t16">
<p><code>REWRITE_GENERAL</code></p>
</td>
<td class="cellalignment1378" headers="r14c1-t16 r1c2-t16">
<p>If this capability is possible, all query rewrite capabilities are possible, including general query rewrite and full and partial text match query rewrite. If this capability is not possible, at least general query rewrite is not possible.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r15c1-t16" headers="r1c1-t16">
<p><code>REWRITE_PCT</code></p>
</td>
<td class="cellalignment1378" headers="r15c1-t16 r1c2-t16">
<p>If this capability is possible, query rewrite can use a partially stale materialized view even in <code>QUERY_REWRITE_INTEGRITY</code> = <code>ENFORCED</code> or <code>TRUSTED</code> modes. When this capability is not possible, query rewrite can use a partially stale materialized view only in <code>QUERY_REWRITE_INTEGRITY</code> = <code>STALE_TOLERATED</code> mode.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" -->
<a id="DWHSG8225"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref266"></a>
<h4 class="sect3">MV_CAPABILITIES_TABLE Column Details</h4>
<p><a href="#g1014409">Table 9-8</a> lists the semantics for <code>RELATED_TEXT</code> and <code>RELATED_NUM</code> columns.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="DWHSG8226"></a><a id="sthref267"></a><a id="g1014409"></a>Table 9-8 MV_CAPABILITIES_TABLE Column Details</p>
<table class="cellalignment1383" title="MV_CAPABILITIES_TABLE Column Details" summary="MV_CAPABILITIES_TABLE Column Details" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t17">MSGNO</th>
<th class="cellalignment1382" id="r1c2-t17">MSGTXT</th>
<th class="cellalignment1382" id="r1c3-t17">RELATED_NUM</th>
<th class="cellalignment1382" id="r1c4-t17">RELATED_TEXT</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t17" headers="r1c1-t17">
<p><code>NULL</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t17 r1c2-t17">
<p><code>NULL</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r2c1-t17 r1c4-t17">
<p>For PCT capability only: <code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of the table upon which PCT is enabled</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t17" headers="r1c1-t17">
<p>2066</p>
</td>
<td class="cellalignment1378" headers="r3c1-t17 r1c2-t17">
<p>This statement resulted in an Oracle error</p>
</td>
<td class="cellalignment1378" headers="r3c1-t17 r1c3-t17">
<p>Oracle error number that occurred</p>
</td>
<td class="cellalignment1378" headers="r3c1-t17 r1c4-t17">&nbsp;</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t17" headers="r1c1-t17">
<p>2067</p>
</td>
<td class="cellalignment1378" headers="r4c1-t17 r1c2-t17">
<p>No partition key or <code>PMARKER</code> or join dependent expression in <code>SELECT</code> list</p>
</td>
<td class="cellalignment1378" headers="r4c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r4c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t17" headers="r1c1-t17">
<p>2068</p>
</td>
<td class="cellalignment1378" headers="r5c1-t17 r1c2-t17">
<p>Relation is not partitioned</p>
</td>
<td class="cellalignment1378" headers="r5c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r5c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r6c1-t17" headers="r1c1-t17">
<p>2069</p>
</td>
<td class="cellalignment1378" headers="r6c1-t17 r1c2-t17">
<p>PCT not supported with multicolumn partition key</p>
</td>
<td class="cellalignment1378" headers="r6c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r6c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r7c1-t17" headers="r1c1-t17">
<p>2070</p>
</td>
<td class="cellalignment1378" headers="r7c1-t17 r1c2-t17">
<p>PCT not supported with this type of partitioning</p>
</td>
<td class="cellalignment1378" headers="r7c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r7c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r8c1-t17" headers="r1c1-t17">
<p>2071</p>
</td>
<td class="cellalignment1378" headers="r8c1-t17 r1c2-t17">
<p>Internal error: undefined PCT failure code</p>
</td>
<td class="cellalignment1378" headers="r8c1-t17 r1c3-t17">
<p>The unrecognized numeric PCT failure code</p>
</td>
<td class="cellalignment1378" headers="r8c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r9c1-t17" headers="r1c1-t17">
<p>2072</p>
</td>
<td class="cellalignment1378" headers="r9c1-t17 r1c2-t17">
<p>Requirements not satisfied for fast refresh of nested materialized view</p>
</td>
<td class="cellalignment1378" headers="r9c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r9c1-t17 r1c4-t17">&nbsp;</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r10c1-t17" headers="r1c1-t17">
<p>2077</p>
</td>
<td class="cellalignment1378" headers="r10c1-t17 r1c2-t17">
<p>Materialized view log is newer than last full refresh</p>
</td>
<td class="cellalignment1378" headers="r10c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r10c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">table_name</span></code> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r11c1-t17" headers="r1c1-t17">
<p>2078</p>
</td>
<td class="cellalignment1378" headers="r11c1-t17 r1c2-t17">
<p>Materialized view log must have new values</p>
</td>
<td class="cellalignment1378" headers="r11c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r11c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">table_name</span></code> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r12c1-t17" headers="r1c1-t17">
<p>2079</p>
</td>
<td class="cellalignment1378" headers="r12c1-t17 r1c2-t17">
<p>Materialized view log must have <code>ROWID</code></p>
</td>
<td class="cellalignment1378" headers="r12c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r12c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">table_name</span></code> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r13c1-t17" headers="r1c1-t17">
<p>2080</p>
</td>
<td class="cellalignment1378" headers="r13c1-t17 r1c2-t17">
<p>Materialized view log must have primary key</p>
</td>
<td class="cellalignment1378" headers="r13c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r13c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">table_name</span></code> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r14c1-t17" headers="r1c1-t17">
<p>2081</p>
</td>
<td class="cellalignment1378" headers="r14c1-t17 r1c2-t17">
<p>Materialized view log does not have all necessary columns</p>
</td>
<td class="cellalignment1378" headers="r14c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r14c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">table_name</span></code> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r15c1-t17" headers="r1c1-t17">
<p>2082</p>
</td>
<td class="cellalignment1378" headers="r15c1-t17 r1c2-t17">
<p>Problem with materialized view log</p>
</td>
<td class="cellalignment1378" headers="r15c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r15c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">table_name</span></code> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r16c1-t17" headers="r1c1-t17">
<p>2099</p>
</td>
<td class="cellalignment1378" headers="r16c1-t17 r1c2-t17">
<p>Materialized view references a remote table or view in the <code>FROM</code> list</p>
</td>
<td class="cellalignment1378" headers="r16c1-t17 r1c3-t17">
<p>Offset from the <code>SELECT</code> keyword to the table or view in question</p>
</td>
<td class="cellalignment1378" headers="r16c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of the table or view in question</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r17c1-t17" headers="r1c1-t17">
<p>2126</p>
</td>
<td class="cellalignment1378" headers="r17c1-t17 r1c2-t17">
<p>Multiple master sites</p>
</td>
<td class="cellalignment1378" headers="r17c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r17c1-t17 r1c4-t17">
<p>Name of the first different node, or <code>NULL</code> if the first different node is local</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r18c1-t17" headers="r1c1-t17">
<p>2129</p>
</td>
<td class="cellalignment1378" headers="r18c1-t17 r1c2-t17">
<p>Join or filter condition(s) are complex</p>
</td>
<td class="cellalignment1378" headers="r18c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r18c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of the table involved with the join or filter condition (or <code>NULL</code> when not available)</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r19c1-t17" headers="r1c1-t17">
<p>2130</p>
</td>
<td class="cellalignment1378" headers="r19c1-t17 r1c2-t17">
<p>Expression not supported for fast refresh</p>
</td>
<td class="cellalignment1378" headers="r19c1-t17 r1c3-t17">
<p>Offset from the <code>SELECT</code> keyword to the expression in question</p>
</td>
<td class="cellalignment1378" headers="r19c1-t17 r1c4-t17">
<p>The alias name in the <code>SELECT</code> list of the expression in question</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r20c1-t17" headers="r1c1-t17">
<p>2150</p>
</td>
<td class="cellalignment1378" headers="r20c1-t17 r1c2-t17">
<p><code>SELECT</code> lists must be identical across the <code>UNION</code> operator</p>
</td>
<td class="cellalignment1378" headers="r20c1-t17 r1c3-t17">
<p>Offset from the <code>SELECT</code> keyword to the first different select item in the <code>SELECT</code> list</p>
</td>
<td class="cellalignment1378" headers="r20c1-t17 r1c4-t17">
<p>The alias name of the first different select item in the <code>SELECT</code> list</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r21c1-t17" headers="r1c1-t17">
<p>2182</p>
</td>
<td class="cellalignment1378" headers="r21c1-t17 r1c2-t17">
<p>PCT is enabled through a join dependency</p>
</td>
<td class="cellalignment1378" headers="r21c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r21c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which <code>PCT_TABLE_REWRITE</code> is not enabled</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r22c1-t17" headers="r1c1-t17">
<p>2183</p>
</td>
<td class="cellalignment1378" headers="r22c1-t17 r1c2-t17">
<p>Expression to enable PCT not in <code>PARTITION</code> <code>BY</code> of analytic function or model</p>
</td>
<td class="cellalignment1378" headers="r22c1-t17 r1c3-t17">
<p>The unrecognized numeric PCT failure code</p>
</td>
<td class="cellalignment1378" headers="r22c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which PCT is not enabled</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r23c1-t17" headers="r1c1-t17">
<p>2184</p>
</td>
<td class="cellalignment1378" headers="r23c1-t17 r1c2-t17">
<p>Expression to enable PCT cannot be rolled up</p>
</td>
<td class="cellalignment1378" headers="r23c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r23c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which PCT is not enabled</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r24c1-t17" headers="r1c1-t17">
<p>2185</p>
</td>
<td class="cellalignment1378" headers="r24c1-t17 r1c2-t17">
<p>No partition key or <code>PMARKER</code> in the <code>SELECT</code> list</p>
</td>
<td class="cellalignment1378" headers="r24c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r24c1-t17 r1c4-t17">
<p><code>[</code><code><span class="codeinlineitalic">owner</span></code><code>.]</code><code><span class="codeinlineitalic">name</span></code> of relation for which <code>PCT_TABLE_REWRITE</code> is not enabled</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r25c1-t17" headers="r1c1-t17">
<p>2186</p>
</td>
<td class="cellalignment1378" headers="r25c1-t17 r1c2-t17">
<p><code>GROUP</code> <code>OUTER</code> <code>JOIN</code> is present</p>
</td>
<td class="cellalignment1378" headers="r25c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r25c1-t17 r1c4-t17">&nbsp;</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r26c1-t17" headers="r1c1-t17">
<p>2187</p>
</td>
<td class="cellalignment1378" headers="r26c1-t17 r1c2-t17">
<p>Materialized view on external table</p>
</td>
<td class="cellalignment1378" headers="r26c1-t17 r1c3-t17">&nbsp;</td>
<td class="cellalignment1378" headers="r26c1-t17 r1c4-t17">&nbsp;</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1371">
<tr>
<td class="cellalignment1378">
<table class="cellalignment1376">
<tr>
<td class="cellalignment1375"><a href="constra.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1375"><a href="advmv.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1380">
<table class="cellalignment1374">
<tr>
<td class="cellalignment1375"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1375"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1375"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1375"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1375"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1375"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
