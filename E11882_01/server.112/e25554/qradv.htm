<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Advanced Query Rewrite</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 070" />
<meta name="dcterms.created" content="2013-07-04T23:23:20Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Warehousing Guide" />
<meta name="dcterms.identifier" content="E25554-02" />
<meta name="dcterms.isVersionOf" content="DWHSG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="qrbasic.htm" title="Previous" type="text/html" />
<link rel="Next" href="schemas.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25554.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">28/35</span> <!-- End Header --><a id="g1045552"></a><a id="DWHSG080"></a>
<h1 class="chapter"><span class="secnum">19</span> Advanced Query Rewrite</h1>
<p>This chapter discusses advanced query rewrite topics in Oracle, and contains:</p>
<ul>
<li>
<p><a href="#i1006458">How Oracle Rewrites Queries</a></p>
</li>
<li>
<p><a href="#BABFDGFG">Types of Query Rewrite</a></p>
</li>
<li>
<p><a href="#BABJCJEC">Other Query Rewrite Considerations</a></p>
</li>
<li>
<p><a href="#i1010537">Advanced Query Rewrite Using Equivalences</a></p>
</li>
<li>
<p><a href="#BABEAGAB">Creating Result Cache Materialized Views with Equivalences</a></p>
</li>
<li>
<p><a href="#i1007733">Verifying that Query Rewrite has Occurred</a></p>
</li>
<li>
<p><a href="#i1007925">Design Considerations for Improving Query Rewrite Capabilities</a></p>
</li>
</ul>
<a id="i1006458"></a><a id="DWHSG0801"></a>
<div class="sect1">
<h2 class="sect1">How Oracle Rewrites Queries</h2>
<p><a id="sthref882"></a>The optimizer uses a number of different methods to rewrite a query. The first step in determining whether query rewrite is possible is to see if the query satisfies the following prerequisites:</p>
<ul>
<li>
<p>Joins present in the materialized view are present in the SQL.</p>
</li>
<li>
<p>There is sufficient data in the materialized view(s) to answer the query.</p>
</li>
</ul>
<p>After that, it must determine how it will rewrite the query. The simplest case occurs when the result stored in a materialized view exactly matches what is requested by a query. The optimizer makes this type of determination by comparing the text of the query with the text of the materialized view definition. This text match method is most straightforward but the number of queries eligible for this type of query rewrite is minimal.</p>
<p>When the text comparison test fails, the optimizer performs a series of generalized checks based on the joins, selections, grouping, aggregates, and column data fetched. This is accomplished by individually comparing various clauses (<code>SELECT</code>, <code>FROM</code>, <code>WHERE</code>, <code>HAVING</code>, or <code>GROUP</code> <code>BY</code>) of a query with those of a materialized view.</p>
<p>This section discusses the optimizer in more detail, as well as the following types of query rewrite:</p>
<ul>
<li>
<p><a href="#i1018002">Text Match Rewrite</a></p>
</li>
<li>
<p><a href="#i1018017">General Query Rewrite Methods</a></p>
</li>
</ul>
<a id="DWHSG08011"></a>
<div class="sect2"><a id="sthref883"></a>
<h3 class="sect2">Cost-Based Optimization</h3>
<p>When a query is rewritten, Oracle's cost-based optimizer compares the cost of the rewritten query and original query and chooses the cheaper execution plan.</p>
<p><a id="sthref884"></a>Query rewrite is available with cost-based optimization. Oracle Database optimizes the input query with and without rewrite and selects the least costly alternative. The optimizer rewrites a query by rewriting one or more query blocks, one at a time.</p>
<p>If query rewrite has a choice between several materialized views to rewrite a query block, it selects the ones which can result in reading in the least amount of data. After a materialized view has been selected for a rewrite, the optimizer then tests whether the rewritten query can be rewritten further with other materialized views. This process continues until no further rewrites are possible. Then the rewritten query is optimized and the original query is optimized. The optimizer compares these two optimizations and selects the least costly alternative.</p>
<p>Because optimization is based on cost, it is important to collect statistics both on tables involved in the query and on the tables representing materialized views. Statistics are fundamental measures, such as the number of rows in a table, that are used to calculate the cost of a rewritten query. They are created by using the <code><a id="sthref885"></a><a id="sthref886"></a>DBMS_STATS</code> package.</p>
<p>Queries that contain inline or named views are also candidates for query rewrite. When a query contains a named view, the view name is used to do the matching between a materialized view and the query. When a query contains an inline view, the inline view can be merged into the query before matching between a materialized view and the query occurs.</p>
<p><a href="#i1006234">Figure 19-1</a> presents a graphical view of the cost-based approach used during the rewrite process.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006234"></a><a id="DWHSG8499"></a>Figure 19-1 The Query Rewrite Process</p>
<img width="281" height="473" src="./dwhsg017.gif" alt="Description of Figure 19-1 follows" /><br />
<a id="sthref887" href="./img_text/dwhsg017.htm">Description of "Figure 19-1 The Query Rewrite Process"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="i1018017"></a><a id="DWHSG08012"></a>
<div class="sect2">
<h3 class="sect2">General Query Rewrite Methods</h3>
<p>The optimizer has a number of different types of query rewrite methods that it can choose from to answer a query. When text match rewrite is not possible, this group of rewrite methods is known as general query rewrite. The advantage of using these more advanced techniques is that one or more materialized views can be used to answer a number of different queries and the query does not always have to match the materialized view exactly for query rewrite to occur.</p>
<p>When using general query rewrite methods, the optimizer uses data relationships on which it can depend, such as primary and foreign key constraints and dimension objects. For example, primary key and foreign key relationships tell the optimizer that each row in the foreign key table joins with at most one row in the primary key table. Furthermore, if there is a <code>NOT</code> <code>NULL</code> constraint on the foreign key, it indicates that each row in the foreign key table must join to exactly one row in the primary key table. A dimension object describes the relationship between, say, day, months, and year, which can be used to roll up data from the day to the month level.</p>
<p>Data relationships such as these are very important for query rewrite because they tell what type of result is produced by joins, grouping, or aggregation of data. Therefore, to maximize the rewritability of a large set of queries when such data relationships exist in a database, you should declare constraints and dimensions.</p>
<a id="CHDIHACH"></a><a id="DWHSG8500"></a>
<div class="sect3">
<h4 class="sect3">When are Constraints and Dimensions Needed?</h4>
<p><a href="#g1021681">Table 19-1</a> illustrates when dimensions and constraints are required for different types of query rewrite. These types of query rewrite are described throughout this chapter.</p>
<div class="tblformalmax">
<p class="titleintable"><a id="DWHSG8501"></a><a id="sthref888"></a><a id="g1021681"></a>Table 19-1 Dimension and Constraint Requirements for Query Rewrite</p>
<table class="cellalignment1383" title="Dimension and Constraint Requirements for Query Rewrite" summary="Dimension and Constraint Requirements for Query Rewrite" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t2">Query Rewrite Types</th>
<th class="cellalignment1382" id="r1c2-t2">Dimensions</th>
<th class="cellalignment1382" id="r1c3-t2">Primary Key/Foreign Key/Not Null Constraints</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t2" headers="r1c1-t2">
<p>Matching SQL Text</p>
</td>
<td class="cellalignment1378" headers="r2c1-t2 r1c2-t2">
<p>Not Required</p>
</td>
<td class="cellalignment1378" headers="r2c1-t2 r1c3-t2">
<p>Not Required</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t2" headers="r1c1-t2">
<p>Join Back</p>
</td>
<td class="cellalignment1378" headers="r3c1-t2 r1c2-t2">
<p>Required OR</p>
</td>
<td class="cellalignment1378" headers="r3c1-t2 r1c3-t2">
<p>Required</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t2" headers="r1c1-t2">
<p>Aggregate Computability</p>
</td>
<td class="cellalignment1378" headers="r4c1-t2 r1c2-t2">
<p>Not Required</p>
</td>
<td class="cellalignment1378" headers="r4c1-t2 r1c3-t2">
<p>Not Required</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t2" headers="r1c1-t2">
<p>Aggregate Rollup</p>
</td>
<td class="cellalignment1378" headers="r5c1-t2 r1c2-t2">
<p>Not Required</p>
</td>
<td class="cellalignment1378" headers="r5c1-t2 r1c3-t2">
<p>Not Required</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r6c1-t2" headers="r1c1-t2">
<p>Rollup Using a Dimension</p>
</td>
<td class="cellalignment1378" headers="r6c1-t2 r1c2-t2">
<p>Required</p>
</td>
<td class="cellalignment1378" headers="r6c1-t2 r1c3-t2">
<p>Not Required</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r7c1-t2" headers="r1c1-t2">
<p>Filtering the Data</p>
</td>
<td class="cellalignment1378" headers="r7c1-t2 r1c2-t2">
<p>Not Required</p>
</td>
<td class="cellalignment1378" headers="r7c1-t2 r1c3-t2">
<p>Not Required</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r8c1-t2" headers="r1c1-t2">
<p>PCT Rewrite</p>
</td>
<td class="cellalignment1378" headers="r8c1-t2 r1c2-t2">
<p>Not Required</p>
</td>
<td class="cellalignment1378" headers="r8c1-t2 r1c3-t2">
<p>Not Required</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r9c1-t2" headers="r1c1-t2">
<p>Multiple Materialized Views</p>
</td>
<td class="cellalignment1378" headers="r9c1-t2 r1c2-t2">
<p>Not Required</p>
</td>
<td class="cellalignment1378" headers="r9c1-t2 r1c3-t2">
<p>Not Required</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalmax" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DWHSG08013"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref889"></a>
<h3 class="sect2">Checks Made by Query Rewrite</h3>
<p>For query<a id="sthref890"></a> rewrite to occur, there are a number of checks that the data must pass. These checks are:</p>
<ul>
<li>
<p><a href="#CHDFIAGB">Join Compatibility Check</a></p>
</li>
<li>
<p><a href="#CHDJHEJC">Data Sufficiency Check</a></p>
</li>
<li>
<p><a href="#CHDDFEID">Grouping Compatibility Check</a></p>
</li>
<li>
<p><a href="#CHDIACJH">Aggregate Computability Check</a></p>
</li>
</ul>
<a id="CHDFIAGB"></a><a id="DWHSG8502"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Join Compatibility Check</h4>
<p><a id="sthref891"></a>In this check, the joins in a query are compared against the joins in a materialized view. In general, this comparison results in the classification of joins into three categories:</p>
<ul>
<li>
<p>Common joins that occur in both the query and the materialized view. These joins form the common subgraph.</p>
</li>
<li>
<p>Delta joins that occur in the query but not in the materialized view. These joins form the query delta subgraph.</p>
</li>
<li>
<p>Delta joins that occur in the materialized view but not in the query. These joins form the materialized view delta subgraph.</p>
</li>
</ul>
<p>These can be visualized as shown in <a href="#CHDDIIEJ">Figure 19-2</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDDIIEJ"></a><a id="DWHSG8503"></a>Figure 19-2 Query Rewrite Subgraphs</p>
<img width="472" height="355" src="./dwhsg016.gif" alt="Description of Figure 19-2 follows" /><br />
<a id="sthref892" href="./img_text/dwhsg016.htm">Description of "Figure 19-2 Query Rewrite Subgraphs"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="DWHSG8504"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref893"></a>
<h5 class="sect4">Common Joins</h5>
<p>The <a id="sthref894"></a>common join pairs between the two must be of the same type, or the join in the query must be derivable from the join in the materialized view. For example, if a materialized view contains an outer join of table <code>A</code> with table <code>B</code>, and a query contains an inner join of table <code>A</code> with table <code>B</code>, the result of the inner join can be derived by filtering the antijoin rows from the result of the outer join. For example, consider the following query:</p>
<pre>
SELECT p.prod_name, t.week_ending_day, SUM(s.amount_sold)
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id AND s.prod_id = p.prod_id
AND mv.week_ending_day BETWEEN TO_DATE('01-AUG-1999', 'DD-MON-YYYY')
                          AND TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY p.prod_name, mv.week_ending_day;
</pre>
<p>The common joins between this query and the materialized view <code>join_sales_time_product_mv</code> are:</p>
<pre>
s.time_id = t.time_id AND s.prod_id = p.prod_id
 
</pre>
<p>They match exactly and the query can be rewritten as follows:</p>
<pre>
SELECT p.prod_name, mv.week_ending_day, SUM(s.amount_sold)
FROM   join_sales_time_product_mv
WHERE  mv.week_ending_day BETWEEN TO_DATE('01-AUG-1999','DD-MON-YYYY')
                         AND   TO_DATE('10-AUG-1999','DD-MON-YYYY')
GROUP BY mv.prod_name, mv.week_ending_day;
</pre>
<p>The query could also be answered using the <code>join_sales_time_product_oj_mv</code> materialized view where inner joins in the query can be derived from outer joins in the materialized view. The rewritten version (transparently to the user) filters out the antijoin rows. The rewritten query has the following structure:</p>
<pre>
SELECT mv.prod_name, mv.week_ending_day, SUM(mv.amount_sold)
FROM   join_sales_time_product_oj_mv mv
WHERE  mv.week_ending_day BETWEEN TO_DATE('01-AUG-1999','DD-MON-YYYY')
  AND  TO_DATE('10-AUG-1999','DD-MON-YYYY') AND mv.prod_id IS NOT NULL
GROUP BY mv.prod_name, mv.week_ending_day;
</pre>
<p>In general, if you use an outer join in a materialized view containing only joins, you should put in the materialized view either the primary key or the rowid on the right side of the outer join. For example, in the previous example, <code>join_sales_time_product_oj_mv</code>, there is a primary key on both <code>sales</code> and <code>products</code>.</p>
<p>Another example of when a materialized view containing only joins is used is the case of a semijoin rewrites. That is, a query contains either an <code>EXISTS</code> or an <code>IN</code> subquery with a single table. Consider the following query, which reports the products that had sales greater than $1,000:</p>
<pre>
SELECT DISTINCT p.prod_name
FROM products p
WHERE EXISTS (SELECT p.prod_id, SUM(s.amount_sold) FROM sales s
              WHERE p.prod_id=s.prod_id HAVING SUM(s.amount_sold) &gt; 1000)
              GROUP BY p.prod_id);
</pre>
<p>This query could also be represented as:</p>
<pre>
SELECT DISTINCT p.prod_name
FROM products p WHERE p.prod_id IN (SELECT s.prod_id FROM sales s
                    WHERE s.amount_sold &gt; 1000);
</pre>
<p>This query contains a semijoin (<code>s.prod_id = p.prod_id</code>) between the <code>products</code> and the <code>sales</code> table.</p>
<p>This query can be rewritten to use either the <code>join_sales_time_product_mv</code> materialized view, if foreign key constraints are active or <code>join_sales_time_product_oj_mv</code> materialized view, if primary keys are active. Observe that both materialized views contain <code>s.prod_id=p.prod_id</code>, which can be used to derive the semijoin in the query. The query is rewritten with <code>join_sales_time_product_mv</code> as follows:</p>
<pre>
SELECT mv.prod_name
FROM (SELECT DISTINCT mv.prod_name FROM  join_sales_time_product_mv mv
      WHERE mv.amount_sold &gt; 1000);
</pre>
<p>If the materialized view <code>join_sales_time_product_mv</code> is partitioned by <code>time_id</code>, then this query is likely to be more efficient than the original query because the original join between <code>sales</code> and <code>products</code> has been avoided. The query could be rewritten using <code>join_sales_time_product_oj_mv</code> as follows.</p>
<pre>
SELECT mv.prod_name 
FROM (SELECT DISTINCT mv.prod_name FROM join_sales_time_product_oj_mv mv
      WHERE mv.amount_sold &gt; 1000 AND mv.prod_id IS NOT NULL);
</pre>
<p>Rewrites with semi-joins are restricted to materialized views with joins only and are not possible for materialized views with joins and aggregates.</p>
</div>
<!-- class="sect4" -->
<a id="DWHSG8505"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref895"></a>
<h5 class="sect4">Query Delta Joins</h5>
<p>A <span class="bold">query<a id="sthref896"></a></span> <span class="bold">delta</span> <span class="bold">join</span> is a join that appears in the query but not in the materialized view. Any number and type of delta joins in a query are allowed and they are simply retained when the query is rewritten with a materialized view. In order for the retained join to work, the materialized view must contain the joining key. Upon rewrite, the materialized view is joined to the appropriate tables in the query delta. For example, consider the following query:</p>
<pre>
SELECT p.prod_name, t.week_ending_day, c.cust_city, SUM(s.amount_sold)
FROM   sales s, products p, times t, customers c
WHERE  s.time_id=t.time_id AND s.prod_id = p.prod_id
AND    s.cust_id = c.cust_id
GROUP BY p.prod_name, t.week_ending_day, c.cust_city;
</pre>
<p>Using the materialized view <code>join_sales_time_product_mv</code>, common joins are: <code>s.time_id=t.time_id</code> and <code>s.prod_id=p.prod_id</code>. The delta join in the query is <code>s.cust_id=c.cust_id</code>. The rewritten form then joins the <code>join_sales_time_product_mv</code> materialized view with the <code>customers</code> table as follows:</p>
<pre>
SELECT mv.prod_name, mv.week_ending_day, c.cust_city, SUM(mv.amount_sold)
FROM   join_sales_time_product_mv mv, customers c
WHERE  mv.cust_id = c.cust_id
GROUP BY mv.prod_name, mv.week_ending_day, c.cust_city;
</pre></div>
<!-- class="sect4" -->
<a id="DWHSG8506"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref897"></a>
<h5 class="sect4">Materialized View Delta Joins</h5>
<p>A <span class="bold">materialized</span> <span class="bold">view</span> <span class="bold">delta</span> <span class="bold">join</span> is a join that appears in the materialized view but not the query. All de<a id="sthref898"></a>lta joins in a materialized view are required to be lossless with respect to the result of common joins. A lossless join guarantees that the result of common joins is not restricted. A <span class="bold">lossless</span> join is one where, if two tables called <code>A</code> and <code>B</code> are joined together, rows in table <code>A</code> will always match with rows in table <code>B</code> and no data will be lost, hence the term lossless join. For example, every row with the foreign key matches a row with a primary key provided no nulls are allowed in the foreign key. Therefore, to guarantee a lossless join, it is necessary to have <code>FOREIGN</code> <code>KEY</code>, <code>PRIMARY</code> <code>KEY</code>, and <code>NOT</code> <code>NULL</code> constraints on appropriate join keys. Alternatively, if the join between tables <code>A</code> and <code>B</code> is an outer join (<code>A</code> being the outer table), it is lossless as it preserves all rows of table <code>A</code>.</p>
<p>All delta joins in a materialized view are required to be non-duplicating with respect to the result of common joins. A non-duplicating join guarantees that the result of common joins is not duplicated. For example, a non-duplicating join is one where, if table <code>A</code> and table <code>B</code> are joined together, rows in table <code>A</code> will match with at most one row in table <code>B</code> and no duplication occurs. To guarantee a non-duplicating join, the key in table <code>B</code> must be constrained to unique values by using a primary key or unique constraint.</p>
<p>Consider the following query that joins <code>sales</code> and <code>times</code>:</p>
<pre>
SELECT t.week_ending_day, SUM(s.amount_sold)
FROM   sales s, times t
WHERE s.time_id = t.time_id AND t.week_ending_day BETWEEN TO_DATE
 ('01-AUG-1999', 'DD-MON-YYYY') AND TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY week_ending_day;
</pre>
<p>The materialized view <code>join_sales_time_product_mv</code> has an additional join (<code>s.prod_id=p.prod_id</code>) between <code>sales</code> and <code>products</code>. This is the delta join in <code>join_sales_time_product_mv</code>. You can rewrite the query if this join is lossless and non-duplicating. This is the case if <code>s.prod_id</code> is a foreign key to <code>p.prod_id</code> and is not null. The query is therefore rewritten as:</p>
<pre>
SELECT week_ending_day, SUM(amount_sold)
FROM   join_sales_time_product_mv
WHERE  week_ending_day BETWEEN TO_DATE('01-AUG-1999', 'DD-MON-YYYY')
                       AND     TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY week_ending_day;
</pre>
<p>The query can also be rewritten with the materialized view <code>join_sales_time_product_mv_oj</code> where foreign key constraints are not needed. This view contains an outer join (<code>s.prod_id=p.prod_id</code>(+)) between <code>sales</code> and <code>products</code>. This makes the join lossless. If <code>p.prod_id</code> is a primary key, then the non-duplicating condition is satisfied as well and optimizer rewrites the query as follows:</p>
<pre>
SELECT week_ending_day, SUM(amount_sold)
FROM   join_sales_time_product_oj_mv
WHERE  week_ending_day BETWEEN TO_DATE('01-AUG-1999', 'DD-MON-YYYY')
  AND  TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY week_ending_day;
</pre>
<p>The query can also be rewritten with the materialized view <code>join_sales_time_product_mv_oj</code> where foreign key constraints are not needed. This view contains an outer join (<code>s.prod_id=p.prod_id</code>(+)) between <code>sales</code> and <code>products</code>. This makes the join lossless. If <code>p.prod_id</code> is a primary key, then the non-duplicating condition is satisfied as well and optimizer rewrites the query as follows:</p>
<pre>
SELECT week_ending_day, SUM(amount_sold)
FROM   join_sales_time_product_oj_mv
WHERE  week_ending_day BETWEEN TO_DATE('01-AUG-1999', 'DD-MON-YYYY')
  AND  TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY week_ending_day;
</pre>
<p>Note that the outer join in the definition of <code>join_sales_time_product_mv_oj</code> is not necessary because the primary key - foreign key relationship between <code>sales</code> and <code>products</code> in the <code>sh</code> schema is already lossless. It is used for demonstration purposes only, and would be necessary if <code>sales.prod_id</code> were nullable, thus violating the losslessness of the join condition <code>sales.prod_id = products.prod_id</code>.</p>
<p>Current limitations restrict most rewrites with outer joins to materialized views with joins only. There is limited support for rewrites with materialized aggregate views with outer joins, so those materialized views should rely on foreign key constraints to assure losslessness of materialized view delta joins.</p>
</div>
<!-- class="sect4" -->
<a id="DWHSG8507"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref899"></a>
<h5 class="sect4">Join Equivalence Recognition</h5>
<p>Query rewrite is able to make many transformations based upon the recognition of equivalent joins. Query rewrite recognizes the following construct as being equivalent to a join:</p>
<pre>
WHERE table1.column1 = F(args)   /* sub-expression A */
AND table2.column2 = F(args)     /* sub-expression B */
</pre>
<p>If <code>F(args)</code> is a PL/SQL function that is declared to be deterministic and the arguments to both invocations of <code>F</code> are the same, then the combination of subexpression <code>A</code> with subexpression <code>B</code> be can be recognized as a join between <code>table1.column1</code> and <code>table2.column2</code>. That is, the following expression is equivalent to the previous expression:</p>
<pre>
WHERE table1.column1 = F(args)          /* sub-expression A */
AND table2.column2 = F(args)            /* sub-expression B */
AND table1.column1 = table2.column2     /* join-expression J */
</pre>
<p>Because join-expression <code>J</code> can be inferred from sub-expression <code>A</code> and subexpression <code>B</code>, the inferred join can be used to match a corresponding join of <code>table1.column1 = table2.column2</code> in a materialized view.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDJHEJC"></a><a id="DWHSG8508"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Data Sufficiency Check</h4>
<p><a id="sthref900"></a>In this check, the optimizer determines if the necessary column data requested by a query can be obtained from a materialized view. For this, the equivalence of one column with another is used. For example, if an inner join between table <code>A</code> and table <code>B</code> is based on a join predicate <code>A.X = B.X</code>, then the data in column <code>A.X</code> equals the data in column <code>B.X</code> in the result of the join. This data property is used to match column <code>A.X</code> in a query with column <code>B.X</code> in a materialized view or vice versa. For example, consider the following query:</p>
<pre>
SELECT p.prod_name, s.time_id, t.week_ending_day, SUM(s.amount_sold)
FROM sales s, products p, times t
WHERE s.time_id=t.time_id AND s.prod_id = p.prod_id
GROUP BY p.prod_name, s.time_id, t.week_ending_day;
</pre>
<p>This query can be answered with <code>join_sales_time_product_mv</code> even though the materialized view does not have <code>s.time_id</code>. Instead, it has <code>t.time_id</code>, which, through a join condition <code>s.time_id=t.time_id</code>, is equivalent to <code>s.time_id</code>. Thus, the optimizer might select the following rewrite:</p>
<pre>
SELECT prod_name, time_id, week_ending_day, SUM(amount_sold)
FROM join_sales_time_product_mv
GROUP BY prod_name, time_id, week_ending_day;
</pre></div>
<!-- class="sect3" -->
<a id="CHDDFEID"></a><a id="DWHSG8509"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Grouping Compatibility Check</h4>
<p><a id="sthref901"></a>This check is required only if both the materialized view and the query contain a <code>GROUP</code> <code>BY</code> clause. The optimizer first determines if the grouping of data requested by a query is exactly the same as the grouping of data stored in a materialized view. In other words, the level of grouping is the same in both the query and the materialized view. If the materialized views groups on all the columns and expressions in the query and also groups on additional columns or expressions, query rewrite can reaggregate the materialized view over the grouping columns and expressions of the query to derive the same result requested by the query.</p>
</div>
<!-- class="sect3" -->
<a id="CHDIACJH"></a><a id="DWHSG8510"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Aggregate Computability Check</h4>
<p><a id="sthref902"></a>This check is required only if both the query and the materialized view contain aggregates. Here the optimizer determines if the aggregates requested by a query can be derived or computed from one or more aggregates stored in a materialized view. For example, if a query requests <code>AVG(X)</code> and a materialized view contains <code>SUM(X)</code> and <code>COUNT(X)</code>, then <code>AVG(X)</code> can be computed as <code>SUM(X)/COUNT(X)</code>.</p>
<p>If the grouping compatibility check determined that the rollup of aggregates stored in a materialized view is required, then the aggregate computability check determines if it is possible to roll up each aggregate requested by the query using aggregates in the materialized view.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DWHSG08014"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref903"></a>
<h3 class="sect2">Query Rewrite Using Dimensions</h3>
<p>This section discusses the following aspects of using dimensions in a rewrite environment:</p>
<ul>
<li>
<p><a href="#BABDGGGB">Benefits of Using Dimensions</a></p>
</li>
<li>
<p><a href="#BABBDDJA">How to Define Dimensions</a></p>
</li>
</ul>
<a id="BABDGGGB"></a><a id="DWHSG8511"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Benefits of Using Dimensions</h4>
<p>A dimension defines a hierarchical (parent/child) relationships between columns, where all the columns do not have to come from the same table.</p>
<p>Dimension definitions increase the possibility of query rewrite because they help to establish functional dependencies between the columns. In addition, dimensions can express intra-table relationships that cannot be expressed by constraints. A dimension definition does not occupy additional storage. Rather, a dimension definition establishes metadata that describes the intra- and inter-dimensional relationships within your schema. Before creating a materialized view, the first step is to review the schema and define the dimensions as this can significantly improve the chances of rewriting a query.</p>
</div>
<!-- class="sect3" -->
<a id="BABBDDJA"></a><a id="DWHSG8512"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">How to Define Dimensions</h4>
<p>For any given schema, dimensions can be created by following the following steps.</p>
<dl>
<dd><a id="sthref904"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Identify all dimensions and dimension tables in the schema.</dt>
<dd>
<p>If the dimensions are normalized, that is, stored in multiple tables, then check that a join between the dimension tables guarantees that each child-side row joins with one and only one parent-side row. In the case of denormalized dimensions, check that the child-side columns uniquely determine the parent-side (or attribute) columns. Failure to abide by these rules may result in incorrect results being returned from queries.</p>
</dd>
</dl>
<dl>
<dd><a id="sthref905"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Identify the hierarchies within each dimension.</dt>
<dd>
<p>As an example, day is a child of month (we can aggregate day level data up to month), and quarter is a child of year.</p>
</dd>
</dl>
<dl>
<dd><a id="sthref906"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Identify the attribute dependencies within each level of the hierarchy.</dt>
<dd>
<p>As an example, identify that <code>calendar_month_name</code> is an attribute of month.</p>
</dd>
</dl>
<dl>
<dd><a id="sthref907"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;Identify joins from the fact table in a data warehouse to each dimension.</dt>
<dd>
<p>Then check that each join can guarantee that each fact row joins with one and only one dimension row. This condition must be declared, and optionally enforced, by adding <code>FOREIGN</code> <code>KEY</code> and <code>NOT</code> <code>NULL</code> constraints on the fact key columns and <code>PRIMARY</code> <code>KEY</code> constraints on the parent-side join keys. If these relationships can be guaranteed by other data handling procedures (for example, your load process), these constraints can be enabled using the <code>NOVALIDATE</code> option to avoid the time required to validate that every row in the table conforms to the constraints. The <code>RELY</code> clause is also required for all nonvalidated constraints to make them eligible for use in query rewrite.</p>
</dd>
</dl>
<p>Example SQL Statement to Create Time Dimension</p>
<pre>
CREATE DIMENSION times_dim
LEVEL day IS TIMES.TIME_ID
LEVEL month IS TIMES.CALENDAR_MONTH_DESC
LEVEL quarter IS TIMES.CALENDAR_QUARTER_DESC
LEVEL year IS TIMES.CALENDAR_YEAR
LEVEL fis_week IS TIMES.WEEK_ENDING_DAY
LEVEL fis_month  IS TIMES.FISCAL_MONTH_DESC
LEVEL fis_quarter IS TIMES.FISCAL_QUARTER_DESC
LEVEL fis_year IS TIMES.FISCAL_YEAR
        HIERARCHY cal_rollup
        (day  CHILD OF month CHILD OF quarter CHILD OF year)
        HIERARCHY fis_rollup    
        (day  CHILD OF fis_week CHILD OF fis_month CHILD OF fis_quarter 
        CHILD OF fis_year)
 
        ATTRIBUTE day DETERMINES
        (day_number_in_week, day_name, day_number_in_month,
         calendar_week_number)
 
        ATTRIBUTE month DETERMINES
        (calendar_month_desc, calendar_month_number, calendar_month_name, 
         days_in_cal_month, end_of_cal_month)
 
        ATTRIBUTE quarter DETERMINES 
        (calendar_quarter_desc, calendar_quarter_number,days_in_cal_quarter,
         end_of_cal_quarter)
 
        ATTRIBUTE year DETERMINES
        (calendar_year,  days_in_cal_year, end_of_cal_year)
 
        ATTRIBUTE fis_week DETERMINES
        (week_ending_day, fiscal_week_number);
</pre>
<p>Remember to set the parameter <code>QUERY_REWRITE_INTEGRITY</code> to <code>TRUSTED</code> or <code>STALE_TOLERATED</code> for query rewrite to take advantage of the relationships declared in dimensions.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFDGFG"></a><a id="DWHSG0802"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Types of Query Rewrite</h2>
<p>Queries that have aggregates that require computations over a large number of rows or joins between very large tables can be expensive and thus can take a long time to return the results. Query rewrite transparently rewrites such queries using materialized views that have pre-computed results, so that the queries can be answered almost instantaneously. These materialized views can be broadly categorized into two groups, namely materialized aggregate views and materialized join views. Materialized aggregate views are tables that have pre-computed aggregate values for columns from original tables. Similarly, materialized join views are tables that have pre-computed joins between columns from original tables. Query rewrite transforms an incoming query to fetch the results from materialized view columns. Because these columns contain already pre-computed results, the incoming query can be answered almost instantaneously. For considerations regarding query rewrite of cube organized materialized views, see <a class="olink OLAUG" href="../../olap.112/e17123/toc.htm"><span class="italic">Oracle OLAP User's Guide</span></a>.</p>
<p>This section discusses the following methods that can be used to rewrite a query:</p>
<ul>
<li>
<p><a href="#i1018002">Text Match Rewrite</a></p>
</li>
<li>
<p><a href="#BABDFBEJ">Join Back</a></p>
</li>
<li>
<p><a href="#BABIIDIB">Aggregate Computability</a></p>
</li>
<li>
<p><a href="#BABDCECJ">Aggregate Rollup</a></p>
</li>
<li>
<p><a href="#BABGGBHE">Rollup Using a Dimension</a></p>
</li>
<li>
<p><a href="#BABICBAF">When Materialized Views Have Only a Subset of Data</a></p>
</li>
<li>
<p><a href="#BABDFEDC">Partition Change Tracking (PCT) Rewrite</a></p>
</li>
<li>
<p><a href="#BABCFHJI">Multiple Materialized Views</a></p>
</li>
</ul>
<a id="i1018002"></a><a id="DWHSG08021"></a>
<div class="sect2">
<h3 class="sect2">Text Match Rewrite</h3>
<p><a id="sthref908"></a>The query rewrite engine always initially tries to compare the text of incoming query with the text of the definition of any potential materialized views to rewrite the query. This is because the overhead of doing a simple text comparison is usually negligible comparing to the cost of doing a complex analysis required for the general rewrite.</p>
<p>The query rewrite engine uses two text match methods, full text match rewrite and partial text match rewrite. In full text match the entire text of a query is compared against the entire text of a materialized view definition (that is, the entire <code>SELECT</code> expression), ignoring the white space during text comparison. For example, assume that we have the following materialized view, <code>sum_sales_pscat_month_city_mv</code>:</p>
<pre>
CREATE MATERIALIZED VIEW sum_sales_pscat_month_city_mv
ENABLE QUERY REWRITE AS
   SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city,
   SUM(s.amount_sold) AS sum_amount_sold,
   COUNT(s.amount_sold) AS count_amount_sold
   FROM sales s, products p, times t, customers c
   WHERE s.time_id=t.time_id
      AND     s.prod_id=p.prod_id
      AND     s.cust_id=c.cust_id
  GROUP BY p.prod_subcategory, t.calendar_month_desc, c.cust_city;
</pre>
<p>Consider the following query:</p>
<pre>
SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold,
       COUNT(s.amount_sold) AS count_amount_sold
       FROM sales s, products p, times t, customers c
       WHERE s.time_id=t.time_id
         AND     s.prod_id=p.prod_id
         AND     s.cust_id=c.cust_id
       GROUP BY p.prod_subcategory, t.calendar_month_desc, c.cust_city;
 
</pre>
<p>This query matches <code>sum_sales_pscat_month_city_mv</code> (white space excluded) and is rewritten as:</p>
<pre>
SELECT mv.prod_subcategory, mv.calendar_month_desc, mv.cust_city,
       mv.sum_amount_sold, mv.count_amount_sold
FROM   sum_sales_pscat_month_city_mv;
</pre>
<p>When full text match fails, the optimizer then attempts a partial text match. In this method, the text starting from the <code>FROM</code> clause of a query is compared against the text starting with the <code>FROM</code> clause of a materialized view definition. Therefore, the following query can be rewritten:</p>
<pre>
SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city,
       AVG(s.amount_sold)
FROM   sales s, products p, times t, customers c
WHERE  s.time_id=t.time_id AND s.prod_id=p.prod_id
AND    s.cust_id=c.cust_id
GROUP BY p.prod_subcategory, t.calendar_month_desc, c.cust_city;
</pre>
<p>This query is rewritten as:</p>
<pre>
SELECT mv.prod_subcategory, mv.calendar_month_desc, mv.cust_city,
       mv.sum_amount_sold/mv.count_amount_sold
FROM   sum_sales_pscat_month_city_mv mv;
</pre>
<p>Note that, under the partial text match rewrite method, the average of sales aggregate required by the query is computed using the sum of sales and count of sales aggregates stored in the materialized view.</p>
<p>When neither text match succeeds, the optimizer uses a general query rewrite method.</p>
<p>Text match rewrite can distinguish contexts where the difference between uppercase and lowercase is significant and where it is not. For example, the following statements are equivalent:</p>
<pre>
SELECT X, 'aBc' FROM Y

Select x, 'aBc' From y
</pre></div>
<!-- class="sect2" -->
<a id="BABDFBEJ"></a><a id="DWHSG08022"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Join Back</h3>
<p>If some column data requested by a query cannot be obtained from a materialized view, the optimizer further determines if it can be obtained based on a data relationship called a functional dependency. When the data in a column can determine data in another column, such a relationship is called a functional dependency or functional determinance. For example, if a table contains a primary key column called <code>prod_id</code> and another column called <code>prod_name</code>, then, given a <code>prod_id</code> value, it is possible to look up the corresponding <code>prod_name</code>. The opposite is not true, which means a <code>prod_name</code> value need not relate to a unique <code>prod_id</code>.</p>
<p>When the column data required by a query is not available from a materialized view, such column data can still be obtained by joining the materialized view back to the table that contains required column data provided the materialized view contains a key that functionally determines the required column data. For example, consider the following query:</p>
<pre>
SELECT p.prod_category, t.week_ending_day, SUM(s.amount_sold)
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id  AND s.prod_id=p.prod_id AND p.prod_category='CD'
GROUP BY p.prod_category, t.week_ending_day;
</pre>
<p>The materialized view <code>sum_sales_prod_week_mv</code> contains <code>p.prod_id</code>, but not <code>p.prod_category</code>. However, you can join <code>sum_sales_prod_week_mv</code> back to <code>products</code> to retrieve <code>prod_category</code> because <code>prod_id</code> functionally determines <code>prod_category</code>. The optimizer rewrites this query using <code>sum_sales_prod_week_mv</code> as follows:</p>
<pre>
SELECT p.prod_category, mv.week_ending_day, SUM(mv.sum_amount_sold)
FROM   sum_sales_prod_week_mv mv, products p
WHERE  mv.prod_id=p.prod_id AND p.prod_category='CD'
GROUP BY p.prod_category, mv.week_ending_day;
</pre>
<p>Here the <code>products</code> table is called a joinback table because it was originally joined in the materialized view but joined again in the rewritten query.</p>
<p>You can declare functional dependency in two ways:</p>
<ul>
<li>
<p>Using the primary key constraint (as shown in the previous example)</p>
</li>
<li>
<p>Using the <code>DETERMINES</code> clause of a dimension</p>
</li>
</ul>
<p>The <code>DETERMINES</code> clause of a dimension definition might be the only way you could declare functional dependency when the column that determines another column cannot be a primary key. For example, the <code>products</code> table is a denormalized dimension table that has columns <code>prod_id</code>, <code>prod_name</code>, and <code>prod_subcategory</code> that functionally determines <code>prod_subcat_desc</code> and <code>prod_category</code> that determines <code>prod_cat_desc</code>.</p>
<p>The first functional dependency can be established by declaring <code>prod_id</code> as the primary key, but not the second functional dependency because the <code>prod_subcategory</code> column contains duplicate values. In this situation, you can use the <code>DETERMINES</code> clause of a dimension to declare the second functional dependency.</p>
<p>The following dimension definition illustrates how functional dependencies are declared:</p>
<pre>
CREATE DIMENSION products_dim 
        LEVEL product           IS (products.prod_id)
        LEVEL subcategory       IS (products.prod_subcategory) 
        LEVEL category          IS (products.prod_category) 
        HIERARCHY prod_rollup (
                product         CHILD OF 
                subcategory     CHILD OF 
                category
        )
        ATTRIBUTE product DETERMINES products.prod_name 
        ATTRIBUTE product DETERMINES products.prod_desc
        ATTRIBUTE subcategory DETERMINES products.prod_subcat_desc
        ATTRIBUTE category DETERMINES products.prod_cat_desc;
</pre>
<p>The hierarchy <code>prod_rollup</code> declares hierarchical relationships that are also <code>1:n</code> functional dependencies. The <code>1:1</code> functional dependencies are declared using the <code>DETERMINES</code> clause, as seen when <code>prod_subcategory</code> functionally determines <code>prod_subcat_desc</code>.</p>
<p>If the following materialized view is created:</p>
<pre>
CREATE MATERIALIZED VIEW sum_sales_pscat_week_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_subcategory, t.week_ending_day,
       SUM(s.amount_sold) AS sum_amount_sole
FROM sales s, products p, times t
WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY p.prod_subcategory, t.week_ending_day;
</pre>
<p>Then consider the following query:</p>
<pre>
SELECT p.prod_subcategory_desc, t.week_ending_day, SUM(s.amount_sold)
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id AND s.prod_id=p.prod_id
AND    p.prod_subcat_desc LIKE '%Men'
GROUP BY p.prod_subcat_desc, t.week_ending_day;
</pre>
<p>This can be rewritten by joining <code>sum_sales_pscat_week_mv</code> to the <code>products</code> table so that <code>prod_subcat_desc</code> is available to evaluate the predicate. However, the join is based on the <code>prod_subcategory</code> column, which is not a primary key in the <code>products</code> table; therefore, it allows duplicates. This is accomplished by using an inline view that selects distinct values and this view is joined to the materialized view as shown in the rewritten query.</p>
<pre>
SELECT iv.prod_subcat_desc, mv.week_ending_day, SUM(mv.sum_amount_sold)
FROM  sum_sales_pscat_week_mv mv, 
     (SELECT DISTINCT prod_subcategory, prod_subcat_desc
      FROM products) iv
WHERE  mv.prod_subcategory=iv.prod_subcategory 
AND iv.prod_subcat_desc LIKE '%Men'
GROUP BY iv.prod_subcat_desc, mv.week_ending_day;
</pre>
<p>This type of rewrite is possible because <code>prod_subcategory</code> functionally determines <code>prod_subcategory_desc</code> as declared in the dimension.</p>
</div>
<!-- class="sect2" -->
<a id="BABIIDIB"></a><a id="DWHSG08023"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Aggregate Computability</h3>
<p>Query rewrite can also occur when the optimizer determines if the aggregates requested by a query can be derived or computed from one or more aggregates stored in a materialized view. For example, if a query requests <code>AVG(X)</code> and a materialized view contains <code>SUM(X)</code> and <code>COUNT(X)</code>, then <code>AVG(X)</code> can be computed as <code>SUM(X)/COUNT(X)</code>.</p>
<p>In addition, if it is determined that the rollup of aggregates stored in a materialized view is required, then, if it is possible, query rewrite also rolls up each aggregate requested by the query using aggregates in the materialized view.</p>
<p>For example, <code>SUM(sales)</code> at the city level can be rolled up to <code>SUM(sales)</code> at the state level by summing all <code>SUM(sales)</code> aggregates in a group with the same state value. However, <code>AVG(sales)</code> cannot be rolled up to a coarser level unless <code>COUNT(sales)</code> or <code>SUM(sales)</code> is also available in the materialized view. Similarly, <code>VARIANCE(sales)</code> or <code>STDDEV(sales)</code> cannot be rolled up unless both <code>COUNT(sales)</code> and <code>SUM(sales)</code> are also available in the materialized view. For example, consider the following query:</p>
<pre>
ALTER TABLE times MODIFY CONSTRAINT time_pk RELY;
ALTER TABLE customers MODIFY CONSTRAINT customers_pk RELY;
ALTER TABLE sales MODIFY CONSTRAINT sales_time_pk RELY;
ALTER TABLE sales MODIFY CONSTRAINT sales_customer_fk RELY;
SELECT  p.prod_subcategory, AVG(s.amount_sold) AS avg_sales
FROM  sales s, products p WHERE s.prod_id = p.prod_id
GROUP BY p.prod_subcategory;
</pre>
<p>This statement can be rewritten with materialized view <code>sum_sales_pscat_month_city_mv</code> provided the join between <code>sales</code> and <code>times</code> and <code>sales</code> and <code>customers</code> are lossless and non-duplicating. Further, the query groups by <code>prod_subcategory</code> whereas the materialized view groups by <code>prod_subcategory</code>, <code>calendar_month_desc</code> and <code>cust_city</code>, which means the aggregates stored in the materialized view have to be rolled up. The optimizer rewrites the query as the following:</p>
<pre>
SELECT mv.prod_subcategory, SUM(mv.sum_amount_sold)/COUNT(mv.count_amount_sold) 
   AS avg_sales
FROM sum_sales_pscat_month_city_mv mv 
GROUP BY mv.prod_subcategory;
</pre>
<p>The argument of an aggregate such as <code>SUM</code> can be an arithmetic expression such as <code>A+B</code>. The optimizer tries to match an aggregate <code>SUM(A+B)</code> in a query with an aggregate <code>SUM(A+B)</code> or <code>SUM(B+A)</code> stored in a materialized view. In other words, expression equivalence is used when matching the argument of an aggregate in a query with the argument of a similar aggregate in a materialized view. To accomplish this, Oracle converts the aggregate argument expression into a canonical form such that two different but equivalent expressions convert into the same canonical form. For example, <code>A*(B-C)</code>, <code>A*B-C*A</code>, <code>(B-C)*A</code>, and <code>-A*C+A*B</code> all convert into the same canonical form and, therefore, they are successfully matched.</p>
</div>
<!-- class="sect2" -->
<a id="BABDCECJ"></a><a id="DWHSG08024"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Aggregate Rollup</h3>
<p>If the grouping of data requested by a query is at a coarser level than the grouping of data stored in a materialized view, the optimizer can still use the materialized view to rewrite the query. For example, the materialized view <code>sum_sales_pscat_week_mv</code> groups by <code>prod_subcategory</code> and <code>week_ending_day</code>. This query groups by <code>prod_subcategory</code>, a coarser grouping granularity:</p>
<pre>
ALTER TABLE times MODIFY CONSTRAINT time_pk RELY;
ALTER TABLE sales MODIFY CONSTRAINT sales_time_fk RELY;
SELECT p.prod_subcategory, SUM(s.amount_sold) AS sum_amount
FROM   sales s, products pWHERE  s.prod_id=p.prod_id 
GROUP BY p.prod_subcategory;
</pre>
<p>Therefore, the optimizer rewrites this query as:</p>
<pre>
SELECT mv.prod_subcategory, SUM(mv.sum_amount_sold)
FROM   sum_sales_pscat_week_mv mv
GROUP BY mv.prod_subcategory;
</pre></div>
<!-- class="sect2" -->
<a id="BABGGBHE"></a><a id="DWHSG08025"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Rollup Using a Dimension</h3>
<p>When reporting is required at different levels in a hierarchy, materialized views do not have to be created at each level in the hierarchy provided dimensions have been defined. This is because query rewrite can use the relationship information in the dimension to roll up the data in the materialized view to the required level in the hierarchy.</p>
<p>In the following example, a query requests data grouped by <code>prod_category</code> while a materialized view stores data grouped by <code>prod_subcategory</code>. If <code>prod_subcategory</code> is a <code>CHILD</code> <code>OF</code> <code>prod_category</code> (see the dimension example earlier), the grouped data stored in the materialized view can be further grouped by <code>prod_category</code> when the query is rewritten. In other words, aggregates at <code>prod_subcategory</code> level (finer granularity) stored in a materialized view can be rolled up into aggregates at <code>prod_category</code> level (coarser granularity).</p>
<p>For example, consider the following query:</p>
<pre>
SELECT p.prod_category, t.week_ending_day, SUM(s.amount_sold) AS sum_amount
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id AND s.prod_id=p.prod_id
GROUP BY p.prod_category, t.week_ending_day;
</pre>
<p>Because <code>prod_subcategory</code> functionally determines <code>prod_category</code>, <code>sum_sales_pscat_week_mv</code> can be used with a joinback to <code>products</code> to retrieve <code>prod_category</code> column data, and then aggregates can be rolled up to <code>prod_category</code> level, as shown in the following:</p>
<pre>
SELECT pv.prod_category, mv.week_ending_day, SUM(mv.sum_amount_sold)
FROM   sum_sales_pscat_week_mv mv,
       (SELECT DISTINCT prod_subcategory, prod_category
        FROM products) pv
WHERE mv.prod_subcategory= pv.prod_subcategory
GROUP BY pv.prod_category, mv.week_ending_day;
</pre></div>
<!-- class="sect2" -->
<a id="BABICBAF"></a><a id="DWHSG8513"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">When Materialized Views Have Only a Subset of Data</h3>
<p>Oracle supports rewriting of queries so that they will use materialized views in which the <code>HAVING</code> or <code>WHERE</code> clause of the materialized view contains a selection of a subset of the data in a table or tables. For example, only those customers who live in New Hampshire. In other words, the <code>WHERE</code> clause in the materialized view will be <code>WHERE state = 'New Hampshire'</code>.</p>
<p>To perform this type of query rewrite, Oracle must determine if the data requested in the query is contained in, or is a subset of, the data stored in the materialized view. The following sections detail the conditions where Oracle can solve this problem and thus rewrite a query to use a materialized view that contains a filtered portion of the data in the detail table.</p>
<p>To determine if query rewrite can occur on filtered data, a selection computability check is performed when both the query and the materialized view contain selections (non-joins) and the check is done on the <code>WHERE</code> as well as the <code>HAVING</code> clause. If the materialized view contains selections and the query does not, then the selection compatibility check fails because the materialized view is more restrictive than the query. If the query has selections and the materialized view does not, then the selection compatibility check is not needed.</p>
<p>A materialized view's <code>WHERE</code> or <code>HAVING</code> clause can contain a join, a selection, or both, and still be used to rewrite a query. Predicate clauses containing expressions, or selecting rows based on the values of particular columns, are examples of non-join predicates.</p>
<a id="DWHSG8514"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref909"></a>
<h4 class="sect3">Query Rewrite Definitions</h4>
<p>Before describing what is possible when query rewrite works with only a subset of the data, the following definitions are useful:</p>
<ul>
<li>
<p><span class="italic">join relop</span></p>
<p>Is one of the following <code>(=, &lt;, &lt;=, &gt;, &gt;=)</code></p>
</li>
<li>
<p><span class="italic">selection relop</span></p>
<p>Is one of the following <code>(=, &lt;, &lt;=, &gt;, &gt;=, !=, [NOT] BETWEEN | IN| LIKE |NULL)</code></p>
</li>
<li>
<p><span class="italic">join predicate</span></p>
<p>Is of the form <code>(</code><span class="italic">column1</span> <span class="italic">join</span> <span class="italic">relop</span> <span class="italic">column2</span><code>)</code>, where columns are from different tables within the same <code>FROM</code> clause in the current query block. So, for example, an outer reference is not possible.</p>
</li>
<li>
<p><span class="italic">selection predicate</span></p>
<p>Is of the form <span class="italic">left-hand-side-expression</span> <span class="italic">relop</span> <span class="italic">right-hand-side-expression</span>. All non-join predicates are selection predicates. The left-hand side usually contains a column and the right-hand side contains the values. For example, <code>color='red'</code> means the left-hand side is <code>color</code> and the right-hand side is <code>'red'</code> and the relational operator is <code>(=)</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="DWHSG8515"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref910"></a>
<h4 class="sect3">Selection Categories</h4>
<p>Selections are categorized into the following cases:</p>
<ul>
<li>
<p>Simple</p>
<p>Simple selections are of the form <span class="italic">expression relop constant</span>.</p>
</li>
<li>
<p>Complex</p>
<p>Complex selections are of the form <span class="italic">expression relop expression</span>.</p>
</li>
<li>
<p>Range</p>
<p>Range selections are of a form such as <code>WHERE (cust_last_name BETWEEN 'abacrombe' AND 'anakin')</code>.</p>
<p>Note that simple selections with relational operators <code>(&lt;,&lt;=,&gt;,&gt;=)</code>are also considered range selections.</p>
</li>
<li>
<p><code>IN</code>-lists</p>
<p>Single and multi-column <code>IN</code>-lists such as <code>WHERE(prod_id) IN (102, 233, ....)</code>.</p>
<p>Note that selections of the form <code>(column1='v1' OR column1='v2' OR column1='v3' OR ....)</code> are treated as a group and classified as an <code>IN</code>-list.</p>
</li>
<li>
<p><code>IS [NOT] NULL</code></p>
</li>
<li>
<p><code>[NOT] LIKE</code></p>
</li>
<li>
<p>Other</p>
<p>Other selections are when it cannot determine the boundaries for the data. For example, <code>EXISTS</code>.</p>
</li>
</ul>
<p>When comparing a selection from the query with a selection from the materialized view, the left-hand side of both selections are compared.</p>
<p>If the left-hand side selections match, then the right-hand side values are checked for containment. That is, the right-hand side values of the query selection must be contained by right-hand side values of the materialized view selection.</p>
<p>You can also use expressions in selection predicates. This process resembles the following:</p>
<pre>
<span class="italic">expression relational operator constant</span>
</pre>
<p>Where <span class="italic">expression</span> can be any arbitrary arithmetic expression allowed by the Oracle Database. The expression in the materialized view and the query must match. Oracle attempts to discern expressions that are logically equivalent, such as <code>A+B</code> and <code>B+A</code>, and always recognizes identical expressions as being equivalent.</p>
<p>You can also use queries with an expression on both sides of the operator or user-defined functions as operators. Query rewrite occurs when the complex predicate in the materialized view and the query are logically equivalent. This means that, unlike exact text match, terms could be in a different order and rewrite can still occur, as long as the expressions are equivalent.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8516"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref911"></a>
<h4 class="sect3">Examples of Query Rewrite Selection</h4>
<p>Here are a number of examples showing how query rewrite can still occur when the data is being filtered.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8517"></a><a id="sthref912"></a>Example 19-1 Single Value Selection</p>
<p>If the query contains the following clause:</p>
<pre>
WHERE prod_id = 102
</pre>
<p>And, if a materialized view contains the following clause:</p>
<pre>
WHERE prod_id BETWEEN 0 AND 200
</pre>
<p>Then, the left-hand side selections match on <code>prod_id</code> and the right-hand side value of the query <code>102</code> is within the range of the materialized view, so query rewrite is possible.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8518"></a><a id="sthref913"></a>Example 19-2 Bounded Range Selection</p>
<p>A selection can be a bounded range (a range with an upper and lower value). For example, if the query contains the following clause:</p>
<pre>
WHERE prod_id &gt; 10 AND prod_id &lt; 50
</pre>
<p>And if a materialized view contains the following clause:</p>
<pre>
WHERE prod_id BETWEEN 0 AND 200
</pre>
<p>Then, the selections are matched on <code>prod_id</code> and the query range is within the materialized view range. In this example, notice that both query selections are based on the same column.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8519"></a><a id="sthref914"></a>Example 19-3 Selection With Expression</p>
<p>If the query contains the following clause:</p>
<pre>
WHERE (sales.amount_sold * .07) BETWEEN 1.00 AND 100.00
</pre>
<p>And if a materialized view contains the following clause:</p>
<pre>
WHERE (sales.amount_sold * .07) BETWEEN 0.0 AND 200.00
</pre>
<p>Then, the selections are matched on <code>(sales.amount_sold *.07)</code> and the right-hand side value of the query is within the range of the materialized view, therefore query rewrite is possible. Complex selections such as this require that the left-hand side and the right-hand side be matched within range of the materialized view.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8520"></a><a id="sthref915"></a>Example 19-4 Exact Match Selections</p>
<p>If the query contains the following clause:</p>
<pre>
WHERE (cost.unit_price * 0.95) &gt; (cost_unit_cost  * 1.25)
</pre>
<p>And if a materialized view contains the following:</p>
<pre>
WHERE (cost.unit_price * 0.95) &gt; (cost_unit_cost  * 1.25)
</pre>
<p>If the left-hand side and the right-hand side match the materialized view and the <span class="italic">selection_relop</span> is the same, then the selection can usually be dropped from the rewritten query. Otherwise, the selection must be kept to filter out extra data from the materialized view.</p>
<p>If query rewrite can drop the selection from the rewritten query, all columns from the selection may not have to be in the materialized view so more rewrites can be done. This ensures that the materialized view data is not more restrictive than the query.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8521"></a><a id="sthref916"></a>Example 19-5 More Selection in the Query</p>
<p>Selections in the query do not have to be matched by any selections in the materialized view but, if they are, then the right-hand side values must be contained by the materialized view. For example, if the query contains the following clause:</p>
<pre>
WHERE prod_name = 'Shorts' AND prod_category = 'Men'
</pre>
<p>And if a materialized view contains the following clause:</p>
<pre>
WHERE prod_category = 'Men'
</pre>
<p>Then, in this example, only selection with <code>prod_category</code> is matched. The query has an extra selection that is not matched but this is acceptable because if the materialized view selects <code>prod_name</code> or selects a column that can be joined back to the detail table to get <code>prod_name</code>, then query rewrite is possible. The only requirement is that query rewrite must have a way of applying the <code>prod_name</code> selection to the materialized view.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8522"></a><a id="sthref917"></a>Example 19-6 No Rewrite Because of Fewer Selections in the Query</p>
<p>If the query contains the following clause:</p>
<pre>
WHERE prod_category = 'Men'
</pre>
<p>And if a materialized view contains the following clause:</p>
<pre>
WHERE prod_name = 'Shorts' AND prod_category = 'Men'
</pre>
<p>Then, the materialized view selection with <code>prod_name</code> is not matched. The materialized view is more restrictive that the query because it only contains the product Shorts, therefore, query rewrite does not occur.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8523"></a><a id="sthref918"></a>Example 19-7 Multi-Column IN-List Selections</p>
<p>Query rewrite also checks for cases where the query has a multi-column <code>IN</code>-list where the columns are fully matched by individual columns from the materialized view single column <code>IN</code>-lists. For example, if the query contains the following:</p>
<pre>
WHERE (prod_id, cust_id) IN ((1022, 1000), (1033, 2000))
</pre>
<p>And if a materialized view contains the following:</p>
<pre>
WHERE prod_id IN (1022,1033) AND cust_id IN (1000, 2000)
</pre>
<p>Then, the materialized view <code>IN</code>-lists are matched by the columns in the query multi-column <code>IN</code>-list. Furthermore, the right-hand side values of the query selection are contained by the materialized view so that rewrite occurs.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8524"></a><a id="sthref919"></a>Example 19-8 Selections Using IN-Lists</p>
<p>Selection compatibility also checks for cases where the materialized view has a multi-column <code>IN</code>-list where the columns are fully matched by individual columns or columns from <code>IN</code>-lists in the query. For example, if the query contains the following:</p>
<pre>
WHERE prod_id = 1022 AND cust_id IN (1000, 2000)
</pre>
<p>And if a materialized view contains the following:</p>
<pre>
WHERE (prod_id, cust_id) IN ((1022, 1000), (1022, 2000))
</pre>
<p>Then, the materialized view <code>IN</code>-list columns are fully matched by the columns in the query selections. Furthermore, the right-hand side values of the query selection are contained by the materialized view. So rewrite succeeds.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="i1016151"></a><a id="DWHSG8525"></a>Example 19-9 Multiple Selections or Expressions</p>
<p>If the query contains the following clause:</p>
<pre>
WHERE (city_population &gt; 15000 AND city_population &lt; 25000 
   AND state_name = 'New Hampshire')
</pre>
<p>And if a materialized view contains the following clause:</p>
<pre>
WHERE (city_population &lt; 5000 AND state_name = 'New York') OR 
   (city_population BETWEEN 10000 AND 50000 AND state_name = 'New Hampshire')
</pre>
<p>Then, the query is said to have a single disjunct (group of selections separated by <code>AND</code>) and the materialized view has two disjuncts separated by <code>OR</code>. The single query disjunct is contained by the second materialized view disjunct so selection compatibility succeeds. It is clear that the materialized view contains more data than needed by the query so the query can be rewritten.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="DWHSG8526"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref920"></a>
<h4 class="sect3">Handling of the HAVING Clause in Query Rewrite</h4>
<p>Query rewrite can also occur when the query specifies a range of values for an aggregate in the <code>HAVING</code> clause, such as <code>SUM(s.amount_sold) BETWEEN 10000 AND 20000</code>, as long as the range specified is within the range specified in the materialized view.</p>
<pre>
CREATE MATERIALIZED VIEW product_sales_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS
SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales
FROM products p, sales s
WHERE p.prod_id = s.prod_id
GROUP BY prod_name
HAVING SUM(s.amount_sold) BETWEEN 5000 AND 50000;
</pre>
<p>Then, a query such as the following could be rewritten:</p>
<pre>
SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales
FROM products p, sales s WHERE p.prod_id = s.prod_id
GROUP BY prod_name
HAVING SUM(s.amount_sold) BETWEEN 10000 AND 20000;
</pre>
<p>This query is rewritten as follows:</p>
<pre>
SELECT mv.prod_name, mv.dollar_sales FROM product_sales_mv mv
WHERE mv.dollar_sales BETWEEN 10000 AND 20000;
</pre></div>
<!-- class="sect3" -->
<a id="DWHSG8527"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref921"></a>
<h4 class="sect3">Query Rewrite When the Materialized View has an IN-List</h4>
<p>You can use query rewrite when the materialized view contains an <code>IN</code>-list. For example, given the following materialized view definition:</p>
<pre>
CREATE MATERIALIZED VIEW popular_promo_sales_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS 
SELECT p.promo_name, SUM(s.amount_sold) AS sum_amount_sold
FROM  promotions p, sales s
WHERE s.promo_id = p.promo_id
AND p.promo_name IN ('coupon', 'premium', 'giveaway')
GROUP BY promo_name;
</pre>
<p>The following query can be rewritten:</p>
<pre>
SELECT p.promo_name, SUM(s.amount_sold)
FROM  promotions p, sales s
WHERE s.promo_id = p.promo_id AND p.promo_name IN ('coupon', 'premium')
GROUP BY p.promo_name;
</pre>
<p>This query is rewritten as follows:</p>
<pre>
SELECT * FROM popular_promo_sales_mv mv
WHERE mv.promo_name IN ('coupon', 'premium');
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDFEDC"></a><a id="DWHSG08026"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Partition Change Tracking (PCT) Rewrite</h3>
<p>PCT rewrite enables the optimizer to accurately rewrite queries with fresh data using materialized views that are only partially fresh. To do so, Oracle Database keeps track of which partitions in the detail tables have been updated. Oracle Database then tracks which rows in the materialized view originate from the affected partitions in the detail tables. The optimizer is then able to use those portions of the materialized view that are known to be fresh. You can check details about freshness with the <code>DBA_MVIEWS</code>, <code>DBA_DETAIL_RELATIONS</code>, and <code>DBA_MVIEW_DETAIL_PARTITION</code> views. See <a href="refresh.htm#CEGGEIFG">"Viewing Partition Freshness"</a> for examples of using these views.</p>
<p>The optimizer uses PCT rewrite in <code>QUERY_REWRITE_INTEGRITY = ENFORCED</code> and <code>TRUSTED</code> modes. The optimizer does not use PCT rewrite in <code>STALE_TOLERATED</code> mode because data freshness is not considered in that mode. Also, for PCT rewrite to occur, a <code>WHERE</code> clause is required.</p>
<p>You can use<a id="sthref922"></a><a id="sthref923"></a> PCT rewrite with partitioning, but hash partitioning is not supported. The following sections discuss aspects of using PCT:</p>
<ul>
<li>
<p><a href="#BABHJHCG">PCT Rewrite Based on Range Partitioned Tables</a></p>
</li>
<li>
<p><a href="#BABFCCAF">PCT Rewrite Based on Range-List Partitioned Tables</a></p>
</li>
<li>
<p><a href="#BABJIHJI">PCT Rewrite Based on List Partitioned Tables</a></p>
</li>
<li>
<p><a href="#BABFJIAJ">PCT Rewrite and PMARKER</a></p>
</li>
<li>
<p><a href="#BABJBEAF">PCT Rewrite Using Rowid as PMARKER</a></p>
</li>
</ul>
<a id="BABHJHCG"></a><a id="DWHSG8528"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">PCT Rewrite Based on Range Partitioned Tables</h4>
<p>The following example illustrates a PCT rewrite example where the materialized view is PCT enabled through partition key and the underlying base table is range partitioned on the time key.</p>
<pre>
CREATE TABLE part_sales_by_time (time_id, prod_id, amount_sold,
       quantity_sold)
  PARTITION BY RANGE (time_id)
  (
    PARTITION old_data
      VALUES LESS THAN (TO_DATE('01-01-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION quarter1
      VALUES LESS THAN (TO_DATE('01-04-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION quarter2
      VALUES LESS THAN (TO_DATE('01-07-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION quarter3
      VALUES LESS THAN (TO_DATE('01-10-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION quarter4
      VALUES LESS THAN (TO_DATE('01-01-2000', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION max_partition
      VALUES LESS THAN (MAXVALUE)
      PCTFREE 0
      STORAGE (INITIAL 8M)
  )
  AS
  SELECT s.time_id, s.prod_id, s.amount_sold, s.quantity_sold
  FROM sales s;
 
</pre>
<p>Then create a materialized view that contains the total number of products sold by date.</p>
<pre>
CREATE MATERIALIZED VIEW  sales_in_1999_mv
  BUILD IMMEDIATE
  REFRESH FORCE ON DEMAND
  ENABLE QUERY REWRITE
  AS
  SELECT s.time_id, s.prod_id, p.prod_name, SUM(quantity_sold)
  FROM part_sales_by_time s, products p
  WHERE p.prod_id = s.prod_id
    AND s.time_id BETWEEN TO_DATE('01-01-1999', 'DD-MM-YYYY')
    AND TO_DATE('31-12-1999', 'DD-MM-YYYY')
  GROUP BY s.time_id, s.prod_id, p.prod_name;
</pre>
<p>Note that the following query will be rewritten with materialized view <code>sales_in_1999_mv</code>:</p>
<pre>
SELECT s.time_id, p.prod_name, SUM(quantity_sold)
  FROM part_sales_by_time s, products p
  WHERE p.prod_id = s.prod_id
    AND s.time_id &lt; TO_DATE(''01-02-1999'', ''DD-MM-YYYY'')
    AND s.time_id &gt;= TO_DATE(''01-01-1999'', ''DD-MM-YYYY'')
  GROUP BY s.time_id, p.prod_name');
</pre>
<p>If we add a row to <code>quarter4</code> in <code>part_sales_by_time</code> as:</p>
<pre>
INSERT INTO part_sales_by_time 
  VALUES (TO_DATE('26-12-1999', 'DD-MM-YYYY'),38920,2500, 20);
 
commit;
</pre>
<p>Then the materialized view <code>sales_in_1999_mv</code> becomes stale. With PCT rewrite, we can rewrite queries that request data from only the fresh portions of the materialized view. Note that since the materialized view <code>sales_in_1999_mv</code> has the <code>time_id</code> in its <code>SELECT</code> and <code>GROUP</code> <code>BY</code> clause, it is PCT enabled so the following query will be rewritten successfully as no data from <code>quarter4</code> is requested.</p>
<pre>
SELECT s.time_id, p.prod_name, SUM(quantity_sold)
  FROM part_sales_by_time s, products p
  WHERE p.prod_id = s.prod_id
  AND s.time_id &lt; TO_DATE(''01-07-1999'', ''DD-MM-YYYY'')
  AND s.time_id &gt;= TO_DATE(''01-03-1999'', ''DD-MM-YYYY'')
  GROUP BY s.time_id, p.prod_name');
</pre>
<p>The following query cannot be rewritten if multiple materialized view rewrite is set to off. Because multiple materialized view rewrite is on by default, the following query is rewritten with materialized view and base tables:</p>
<pre>
SELECT s.time_id, p.prod_name, SUM(quantity_sold)
  FROM part_sales_by_time s, products p
  WHERE p.prod_id = s.prod_id
  AND s.time_id &lt; TO_DATE(''31-10-1999'', ''DD-MM-YYYY'') AND
       s.time_id &gt; TO_DATE(''01-07-1999'', ''DD-MM-YYYY'')
  GROUP BY s.time_id, p.prod_name');
</pre></div>
<!-- class="sect3" -->
<a id="BABFCCAF"></a><a id="DWHSG8529"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">PCT Rewrite Based on Range-List Partitioned Tables</h4>
<p>If the detail table is range-list partitioned, a materialized view that depends on this detail table can support PCT at both the partitioning and subpartitioning levels. If both the partition and subpartition keys are present in the materialized view, PCT can be done at a finer granularity; materialized view refreshes can be done to smaller portions of the materialized view and more queries could be rewritten with a stale materialized view. Alternatively, if only the partition key is present in the materialized view, PCT can be done with courser granularity.</p>
<p>Consider the following range-list partitioned table:</p>
<pre>
CREATE TABLE sales_par_range_list
 (calendar_year, calendar_month_number, day_number_in_month,
  country_name, prod_id, prod_name, quantity_sold, amount_sold)
PARTITION BY RANGE (calendar_month_number)
SUBPARTITION BY LIST (country_name)
 (PARTITION q1 VALUES LESS THAN (4)
 (SUBPARTITION q1_America VALUES
 ('United States of America', 'Argentina'),
   SUBPARTITION q1_Asia VALUES ('Japan', 'India'),
   SUBPARTITION q1_Europe VALUES ('France', 'Spain', 'Ireland')),
   PARTITION q2 VALUES LESS THAN (7)
  (SUBPARTITION q2_America VALUES
   ('United States of America', 'Argentina'),
   SUBPARTITION q2_Asia VALUES ('Japan', 'India'),
   SUBPARTITION q2_Europe VALUES ('France', 'Spain', 'Ireland')),
     PARTITION q3 VALUES LESS THAN (10)
  (SUBPARTITION q3_America VALUES
   ('United States of America', 'Argentina'),
   SUBPARTITION q3_Asia VALUES ('Japan', 'India'),
   SUBPARTITION q3_Europe VALUES ('France', 'Spain', 'Ireland')),
     PARTITION q4 VALUES LESS THAN (13)
  (SUBPARTITION q4_America VALUES
   ('United States of America', 'Argentina'),
   SUBPARTITION q4_Asia VALUES ('Japan', 'India'),
   SUBPARTITION q4_Europe VALUES ('France', 'Spain', 'Ireland')))
  AS SELECT t.calendar_year, t.calendar_month_number,
     t.day_number_in_month, c1.country_name, s.prod_id,
     p.prod_name, s.quantity_sold, s.amount_sold
  FROM times t, countries c1, products p, sales s, customers c2
  WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND
        s.cust_id = c2.cust_id AND c2.country_id = c1.country_id AND
        c1.country_name IN ('United States of America', 'Argentina',
          'Japan', 'India', 'France', 'Spain', 'Ireland');
</pre>
<p>Then consider the following materialized view <code>sum_sales_per_year_month_mv</code>, which has the total amount of products sold each month of each year:</p>
<pre>
CREATE MATERIALIZED VIEW  sum_sales_per_year_month_mv
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.calendar_year, s.calendar_month_number,
         SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_range_list s WHERE s.calendar_year &gt; 1990
GROUP BY s.calendar_year, s.calendar_month_number;
</pre>
<p><code>sales_per_country_mv</code> supports PCT against <code>sales_par_range_list</code> at the range partitioning level as its range partition key <code>calendar_month_number</code> is in its <code>SELECT</code> and <code>GROUP</code> <code>BY</code> list:</p>
<pre>
INSERT INTO sales_par_range_list
   VALUES (2001, 3, 25, 'Spain', 20, 'PROD20',  300,  20.50);
</pre>
<p>This statement inserts a row with <code>calendar_month_number = 3</code> and <code>country_name = 'Spain'</code>. This row is inserted into partition <code>q1</code> subpartition <code>Europe</code>. After this <code>INSERT</code> statement, <code>sum_sales_per_year_month_mv</code> is stale with respect to partition <code>q1</code> of <code>sales_par_range_list</code>. So any incoming query that accesses data from this partition in <code>sales_par_range_list</code> cannot be rewritten, for example, the following statement:</p>
<p>Note that the following query accesses data from partitions <code>q1</code> and <code>q2</code>. Because q1 was updated, the materialized view is stale with respect to <code>q1</code> so PCT rewrite is unavailable.</p>
<pre>
SELECT s.calendar_year, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_range_list s
WHERE s.calendar_year = 2000 
  AND s.calendar_month_number BETWEEN 2 AND 6
GROUP BY s.calendar_year;
</pre>
<p>An example of a statement that does rewrite after the <code>INSERT</code> statement is the following, because it accesses fresh material:</p>
<pre>
SELECT s.calendar_year, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_range_list s
WHERE s.calendar_year = 2000 AND s.calendar_month_number BETWEEN 5 AND 9
GROUP BY s.calendar_year;
</pre>
<p><a href="#CHDFDGCC">Figure 19-3</a> offers a graphical illustration of what is stale and what is fresh.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDFDGCC"></a><a id="DWHSG8530"></a>Figure 19-3 PCT Rewrite and Range-List Partitioning</p>
<img width="618" height="321" src="./dwhsg115.gif" alt="Description of Figure 19-3 follows" /><br />
<a id="sthref924" href="./img_text/dwhsg115.htm">Description of "Figure 19-3 PCT Rewrite and Range-List Partitioning"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="BABJIHJI"></a><a id="DWHSG8531"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">PCT Rewrite Based on List Partitioned Tables</h4>
<p>If the <code>LIST</code> partitioning key is present in the materialized view's <code>SELECT</code> and <code>GROUP</code> <code>BY</code>, then PCT will be supported by the materialized view. Regardless of the supported partitioning type, if the partition marker or rowid of the detail table is present in the materialized view then PCT is supported by the materialized view on that specific detail table.</p>
<pre>
CREATE TABLE sales_par_list
(calendar_year, calendar_month_number, day_number_in_month,
 country_name, prod_id, quantity_sold, amount_sold)
 PARTITION BY LIST (country_name)
 (PARTITION America
      VALUES ('United States of America', 'Argentina'),
  PARTITION Asia
      VALUES ('Japan', 'India'),
  PARTITION Europe
      VALUES ('France', 'Spain', 'Ireland'))
  AS SELECT t.calendar_year, t.calendar_month_number, 
         t.day_number_in_month, c1.country_name, s.prod_id, 
         s.quantity_sold, s.amount_sold
  FROM times t, countries c1, sales s, customers c2
  WHERE s.time_id = t.time_id and s.cust_id = c2.cust_id and 
        c2.country_id = c1.country_id and
        c1.country_name IN ('United States of America', 'Argentina',
       'Japan', 'India', 'France', 'Spain', 'Ireland');
</pre>
<p>If a materialized view is created on the table <code>sales_par_list</code>, which has a list partitioning key, PCT rewrite will use that materialized view for potential rewrites.</p>
<p>To illustrate this feature, the following example creates a materialized view that has the total amounts sold of every product in each country for each year. The view depends on detail tables <code>sales_par_list</code> and <code>products</code>.</p>
<pre>
CREATE MATERIALIZED VIEW sales_per_country_mv
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.calendar_year AS calendar_year, s.country_name AS country_name,
 p.prod_name AS prod_name, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE s.prod_id = p.prod_id AND s.calendar_year &lt;= 2000
GROUP BY s.calendar_year, s.country_name, prod_name;
</pre>
<p><code>sales_per_country_mv</code> supports PCT against <code>sales_par_list</code> as its list partition key <code>country_name</code> is in its <code>SELECT</code> and <code>GROUP</code> <code>BY</code> list. Table <code>products</code> is not partitioned, so <code>sales_per_country_mv</code> does not support PCT against this table.</p>
<p>A query could be rewritten (in <code>ENFORCED</code> or <code>TRUSTED</code> modes) in terms of <code>sales_per_country_mv</code> even if <code>sales_per_country_mv</code> is stale if the incoming query accesses only fresh parts of the materialized view. You can determine which parts of the materialized view are <code>FRESH</code> only if the updated tables are PCT enabled in the materialized view. If non-PCT enabled tables have been updated, then the rewrite is not possible with fresh data from that specific materialized view as you cannot identify the <code>FRESH</code> portions of the materialized view.</p>
<p><code>sales_per_country_mv</code> supports PCT on <code>sales_par_list</code> and does not support PCT on table product. If table <code>products</code> is updated, then PCT rewrite is not possible with <code>sales_per_country_mv</code> as you cannot tell which portions of the materialized view are <code>FRESH</code>.</p>
<p>The following updates <code>sales_par_list</code> as follows:</p>
<pre>
INSERT INTO sales_par_list VALUES (2000, 10, 22, 'France', 900, 20, 200.99);
</pre>
<p>This statement inserted a row into partition Europe in table <code>sales_par_list</code>. Now <code>sales_per_country_mv</code> is stale, but PCT rewrite (in <code>ENFORCED</code> and <code>TRUSTED</code> modes) is possible as this materialized view supports PCT against table <code>sales_par_list</code>. The fresh and stale areas of the materialized view are identified based on the partitioned detail table <code>sales_par_list</code>.</p>
<p><a href="#i1015969">Figure 19-4</a> illustrates what is fresh and what is stale in this example.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1015969"></a><a id="DWHSG8532"></a>Figure 19-4 PCT Rewrite and List Partitioning</p>
<img width="448" height="297" src="./dwhsg114.gif" alt="Description of Figure 19-4 follows" /><br />
<a id="sthref925" href="./img_text/dwhsg114.htm">Description of "Figure 19-4 PCT Rewrite and List Partitioning"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Consider the following query:</p>
<pre>
SELECT s.country_name, p.prod_name, SUM(s.amount_sold) AS sum_sales, 
   COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE s.prod_id = p.prod_id AND s.calendar_year = 2000
  AND s.country_name IN ('United States of America', 'Japan')
GROUP BY s.country_name, p.prod_name;
</pre>
<p>This query accesses partitions <code>America</code> and <code>Asia</code> in <code>sales_par_list</code>; these partition have not been updated so rewrite is possible with stale materialized view <code>sales_per_country_mv</code> as this query will access only <code>FRESH</code> portions of the materialized view.</p>
<p>The query is rewritten in terms of <code>sales_per_country_mv</code> as follows:</p>
<pre>
SELECT country_name, prod_name, SUM(sum_sales) AS sum_slaes, SUM(cnt) AS cnt
FROM sales_per_country_mv WHERE calendar_year = 2000 
  AND country_name IN ('United States of America', 'Japan')
GROUP BY country_name, prod_name;
</pre>
<p>Now consider the following query:</p>
<pre>
SELECT s.country_name,  p.prod_name,
 SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE  s.prod_id = p.prod_id AND s.calendar_year = 1999
  AND s.country_name IN ('Japan', 'India', 'Spain')
GROUP BY s.country_name, p.prod_name;
</pre>
<p>This query accesses partitions <code>Europe</code> and <code>Asia</code> in <code>sales_par_list</code>. Partition <code>Europe</code> has been updated, so this query cannot be rewritten in terms of <code>sales_per_country_mv</code> as the required data from the materialized view is stale.</p>
<p>You will be able to rewrite after any kinds of updates to <code>sales_par_list</code>, that is DMLs, direct loads and Partition Maintenance Operations (PMOPs) if the incoming query accesses <code>FRESH</code> parts of the materialized view.</p>
</div>
<!-- class="sect3" -->
<a id="BABFJIAJ"></a><a id="DWHSG8533"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">PCT Rewrite and PMARKER</h4>
<p>Whe<a id="sthref926"></a><a id="sthref927"></a>n a partition marker is provided, the query rewrite capabilities are limited to rewrite queries that access whole detail table partitions as all rows from a specific partition have the same pmarker value. That is, if a query accesses a portion of a detail table partition, it is not rewritten even if that data corresponds to a <code>FRESH</code> portion of the materialized view. Now <code>FRESH</code> portions of the materialized view are determined by the pmarker value. To determine which rows of the materialized view are fresh, you associate freshness with the marker value, so all rows in the materialized view with a specific pmarker value are <code>FRESH</code> or are <code>STALE</code>.</p>
<p>The following creates a materialized view has the total amounts sold of every product in each detail table partition of <code>sales_par_list</code> for each year. This materialized view will also depend on detail table <code>products</code> as shown in the following:</p>
<pre>
CREATE MATERIALIZED VIEW sales_per_dt_partition_mv
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.calendar_year AS calendar_year, p.prod_name AS prod_name,
       DBMS_MVIEW.PMARKER(s.rowid) pmarker,
       SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE s.prod_id = p.prod_id AND s.calendar_year &gt; 2000
GROUP BY s.calendar_year, DBMS_MVIEW.PMARKER(s.rowid), p.prod_name;
</pre>
<p>The materialized view <code>sales_per_dt_partition_mv</code> provides the sum of sales for each detail table partition. This materialized view supports PCT rewrite against table <code>sales_par_list</code> because the partition marker is in its <code>SELECT</code> and <code>GROUP</code> <code>BY</code> clauses. <a href="#g1021737">Table 19-2</a> lists the partition names and their pmarkers for this example.</p>
<div class="tblformal">
<p class="titleintable"><a id="DWHSG8534"></a><a id="sthref928"></a><a id="g1021737"></a>Table 19-2 Partition Names and Their Pmarkers</p>
<table class="cellalignment1381" title="Partition Names and Their Pmarkers" summary="Partition Names and Their Pmarkers" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t3">Partition Name</th>
<th class="cellalignment1382" id="r1c2-t3">Pmarker</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t3" headers="r1c1-t3">
<p>America</p>
</td>
<td class="cellalignment1378" headers="r2c1-t3 r1c2-t3">
<p>1000</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t3" headers="r1c1-t3">
<p>Asia</p>
</td>
<td class="cellalignment1378" headers="r3c1-t3 r1c2-t3">
<p>1001</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t3" headers="r1c1-t3">
<p>Europe</p>
</td>
<td class="cellalignment1378" headers="r4c1-t3 r1c2-t3">
<p>1002</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Then update the table <code>sales_par_list</code> as follows:</p>
<pre>
DELETE FROM sales_par_list WHERE country_name = 'India';
</pre>
<p>You have deleted rows from partition <code>Asia</code> in table <code>sales_par_list</code>. Now <code>sales_per_dt_partition_mv</code> is stale, but PCT rewrite (in <code>ENFORCED</code> and <code>TRUSTED</code> modes) is possible as this materialized view supports PCT (pmarker based) against table <code>sales_par_list</code>.</p>
<p>Now consider the following query:</p>
<pre>
SELECT p.prod_name, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE  s.prod_id = p.prod_id AND s.calendar_year = 2001 AND
       s.country_name IN ('United States of America', 'Argentina')
GROUP BY p.prod_name;
</pre>
<p>This query can be rewritten in terms of <code>sales_per_dt_partition_mv</code> as all the data corresponding to a detail table partition is accessed, and the materialized view is <code>FRESH</code> with respect to this data. This query accesses all data in partition <code>America</code>, which has not been updated.</p>
<p>The query is rewritten in terms of <code>sales_per_dt_partition_mv</code> as follows:</p>
<pre>
SELECT prod_name, SUM(sum_sales) AS sum_sales, SUM(cnt) AS cnt
FROM sales_per_dt_partition_mv
WHERE calendar_year = 2001 AND pmarker = 1000
GROUP BY prod_name;
</pre></div>
<!-- class="sect3" -->
<a id="BABJBEAF"></a><a id="DWHSG8535"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">PCT Rewrite Using Rowid as PMARKER</h4>
<p>A materialized view supports PCT rewrite provided a partition key or a partition marker is provided in its <code>SELECT</code> and <code>GROUP</code> <code>BY</code> clause, if there is a <code>GROUP</code> <code>BY</code> clause. You can use the rowids of the partitioned table instead of the pmarker or the partition key. Note that Oracle converts the rowids into pmarkers internally. Consider the following table:</p>
<pre>
CREATE TABLE product_par_list
(prod_id, prod_name, prod_category,
 prod_subcategory, prod_list_price)
 PARTITION BY LIST (prod_category)
 (PARTITION prod_cat1
      VALUES ('Boys', 'Men'),
  PARTITION prod_cat2
      VALUES ('Girls', 'Women'))
 AS
   SELECT prod_id, prod_name, prod_category, 
      prod_subcategory, prod_list_price
   FROM products;
</pre>
<p>Let us create the following materialized view on tables, <code>sales_par_list</code> and <code>product_par_list</code>:</p>
<pre>
CREATE MATERIALIZED VIEW  sum_sales_per_category_mv
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT p.rowid prid, p.prod_category, 
       SUM (s.amount_sold) sum_sales, COUNT(*) cnt
FROM sales_par_list s, product_par_list p
WHERE s.prod_id = p.prod_id and s.calendar_year &lt;= 2000
GROUP BY p.rowid, p.prod_category;
</pre>
<p>All the limitations that apply to pmarker rewrite apply here as well. The incoming query should access a whole partition for the query to be rewritten. The following pmarker table is used in this case:</p>
<pre>
product_par_list       pmarker value
----------------       -------------
prod_cat1                      1000
prod_cat2                      1001
prod_cat3                      1002
</pre>
<p>Then update table <code>product_par_list</code> as follows:</p>
<pre>
DELETE FROM product_par_list WHERE prod_name = 'MEN';
</pre>
<p>So <code>sum_sales_per_category_mv</code> is stale with respect to partition <code>prod_list1</code> from <code>product_par_list</code>.</p>
<p>Now consider the following query:</p>
<pre>
SELECT p.prod_category, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, product_par_list p
WHERE  s.prod_id = p.prod_id AND p.prod_category IN
       ('Girls', 'Women') AND s.calendar_year &lt;= 2000
GROUP BY p.prod_category;
</pre>
<p>This query can be rewritten in terms of <code>sum_sales_per_category_mv</code> as all the data corresponding to a detail table partition is accessed, and the materialized view is <code>FRESH</code> with respect to this data. This query accesses all data in partition <code>prod_cat2</code>, which has not been updated. Following is the rewritten query in terms of <code>sum_sales_per_category_mv</code>:</p>
<pre>
SELECT prod_category, sum_sales, cnt
FROM sum_sales_per_category_mv WHERE DBMS_MVIEW.PMARKER(srid) IN (1000)
GROUP BY prod_category;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABCFHJI"></a><a id="DWHSG08027"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Multiple Materialized Views</h3>
<p>Que<a id="sthref929"></a><a id="sthref930"></a>ry rewrite has been extended to enable the rewrite of a query using multiple materialized views. If query rewrite determines that there is no set of materialized views that returns all of the data, then query rewrite retrieves the remaining data from the base tables.</p>
<p>Query rewrite using multiple materialized views can take advantage of many different types and combinations of rewrite, such as using PCT and <code>IN</code>-lists. The following examples illustrate some of the queries where query rewrite is now possible.</p>
<p>Consider the following two materialized views, <code>cust_avg_credit_mv1</code> and <code>cust_avg_credit_mv2</code>. <code>cust_avg_credit_mv1</code> asks for all customers average credit limit for each postal code that were born between the years 1940 and 1950. <code>cust_avg_credit_mv2</code> asks for customers average credit limit for each postal code that were born after 1950 and before or on 1970.</p>
<p>The materialized views' definitions for this example are as follows:</p>
<pre>
CREATE MATERIALIZED VIEW cust_avg_credit_mv1
ENABLE QUERY REWRITE
AS SELECT cust_postal_code, cust_year_of_birth, 
       SUM(cust_credit_limit) AS sum_credit,
       COUNT(cust_credit_limit) AS count_credit
FROM customers
WHERE cust_year_of_birth BETWEEN 1940 AND 1950
GROUP BY cust_postal_code, cust_year_of_birth;

CREATE MATERIALIZED VIEW cust_avg_credit_mv2
ENABLE QUERY REWRITE
AS SELECT cust_postal_code, cust_year_of_birth,
       SUM(cust_credit_limit) AS sum_credit, 
       COUNT(cust_credit_limit) AS count_credit
FROM customers 
WHERE cust_year_of_birth &gt; 1950 AND cust_year_of_birth &lt;= 1970
GROUP BY cust_postal_code, cust_year_of_birth;
</pre>
<p class="subhead1"><a id="DWHSG8536"></a><a id="sthref931"></a>Query 1: One Matched Interval in Materialized View and Query</p>
<p>Consider a query that asks for all customers average credit limit for each postal code who were born between 1940 and 1970. This query is matched by the interval <code>BETWEEN</code> on <code>cust_year_of_birth</code>.</p>
<pre>
SELECT cust_postal_code, AVG(cust_credit_limit) AS avg_credit
FROM customers c
WHERE cust_year_of_birth BETWEEN 1940 AND 1970
GROUP BY cust_postal_code;
</pre>
<p>The preceding query can be rewritten in terms of these two materialized views to get all the data as follows:</p>
<pre>
SELECT v1.cust_postal_code, 
SUM(v1.sum_credit)/SUM(v1.count_credit) AS avg_credit
FROM (SELECT cust_postal_code, sum_credit, count_credit
 FROM <span class="bold">cust_avg_credit_mv1</span> 
 GROUP BY cust_postal_code
 UNION ALL
 SELECT cust_postal_code, sum_credit, count_credit
 FROM <span class="bold">cust_avg_credit_mv2</span>
 GROUP BY cust_postal_code) v1
 GROUP BY v1.cust_postal_code;
</pre>
<p>Note that the <code>UNION</code> <code>ALL</code> query is used in an inline view because of the re-aggregation that needs to take place. Note also how query rewrite was the count aggregate to perform this rollup.</p>
<p class="subhead1"><a id="DWHSG8537"></a><a id="sthref932"></a>Query 2: Query Outside of Data Contained in Materialized View</p>
<p>When the materialized view goes beyond the range asked by the query, a filter (also called selection) is added to the rewritten query to drop out the unneeded rows returned by the materialized view. This case is illustrated in the following query:</p>
<pre>
SELECT cust_postal_code, SUM(cust_credit_limit) AS sum_credit
FROM customers c 
WHERE cust_year_of_birth BETWEEN 1945 AND 1955
GROUP BY cust_postal_code;
</pre>
<p>Query 2 is rewritten as:</p>
<pre>
SELECT v1.cust_postal_code, SUM(v1.sum_credit)
FROM
(SELECT cust_postal_code, SUM(sum_credit) AS sum_credit
FROM cust_avg_credit_mv1 
WHERE cust_year_of_birth BETWEEN 1945 AND 1950
GROUP BY cust_postal_code
UNION ALL
SELECT cust_postal_code, SUM(sum_credit) AS sum_credit
FROM cust_birth_mv2
WHERE cust_year_of_birth &gt; 1950 AND cust_year_of_birth &lt;= 1955
GROUP BY cust_postal_code) v1
GROUP BY v1.cust_postal_code;
</pre>
<p class="subhead1"><a id="DWHSG8538"></a><a id="sthref933"></a>Query 3: Requesting More Data Than is in the Materialized View</p>
<p>What if a query asks for more data than is contained in the two materialized views? It still rewrites using both materialized views and the data in the base table. In the following example, a new set of materialized views without aggregates is defined It will still rewrite using both materialized views and the data in the base table.</p>
<pre>
CREATE MATERIALIZED VIEW cust_birth_mv1
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, cust_year_of_birth
FROM customers WHERE cust_year_of_birth BETWEEN 1940 AND 1950;

CREATE MATERIALIZED VIEW cust_avg_credit_mv2
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, cust_year_of_birth
FROM customers 
WHERE cust_year_of_birth &gt; 1950 AND cust_year_of_birth &lt;= 1970;
</pre>
<p>Our queries now require all customers born between 1940 and 1990.</p>
<pre>
SELECT cust_last_name, cust_first_name 
FROM customers c WHERE cust_year_of_birth BETWEEN 1940 AND 1990;
</pre>
<p>Query rewrite needs to access the base table to access the customers that were born after 1970 and before or on 1990. Therefore, Query 3 is rewritten as the following:</p>
<pre>
SELECT cust_last_name, cust_first_name 
FROM cust_birth_mv1 
UNION ALL
SELECT cust_last_name, cust_first_name 
FROM cust_birth_mv2
UNION ALL
SELECT cust_last_name, cust_first_name 
FROM customers c 
WHERE cust_year_of_birth &gt; 1970 AND cust_year_of_birth &lt;= 1990;
</pre>
<p class="subhead1"><a id="DWHSG8539"></a><a id="sthref934"></a>Query 4: Requesting Data on Multiple Selection Columns</p>
<p>Consider the following query, which asks for all customers who have a credit limit between 1,000 and 10,000 and were born between the years 1945 and 1960. This query is a multi-selection query because it is asking for data on multiple selection columns.</p>
<pre>
SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_year_of_birth BETWEEN 1945 AND 1960 AND
   cust_credit_limit BETWEEN 1000 AND 10000;
</pre>
<p><a href="#BABJABEH">Figure 19-5</a> shows a two-selection query, which can be rewritten with the two-selection materialized views described in the following section.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABJABEH"></a><a id="DWHSG8540"></a>Figure 19-5 Query Rewrite Using Multiple Materialized Views</p>
<img width="351" height="285" src="./dwhsg111.gif" alt="Description of Figure 19-5 follows" /><br />
<a id="sthref935" href="./img_text/dwhsg111.htm">Description of "Figure 19-5 Query Rewrite Using Multiple Materialized Views"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The graph in <a href="#BABJABEH">Figure 19-5</a> illustrates the materialized views that can be used to satisfy this query. <code>credit_mv1</code> asks for customers that have credit limits between 1,000 and 5,000 and were born between 1945 and 1950. <code>credit_mv2</code> asks for customers that have credit limits &gt; 5,000 and &lt;= 10,000 and were born between 1945 and 1960. <code>credit_mv3</code> asks for customers that have credit limits between 1,000 and 5,000 and were born after 1950 and before or on 1955.</p>
<p>The materialized views' definitions for this case are as follows:</p>
<pre>
CREATE MATERIALIZED VIEW credit_mv1
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, 
    cust_credit_limit, cust_year_of_birth
FROM customers
WHERE cust_credit_limit BETWEEN 1000 AND 5000 
AND cust_year_of_birth BETWEEN 1945 AND 1950;

CREATE MATERIALIZED VIEW credit_mv2
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, 
   cust_credit_limit, cust_year_of_birth
FROM customers
WHERE cust_credit_limit &gt; 5000 
   AND cust_credit_limit &lt;= 10000 AND cust_year_of_birth 
   BETWEEN 1945 AND 1960;

CREATE MATERIALIZED VIEW credit_mv3
ENABLE QUERY REWRITE AS
SELECT cust_last_name, cust_first_name, 
   cust_credit_limit, cust_year_of_birth
FROM customers
WHERE cust_credit_limit BETWEEN 1000 AND 5000 
  AND cust_year_of_birth &gt; 1950 AND cust_year_of_birth &lt;= 1955;
</pre>
<p>Query 4 can be rewritten by using all three materialized views to access most of the data. However, because not all the data can be obtained from these three materialized views, query rewrite also accesses the base tables to retrieve the data for customers who have credit limits between 1,000 and 5,000 and were born between 1955 and 1960. It is rewritten as follows:</p>
<pre>
SELECT cust_last_name, cust_first_name
FROM credit_mv1
UNION ALL
SELECT cust_last_name, cust_first_name
FROM credit_mv2
UNION ALL
SELECT cust_last_name, cust_first_name
FROM credit_mv3
UNION ALL
SELECT cust_last_name, cust_first_name
FROM customers
WHERE cust_credit_limit BETWEEN 1000 AND 5000 
  AND cust_year_of_birth &gt; 1955 AND cust_year_of_birth &lt;= 1960;
</pre>
<p>This example illustrates how a multi-selection query can be rewritten with multiple materialized views. The example was simplified to show no overlapping data among the three materialized views. However, query rewrite can perform similar rewrites.</p>
<p class="subhead1"><a id="DWHSG8541"></a><a id="sthref936"></a>Query 5: Intervals and Constrained Intervals</p>
<p>This example illustrates how a multi-selection query can be rewritten using a single selection materialized view. In this example, there are two intervals in the query and one constrained interval in the materialized view. It asks for customers that have credit limits between 1,000 and 10,000 and were born between 1945 and 1960. But suppose that <code>credit_mv1</code> asks for just customers that have credit limits between 1,000 and 5,000. <code>credit_mv1</code> is not constrained by a selection in <code>cust_year_of_birth</code>, therefore covering the entire range of birth year values for the query.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABCIEFD"></a><a id="DWHSG8542"></a>Figure 19-6 Constrained Materialized View Selections</p>
<img width="242" height="282" src="./dwhsg113.gif" alt="Description of Figure 19-6 follows" /><br />
<a id="sthref937" href="./img_text/dwhsg113.htm">Description of "Figure 19-6 Constrained Materialized View Selections"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The area between the lines in <a href="#BABCIEFD">Figure 19-6</a> represents the data <code>credit1_mv</code>.</p>
<p>The new <code>credit_mv1</code> is defined as follows:</p>
<pre>
CREATE MATERIALIZED VIEW credit_mv1
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, 
   cust_credit_limit, cust_year_of_birth
FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 5000;
</pre>
<p>The query is as follows:</p>
<pre>
SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_year_of_birth BETWEEN 1945 AND 1960
  AND cust_credit_limit BETWEEN 1000 AND 10000;
</pre>
<p>And finally the rewritten query is as follows:</p>
<pre>
SELECT cust_last_name, cust_first_name
FROM credit_mv1 WHERE cust_year_of_birth BETWEEN 1945 AND 1960
UNION ALL
SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_year_of_brith BETWEEN 1945 AND 1960
  AND cust_credit_limit &gt; 5000 AND cust_credit_limit &lt;= 10000;
</pre>
<p class="subhead1"><a id="DWHSG8543"></a><a id="sthref938"></a>Query 6: Query has Single Column IN-List and Materialized Views have Single Column Intervals</p>
<p>Multiple materialized view query rewrite can process an <code>IN</code>-list in the incoming query and rewrite the query in terms of materialized views that have intervals on the same selection column. Given that an <code>IN</code>-list represents discrete values in an interval, this rewrite capability is a natural extension to the intervals only scenario described earlier.</p>
<p>The following is an example of a one column <code>IN</code>-list selection in the query and one column interval selection in the materialized views. Consider a query that asks for the number of customers for each country who were born in any of the following year: 1945, 1950, 1955, 1960, 1965, 1970 or 1975. This query is constrained by an <code>IN</code>-list on <code>cust_year_of_birth</code>.</p>
<pre>
SELECT c2.country_name, count(c1.country_id)
FROM customers c1, countries c2
WHERE c1.country_id = c2.country_id AND 
   c1.cust_year_of_birth IN (1945, 1950, 1955, 1960, 1965, 1970, 1975)
GROUP BY c2.country_name;
</pre>
<p>Consider the following two materialized views. <code>cust_country_birth_mv1</code> asks for the number of customers for each country that were born between the years 1940 and 1950. <code>cust_country_birth_mv2</code> asks for the number of customers for each country that were born after 1950 and before or on 1970. The preceding query can be rewritten in terms of these two materialized views to get the total number of customers for each country born in 1945, 1950, 1955, 1960, 1965 and 1970. The base table access is required to obtain the number of customers that were born in 1975.</p>
<p>The materialized views' definitions for this example are as follows:</p>
<pre>
CREATE MATERIALIZED VIEW cust_country_birth_mv1
ENABLE QUERY REWRITE
AS SELECT c2.country_name, c1.cust_year_of_birth,
 COUNT(c1.country_id) AS count_customers
FROM customers c1, countries c2
WHERE c1.country_id = c2.country_id AND 
      cust_year_of_birth BETWEEN 1940 AND 1950
GROUP BY c2.country_name, c1.cust_year_of_birth;

CREATE MATERIALIZED VIEW cust_country_birth_mv2
ENABLE QUERY REWRITE
AS SELECT c2.country_name, c1.cust_year_of_birth, 
 COUNT(c1.country_id) AS count_customers
FROM customers c1, countries c2
WHERE c1.country_id = c2.country_id AND cust_year_of_birth &gt; 1950 
AND cust_year_of_birth &lt;= 1970
GROUP BY c2.country_name, c1.cust_year_of_birth;
</pre>
<p>So, Query 6 is rewritten as:</p>
<pre>
SELECT v1.country_name, SUM(v1.count_customers)
FROM (SELECT country_name, SUM(count_customers) AS count_customers
FROM cust_country_birth_mv1 
WHERE cust_year_of_birth IN (1945, 1950)
GROUP BY country_name
UNION ALL
SELECT country_name, SUM(count_customers) AS count_customers
FROM cust_country_birth_mv2
WHERE cust_year_of_birth IN (1955, 1960, 1965, 1970)
GROUP BY country_name
UNION ALL
SELECT c2.country_name, COUNT(c1.country_id) AS count_customers
FROM customers c1, countries c2
WHERE c1.country_id = c2.country_id AND cust_year_of_birth IN (1975)
GROUP BY c2.country_name) v1
GROUP BY v1.country_name;
</pre>
<p class="subhead1"><a id="DWHSG8544"></a><a id="sthref939"></a>Query 7: PCT Rewrite with Multiple Materialized Views</p>
<p>Rewrite with multiple materialized views can also take advantage of PCT rewrite. PCT rewrite refers to the capability of rewriting a query with only the fresh portions of a materialized view when the materialized view is stale. This feature is used in <code>ENFORCED</code> or <code>TRUSTED</code> integrity modes, and with multiple materialized view rewrite, it can use the fresh portions of the materialized view to get the fresh data from it, and go to the base table to get the stale data. So the rewritten query will <code>UNION</code> <code>ALL</code> only the fresh data from one or more materialized views and obtain the rest of the data from the base tables to answer the query. Therefore, all the PCT rules and conditions apply here as well. The materialized view should be PCT enabled and the changes made to the base table should be such that the fresh and stale portions of the materialized view can be clearly identified.</p>
<p>This example assumes you have a query that asks for customers who have credit limits between 1,000 and 10,000 and were born between 1945 and 1964. Also, the customer table is partitioned by <code>cust_date_of_birth</code> and there is a PCT-enabled materialized view called <code>credit_mv1</code> that also asks for customers who have a credit limit between 1,000 and 10,000 and were born between 1945 and 1964.</p>
<pre>
SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 10000;
</pre>
<p>In <a href="#BABEFEFH">Figure 19-7</a>, the diagram illustrates those regions of the materialized view that are fresh (dark) and stale (light) with respect to the base table partitions <code>p1</code>-<code>p6</code>.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABEFEFH"></a><a id="DWHSG8545"></a>Figure 19-7 PCT and Multiple Materialized View Rewrite</p>
<img width="341" height="282" src="./dwhsg112.gif" alt="Description of Figure 19-7 follows" /><br />
<a id="sthref940" href="./img_text/dwhsg112.htm">Description of "Figure 19-7 PCT and Multiple Materialized View Rewrite"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Let us say that we are in <code>ENFORCED</code> mode and that <code>p1</code>, <code>p2</code>, <code>p3</code>, <code>p5</code>, and <code>p6</code> of the customer table are fresh and partition <code>p4</code> is stale. This means that all partitions of <code>credit_mv1</code> cannot be used to answer the query. The rewritten query must get the results for customer partition <code>p4</code> from some other materialized view or as shown in this example, from the base table. Below, we can see part of the table definition for the <code>customers</code> table showing how the table is partitioned:</p>
<pre>
CREATE TABLE customers
(PARTITION BY RANGE (cust_year_of_birth)
 PARTITION p1 VALUES LESS THAN (1945),
 PARTITION p2 VALUES LESS THAN (1950), 
 PARTITION p3 VALUES LESS THAN (1955),
 PARTITION p4 VALUES LESS THAN (1960),
 PARTITION p5 VALUES LESS THAN (1965),
 PARTITION p6 VALUES LESS THAN (1970);
</pre>
<p>The materialized view definition for the preceding example is as follows:</p>
<pre>
CREATE MATERIALIZED VIEW credit_mv1
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, 
   cust_credit_limit, cust_year_of_birth
FROM customers
WHERE cust_credit_limit BETWEEN 1000 AND 10000 
AND cust_year_of_birth BETWEEN 1945 AND 1964;
</pre>
<p>Note that this materialized view is PCT enabled with respect to table <code>customers</code>.</p>
<p>The rewritten query is as follows:</p>
<pre>
SELECT cust_last_name, cust_first_name FROM <span class="bold">credit_mv1</span>
WHERE cust_credit_limit BETWEEN 1000 AND 10000 AND
   (cust_year_of_birth &gt;= 1945 AND cust_year_of_birth &lt; 1955 OR
    cust_year_of_birth BETWEEN 1945 AND 1964)
UNION ALL
SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 10000 
  AND cust_year_of_birth &lt; 1960 AND cust_year_of_birth &gt;= 1955;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJCJEC"></a><a id="DWHSG0803"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Other Query Rewrite Considerations</h2>
<p>The following discusses some of the other cases when query rewrite is possible:</p>
<ul>
<li>
<p><a href="#BABBIFGF">Query Rewrite Using Nested Materialized Views</a></p>
</li>
<li>
<p><a href="#BABEAJBF">Query Rewrite in the Presence of Inline Views</a></p>
</li>
<li>
<p><a href="#BABJDHCH">Query Rewrite Using Remote Tables</a></p>
</li>
<li>
<p><a href="#BABBGDBD">Query Rewrite in the Presence of Duplicate Tables</a></p>
</li>
<li>
<p><a href="#BABGBICE">Query Rewrite Using Date Folding</a></p>
</li>
<li>
<p><a href="#BABGCBIC">Query Rewrite Using View Constraints</a></p>
</li>
<li>
<p><a href="#BABBFAJD">Query Rewrite Using Set Operator Materialized Views</a></p>
</li>
<li>
<p><a href="#BABDCFFH">Query Rewrite in the Presence of Grouping Sets</a></p>
</li>
<li>
<p><a href="#BABIIFEJ">Query Rewrite in the Presence of Window Functions</a></p>
</li>
<li>
<p><a href="#BABJFABD">Query Rewrite and Expression Matching</a></p>
</li>
<li>
<p><a href="#BABJCIDD">Cursor Sharing and Bind Variables</a></p>
</li>
<li>
<p><a href="#BABIEFBI">Handling Expressions in Query Rewrite</a></p>
</li>
</ul>
<a id="BABBIFGF"></a><a id="DWHSG08031"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite Using Nested Materialized Views</h3>
<p>Query<a id="sthref941"></a> rewrite attempts to iteratively take advantage of nested materialized views. Oracle Database first tries to rewrite a query with materialized views having aggregates and joins, then with a materialized view containing only joins. If any of the rewrites succeeds, Oracle repeats that process again until no rewrites are found. For example, assume that you had created materialized views <code>join_sales_time_product_mv</code> and <code>sum_sales_time_product_mv</code> as in the following:</p>
<pre>
CREATE MATERIALIZED VIEW join_sales_time_product_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_id, p.prod_name, t.time_id, t.week_ending_day,
       s.channel_id, s.promo_id, s.cust_id, s.amount_sold
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id AND s.prod_id = p.prod_id;

CREATE MATERIALIZED VIEW sum_sales_time_product_mv
ENABLE QUERY REWRITE AS
SELECT mv.prod_name, mv.week_ending_day, COUNT(*) cnt_all, 
       SUM(mv.amount_sold) sum_amount_sold, 
       COUNT(mv.amount_sold) cnt_amount_sold
FROM join_sales_time_product_mv mv
GROUP BY mv.prod_name, mv.week_ending_day;
</pre>
<p>Then consider the following query:</p>
<pre>
SELECT p.prod_name, t.week_ending_day, SUM(s.amount_sold)
FROM sales s, products p, times t
WHERE s.time_id=t.time_id AND s.prod_id=p.prod_id
GROUP BY p.prod_name, t.week_ending_day;
</pre>
<p>Oracle finds that <code>join_sales_time_product_mv</code> is eligible for rewrite. The rewritten query has this form:</p>
<pre>
SELECT mv.prod_name, mv.week_ending_day, SUM(mv.amount_sold)
FROM join_sales_time_product_mv mv
GROUP BY mv.prod_name, mv.week_ending_day;
</pre>
<p>Because a rewrite occurred, Oracle tries the process again. This time, the query can be rewritten with single-table aggregate materialized view <code>sum_sales_store_time</code> into the following form:</p>
<pre>
SELECT mv.prod_name, mv.week_ending_day, mv.sum_amount_sold
FROM sum_sales_time_product_mv mv;
</pre></div>
<!-- class="sect2" -->
<a id="BABEAJBF"></a><a id="DWHSG08032"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite in the Presence of Inline Views</h3>
<p>O<a id="sthref942"></a>racle Database supports query rewrite with inline views in two ways:</p>
<ul>
<li>
<p>when the text from the inline views in the materialized view exactly matches the text in the request query</p>
</li>
<li>
<p>when the request query contains inline views that are equivalent to the inline views in the materialized view</p>
</li>
</ul>
<p>Two inline views are considered equivalent if their <code>SELECT</code> lists and <code>GROUP</code> <code>BY</code> lists are equivalent, <code>FROM</code> clauses contain the same or equivalent objects, their join graphs, including all the selections in the <code>WHERE</code> clauses are equivalent and their <code>HAVING</code> clauses are equivalent.</p>
<p>The following examples illustrate how a query with an inline view can rewrite with a materialized view using text match and general inline view rewrites. Consider the following materialized view that contains an inline view:</p>
<pre>
CREATE MATERIALIZED VIEW SUM_SALES_MV
ENABLE QUERY REWRITE AS
SELECT mv_iv.prod_id, mv_iv.cust_id,
sum(mv_iv.amount_sold) sum_amount_sold
FROM (SELECT prod_id, cust_id, amount_sold
FROM sales, products
WHERE sales.prod_id = products.prod_id) MV_IV
GROUP BY mv_iv.prod_id, mv_iv.cust_id;
</pre>
<p>The following query has an inline view whose text matches exactly with that of the materialized view's inline view. Hence, the query inline view is internally replaced with the materialized view's inline view so that the query can be rewritten:</p>
<pre>
SELECT iv.prod_id, iv.cust_id,
SUM(iv.amount_sold) sum_amount_sold
FROM (SELECT prod_id, cust_id, amount_sold
FROM sales, products
WHERE sales.prod_id = products.prod_id) IV
GROUP BY iv.prod_id, iv.cust_id;
</pre>
<p>The following query has an inline view that does not have exact text match with the inline view in the preceding materialized view. Note that the join predicate in the query inline view is switched. Even though this query does not textually match with that of the materialized view's inline view, query rewrite identifies the query's inline view as equivalent to the materialized view's inline view. As before, the query inline view will be internally replaced with the materialized view's inline view so that the query can be rewritten.</p>
<pre>
SELECT iv.prod_id, iv.cust_id,
SUM(iv.amount_sold) sum_amount_sold
FROM (SELECT prod_id, cust_id, amount_sold
FROM sales, products
WHERE products.prod_id = sales.prod_id) IV
GROUP BY iv.prod_id, iv.cust_id;
</pre>
<p>Both of these queries are rewritten with <code>SUM_SALES_MV</code> as follows:</p>
<pre>
SELECT prod_id, cust_id, sum_amount_sold
FROM SUM_SALES_MV;
</pre>
<p>General inline view rewrite is not supported for queries that contain set operators, <code>GROUPING</code> <code>SET</code> clauses, nested subqueries, nested inline views, and remote tables.</p>
</div>
<!-- class="sect2" -->
<a id="BABJDHCH"></a><a id="DWHSG00323"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite Using Remote Tables</h3>
<p>Oracle Database supports query rewrite with materialized views that reference tables at a single remote database site. Note that the materialized view should be present at the site where the query is being issued. Because any remote table update cannot be propagated to the local site simultaneously, query rewrite only works in the <code>stale_tolerated</code> mode. Whenever a query contains columns that are not found in the materialized view, it uses a technique called join back to rewrite the query. However, if the join back table is not found at the local site, query rewrite does not take place. Also, because the constraint information of the remote tables is not available at the remote site, query rewrite does not make use of any constraint information.</p>
<p>The following query contains tables that are found at a single remote site:</p>
<pre>
SELECT p.prod_id, t.week_ending_day, s.cust_id,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales@remotedbl s, products@remotedbl p, times@remotedbl t
WHERE s.time_id=t.time_id AND s.prod_id=p.prod_id
GROUP BY p.prod_id, t.week_ending_day, s.cust_id;
</pre>
<p>The following materialized view is present at the local site, but it references tables that are all found at the remote site:</p>
<pre>
CREATE MATERIALIZED VIEW sum_sales_prod_week_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_id, t.week_ending_day, s.cust_id,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales@remotedbl s, products@remotedbl p, times@remotedbl t
WHERE s.time_id=t.time_id AND s.prod_id=p.prod_id
GROUP BY p.prod_id, t.week_ending_day, s.cust_id;
</pre>
<p>Even though the query references remote tables, it is rewritten using the previous materialized view as follows:</p>
<pre>
SELECT prod_id, week_ending_day, cust_id,  sum_amount_sold
FROM sum_sales_prod_week_mv;
</pre></div>
<!-- class="sect2" -->
<a id="BABBGDBD"></a><a id="DWHSG08034"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite in the Presence of Duplicate Tables</h3>
<p>Oracle Database <a id="sthref943"></a>accomplishes query rewrite of queries that contain multiple references to the same tables, or self joins by employing two different strategies. Using the first strategy, you need to ensure that the query and the materialized view definitions have the same aliases for the multiple references to a table. If you do not provide a matching alias, Oracle tries the second strategy, where the joins in the query and the materialized view are compared to match the multiple references in the query to the multiple references in the materialized view.</p>
<p>The following is an example of a materialized view and a query. In this example, the query is missing a reference to a column in a table so an exact text match does not work. General query rewrite can occur, however, because the aliases for the table references match.</p>
<p>To demonstrate the self-join rewriting possibility with the <code>sh</code> sample schema, the following addition is assumed to include the actual shipping and payment date in the fact table, referencing the same dimension table times. This is for demonstration purposes only and does not return any results:</p>
<pre>
ALTER TABLE sales ADD (time_id_ship DATE);
ALTER TABLE sales ADD (CONSTRAINT time_id_book_fk FOREIGN key (time_id_ship)
 REFERENCES times(time_id) ENABLE NOVALIDATE);
ALTER TABLE sales MODIFY CONSTRAINT time_id_book_fk RELY;
ALTER TABLE sales ADD (time_id_paid DATE);
ALTER TABLE sales ADD (CONSTRAINT time_id_paid_fk FOREIGN KEY (time_id_paid)
 REFERENCES times(time_id) ENABLE NOVALIDATE);
ALTER TABLE sales MODIFY CONSTRAINT time_id_paid_fk RELY;
</pre>
<p>Now, you can define a materialized view as follows:</p>
<pre>
CREATE MATERIALIZED VIEW sales_shipping_lag_mv
ENABLE QUERY REWRITE AS
SELECT t1.fiscal_week_number, s.prod_id,
         t2.fiscal_week_number - t1.fiscal_week_number AS lag
FROM times t1, sales s, times t2 
WHERE t1.time_id = s.time_id AND t2.time_id = s.time_id_ship;
</pre>
<p>The following query fails the exact text match test but is rewritten because the aliases for the table references match:</p>
<pre>
SELECT s.prod_id, t2.fiscal_week_number - t1.fiscal_week_number AS lag
FROM times t1, sales s, times t2 
WHERE t1.time_id = s.time_id AND t2.time_id = s.time_id_ship;
</pre>
<p>Note that Oracle Database performs other checks to ensure the correct match of an instance of a multiply instanced table in the request query with the corresponding table instance in the materialized view. For instance, in the following example, Oracle correctly determines that the matching alias names used for the multiple instances of table <code>times</code> does not establish a match between the multiple instances of table <code>times</code> in the materialized view.</p>
<p>The following query cannot be rewritten using <code>sales_shipping_lag_mv</code>, even though the alias names of the multiply instanced table <code>time</code> match because the joins are not compatible between the instances of <code>time</code> aliased by <code>t2</code>:</p>
<pre>
SELECT s.prod_id, t2.fiscal_week_number - t1.fiscal_week_number AS lag
FROM times t1, sales s, times t2 
WHERE t1.time_id = s.time_id AND t2.time_id = s.time_id_paid;
</pre>
<p>This request query joins the instance of the <code>time</code> table aliased by <code>t2</code> on the <code>s.time_id_paid</code> column, while the materialized views joins the instance of the <code>times</code> table aliased by <code>t2</code> on the <code>s.time_id_ship</code> column. Because the join conditions differ, Oracle correctly determines that rewrite cannot occur.</p>
<p>The following query does not have any matching alias in the materialized view, <code>sales_shipping_lag_mv</code>, for the table, times. But query rewrite now compares the joins between the query and the materialized view and correctly match the multiple instances of times.</p>
<pre>
SELECT s.prod_id, x2.fiscal_week_number - x1.fiscal_week_number AS lag
FROM times x1, sales s, times x2
WHERE x1.time_id = s.time_id AND x2.time_id = s.time_id_ship;
</pre></div>
<!-- class="sect2" -->
<a id="BABGBICE"></a><a id="DWHSG08035"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite Using Date Folding</h3>
<p><a id="sthref944"></a><a id="sthref945"></a>Date folding rewrite is a specific form of expression matching rewrite. In this type of rewrite, a date range in a query is folded into an equivalent date range representing higher date granules. The resulting expressions representing higher date granules in the folded date range are matched with equivalent expressions in a materialized view. The folding of date range into higher date granules such as months, quarters, or years is done when the underlying data type of the column is an Oracle <code>DATE</code>. The expression matching is done based on the use of canonical forms for the expressions.</p>
<p><code>DATE</code> is a built-in data type which represents ordered time units such as seconds, days, and months, and incorporates a time hierarchy (second -&gt; minute -&gt; hour -&gt; day -&gt; month -&gt; quarter -&gt; year). This hard-coded knowledge about <code>DATE</code> is used in folding date ranges from lower-date granules to higher-date granules. Specifically, folding a date value to the beginning of a month, quarter, year, or to the end of a month, quarter, year is supported. For example, the date value <code>1-jan-1999</code> can be folded into the beginning of either year <code>1999</code> or quarter <code>1999-1</code> or month <code>1999-01</code>. And, the date value <code>30-sep-1999</code> can be folded into the end of either quarter <code>1999-03</code> or month <code>1999-09</code>.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Due to the way date folding works, you should be careful when using <code>BETWEEN</code> and date columns. The best way to use <code>BETWEEN</code> and date columns is to increment the later date by 1. In other words, instead of using <code>date_col BETWEEN '1-jan-1999' AND '30-jun-1999'</code>, you should use <code>date_col</code> <code>BETWEEN '1-jan-1999' AND '1-jul-1999'</code>. You could also use the <code>TRUNC</code> function to get the equivalent result, as in <code>TRUNC(date_col)</code> <code>BETWEEN '1-jan-1999' AND '30-jun-1999'</code>. <code>TRUNC</code> will, however, strip time values.</div>
<p>Because date values are ordered, any range predicate specified on date columns can be folded from lower level granules into higher level granules provided the date range represents an integral number of higher level granules. For example, the range predicate <code>date_col &gt;= '1-jan-1999' AND date_col &lt; '30-jun-1999'</code> can be folded into either a month range or a quarter range using the <code>TO_CHAR</code> function, which extracts specific date components from a date value.</p>
<p>The advantage of aggregating data by folded date values is the compression of data achieved. Without date folding, the data is aggregated at the lowest granularity level, resulting in increased disk space for storage and increased I/O to scan the materialized view.</p>
<p>Consider a query that asks for the sum of sales by product types for the year 1998:</p>
<pre>
SELECT p.prod_category, SUM(s.amount_sold)
FROM sales s, products p
WHERE s.prod_id=p.prod_id AND s.time_id &gt;= TO_DATE('01-jan-1998', 'dd-mon-yyyy')
  AND s.time_id &lt;   TO_DATE('01-jan-1999', 'dd-mon-yyyy')
GROUP BY p.prod_category;

CREATE MATERIALIZED VIEW sum_sales_pcat_monthly_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_category, TO_CHAR(s.time_id,'YYYY-MM') AS month, 
       SUM(s.amount_sold) AS sum_amount
FROM sales s, products p
WHERE s.prod_id=p.prod_id
GROUP BY p.prod_category, TO_CHAR(s.time_id, 'YYYY-MM');

SELECT p.prod_category, SUM(s.amount_sold)
FROM sales s, products p
WHERE s.prod_id=p.prod_id
AND TO_CHAR(s.time_id, 'YYYY-MM') &gt;= '01-jan-1998'
AND TO_CHAR(s.time_id, 'YYYY-MM') &lt; '01-jan-1999'
GROUP BY p.prod_category;

SELECT mv.prod_category, mv.sum_amount
FROM sum_sales_pcat_monthly_mv mv
WHERE month &gt;= '01-jan-1998' AND month &lt; '01-jan-1999';
</pre>
<p>The range specified in the query represents an integral number of years, quarters, or months. Assume that there is a materialized view <code>mv3</code> that contains pre-summarized sales by <code>prod_type</code> and is defined as follows:</p>
<pre>
CREATE MATERIALIZED VIEW mv3
ENABLE QUERY REWRITE AS
SELECT prod_name, TO_CHAR(sales.time_id,'yyyy-mm') 
   AS month, SUM(amount_sold) AS sum_sales
FROM sales, products WHERE sales.prod_id = products.prod_id
GROUP BY prod_name, TO_CHAR(sales_time_id, 'yyyy-mm');
</pre>
<p>The query can be rewritten by first folding the date range into the month range and then matching the expressions representing the months with the month expression in <code>mv3</code>. This rewrite is shown in two steps (first folding the date range followed by the actual rewrite).</p>
<pre>
SELECT prod_name, SUM(amount_sold) AS sum_sales
FROM sales, products
WHERE sales.prod_id = products.prod_id AND TO_CHAR(sales.time_id, 'yyyy-mm') &gt;= 
      TO_CHAR('01-jan-1998', 'yyyy-mm') AND TO_CHAR(sales.time_id, '01-jan-1999',
 'yyyy-mm') &lt; TO_CHAR(TO_DATE(''01-jan-1999'', ''dd-mon-yyyy''), ''yyyy-mm'')
GROUP BY prod_name;

SELECT prod_name, sum_sales
FROM mv3 WHERE month &gt;=
      TO_CHAR(TO_DATE('01-jan-1998', 'dd-mon-yyyy'), 'yyyy-mm')
  AND month &lt; TO_CHAR(TO_DATE('01-jan-1999', 'dd-mon-yyyy'), 'yyyy-mm');
</pre>
<p>If <code>mv3</code> had pre-summarized sales by <code>prod_name</code> and year instead of <code>prod_name</code> and month, the query could still be rewritten by folding the date range into year range and then matching the year expressions.</p>
</div>
<!-- class="sect2" -->
<a id="BABGCBIC"></a><a id="DWHSG08036"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite Using View Constraints</h3>
<p>Data warehouse <a id="sthref946"></a><a id="sthref947"></a><a id="sthref948"></a>applications recognize multi-dimensional cubes in the database by identifying integrity constraints in the relational schema. Integrity constraints represent primary and foreign key relationships between fact and dimension tables. By querying the data dictionary, applications can recognize integrity constraints and hence the cubes in the database. However, this does not work in an environment where database administrators, for schema complexity or security reasons, define views on fact and dimension tables. In such environments, applications cannot identify the cubes properly. By allowing constraint definitions between views, you can propagate base table constraints to the views, thereby allowing applications to recognize cubes even in a restricted environment.</p>
<p>View constraint definitions are declarative in nature, but operations on views are subject to the integrity constraints defined on the underlying base tables, and constraints on views can be enforced through constraints on base tables. Defining constraints on base tables is necessary, not only for data correctness and cleanliness, but also for materialized view query rewrite purposes using the original base objects.</p>
<p>Materialized view rewrite extensively uses constraints for query rewrite. They are used for determining lossless joins, which, in turn, determine if joins in the materialized view are compatible with joins in the query and thus if rewrite is possible.</p>
<p><code>DISABLE</code> <code>NOVALIDATE</code> is the only valid state for a view constraint. However, you can choose <code>RELY</code> or <code>NORELY</code> as the view constraint state to enable more sophisticated query rewrites. For example, a view constraint in the <code>RELY</code> state allows query rewrite to occur when the query integrity level is set to <code>TRUSTED</code>. <a href="#g1021713">Table 19-3</a> illustrates when view constraints are used for determining lossless joins.</p>
<p>Note that view constraints cannot be used for query rewrite integrity level <code>ENFORCED</code>. This level enforces the highest degree of constraint enforcement <code>ENABLE</code> <code>VALIDATE</code>.</p>
<div class="tblformal">
<p class="titleintable"><a id="DWHSG8546"></a><a id="sthref949"></a><a id="g1021713"></a>Table 19-3 View Constraints and Rewrite Integrity Modes</p>
<table class="cellalignment1381" title="View Constraints and Rewrite Integrity Modes" summary="View Constraints and Rewrite Integrity Modes" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t5">Constraint States</th>
<th class="cellalignment1382" id="r1c2-t5">RELY</th>
<th class="cellalignment1382" id="r1c3-t5">NORELY</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t5" headers="r1c1-t5">
<p><code>ENFORCED</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t5 r1c2-t5">
<p>No</p>
</td>
<td class="cellalignment1378" headers="r2c1-t5 r1c3-t5">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t5" headers="r1c1-t5">
<p><code>TRUSTED</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t5 r1c2-t5">
<p>Yes</p>
</td>
<td class="cellalignment1378" headers="r3c1-t5 r1c3-t5">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t5" headers="r1c1-t5">
<p><code>STALE_TOLERATED</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t5 r1c2-t5">
<p>Yes</p>
</td>
<td class="cellalignment1378" headers="r4c1-t5 r1c3-t5">
<p>No</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8547"></a><a id="sthref950"></a>Example 19-10 View Constraints</p>
<p>To demonstrate the rewrite capabilities on views, you need to extend the <code>sh</code> sample schema as follows:</p>
<pre>
CREATE VIEW time_view AS
SELECT time_id, TO_NUMBER(TO_CHAR(time_id, 'ddd')) AS day_in_year FROM times;
</pre>
<p>You can now establish a foreign key/primary key relationship (in <code>RELY</code> mode) between the view and the fact table, and thus rewrite takes place as described in <a href="#g1021713">Table 19-3</a>, by adding the following constraints. Rewrite will then work for example in <code>TRUSTED</code> mode.</p>
<pre>
ALTER VIEW time_view ADD (CONSTRAINT time_view_pk 
   PRIMARY KEY (time_id) DISABLE NOVALIDATE);
ALTER VIEW time_view MODIFY CONSTRAINT time_view_pk RELY;
ALTER TABLE sales ADD (CONSTRAINT time_view_fk FOREIGN KEY (time_id)
   REFERENCES time_view(time_id) DISABLE NOVALIDATE);
ALTER TABLE sales MODIFY CONSTRAINT time_view_fk RELY;
</pre>
<p>Consider the following materialized view definition:</p>
<pre>
CREATE MATERIALIZED VIEW sales_pcat_cal_day_mv 
ENABLE QUERY REWRITE AS
SELECT p.prod_category, t.day_in_year, SUM(s.amount_sold) AS sum_amount_sold
FROM time_view t, sales s, products p 
WHERE t.time_id = s.time_id AND p.prod_id = s.prod_id
GROUP BY p.prod_category, t.day_in_year;
</pre>
<p>The following query, omitting the dimension table <code>products</code>, is also rewritten without the primary key/foreign key relationships, because the suppressed join between <code>sales</code> and <code>products</code> is known to be lossless.</p>
<pre>
SELECT t.day_in_year, SUM(s.amount_sold) AS sum_amount_sold
FROM time_view t, sales s WHERE t.time_id = s.time_id
GROUP BY t.day_in_year;
</pre>
<p>However, if the materialized view <code>sales_pcat_cal_day_mv</code> were defined only in terms of the view <code>time_view</code>, then you could not rewrite the following query, suppressing then join between <code>sales</code> and <code>time_view</code>, because there is no basis for losslessness of the delta materialized view join. With the additional constraints as shown previously, this query will also rewrite.</p>
<pre>
SELECT p.prod_category, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p WHERE p.prod_id = s.prod_id
GROUP BY p.prod_category;
</pre>
<p>To undo the changes you have made to the <code>sh</code> schema, issue the following statements:</p>
<pre>
ALTER TABLE sales DROP CONSTRAINT time_view_fk;
DROP VIEW time_view;
</pre></div>
<!-- class="example" -->
<a id="DWHSG8548"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref951"></a>
<h4 class="sect3">View Constraints Restrictions</h4>
<p>If the referential constraint definition involves a view, that is, either the foreign key or the referenced key resides in a view, the constraint can only be in <code>DISABLE</code> <code>NOVALIDATE</code> mode.</p>
<p>A <code>RELY</code> constraint on a view is allowed only if the referenced <code>UNIQUE</code> or <code>PRIMARY</code> <code>KEY</code> constraint in <code>DISABLE</code> <code>NOVALIDATE</code> mode is also a <code>RELY</code> constraint.</p>
<p>The specification of <code>ON</code> <code>DELETE</code> actions associated with a referential Integrity constraint, is not allowed (for example, <code>DELETE</code> cascade). However, <code>DELETE</code>, <code>UPDATE</code>, and <code>INSERT</code> operations are allowed on views and their base tables as view constraints are in <code>DISABLE</code> <code>NOVALIDATE</code> mode.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABBFAJD"></a><a id="DWHSG08037"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite Using Set Operator Materialized Views</h3>
<p>You<a id="sthref952"></a> can use query rewrite with materialized views that contain set operators. In this case, the query and materialized view do not have to match textually for rewrite to occur. As an example, consider the following materialized view, which uses the postal codes for male customers from San Francisco or Los Angeles:</p>
<pre>
CREATE MATERIALIZED VIEW cust_male_postal_mv
ENABLE QUERY REWRITE AS
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'M' AND c.cust_city = 'San Francisco'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'M' AND c.cust_city = 'Los Angeles';
</pre>
<p>If you have the following query, which displays the postal codes for male customers from San Francisco or Los Angeles:</p>
<pre>
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'Los Angeles' AND c.cust_gender = 'M'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'San Francisco' AND c.cust_gender = 'M';
</pre>
<p>The rewritten query will be the following:</p>
<pre>
SELECT mv.cust_city, mv.cust_postal_code
FROM cust_male_postal_mv mv;
</pre>
<p>The rewritten query has dropped the <code>UNION</code> <code>ALL</code> and replaced it with the materialized view. Normally, query rewrite has to use the existing set of general eligibility rules to determine if the <code>SELECT</code> subselections under the <code>UNION</code> <code>ALL</code> are equivalent in the query and the materialized view.</p>
<p>If, for example, you have a query that retrieves the postal codes for male customers from San Francisco, Palmdale, or Los Angeles, the same rewrite can occur as in the previous example but query rewrite must keep the <code>UNION</code> <code>ALL</code> with the base tables, as in the following:</p>
<pre>
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city= 'Palmdale' AND c.cust_gender ='M'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'Los Angeles' AND c.cust_gender = 'M'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'San Francisco' AND c.cust_gender = 'M';
</pre>
<p>The rewritten query will be:</p>
<pre>
SELECT mv.cust_city, mv.cust_postal_code
FROM cust_male_postal_mv mv
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'Palmdale' AND c.cust_gender = 'M';
</pre>
<p>So query rewrite detects the case where a subset of the <code>UNION</code> <code>ALL</code> can be rewritten using the materialized view <code>cust_male_postal_mv</code>.</p>
<p><code>UNION</code>, <code>UNION</code> <code>ALL</code>, and <code>INTERSECT</code> are commutative, so query rewrite can rewrite regardless of the order the subselects are found in the query or materialized view. However, <code>MINUS</code> is not commutative. A <code>MINUS</code> B is not equivalent to B <code>MINUS</code> A. Therefore, the order in which the subselects appear under the <code>MINUS</code> operator in the query and the materialized view must be in the same order for rewrite to happen. As an example, consider the case where there exists an old version of the customer table called <code>customer_old</code> and you want to find the difference between the old one and the current customer table only for male customers who live in London. That is, you want to find those customers in the current one that were not in the old one. The following example shows how this is done using a <code>MINUS</code> operator:</p>
<pre>
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city= 'Los Angeles' AND c.cust_gender = 'M'
MINUS
SELECT c.cust_city, c.cust_postal_code
FROM customers_old c
WHERE c.cust_city = 'Los Angeles' AND c.cust_gender = 'M';
</pre>
<p>Switching the subselects would yield a different answer. This illustrates that <code>MINUS</code> is not commutative.</p>
<a id="BABEAHIA"></a><a id="DWHSG8549"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">UNION ALL Marker</h4>
<p>If a materialized view contains one or more <code>UNION</code> <code>ALL</code> operators, it can also include a <code>UNION</code> <code>ALL</code> marker. The <code>UNION</code> <code>ALL</code> marker is used to identify from which <code>UNION</code> <code>ALL</code> subselect each row in the materialized view originates. Query rewrite can use the marker to distinguish what rows coming from the materialized view belong to a certain <code>UNION</code> <code>ALL</code> subselect. This is useful if the query needs only a subset of the data from the materialized view or if the subselects of the query do not textually match with the subselects of the materialized view. As an example, the following query retrieves the postal codes for male customers from San Francisco and female customers from Los Angeles:</p>
<pre>
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'M' and c.cust_city = 'San Francisco'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'F' and c.cust_city = 'Los Angeles';
</pre>
<p>The query can be answered using the following materialized view:</p>
<pre>
CREATE MATERIALIZED VIEW cust_postal_mv
ENABLE QUERY REWRITE AS
SELECT 1 AS marker, c.cust_gender, c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'Los Angeles'
UNION ALL
SELECT 2 AS marker, c.cust_gender, c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'San Francisco';
</pre>
<p>The rewritten query is as follows:</p>
<pre>
SELECT mv.cust_city, mv.cust_postal_code
FROM cust_postal_mv mv
WHERE mv.marker = 2 AND mv.cust_gender = 'M'
UNION ALL
SELECT mv.cust_city, mv.cust_postal_code
FROM cust_postal_mv mv
WHERE mv.marker = 1 AND mv.cust_gender = 'F';
</pre>
<p>The <code>WHERE</code> clause of the first subselect includes <code>mv.marker = 2</code> and <code>mv.cust_gender = 'M'</code>, which selects only the rows that represent male customers in the second subselect of the <code>UNION</code> <code>ALL</code>. The <code>WHERE</code> clause of the second subselect includes <code>mv.marker = 1</code> and <code>mv.cust_gender = 'F'</code>, which selects only those rows that represent female customers in the first subselect of the <code>UNION</code> <code>ALL</code>. Note that query rewrite cannot take advantage of set operators that drop duplicate or distinct rows. For example, <code>UNION</code> drops duplicates so query rewrite cannot tell what rows have been dropped, as in the following:</p>
<pre>
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city= 'Palmdale' AND c.cust_gender ='M'
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'M' and c.cust_city = 'San Francisco'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'F' and c.cust_city = 'Los Angeles';
</pre>
<p>The rewritten query using <code>UNION</code> <code>ALL</code> markers is as follows:</p>
<pre>
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city= 'Palmdale' AND c.cust_gender ='M'
UNION ALL
SELECT mv.cust_city, mv.cust_postal_code

FROM cust_postal_mv mv
WHERE mv.marker = 2 AND mv.cust_gender = 'M'
UNION ALL
  SELECT mv.cust_city, mv.cust_postal_code
  FROM cust_postal_mv mv
  WHERE mv.marker = 1 AND mv.cust_gender = 'F';
</pre>
<p>The rules for using a marker are that it must:</p>
<ul>
<li>
<p>Be a constant number or string and be the same data type for all <code>UNION</code> <code>ALL</code> subselects.</p>
</li>
</ul>
<ul>
<li>
<p>Yield a constant, distinct value for each <code>UNION</code> <code>ALL</code> subselect. You cannot reuse the same value in multiple subselects.</p>
</li>
</ul>
<ul>
<li>
<p>Be in the same ordinal position for all subselects.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDCFFH"></a><a id="DWHSG08038"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite in the Presence of Grouping Sets</h3>
<p>This section discusses various considerations for using query rewrite with grouping sets.</p>
<a id="i1007291"></a><a id="DWHSG8550"></a>
<div class="sect3">
<h4 class="sect3">Query Rewrite When Using GROUP BY Extensions</h4>
<p>Several <a id="sthref953"></a>extensions to the <code>GROUP</code> <code>BY</code> clause in the form of <code>GROUPING</code> <code>SETS</code>, <code>CUBE, ROLLUP</code>, and their concatenation are available. These extensions enable you to selectively specify the groupings of interest in the <code>GROUP</code> <code>BY</code> clause of the query. For example, the following is a typical query with grouping sets:</p>
<pre>
SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city, 
  SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, customers c, products p, times t
WHERE s.time_id=t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS ((p.prod_subcategory, t.calendar_month_desc),
   (c.cust_city, p.prod_subcategory));
</pre>
<p>The term <span class="bold">base</span> <span class="bold">grouping</span> for queries with <code>GROUP</code> <code>BY</code> extensions denotes all unique expressions present in the <code>GROUP</code> <code>BY</code> clause. In the previous query, the following grouping (<code>p.prod_subcategory, t.calendar_month_desc, c.cust_city</code>) is a base grouping.</p>
<p>The extensions can be present in user queries and in the queries defining materialized views. In both cases, materialized view rewrite applies and you can distinguish rewrite capabilities into the following scenarios:</p>
<ul>
<li>
<p><a href="#i1018660">Materialized View has Simple GROUP BY and Query has Extended GROUP BY</a></p>
</li>
<li>
<p><a href="#i1018682">Materialized View has Extended GROUP BY and Query has Simple GROUP BY</a></p>
</li>
<li>
<p><a href="#i1018683">Both Materialized View and Query Have Extended GROUP BY</a></p>
</li>
</ul>
<a id="i1018660"></a><a id="DWHSG8551"></a>
<div class="sect4">
<h5 class="sect4">Materialized View has Simple GROUP BY and Query has Extended GROUP BY</h5>
<p>When a query contains an extended <code>GROUP</code> <code>BY</code> clause, it can be rewritten with a materialized view if its base grouping can be rewritten using the materialized view as listed in the rewrite rules explained in <a href="qrbasic.htm#i1006240">"When Does Oracle Rewrite a Query?"</a>. For example, in the following query:</p>
<pre>
SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city, 
  SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, customers c, products p, times t
WHERE s.time_id=t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS 
((p.prod_subcategory, t.calendar_month_desc), 
   (c.cust_city, p.prod_subcategory));
</pre>
<p>The base grouping is <code>(p.prod_subcategory, t.calendar_month_desc, c.cust_city, p.prod_subcategory))</code> and, consequently, Oracle can rewrite the query using <code>sum_sales_pscat_month_city_mv</code> as follows:</p>
<pre>
SELECT mv.prod_subcategory, mv.calendar_month_desc, mv.cust_city,
  SUM(mv.sum_amount_sold) AS sum_amount_sold
FROM sum_sales_pscat_month_city_mv mv
GROUP BY GROUPING SETS 
((mv.prod_subcategory, mv.calendar_month_desc), 
  (mv.cust_city, mv.prod_subcategory));
</pre>
<p>A special situation arises if the query uses the <code>EXPAND_GSET_TO_UNION</code> hint. See <a href="#i1007474">"Hint for Queries with Extended GROUP BY"</a> for an example of using <code>EXPAND_GSET_TO_UNION</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i1018682"></a><a id="DWHSG8552"></a>
<div class="sect4">
<h5 class="sect4">Materialized View has Extended GROUP BY and Query has Simple GROUP BY</h5>
<p>In order for a materialized view with an extended <code>GROUP</code> <code>BY</code> to be used for rewrite, it must satisfy two additional conditions:</p>
<ul>
<li>
<p>It must contain a grouping distinguisher, which is the <code>GROUPING_ID</code> function on all <code>GROUP</code> <code>BY</code> expressions. For example, if the <code>GROUP</code> <code>BY</code> clause of the materialized view is <code>GROUP</code> <code>BY</code> <code>CUBE(a, b)</code>, then the <code>SELECT</code> list should contain <code>GROUPING_ID(a, b)</code>.</p>
</li>
<li>
<p>The <code>GROUP</code> <code>BY</code> clause of the materialized view should not result in any duplicate groupings. For example, <code>GROUP BY GROUPING SETS ((a, b), (a, b))</code> would disqualify a materialized view from general rewrite.</p>
</li>
</ul>
<p>A materialized view with an extended <code>GROUP</code> <code>BY</code> contains multiple groupings. Oracle finds the grouping with the lowest cost from which the query can be computed and uses that for rewrite. For example, consider the following materialized view:</p>
<pre>
CREATE MATERIALIZED VIEW sum_grouping_set_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_category, p.prod_subcategory, c.cust_state_province, c.cust_city,
  GROUPING_ID(p.prod_category,p.prod_subcategory,
              c.cust_state_province,c.cust_city) AS gid,
  SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS 
((p.prod_category, p.prod_subcategory, c.cust_city), 
  (p.prod_category, p.prod_subcategory, c.cust_state_province, c.cust_city),
  (p.prod_category, p.prod_subcategory));
</pre>
<p>In this case, the following query is rewritten:</p>
<pre>
SELECT p.prod_subcategory, c.cust_city, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY p.prod_subcategory, c.cust_city;
</pre>
<p>This query is rewritten with the closest matching grouping from the materialized view. That is, the <code>(prod_category, prod_subcategory, cust_city)</code> grouping:</p>
<pre>
SELECT prod_subcategory, cust_city, SUM(sum_amount_sold) AS sum_amount_sold
FROM sum_grouping_set_mv
WHERE gid = <span class="italic">grouping identifier of (prod_category,prod_subcategory, cust_city)</span>
GROUP BY prod_subcategory, cust_city;
</pre></div>
<!-- class="sect4" -->
<a id="i1018683"></a><a id="DWHSG8553"></a>
<div class="sect4">
<h5 class="sect4">Both Materialized View and Query Have Extended GROUP BY</h5>
<p>When both materialized view and the query contain <code>GROUP</code> <code>BY</code> extensions, Oracle uses two strategies for rewrite: grouping match and <code>UNION</code> <code>ALL</code> rewrite. First, Oracle tries grouping match. The groupings in the query are matched against groupings in the materialized view and if all are matched with no rollup, Oracle selects them from the materialized view. For example, consider the following query:</p>
<pre>
SELECT p.prod_category, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS 
((p.prod_category, p.prod_subcategory, c.cust_city), 
  (p.prod_category, p.prod_subcategory));
</pre>
<p>This query matches two groupings from <code>sum_grouping_set_mv</code> and Oracle rewrites the query as the following:</p>
<pre>
SELECT prod_subcategory, cust_city, sum_amount_sold
FROM sum_grouping_set_mv
WHERE gid = <span class="italic">grouping identifier of (prod_category,prod_subcategory, cust_city)</span>
   OR gid = <span class="italic">grouping identifier of (prod_category,prod_subcategory)</span>
</pre>
<p>If grouping match fails, Oracle tries a general rewrite mechanism called <code>UNION</code> <code>ALL</code> rewrite. Oracle first represents the query with the extended <code>GROUP</code> <code>BY</code> clause as an equivalent <code>UNION</code> <code>ALL</code> query. Every grouping of the original query is placed in a separate <code>UNION</code> <code>ALL</code> branch. The branch will have a simple <code>GROUP</code> <code>BY</code> clause. For example, consider this query:</p>
<pre>
SELECT p.prod_category, p.prod_subcategory, c.cust_state_province, 
  t.calendar_month_desc, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS 
((p.prod_subcategory, t.calendar_month_desc), 
  (t.calendar_month_desc), 
  (p.prod_category, p.prod_subcategory, c.cust_state_province), 
  (p.prod_category, p.prod_subcategory));
</pre>
<p>This is first represented as <code>UNION</code> <code>ALL</code> with four branches:</p>
<pre>
SELECT null, p.prod_subcategory, null,
    t.calendar_month_desc, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY p.prod_subcategory, t.calendar_month_desc
UNION ALL
  SELECT null, null, null,
    t.calendar_month_desc, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY t.calendar_month_desc
UNION ALL
SELECT p.prod_category, p.prod_subcategory, c.cust_state_province,
    null, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY p.prod_category, p.prod_subcategory, c.cust_state_province
UNION ALL 
  SELECT p.prod_category, p.prod_subcategory, null,
    null, SUM(s.amount_sold) AS sum_amount_sold
  FROM sales s, products p, customers c, times t
  WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
  GROUP BY p.prod_category, p.prod_subcategory;
</pre>
<p>Each branch is then rewritten separately using the rules from <a href="qrbasic.htm#i1006240">"When Does Oracle Rewrite a Query?"</a>. Using the materialized view <code>sum_grouping_set_mv</code>, Oracle can rewrite only branches three (which requires materialized view rollup) and four (which matches the materialized view exactly). The unrewritten branches will be converted back to the extended <code>GROUP</code> <code>BY</code> form. Thus, eventually, the query is rewritten as:</p>
<pre>
SELECT null, p.prod_subcategory, null,
    t.calendar_month_desc, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS
  ((p.prod_subcategory, t.calendar_month_desc),
    (t.calendar_month_desc),)
UNION ALL
  SELECT prod_category, prod_subcategory, cust_state_province,
    null, SUM(sum_amount_sold) AS sum_amount_sold
  FROM sum_grouping_set_mv
  WHERE gid = &lt;grouping id of (prod_category,prod_subcategory, cust_city)&gt;
  GROUP BY p.prod_category, p.prod_subcategory, c.cust_state_province
UNION ALL 
  SELECT prod_category, prod_subcategory, null,
    null, sum_amount_sold
  FROM sum_grouping_set_mv 
  WHERE gid = &lt;grouping id of (prod_category,prod_subcategory)&gt;
</pre>
<p>Note that a query with extended <code>GROUP</code> <code>BY</code> is represented as an equivalent <code>UNION</code> <code>ALL</code> and recursively submitted for rewrite optimization. The groupings that cannot be rewritten stay in the last branch of <code>UNION</code> <code>ALL</code> and access the base data instead.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1007474"></a><a id="DWHSG8554"></a>
<div class="sect3">
<h4 class="sect3">Hint for Queries with Extended GROUP BY</h4>
<p>You can <a id="sthref954"></a><a id="sthref955"></a>use the <code>EXPAND_GSET_TO_UNION</code> hint to force expansion of the query with <code>GROUP</code> <code>BY</code> extensions into the equivalent <code>UNION</code> <code>ALL</code> query. This hint can be used in an environment where materialized views have simple <code>GROUP</code> <code>BY</code> clauses only. In this case, Oracle extends rewrite flexibility as each branch can be independently rewritten by a separate materialized view. See <a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information regarding <code>EXPAND_GSET_TO_UNION</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABIIFEJ"></a><a id="DWHSG08039"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite in the Presence of Window Functions</h3>
<p>Window functions are used to compute cumulative, moving and centered aggregates. These functions work with the following aggregates: <code>SUM</code>, <code>AVG</code>, <code>MIN</code>/<code>MAX</code>., <code>COUNT</code>, <code>VARIANCE</code>, <code>STDDEV</code>, <code>FIRST_VALUE</code>, and <code>LAST_VALUE</code>. A query with window function can be rewritten using exact text match rewrite. This requires that the materialized view definition also matches the query exactly. When there is no window function on the materialized view, then a query with a window function can be rewritten provided the aggregate in the query is found in the materialized view and all other eligibility checks such as the join computability checks are successful. A window function on the query is compared to the window function in the materialized view using its canonical form format. This enables query rewrite to rewrite even complex window functions.</p>
<p>When a query with a window function requires rollup during query rewrite, query rewrite will, whenever possible, split the query into an inner query with the aggregate and an outer query with the windowing function. This permits query rewrite to rewrite the aggregate in the inner query before applying the window function. One exception is when the query has both a window function and grouping sets. In this case, presence of the grouping set prevents query rewrite from splitting the query so query rewrite does not take place in this case.</p>
</div>
<!-- class="sect2" -->
<a id="BABJFABD"></a><a id="DWHSG08040"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite and Expression Matching</h3>
<p><a id="sthref956"></a><a id="sthref957"></a>An expression that appears in a query can be replaced with a simple column in a materialized view provided the materialized view column represents a precomputed expression that matches with the expression in the query. If a query can be rewritten to use a materialized view, it will be faster. This is because materialized views contain precomputed calculations and do not need to perform expression computation.</p>
<p>The expression matching is done by first converting the expressions into canonical forms and then comparing them for equality. Therefore, two different expressions will generally be matched as long as they are equivalent to each other. Further, if the entire expression in a query fails to match with an expression in a materialized view, then subexpressions of it are tried to find a match. The subexpressions are tried in a top-down order to get maximal expression matching.</p>
<p>Consider a query that asks for sum of sales by age brackets (1-10, 11-20, 21-30, and so on).</p>
<pre>
CREATE MATERIALIZED VIEW sales_by_age_bracket_mv
ENABLE QUERY REWRITE AS
SELECT TO_CHAR((2000-c.cust_year_of_birth)/10-0.5,999) AS age_bracket,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, customers c WHERE s.cust_id=c.cust_id
GROUP BY TO_CHAR((2000-c.cust_year_of_birth)/10-0.5,999);
</pre>
<p>The following query rewrites, using expression matching:</p>
<pre>
SELECT TO_CHAR(((2000-c.cust_year_of_birth)/10)-0.5,999), SUM(s.amount_sold) 
FROM sales s, customers c WHERE s.cust_id=c.cust_id
GROUP BY TO_CHAR((2000-c.cust_year_of_birth)/10-0.5,999);
</pre>
<p>This query is rewritten in terms of <code>sales_by_age_bracket_mv</code> based on the matching of the canonical forms of the age bracket expressions (that is, 2000 - <code>c.cust_year_of_birth</code>)/10-0.5), as follows:</p>
<pre>
SELECT age_bracket, sum_amount_sold FROM sales_by_age_bracket_mv;
</pre>
<a id="i1007143"></a><a id="DWHSG8555"></a>
<div class="sect3">
<h4 class="sect3">Query Rewrite Using Partially Stale Materialized Views</h4>
<p>Whe<a id="sthref958"></a>n a partition of the detail table is updated, only specific sections of the materialized view are marked stale. The materialized view must have information that can identify the partition of the table corresponding to a particular row or group of the materialized view. The simplest scenario is when the partitioning key of the table is available in the <code>SELECT</code> list of the materialized view because this is the easiest way to map a row to a stale partition. The key points when using partially stale materialized views are:</p>
<ul>
<li>
<p>Query rewrite can use a materialized view in <code>ENFORCED</code> or <code>TRUSTED</code> mode if the rows from the materialized view used to answer the query are known to be <code>FRESH</code>.</p>
</li>
<li>
<p>The fresh rows in the materialized view are identified by adding selection predicates to the materialized view's <code>WHERE</code> clause. Oracle rewrites a query with this materialized view if its answer is contained within this (restricted) materialized view.</p>
</li>
</ul>
<p>The fact table <code>sales</code> is partitioned based on ranges of <code>time_id</code> as follows:</p>
<pre>
PARTITION BY RANGE (time_id)
(PARTITION SALES_Q1_1998 
           VALUES LESS THAN (TO_DATE('01-APR-1998', 'DD-MON-YYYY')),
 PARTITION SALES_Q2_1998 
           VALUES LESS THAN (TO_DATE('01-JUL-1998', 'DD-MON-YYYY')),
 PARTITION SALES_Q3_1998 
           VALUES LESS THAN (TO_DATE('01-OCT-1998', 'DD-MON-YYYY')), 
...
</pre>
<p>Suppose you have a materialized view grouping by <code>time_id</code> as follows:</p>
<pre>
CREATE MATERIALIZED VIEW sum_sales_per_city_mv
ENABLE QUERY REWRITE AS
SELECT s.time_id, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id
GROUP BY time_id, prod_subcategory, cust_city;
</pre>
<p>Also suppose new data will be inserted for December 2000, which will be assigned to partition <code>sales_q4_2000</code>. For testing purposes, you can apply an arbitrary DML operation on <code>sales</code>, changing a different partition than <code>sales_q1_2000</code> as the following query requests data in this partition when this materialized view is fresh. For example, the following:</p>
<pre>
INSERT INTO SALES VALUES(17, 10, '01-DEC-2000', 4, 380, 123.45, 54321);
</pre>
<p>Until a refresh is done, the materialized view is generically stale and cannot be used for unlimited rewrite in enforced mode. However, because the table <code>sales</code> is partitioned and not all partitions have been modified, Oracle can identify all partitions that have not been touched. The optimizer can identify the fresh rows in the materialized view (the data which is unaffected by updates since the last refresh operation) by implicitly adding selection predicates to the materialized view defining query as follows:</p>
<pre>
SELECT s.time_id, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id
AND   s.time_id &lt; TO_DATE('01-OCT-2000','DD-MON-YYYY') 
OR s.time_id &gt;= TO_DATE('01-OCT-2001','DD-MON-YYYY'))
GROUP BY time_id, prod_subcategory, cust_city;
</pre>
<p>Note that the freshness of partially stale materialized views is tracked on a per-partition base, and not on a logical base. Because the partitioning strategy of the <code>sales</code> fact table is on a quarterly base, changes in December 2000 causes the complete partition <code>sales_q4_2000</code> to become stale.</p>
<p>Consider the following query, which asks for sales in quarters 1 and 2 of 2000:</p>
<pre>
SELECT s.time_id, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id
AND   s.time_id BETWEEN TO_DATE('01-JAN-2000', 'DD-MON-YYYY')
AND TO_DATE('01-JUL-2000', 'DD-MON-YYYY')
GROUP BY time_id, prod_subcategory, cust_city;
</pre>
<p>Oracle Database knows that those ranges of rows in the materialized view are fresh and can therefore rewrite the query with the materialized view. The rewritten query looks as follows:</p>
<pre>
SELECT time_id, prod_subcategory, cust_city, sum_amount_sold
FROM sum_sales_per_city_mv
WHERE time_id BETWEEN TO_DATE('01-JAN-2000', 'DD-MON-YYYY')
AND TO_DATE('01-JUL-2000', 'DD-MON-YYYY');
</pre>
<p>Instead of the partitioning key, a partition marker (a function that identifies the partition given a rowid) can be present in the <code>SELECT</code> (and <code>GROUP</code> <code>BY</code> list) of the materialized view. You can use the materialized view to rewrite queries that require data from only certain partitions (identifiable by the partition-marker), for instance, queries that have a predicate specifying ranges of the partitioning keys containing entire partitions. See <a href="advmv.htm#g1014110">Chapter 10, "Advanced Materialized Views"</a> for details regarding the supplied partition marker function <code>DBMS_MVIEW.PMARKER</code>.</p>
<p>The following example illustrates the use of a partition marker in the materialized view instead of directly using the partition key column:</p>
<pre>
CREATE MATERIALIZED VIEW sum_sales_per_city_2_mv
ENABLE QUERY REWRITE AS
SELECT DBMS_MVIEW.PMARKER(s.rowid) AS pmarker,
       t.fiscal_quarter_desc, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id
AND   s.time_id = t.time_id
GROUP BY DBMS_MVIEW.PMARKER(s.rowid),
    p.prod_subcategory, c.cust_city, t.fiscal_quarter_desc;
</pre>
<p>Suppose you know that the partition <code>sales_q1_2000</code> is fresh and DML changes have taken place for other partitions of the <code>sales</code> table. For testing purposes, you can apply an arbitrary DML operation on <code>sales</code>, changing a different partition than <code>sales_q1_2000</code> when the materialized view is fresh. An example is the following:</p>
<pre>
INSERT INTO SALES VALUES(17, 10, '01-DEC-2000', 4, 380, 123.45, 54321);
</pre>
<p>Although the materialized view <code>sum_sales_per_city_2_mv</code> is now considered generically stale, Oracle Database can rewrite the following query using this materialized view. This query restricts the data to the partition <code>sales_q1_2000</code>, and selects only certain values of <code>cust_city</code>, as shown in the following:</p>
<pre>
SELECT p.prod_subcategory, c.cust_city, SUM(s.amount_sold) AS sum_amount_sold 
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
AND c.cust_city= 'Nuernberg' 
AND s.time_id &gt;=TO_DATE('01-JAN-2000','dd-mon-yyyy')
AND s.time_id &lt;  TO_DATE('01-APR-2000','dd-mon-yyyy') 
GROUP BY prod_subcategory, cust_city;
</pre>
<p>Note that rewrite with a partially stale materialized view that contains a <code>PMARKER</code> function can only take place when the complete data content of one or more partitions is accessed and the predicate condition is on the partitioned fact table itself, as shown in the earlier example.</p>
<p>The <code>DBMS_MVIEW.PMARKER</code> function gives you exactly one distinct value for each partition. This dramatically reduces the number of rows in a potential materialized view compared to the partitioning key itself, but you are also giving up any detailed information about this key. The only information you know is the partition number and, therefore, the lower and upper boundary values. This is the trade-off for reducing the cardinality of the range partitioning column and thus the number of rows.</p>
<p>Assuming the value of <code>p_marker</code> for partition <code>sales_q1_2000</code> is 31070, the previously shown queries can be rewritten against the materialized view as follows:</p>
<pre>
SELECT mv.prod_subcategory, mv.cust_city, SUM(mv.sum_amount_sold) 
FROM sum_sales_per_city_2_mv mv 
WHERE mv.pmarker = 31070 AND mv.cust_city= 'Nuernberg'
GROUP BY prod_subcategory, cust_city; 
</pre>
<p>So the query can be rewritten against the materialized view without accessing stale data.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABJCIDD"></a><a id="DWHSG08041"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Cursor Sharing and Bind Variables</h3>
<p>Query<a id="sthref959"></a><a id="sthref960"></a> rewrite is supported when the query contains user bind variables as long as the actual bind values are not required during query rewrite. If the actual values of the bind variables are required during query rewrite, then we say that query rewrite is dependent on the bind values. Because the user bind variables are not available during query rewrite time, if query rewrite is dependent on the bind values, it is not possible to rewrite the query. For example, consider the following materialized view, <code>customer_mv</code>, which has the predicate, (<code>customer_id &gt;= 1000</code>), in the <code>WHERE</code> clause:</p>
<pre>
CREATE MATERIALIZED VIEW customer_mv
ENABLE QUERY REWRITE AS
SELECT cust_id, prod_id,  SUM(amount_sold) AS total_amount
FROM sales WHERE cust_id &gt;= 1000
GROUP BY cust_id, prod_id;
</pre>
<p>Consider the following query, which has a user bind variable, <code>:user_id</code>, in its <code>WHERE</code> clause:</p>
<pre>
SELECT cust_id, prod_id, SUM(amount_sold) AS sum_amount
FROM sales WHERE cust_id &gt; :user_id
GROUP BY cust_id, prod_id;
</pre>
<p>Because the materialized view, <code>customer_mv</code>, has a selection in its <code>WHERE</code> clause, query rewrite is dependent on the actual value of the user bind variable, <code>user_id</code>, to compute the containment. Because <code>user_id</code> is not available during query rewrite time and query rewrite is dependent on the bind value of <code>user_id</code>, this query cannot be rewritten.</p>
<p>Even though the preceding example has a user bind variable in the <code>WHERE</code> clause, the same is true regardless of where the user bind variable appears in the query. In other words, irrespective of where a user bind variable appears in a query, if query rewrite is dependent on its value, then the query cannot be rewritten.</p>
<p>Now consider the following query which has a user bind variable, <code>:user_id</code>, in its <code>SELECT</code> list:</p>
<pre>
SELECT cust_id + :user_id, prod_id, SUM(amount_sold) AS total_amount
FROM sales WHERE cust_id &gt;= 2000
GROUP BY cust_id, prod_id;
</pre>
<p>Because the value of the user bind variable, <code>user_id</code>, is not required during query rewrite time, the preceding query will rewrite.</p>
<pre>
SELECT cust_id + :user_id, prod_id, total_amount
FROM customer_mv;
</pre></div>
<!-- class="sect2" -->
<a id="BABIEFBI"></a><a id="DWHSG08042"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Handling Expressions in Query Rewrite</h3>
<p>Rewrite with some expressions is also supported when the expression evaluates to a constant, such as <code>TO_DATE(</code><code>'</code><code>12-SEP-1999</code><code>'</code><code>,</code><code>'</code><code>DD-Mon-YYYY</code><code>'</code><code>)</code>. For example, if an existing materialized view is defined as:</p>
<pre>
CREATE MATERIALIZED VIEW sales_on_valentines_day_99_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS
SELECT s.prod_id, s.cust_id, s.amount_sold
FROM times t, sales s WHERE s.time_id = t.time_id
AND t.time_id = TO_DATE('14-FEB-1999', 'DD-MON-YYYY');
</pre>
<p>Then the following query can be rewritten:</p>
<pre>
SELECT s.prod_id, s.cust_id, s.amount_sold
FROM sales s, times t WHERE s.time_id = t.time_id
AND t.time_id = TO_DATE('14-FEB-1999', 'DD-MON-YYYY');
</pre>
<p>This query would be rewritten as follows:</p>
<pre>
SELECT * FROM sales_on_valentines_day_99_mv;
</pre>
<p>Whenever <code>TO_DATE</code> is used, query rewrite only occurs if the date mask supplied is the same as the one specified by the <code>NLS_DATE_FORMAT</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1010537"></a><a id="DWHSG0804"></a>
<div class="sect1">
<h2 class="sect1">Advanced Query Rewrite Using Equivalences</h2>
<p>There is<a id="sthref961"></a><a id="sthref962"></a> a special type of query rewrite that is possible where a declaration is made that two SQL statements are functionally equivalent. This capability enables you to place inside application knowledge into the database so the database can exploit this knowledge for improved query performance. You do this by declaring two <code>SELECT</code> statements to be functionally equivalent (returning the same rows and columns) and indicating that one of the <code>SELECT</code> statements is more favorable for performance.</p>
<p>This advanced rewrite capability can generally be applied to a variety of query performance problems and opportunities. Any application can use this capability to affect rewrites against complex user queries that can be answered with much simpler and more performant queries that have been specifically created, usually by someone with inside application knowledge.</p>
<p>There are many scenarios where you can have inside application knowledge that would allow SQL statement transformation and tuning for significantly improved performance. The types of optimizations you may wish to affect can be very simple or as sophisticated as significant restructuring of the query. However, the incoming SQL queries are often generated by applications and you have no control over the form and structure of the application-generated queries.</p>
<p>To gain access to this capability, you need to connect as <code>SYSDBA</code> and explicitly grant execute access to the desired database administrators who will be declaring rewrite equivalences. See <a class="olink ARPLS083" href="../../appdev.112/e40758/d_advrwr.htm#ARPLS083"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information.</p>
<p>To illustrate this type of advanced rewrite, some examples using multidimensional data are provided. To optimize resource usage, an application may employ complicated SQL, custom C code or table functions to retrieve the data from the database. This complexity is irrelevant as far as end users are concerned. Users would still want to obtain their answers using typical queries with <code>SELECT</code> ... <code>GROUP</code> <code>BY</code>.</p>
<p>The following example declares to Oracle that a given user query must be executed using a specified alternative query. Oracle would recognize this relationship and every time the user asked the query, it would transparently rewrite it using the alternative. Thus, the user is saved from the trouble of understanding and writing SQL for complicated aggregate computations.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8556"></a><a id="sthref963"></a>Example 19-11 Rewrite Using Equivalence</p>
<p>There are two base tables <code>sales_fact</code> and <code>geog_dim</code>. You can compute the total sales for each city, state and region with a rollup, by issuing the following statement:</p>
<pre>
SELECT g.region, g.state, g.city,
GROUPING_ID(g.city, g.state, g.region), SUM(sales)
FROM sales_fact f, geog_dim g WHERE f.geog_key = g.geog_key
GROUP BY ROLLUP(g.region, g.state, g.city);
</pre>
<p>An application may want to materialize this query for quick results. Unfortunately, the resulting materialized view occupies too much disk space. However, if you have a dimension rolling up city to state to region, you can easily compress the three grouping columns into one column using a decode statement. (This is also known as an embedded total):</p>
<pre>
DECODE (gid, 0, city, 1, state, 3, region, 7, "grand_total")
</pre>
<p>What this does is use the lowest level of the hierarchy to represent the entire information. For example, saying <code>Boston</code> means <code>Boston, MA, New England Region</code> and saying <code>CA</code> means <code>CA, Western Region</code>. An application can store these embedded total results into a table, say, <code>embedded_total_sales</code>.</p>
<p>However, when returning the result back to the user, you would want to have all the data columns (city, state, region). In order to return the results efficiently and quickly, an application may use a custom table function (<code>et_function</code>) to retrieve the data back from the <code>embedded_total_sales</code> table in the expanded form as follows:</p>
<pre>
SELECT * FROM TABLE (et_function);
</pre>
<p>In other words, this feature allows an application to declare the equivalence of the user's preceding query to the alternative query, as in the following:</p>
<pre>
DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE (
   'EMBEDDED_TOTAL',
   'SELECT g.region, g.state, g.city,
    GROUPING_ID(g.city, g.state, g.region), SUM(sales)
    FROM sales_fact f, geog_dim g
    WHERE f.geog_key = g.geog_key
    GROUP BY ROLLUP(g.region, g.state, g.city)',
    'SELECT * FROM TABLE(et_function)');
</pre>
<p>This invocation of <code>DECLARE_REWRITE_EQUIVALENCE</code> creates an equivalence declaration named <code>EMBEDDED_TOTAL</code> stating that the specified <code>SOURCE_STMT</code> and the specified <code>DESTINATION_STMT</code> are functionally equivalent, and that the specified <code>DESTINATION_STMT</code> is preferable for performance. After the DBA creates such a declaration, the user need have no knowledge of the space optimization being performed underneath the covers.</p>
<p>This capability also allows an application to perform specialized partial materializations of a SQL query. For instance, it could perform a rollup using a <code>UNION</code> <code>ALL</code> of three relations as shown in <a href="#BABIGJAH">Example 19-12</a>.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BABIGJAH"></a><a id="DWHSG8557"></a>Example 19-12 Rewrite Using Equivalence (UNION ALL)</p>
<pre>
CREATE MATERIALIZED VIEW T1
AS SELECT g.region, g.state, g.city, 0 AS gid, SUM(sales) AS sales
FROM sales_fact f, geog_dim g WHERE f.geog_key = g.geog_key
GROUP BY g.region, g.state, g.city;

CREATE MATERIALIZED VIEW T2 AS
SELECT t.region, t.state, SUM(t.sales) AS sales
FROM T1 GROUP BY t.region, t.state;

CREATE VIEW T3 AS
SELECT t.region, SUM(t.sales) AS sales
FROM T2 GROUP BY t.region;
</pre>
<p>The <code>ROLLUP(region, state, city)</code> query is then equivalent to:</p>
<pre>
SELECT * FROM T1 UNION ALL
SELECT region, state, NULL, 1 AS gid, sales FROM T2 UNION ALL
SELECT region, NULL, NULL, 3 AS gid, sales FROM T3 UNION ALL
SELECT NULL, NULL, NULL, 7 AS gid, SUM(sales) FROM T3;
</pre>
<p>By specifying this equivalence, Oracle Database would use the more efficient second form of the query to compute the <code>ROLLUP</code> query asked by the user.</p>
<pre>
DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE (
   'CUSTOM_ROLLUP',
   'SELECT g.region, g.state, g.city,
   GROUPING_ID(g.city, g.state, g.region), SUM(sales)
   FROM sales_fact f, geog_dim g
   WHERE f.geog_key = g.geog_key
   GROUP BY ROLLUP(g.region, g.state, g.city ',
   ' SELECT * FROM T1
   UNION ALL
   SELECT region, state, NULL, 1 as gid, sales FROM T2
   UNION ALL
   SELECT region, NULL, NULL, 3 as gid, sales FROM T3
   UNION ALL
   SELECT NULL, NULL, NULL, 7 as gid, SUM(sales) FROM T3');
</pre>
<p>Another application of this feature is to provide users special aggregate computations that may be conceptually simple but extremely complex to express in SQL. In this case, the application asks the user to use a specified custom aggregate function and internally compute it using complex SQL.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8558"></a><a id="sthref964"></a>Example 19-13 Rewrite Using Equivalence (Using a Custom Aggregate)</p>
<p>Suppose the application users want to see the sales for each city, state and region and also additional sales information for specific seasons. For example, the New England user wants additional sales information for cities in New England for the winter months. The application would provide you a special aggregate <code>Seasonal_Agg</code> that computes the earlier aggregate. You would ask a classic summary query but use <code>Seasonal_Agg(sales, region)</code> rather than <code>SUM(sales)</code>.</p>
<pre>
SELECT g.region, t.calendar_month_name, Seasonal_Agg(f.sales, g.region) AS sales
FROM sales_fact f, geog_dim g, times t
WHERE f.geog_key = g.geog_key AND f.time_id = t.time_id
GROUP BY g.region, t.calendar_month_name;
</pre>
<p>Instead of asking the user to write SQL that does the extra computation, the application can do it automatically for them by using this feature. In this example, <code>Seasonal_Agg</code> is computed using the spreadsheet functionality (see <a href="sqlmodel.htm#g1042989">Chapter 23, "SQL for Modeling"</a>). Note that even though <code>Seasonal_Agg</code> is a user-defined aggregate, the required behavior is to add extra rows to the query's answer, which cannot be easily done with simple PL/SQL functions.</p>
<pre>
DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE (
   'CUSTOM_SEASONAL_AGG',
   SELECT g.region, t.calendar_month_name, Seasonal_Agg(sales, region) AS sales
   FROM sales_fact f, geog_dim g, times t
   WHERE f.geog_key = g.geog_key AND f.time_id = t.time_id
   GROUP BY g.region, t.calendar_month_name',
   'SELECT g,region, t.calendar_month_name, SUM(sales) AS sales
   FROM sales_fact f, geog_dim g
   WHERE f.geog_key = g.geog_key AND t.time_id = f.time_id
   GROUP BY g.region, g.state, g.city, t.calendar_month_name
   DIMENSION BY g.region, t.calendar_month_name
   (sales ['New England', 'Winter'] = AVG(sales) OVER calendar_month_name IN
    ('Dec', 'Jan', 'Feb', 'Mar'),
   sales ['Western', 'Summer' ] = AVG(sales) OVER calendar_month_name IN
   ('May', 'Jun', 'July', 'Aug'), .);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="BABEAGAB"></a><a id="DWHSG0807"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Creating Result Cache Materialized Views with Equivalences</h2>
<p>A special type of materialized view, called a result cache materialized view (RCMV), enables you to use a result cache when running query rewrite. These result cache materialized views offer the main advantages of the result cache, faster access with less space required, without the normal drawback of being unable to run query rewrite against them.</p>
<p>An example of using this type of materialized view is the following.</p>
<div class="example">
<p class="titleinexample"><a id="sthref965"></a>Example 19-14 Result Cache Materialized View</p>
<p>First, we grant the requisite permissions.</p>
<pre>
CONNECT / AS SYSDBA
GRANT CREATE MATERIALIZED VIEW TO sh;
GRANT EXECUTE ON DBMS_ADVANCED_REWRITE TO sh;
</pre>
<p>Next, we create the result cache materialized view.</p>
<pre>
CONNECT sh/sh
begin
   sys.DBMS_ADVANCED_REWRITE.Declare_Rewrite_Equivalence
    (
     Name               =&gt; 'RCMV_SALES',
     Source_Stmt        =&gt;
      'select channel_id, prod_id, sum(amount_sold), count(amount_sold)
       from sales
       group by prod_id, channel_id',
     Destination_Stmt   =&gt;
      'select * from
      (select /*+ RESULT_CACHE(name=RCMV_SALES) */
               channel_id, prod_id, sum(amount_sold), count(amount_sold)
         from sales
         group by prod_id, channel_id)',
       Validate         =&gt; FALSE,
       Rewrite_Mode     =&gt; 'GENERAL'
       );
end;
/

ALTER SESSION SET query_rewrite_integrity = stale_tolerated;
</pre>
<p>Then, we verify that different queries all rewrite to <code>RCMV_SALES</code> by looking at the explain plan.</p>
<pre>
EXPLAIN PLAN FOR
  SELECT channel_id, SUM(amount_sold) FROM sales GROUP BY channel_id;
@?/rdbms/admin/utlxpls

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 3903632134
--------------------------------------------------------------------------------
|Id |         Operation       | Name  |Rows|Bytes|Cost(%CPU)| Time |Pstart|Pstop|
---------------------------------------------------------------------------------
| 0 | SELECT STATEMENT        |       |  4 |   64| 1340 (68)|00:00:17|    |    |
| 1 |  HASH GROUP BY          |       |  4 |   64| 1340 (68)|00:00:17|    |    |
| 2 |   VIEW                  |       | 204| 3264| 1340 (68)|00:00:17|    |    |
| 3 |    RESULT CACHE         |3gps5zr86gyb53y36js9zuay2s| | | |     |    |    |
| 4 |     HASH GROUP BY       |       | 204| 2448| 1340 (68)|00:00:17|    |    |
| 5 |      PARTITION RANGE ALL|       |918K|  10M|  655 (33)|00:00:08|  1 | 28 |
| 6 |       TABLE ACCESS FULL | SALES |918K|  10M|  655 (33)|00:00:08|  1 | 28 |
---------------------------------------------------------------------------------

Result Cache Information (identified by operation id):
------------------------------------------------------
   3 - column-count=4; dependencies=(SH.SALES); name="RCMV_SALES"

18 rows selected.
</pre>
<p>Then, we execute the query that creates the cached result.</p>
<pre>
SELECT channel_id, SUM(amount_sold)
FROM sales
GROUP BY channel_id;

CHANNEL_ID  SUM(AMOUNT_SOLD)
----------  ----------------
         2        26346342.3
         4          13706802
         3        57875260.6
         9         277426.26

</pre>
<p>Next, we verify that the materialized view was materialized in the result cache.</p>
<pre>
CONNECT / AS SYSDBA

SELECT name, scan_count hits, block_count blocks, depend_count dependencies
FROM V$RESULT_CACHE_OBJECTS
WHERE name = 'RCMV_SALES';

NAME         HITS    BLOCKS   DEPENDENCIES
----------   ----    ------   ------------
RCMV_SALES      0         5              1
</pre>
<p>Finally, we drop the RCMV query equivalence.</p>
<pre>
begin
  sys.DBMS_ADVANCED_REWRITE.Drop_Rewrite_equivalence('RCMV_SALES');
end;
/
</pre></div>
<!-- class="example" -->
<p>For more information regarding result caches, see <a class="olink PFGRF987" href="../../server.112/e41573/memory.htm#PFGRF987"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="i1007733"></a><a id="DWHSG0805"></a>
<div class="sect1">
<h2 class="sect1">Verifying that Query Rewrite has Occurred</h2>
<p>Because query rewrite occurs transparently, special steps have to be taken to verify that a query has been rewritten. Of course, if the query runs faster, this should indicate that rewrite has occurred, but that is not proof. Therefore, to confirm that query rewrite does occur, use the <code>EXPLAIN</code> <code>PLAN</code> statement or the <code>DBMS_MVIEW.EXPLAIN_REWRITE</code> procedure.</p>
<a id="DWHSG08051"></a>
<div class="sect2"><a id="sthref966"></a>
<h3 class="sect2">Using EXPLAIN PLAN with Query Rewrite</h3>
<p><a id="sthref967"></a>The <code>EXPLAIN</code> <code>PLAN</code> facility is used as described in <a class="olink SQLRF01601" href="../../server.112/e41084/statements_9010.htm#SQLRF01601"><span class="italic">Oracle Database SQL Language Reference</span></a>. For query rewrite, all you need to check is that the operation shows <code>MAT_VIEW</code> <code>REWRITE</code> <code>ACCESS</code>. If it does, then query rewrite has occurred. An example is the following, which creates the materialized view <code>cal_month_sales_mv</code>:</p>
<pre>
CREATE MATERIALIZED VIEW cal_month_sales_mv
ENABLE QUERY REWRITE AS
SELECT  t.calendar_month_desc, SUM(s.amount_sold) AS dollars
FROM sales s, times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
</pre>
<p>If <code>EXPLAIN</code> <code>PLAN</code> is used on the following SQL statement, the results are placed in the default table <code>PLAN_TABLE</code>. However, <code>PLAN_TABLE</code> must first be created using the <code>utlxplan.sql</code> script. Note that <code>EXPLAIN</code> <code>PLAN</code> does not actually execute the query.</p>
<pre>
EXPLAIN PLAN FOR
SELECT  t.calendar_month_desc, SUM(s.amount_sold)
FROM  sales s, times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc; 
</pre>
<p>For the purposes of query rewrite, the only information of interest from <code>PLAN_TABLE</code> is the operation <code>OBJECT_NAME</code>, which identifies the method used to execute this query. Therefore, you would expect to see the operation <code>MAT_VIEW</code> <code>REWRITE</code> <code>ACCESS</code> in the output as illustrated in the following:</p>
<pre>
SELECT OPERATION, OBJECT_NAME FROM PLAN_TABLE;

OPERATION                  OBJECT_NAME
--------------------       -----------------------
SELECT STATEMENT
MAT_VIEW REWRITE ACCESS    CALENDAR_MONTH_SALES_MV
</pre></div>
<!-- class="sect2" -->
<a id="DWHSG8559"></a>
<div class="sect2"><a id="sthref968"></a>
<h3 class="sect2">Using the EXPLAIN_REWRITE Procedure with Query Rewrite</h3>
<p>It can be difficult <a id="sthref969"></a><a id="sthref970"></a><a id="sthref971"></a>to understand why a query did not rewrite. The rules governing query rewrite eligibility are quite complex, involving various factors such as constraints, dimensions, query rewrite integrity modes, freshness of the materialized views, and the types of queries themselves. In addition, you may want to know why query rewrite chose a particular materialized view instead of another. To help with this matter, Oracle provides the <code>DBMS_MVIEW.EXPLAIN_REWRITE</code> procedure to advise you when a query can be rewritten and, if not, why not. Using the results from <code>DBMS_MVIEW.EXPLAIN_REWRITE</code>, you can take the appropriate action needed to make a query rewrite if at all possible.</p>
<p>Note that the query specified in the <code>EXPLAIN_REWRITE</code> statement does not actually execute.</p>
<a id="DWHSG8560"></a>
<div class="sect3"><a id="sthref972"></a>
<h4 class="sect3">DBMS_MVIEW.EXPLAIN_REWRITE Syntax</h4>
<p>You can obtain the output from <code>DBMS_MVIEW.EXPLAIN_REWRITE</code> in two ways. The first is to use a table, while the second is to create a <code>VARRAY</code>. The following shows the basic syntax for using an output table:</p>
<pre>
DBMS_MVIEW.EXPLAIN_REWRITE (
    query           VARCHAR2,
    mv              VARCHAR2(30),
    statement_id    VARCHAR2(30));
</pre>
<p>You can create an output table called <code>REWRITE_TABLE</code> by executing the <code>utlxrw.sql</code> script.</p>
<p>The <code>query</code> parameter is a text string representing the SQL query. The parameter, <code>mv</code>, is a fully-qualified materialized view name in the form of <code>schema.mv</code>. This is an optional parameter. When it is not specified, <code>EXPLAIN_REWRITE</code> returns any relevant messages regarding all the materialized views considered for rewriting the given query. When <code>schema</code> is omitted and only <code>mv</code> is specified, <code>EXPLAIN_REWRITE</code> looks for the materialized view in the current schema.</p>
<p>If you want to direct the output of <code>EXPLAIN_REWRITE</code> to a varray instead of a table, you should call the procedure as follows:</p>
<pre>
DBMS_MVIEW.EXPLAIN_REWRITE (
    query           [VARCHAR2 | CLOB],
    mv               VARCHAR2(30),
    output_array     SYS.RewriteArrayType);
</pre>
<p>Note that if the query is less than 256 characters long, <code>EXPLAIN_REWRITE</code> can be easily invoked with the <code>EXECUTE</code> command from SQL*Plus. Otherwise, the recommended method is to use a PL/SQL <code>BEGIN... END</code> block, as shown in the examples in <code>/rdbms/demo/smxrw*</code>.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8561"></a>
<div class="sect3"><a id="sthref973"></a>
<h4 class="sect3">Using REWRITE_TABLE</h4>
<p>The output of <code>EXPLAIN_REWRITE</code> can be directed to a table named <code>REWRITE_TABLE</code>. You can create this output table by running the <code>utlxrw.sql</code> script. This script can be found in the <code>admin</code> directory. The format of <code>REWRITE_TABLE</code> is as follows:</p>
<pre>
CREATE TABLE REWRITE_TABLE(
  statement_id          VARCHAR2(30),   -- id for the query
  mv_owner              VARCHAR2(30),   -- owner of the MV
  mv_name               VARCHAR2(30),   -- name of the MV
  sequence              INTEGER,        -- sequence no of the msg
  query                 VARCHAR2(2000), -- user query
  query_block_no        INTEGER,        -- block no of the current subquery
  rewritten_txt         VARCHAR2(2000), -- rewritten query
  message               VARCHAR2(512),  -- EXPLAIN_REWRITE msg
  pass                  VARCHAR2(3),    -- rewrite pass no
  mv_in_msg             VARCHAR2(30),   -- MV in current message 
  measure_in_msg        VARCHAR2(30),   -- Measure in current message 
  join_back_tbl         VARCHAR2(30),   -- Join back table in message 
  join_back_col         VARCHAR2(30),   -- Join back column in message
  original_cost         INTEGER,        -- Cost of original query
  rewritten_cost        INTEGER,        -- Cost of rewritten query
  flags                 INTEGER,        -- associated flags
  reserved1             INTEGER,        -- currently not used 
  reerved2              VARCHAR2(10))   -- currently not used;
</pre>
<div class="example">
<p class="titleinexample"><a id="DWHSG8562"></a><a id="sthref974"></a>Example 19-15 EXPLAIN_REWRITE Using REWRITE_TABLE</p>
<p>An example PL/SQL invocation is:</p>
<pre>
EXECUTE DBMS_MVIEW.EXPLAIN_REWRITE -
('SELECT p.prod_name, SUM(amount_sold) ' || -
'FROM sales s, products p ' || -
'WHERE s.prod_id = p.prod_id ' || -
' AND prod_name &gt; ''B%'' ' || -
' AND prod_name &lt; ''C%'' ' || -
'GROUP BY prod_name', -
'TestXRW.PRODUCT_SALES_MV', -
'SH');

SELECT message FROM rewrite_table ORDER BY sequence;
MESSAGE                                                                         
--------------------------------------------------------------------------------
QSM-01033: query rewritten with materialized view, PRODUCT_SALES_MV             
1 row selected.
</pre>
<p>The demo file <code>xrwutl.sql</code> contains a procedure that you can call to provide a more detailed output from <code>EXPLAIN_REWRITE</code>. See <a href="#BABDGCBH">"EXPLAIN_REWRITE Output"</a> for more information.</p>
<p>The following is an example where you can see a more detailed explanation of why some materialized views were not considered and, eventually, the materialized view <code>sales_mv</code> was chosen as the best one.</p>
<pre>
DECLARE
  qrytext VARCHAR2(500)  :='SELECT cust_first_name, cust_last_name,
 SUM(amount_sold) AS dollar_sales FROM sales s, customers c WHERE s.cust_id=
 c.cust_id GROUP BY cust_first_name, cust_last_name';
    idno    VARCHAR2(30) :='ID1';
BEGIN
  DBMS_MVIEW.EXPLAIN_REWRITE(qrytext, '', idno);
END;
/
SELECT message FROM rewrite_table ORDER BY sequence;

</pre>
<pre>
SQL&gt; MESSAGE                                      
--------------------------------------------------------------------------------
QSM-01082: Joining materialized view, CAL_MONTH_SALES_MV, with table, SALES, not possible
QSM-01022: a more optimal materialized view than PRODUCT_SALES_MV was used to rewrite
QSM-01022: a more optimal materialized view than FWEEK_PSCAT_SALES_MV was used to rewrite
QSM-01033: query rewritten with materialized view, SALES_MV
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="DWHSG8563"></a>
<div class="sect3"><a id="sthref975"></a>
<h4 class="sect3">Using a Varray</h4>
<p>You can save the output of <code>EXPLAIN_REWRITE</code> in a PL/SQL <code>VARRAY</code>. The elements of this array are of the type <code>RewriteMessage</code>, which is predefined in the <code>SYS</code> schema as shown in the following:</p>
<pre>
TYPE RewriteMessage IS OBJECT(
  mv_owner        VARCHAR2(30),   -- MV's schema
  mv_name         VARCHAR2(30),   -- Name of the MV
  sequence        NUMBER(3),      -- sequence no of the msg 
  query_text      VARCHAR2(2000), -- User query
  query_block_no  NUMBER(3),      -- block no of the current subquery
  rewritten_text  VARCHAR2(2000), -- rewritten query text 
  message         VARCHAR2(512),  -- EXPLAIN_REWRITE error msg
  pass            VARCHAR2(3),    -- Query rewrite pass no 
  mv_in_msg       VARCHAR2(30),   -- MV in current message 
  measure_in_msg  VARCHAR2(30),   -- Measure in current message 
  join_back_tbl   VARCHAR2(30),   -- Join back table in current msg 
  join_back_col   VARCHAR2(30),   -- Join back column in current msg 
  original_cost   NUMBER(10),     -- Cost of original query 
  rewritten_cost  NUMBER(10),     -- Cost rewritten query 
  flags           NUMBER,         -- Associated flags
  reserved1       NUMBER,         -- For future use
  reserved2       VARCHAR2(10)    -- For future use
);
</pre>
<p>The array type, <code>RewriteArrayType</code>, which is a varray of <code>RewriteMessage</code> objects, is predefined in the <code>SYS</code> schema as follows:</p>
<ul>
<li>
<p><code>TYPE RewriteArrayType AS VARRAY(256) OF RewriteMessage;</code></p>
</li>
<li>
<p>Using this array type, now you can declare an array variable and specify it in the <code>EXPLAIN_REWRITE</code> statement.</p>
</li>
<li>
<p>Each <code>RewriteMessage</code> record provides a message concerning rewrite processing.</p>
</li>
<li>
<p>The parameters are the same as for <code>REWRITE_TABLE</code>, except for <code>statement_id</code>, which is not used when using a varray as output.</p>
</li>
<li>
<p>The <code>mv_owner</code> field defines the owner of materialized view that is relevant to the message.</p>
</li>
<li>
<p>The <code>mv_name</code> field defines the name of a materialized view that is relevant to the message.</p>
</li>
<li>
<p>The <code>sequence</code> field defines the sequence in which messages should be ordered.</p>
</li>
<li>
<p>The <code>query_text</code> field contains the first 2000 characters of the query text under analysis.</p>
</li>
<li>
<p>The <code>message</code> field contains the text of message relevant to rewrite processing of <code>query</code>.</p>
</li>
<li>
<p>The <code>flags</code>, <code>reserved1</code>, and <code>reserved2</code> fields are reserved for future use.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="DWHSG8564"></a><a id="sthref976"></a>Example 19-16 EXPLAIN_REWRITE Using a VARRAY</p>
<p>Consider the following materialized view:</p>
<pre>
CREATE MATERIALIZED VIEW avg_sales_city_state_mv
ENABLE QUERY REWRITE AS
SELECT c.cust_city, c.cust_state_province, AVG(s.amount_sold)
FROM sales s, customers c WHERE s.cust_id = c.cust_id
GROUP BY c.cust_city, c.cust_state_province;
</pre>
<p>We might try to use this materialized view with the following query:</p>
<pre>
SELECT c.cust_state_province, AVG(s.amount_sold)
FROM sales s, customers c WHERE s.cust_id = c.cust_id
GROUP BY c.cust_state_province;
</pre>
<p>However, the query does not rewrite with this materialized view. This can be quite confusing to a novice user as it seems like all information required for rewrite is present in the materialized view. You can find out from <code>DBMS_MVIEW.EXPLAIN_REWRITE</code> that <code>AVG</code> cannot be computed from the given materialized view. The problem is that a <code>ROLLUP</code> is required here and <code>AVG</code> requires a <code>COUNT</code> or a <code>SUM</code> to do <code>ROLLUP</code>.</p>
<p>An example PL/SQL block for the previous query, using a <code>VARRAY</code> as its output, is as follows:</p>
<pre>
SET SERVEROUTPUT ON
DECLARE
  Rewrite_Array SYS.RewriteArrayType := SYS.RewriteArrayType();
  querytxt VARCHAR2(1500) := 'SELECT c.cust_state_province,
  AVG(s.amount_sold)
   FROM sales s, customers c WHERE s.cust_id = c.cust_id
   GROUP BY c.cust_state_province';
  i NUMBER;
BEGIN
  DBMS_MVIEW.EXPLAIN_REWRITE(querytxt, 'AVG_SALES_CITY_STATE_MV',
  Rewrite_Array);
  FOR i IN 1..Rewrite_Array.count
  LOOP
    DBMS_OUTPUT.PUT_LINE(Rewrite_Array(i).message);
  END LOOP;
END;
/
</pre>
<p>The following is the output of this <code>EXPLAIN_REWRITE</code> statement:</p>
<pre>
QSM-01065: materialized view, AVG_SALES_CITY_STATE_MV, cannot compute
  measure, AVG, in the query
QSM-01101: rollup(s) took place on mv, AVG_SALES_CITY_STATE_MV
QSM-01053: NORELY referential integrity constraint on table, CUSTOMERS,
  in TRUSTED/STALE TOLERATED integrity mode
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="DWHSG8565"></a>
<div class="sect3"><a id="sthref977"></a>
<h4 class="sect3">EXPLAIN_REWRITE Benefit Statistics</h4>
<p>The output of <code>EXPLAIN_REWRITE</code> contains two columns, <code>original_cost</code> and <code>rewritten_cost</code>, that can help you estimate query cost. <code>original_cost</code> gives the optimizer's estimation for the query cost when query rewrite was disabled. <code>rewritten_cost</code> gives the optimizer's estimation for the query cost when query was rewritten using a materialized view. These cost values can be used to find out what benefit a particular query receives from rewrite.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8566"></a>
<div class="sect3"><a id="sthref978"></a>
<h4 class="sect3">Support for Query Text Larger than 32KB in EXPLAIN_REWRITE</h4>
<p>In this release, the <code>EXPLAIN_REWRITE</code> procedure has been enhanced to support large queries. The input query text can now be defined using a <code>CLOB</code> data type instead of a <code>VARCHAR</code> data type. This allows <code>EXPLAIN_REWRITE</code> to accept queries up to 4 GB.</p>
<p>The syntax for using <code>EXPLAIN_REWRITE</code> using <code>CLOB</code> to obtain the output into a table is shown as follows:</p>
<pre>
DBMS_MVIEW.EXPLAIN_REWRITE(
   query          IN CLOB,
   mv             IN VARCHAR2,
   statement_id   IN VARCHAR2);
</pre>
<p>The second argument, <code>mv</code>, and the third argument, <code>statement_id</code>, can be <code>NULL</code>. Similarly, the syntax for using <code>EXPLAIN_REWRITE</code> using <code>CLOB</code> to obtain the output into a varray is shown as follows:</p>
<pre>
DBMS_MVIEW.EXPLAIN_REWRITE(
   query           IN CLOB,
   mv              IN VARCHAR2,
   msg_array       IN OUT SYS.RewriteArrayType);
 
</pre>
<p>As before, the second argument, <code>mv</code>, can be <code>NULL</code>. Note that long query texts in <code>CLOB</code> can be generated using the procedures provided in the <code>DBMS_LOB</code> package.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8567"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref979"></a>
<h4 class="sect3">EXPLAIN_REWRITE and Multiple Materialized Views</h4>
<p>The syntax for using <code>EXPLAIN_REWRITE</code> with multiple materialized views is the same as using it with a single materialized view, except that the materialized views are specified by a comma-delimited string. For example, to find out whether a given set of materialized views <code>mv1</code>, <code>mv2</code>, and <code>mv3</code> could be used to rewrite the query, <code>query_txt</code>, and, if not, why not, use <code>EXPLAIN_REWRITE</code> as follows:</p>
<pre>
DBMS_MVIEW.EXPLAIN_REWRITE(query_txt, 'mv1, mv2, mv3')
</pre>
<p>If the query, <code>query_txt</code>, rewrote with the given set of materialized views, then the following message appears:</p>
<pre>
QSM-01127: query rewritten with materialized view(s), mv1, mv2, and mv3.
</pre>
<p>If the query fails to rewrite with one or more of the given set of materialized views, then the reason for the failure will be output by <code>EXPLAIN_REWRITE</code> for each of the materialized views that did not participate in the rewrite.</p>
</div>
<!-- class="sect3" -->
<a id="BABDGCBH"></a><a id="DWHSG8568"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">EXPLAIN_REWRITE Output</h4>
<p>Some examples showing how to use <code>EXPLAIN_REWRITE</code> are included in <code>/rdbms/demo/smxrw.sql</code>. There is also a utility called <code>SYS.XRW</code> included in the demo <code>xrw</code> area to help you select the output from the <code>EXPLAIN_REWRITE</code> procedure. When <code>EXPLAIN_REWRITE</code> evaluates a query, its output includes information such as the rewritten query text, query block number, and the cost of the rewritten query. The utility <code>SYS.XRW</code> outputs the user specified fields in a neatly formatted way, so that the output can be easily understood. The syntax is as follows:</p>
<pre>
SYS.XRW(list_of_mvs, list_of_commands, query_text),
</pre>
<p>where <code>list_of_mvs</code> are the materialized views the user would expect the query rewrite to use. If there is more than one materialized view, they must be separated by commas, and <code>list_of_commands</code> is one of the following fields:</p>
<pre>
QUERY_TXT:      User query text
REWRITTEN_TXT:  Rewritten query text
QUERY_BLOCK_NO: Query block number to identify each query blocks in
                case the query has subqueries or inline views
PASS:           Pass indicates whether a given message was generated
                before or after the view merging process of query rewrite.
COSTS:          Costs indicates the estimated execution cost of the
                original query and the rewritten query
</pre>
<p>The following example illustrates the use of this utility:</p>
<pre>
DROP MATERIALIZED VIEW month_sales_mv;
 
CREATE MATERIALIZED VIEW month_sales_mv
  ENABLE QUERY REWRITE
  AS
  SELECT t.calendar_month_number, SUM(s.amount_sold) AS sum_dollars
  FROM sales s, times t
  WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_number;
 
SET SERVEROUTPUT ON
DECLARE
  querytxt VARCHAR2(1500) := 'SELECT t.calendar_month_number,
         SUM(s.amount_sold) AS sum_dollars FROM sales s, times t
  WHERE s.time_id = t.time_id GROUP BY t.calendar_month_number';
BEGIN
  SYS.XRW('MONTH_SALES_MV', 'COSTS, PASS, REWRITTEN_TXT, QUERY_BLOCK_NO', querytxt);
END;
/
</pre>
<p>Following is the output from <code>SYS.XRW</code>. As can be seen from the output, <code>SYS.XRW</code> outputs both the original query cost, rewritten costs, rewritten query text, query block number and whether the message was generated before or after the view merging process.</p>
<pre>
============================================================================
&gt;&gt; MESSAGE  : QSM-01151: query was rewritten
&gt;&gt; RW QUERY : SELECT MONTH_SALES_MV.CALENDAR_MONTH_NUMBER CALENDAR_MONTH_NUMBER,
MONTH_SALES_MV.SUM_DOLLARS SUM_DOLLARS FROM SH.MONTH_SALES_MV MONTH_SALES_MV
&gt;&gt; ORIG COST: 19.952763130792                  RW COST: 1.80687108
============================================================================
&gt;&gt;
------------------------- ANALYSIS OF QUERY REWRITE -------------------------
&gt;&gt;
&gt;&gt; QRY BLK #: 0
&gt;&gt; MESSAGE  : QSM-01209: query rewritten with materialized view, 
   MONTH_SALES_MV, using text match algorithm
&gt;&gt; RW QUERY : SELECT MONTH_SALES_MV.CALENDAR_MONTH_NUMBER CALENDAR_MONTH_NUMBER,
   MONTH_SALES_MV.SUM_DOLLARS SUM_DOLLARS FROM SH.MONTH_SALES_MV MONTH_SALES_MV
&gt;&gt; ORIG COST: 19.952763130792                  RW COST: 1.80687108
&gt;&gt; MESSAGE OUTPUT BEFORE VIEW MERGING...
============================ END OF MESSAGES ===============================
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007925"></a><a id="DWHSG0806"></a>
<div class="sect1">
<h2 class="sect1">Design Considerations for Improving Query Rewrite Capabilities</h2>
<p>This section discusses design considerations that will help in obtaining the maximum benefit from query rewrite. They are not mandatory for using query rewrite and rewrite is not guaranteed if you follow them. They are general rules to consider, and are the following:</p>
<ul>
<li>
<p><a href="#i1016297">Query Rewrite Considerations: Constraints</a></p>
</li>
<li>
<p><a href="#i1016354">Query Rewrite Considerations: Dimensions</a></p>
</li>
<li>
<p><a href="#i1016355">Query Rewrite Considerations: Outer Joins</a></p>
</li>
<li>
<p><a href="#i1016356">Query Rewrite Considerations: Text Match</a></p>
</li>
<li>
<p><a href="#i1016357">Query Rewrite Considerations: Aggregates</a></p>
</li>
<li>
<p><a href="#i1016358">Query Rewrite Considerations: Grouping Conditions</a></p>
</li>
<li>
<p><a href="#i1016359">Query Rewrite Considerations: Expression Matching</a></p>
</li>
<li>
<p><a href="#i1016360">Query Rewrite Considerations: Date Folding</a></p>
</li>
<li>
<p><a href="#i1016379">Query Rewrite Considerations: Statistics</a></p>
</li>
<li>
<p><a href="#BABCHBDF">Query Rewrite Considerations: Hints</a></p>
</li>
</ul>
<a id="i1016297"></a><a id="DWHSG8569"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Constraints</h3>
<p><a id="sthref980"></a>Make sure all inner joins referred to in a materialized view have referential integrity (foreign key/primary key constraints) with additional <code>NOT</code> <code>NULL</code> constraints on the foreign key columns. Since constraints tend to impose a large overhead, you could make them <code>NO</code> <code>VALIDATE</code> and <code>RELY</code> and set the parameter <code>QUERY_REWRITE_INTEGRITY</code> to <code>STALE_TOLERATED</code> or <code>TRUSTED</code>. However, if you set <code>QUERY_REWRITE_INTEGRITY</code> to <code>ENFORCED</code>, all constraints must be enabled, enforced, and validated to get maximum rewritability.</p>
<p>You should avoid using the <code>ON</code> <code>DELETE</code> clause as it can lead to unexpected results.</p>
</div>
<!-- class="sect2" -->
<a id="i1016354"></a><a id="DWHSG8570"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Dimensions</h3>
<p><a id="sthref981"></a>You can express the hierarchical relationships and functional dependencies in normalized or denormalized dimension tables using the <code>HIERARCHY</code> and <code>DETERMINES</code> clauses of a dimension. Dimensions can express intra-table relationships which cannot be expressed by constraints. Set the parameter <code>QUERY_REWRITE_INTEGRITY</code> to <code>TRUSTED</code> or <code>STALE_TOLERATED</code> for query rewrite to take advantage of the relationships declared in dimensions.</p>
</div>
<!-- class="sect2" -->
<a id="i1016355"></a><a id="DWHSG8571"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Outer Joins</h3>
<p><a id="sthref982"></a>Another way of avoiding constraints is to use outer joins in the materialized view. Query rewrite will be able to derive an inner join in the query, such as <code>(A.a=B.b)</code>, from an outer join in the materialized view <code>(A.a = B.b(+))</code>, as long as the rowid of <code>B</code> or column <code>B.b</code> is available in the materialized view. Most of the support for rewrites with outer joins is provided for materialized views with joins only. To exploit it, a materialized view with outer joins should store the rowid or primary key of the inner table of an outer join. For example, the materialized view <code>join_sales_time_product_mv_oj</code> stores the primary keys <code>prod_id</code> and <code>time_id</code> of the inner tables of outer joins.</p>
</div>
<!-- class="sect2" -->
<a id="i1016356"></a><a id="DWHSG8572"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Text Match</h3>
<p><a id="sthref983"></a>If you need to speed up an extremely complex, long-running query, you could create a materialized view with the exact text of the query. Then the materialized view would contain the query results, thus eliminating the time required to perform any complex joins and search through all the data for that which is required.</p>
</div>
<!-- class="sect2" -->
<a id="i1016357"></a><a id="DWHSG8573"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Aggregates</h3>
<p><a id="sthref984"></a>To get the maximum benefit from query rewrite, make sure that all aggregates which are needed to compute ones in the targeted set of queries are present in the materialized view. The conditions on aggregates are quite similar to those for incremental refresh. For instance, if <code>AVG(x)</code> is in the query, then you should store <code>COUNT(x)</code> and <code>AVG(x)</code> or store <code>SUM(x)</code> and <code>COUNT(x)</code> in the materialized view. See <a href="basicmv.htm#i1007007">"General Restrictions on Fast Refresh"</a> for fast refresh requirements.</p>
</div>
<!-- class="sect2" -->
<a id="i1016358"></a><a id="DWHSG8574"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Grouping Conditions</h3>
<p><a id="sthref985"></a>Aggregating data at lower levels in the hierarchy is better than aggregating at higher levels because lower levels can be used to rewrite more queries. Note, however, that doing so will also take up more space. For example, instead of grouping on state, group on city (unless space constraints prohibit it).</p>
<p>Instead of creating multiple materialized views with overlapping or hierarchically related <code>GROUP</code> <code>BY</code> columns, create a single materialized view with all those <code>GROUP</code> <code>BY</code> columns. For example, instead of using a materialized view that groups by city and another materialized view that groups by month, use a single materialized view that groups by city and month.</p>
<p>Use <code>GROUP</code> <code>BY</code> on columns that correspond to levels in a dimension but not on columns that are functionally dependent, because query rewrite will be able to use the functional dependencies automatically based on the <code>DETERMINES</code> clause in a dimension. For example, instead of grouping on <code>prod_name</code>, group on <code>prod_id</code> (as long as there is a dimension which indicates that the attribute <code>prod_id</code> determines <code>prod_name</code>, you will enable the rewrite of a query involving <code>prod_name</code>).</p>
</div>
<!-- class="sect2" -->
<a id="i1016359"></a><a id="DWHSG8575"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Expression Matching</h3>
<p>If several queries share the same common subselect, it is advantageous to create a materialized view with the common subselect as one of its <code>SELECT</code> columns. This way, the performance benefit due to precomputation of the common subselect can be obtained across several queries.</p>
</div>
<!-- class="sect2" -->
<a id="i1016360"></a><a id="DWHSG8576"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Date Folding</h3>
<p>When creating a materialized view that aggregates data by folded date granules such as months or quarters or years, always use the year component as the prefix but not as the suffix. For example, <code>TO_CHAR</code>(<code>date_col</code>, <code>'yyyy-q'</code>) folds the date into quarters, which collate in year order, whereas <code>TO_CHAR</code>(<code>date_col, 'q-yyyy'</code>) folds the date into quarters, which collate in quarter order. The former preserves the ordering while the latter does not. For this reason, any materialized view created without a year prefix will not be eligible for date folding rewrite.</p>
</div>
<!-- class="sect2" -->
<a id="i1016379"></a><a id="DWHSG8577"></a>
<div class="sect2">
<h3 class="sect2">Query Rewrite Considerations: Statistics</h3>
<p><a id="sthref986"></a>Optimization with materialized views is based on cost and the optimizer needs statistics of both the materialized view and the tables in the query to make a cost-based choice. Materialized views should thus have statistics collected using the <code>DBMS_STATS</code> package.</p>
</div>
<!-- class="sect2" -->
<a id="BABCHBDF"></a><a id="DWHSG8578"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite Considerations: Hints</h3>
<p>This section discusses the following considerations:</p>
<ul>
<li>
<p><a href="#BABIIEHE">REWRITE and NOREWRITE Hints</a></p>
</li>
<li>
<p><a href="#BABIAIHJ">REWRITE_OR_ERROR Hint</a></p>
</li>
<li>
<p><a href="#BABGFBEF">Multiple Materialized View Rewrite Hints</a></p>
</li>
<li>
<p><a href="#BABEDJCG">EXPAND_GSET_TO_UNION Hint</a></p>
</li>
</ul>
<a id="BABIIEHE"></a><a id="DWHSG8579"></a>
<div class="sect3">
<h4 class="sect3">REWRITE and NOREWRITE Hints</h4>
<p><a id="sthref987"></a>You can include hints in the <code>SELECT</code> blocks of your SQL statements to control whether query rewrite occurs. Using the<a id="sthref988"></a><a id="sthref989"></a><a id="sthref990"></a><a id="sthref991"></a><a id="sthref992"></a><a id="sthref993"></a><a id="sthref994"></a><a id="sthref995"></a> <code>NOREWRITE</code> hint in a query prevents the optimizer from rewriting it.</p>
<p>The <code>REWRITE</code> hint <a id="sthref996"></a><a id="sthref997"></a>with no argument in a query forces the optimizer to use a materialized view (if any) to rewrite it regardless of the cost. If you use the <code>REWRITE(mv1,mv2,...)</code> hint with arguments, this forces rewrite to select the most suitable materialized view from the list of names specified.</p>
<p>To prevent a rewrite, you can use the following statement:</p>
<pre>
SELECT /*+ NOREWRITE */ p.prod_subcategory, SUM(s.amount_sold)
FROM   sales s, products p WHERE  s.prod_id = p.prod_id
GROUP BY p.prod_subcategory;
</pre>
<p>To force a rewrite using <code>sum_sales_pscat_week_mv</code> (if such a rewrite is possible), use the following statement:</p>
<pre>
SELECT /*+ REWRITE (sum_sales_pscat_week_mv) */ 
       p.prod_subcategory,  SUM(s.amount_sold)
FROM   sales s, products p WHERE  s.prod_id=p.prod_id
GROUP BY p.prod_subcategory;
</pre>
<p>Note that the scope of a rewrite hint is a query block. If a SQL statement consists of several query blocks (<code>SELECT</code> clauses), you must specify a rewrite hint on each query block to control the rewrite for the entire statement.</p>
</div>
<!-- class="sect3" -->
<a id="BABIAIHJ"></a><a id="DWHSG8580"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">REWRITE_OR_ERROR Hint</h4>
<p>Using<a id="sthref998"></a><a id="sthref999"></a> the <code>REWRITE_OR_ERROR</code> hint in a query causes the following error if the query failed to rewrite:</p>
<pre>
ORA-30393: a query block in the statement did not rewrite
</pre>
<p>For example, the following query issues an ORA-30393 error when there are no suitable materialized views for query rewrite to use:</p>
<pre>
SELECT /*+ REWRITE_OR_ERROR */ p.prod_subcategory, SUM(s.amount_sold)
FROM sales s, products p WHERE s.prod_id = p.prod_id
GROUP BY p.prod_subcategory;
</pre></div>
<!-- class="sect3" -->
<a id="BABGFBEF"></a><a id="DWHSG8581"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Multiple Materialized View Rewrite Hints</h4>
<p>There are two hints to control rewrites when using multiple materialized views. The <code>NO_MULTIMV_REWRITE</code> hint prevents the query from being rewritten with more than one materialized view and the <code>NO_BASETABLE_MULTIMV_REWRITE</code> hint prevents the query from being rewritten with a combination of materialized views and the base tables.</p>
</div>
<!-- class="sect3" -->
<a id="BABEDJCG"></a><a id="DWHSG8582"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">EXPAND_GSET_TO_UNION Hint</h4>
<p>You can use the<a id="sthref1000"></a><a id="sthref1001"></a> <code>EXPAND_GSET_TO_UNION</code> hint to force expansion of the query with <code>GROUP</code> <code>BY</code> extensions into the equivalent <code>UNION</code> <code>ALL</code> query. See <a href="#i1007474">"Hint for Queries with Extended GROUP BY"</a> for further information.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1371">
<tr>
<td class="cellalignment1378">
<table class="cellalignment1376">
<tr>
<td class="cellalignment1375"><a href="qrbasic.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1375"><a href="schemas.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1380">
<table class="cellalignment1374">
<tr>
<td class="cellalignment1375"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1375"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1375"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1375"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1375"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1375"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
