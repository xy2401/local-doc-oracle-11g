<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Maintaining the Data Warehouse</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 070" />
<meta name="dcterms.created" content="2013-07-04T23:23:17Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Warehousing Guide" />
<meta name="dcterms.identifier" content="E25554-02" />
<meta name="dcterms.isVersionOf" content="DWHSG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="transform.htm" title="Previous" type="text/html" />
<link rel="Next" href="cdc.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25554.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">24/35</span> <!-- End Header --><a id="g1018554"></a><a id="DWHSG015"></a><a id="i1007103"></a>
<h1 class="chapter"><span class="secnum">16</span> Maintaining the Data Warehouse</h1>
<p>This chapter discusses how to load and refresh a data warehouse, and discusses:</p>
<ul>
<li>
<p><a href="#i1006199">Using Partitioning to Improve Data Warehouse Refresh</a></p>
</li>
<li>
<p><a href="#i1006319">Optimizing DML Operations During Refresh</a></p>
</li>
<li>
<p><a href="#i1006419">Refreshing Materialized Views</a></p>
</li>
<li>
<p><a href="#i1006759">Using Materialized Views with Partitioned Tables</a></p>
</li>
</ul>
<a id="i1006199"></a><a id="DWHSG03001"></a>
<div class="sect1">
<h2 class="sect1">Using Partitioning to Improve Data Warehouse Refresh</h2>
<p><a href="glossary.htm#i996924"><span class="xrefglossterm">ETL</span></a> (Extraction, Transformation and Loading) is done on a scheduled basis to reflect changes made to the original source system. During this step, you physically insert the new, clean data into the production data warehouse schema, and take all of the other steps necessary (such as building indexes, validating constraints, taking backups) to make this new data available to the end users. Once all of this data has been loaded into the data warehouse, the materialized views have to be updated to reflect the latest data.</p>
<p><a id="sthref413"></a>The partitioning scheme of the data warehouse is often crucial in determining the efficiency of refresh operations in the data warehouse load process. In fact, the load process is often the primary consideration in choosing the partitioning scheme of data warehouse tables and indexes.</p>
<p>The partitioning scheme of the largest data warehouse tables (for example, the fact table in a star schema) should be based upon the loading paradigm of the data warehouse.</p>
<p>Most data warehouses are loaded with new data on a regular schedule. For example, every night, week, or month, new data is brought into the data warehouse. The data being loaded at the end of the week or month typically corresponds to the transactions for the week or month. In this very common scenario, the data warehouse is being loaded by time. This suggests that the data warehouse tables should be partitioned on a date column. In our data warehouse example, suppose the new data is loaded into the <code>sales</code> table every month. Furthermore, the <code>sales</code> table has been partitioned by month. These steps show how the load process will proceed to add the data for a new month (January 2001) to the table <code>sales</code>.</p>
<ol>
<li>
<p>Place the new data into a separate table, <code>sales_01_2001</code>. This data can be directly loaded into <code>sales_01_2001</code> from outside the data warehouse, or this data can be the result of previous data transformation operations that have already occurred in the data warehouse. <code>sales_01_2001</code> has the exact same columns, datatypes, and so forth, as the <code>sales</code> table. Gather statistics on the <code>sales_01_2001</code> table.</p>
</li>
<li>
<p>Create indexes and add constraints on <code>sales_01_2001</code>. Again, the indexes and constraints on <code>sales_01_2001</code> should be identical to the indexes and constraints on <code>sales</code>. Indexes can be built in parallel and should use the <code>NOLOGGING</code> and the <code>COMPUTE</code> <code>STATISTICS</code> options. For example:</p>
<pre>
CREATE BITMAP INDEX sales_01_2001_customer_id_bix
  ON sales_01_2001(customer_id)
      TABLESPACE sales_idx NOLOGGING PARALLEL 8 COMPUTE STATISTICS;
</pre>
<p>Apply all constraints to the <code>sales_01_2001</code> table that are present on the <code>sales</code> table. This includes referential integrity constraints. A typical constraint would be:</p>
<pre>
ALTER TABLE sales_01_2001 ADD CONSTRAINT sales_customer_id
      REFERENCES customer(customer_id) ENABLE NOVALIDATE;
</pre>
<p>If the partitioned table <code>sales</code> has a primary or unique key that is enforced with a global index structure, ensure that the constraint on <code>sales_pk_jan01</code> is validated without the creation of an index structure, as in the following:</p>
<pre>
ALTER TABLE sales_01_2001 ADD CONSTRAINT sales_pk_jan01
PRIMARY KEY (sales_transaction_id) DISABLE VALIDATE;
</pre>
<p>The creation of the constraint with <code>ENABLE</code> clause would cause the creation of a unique index, which does not match a local index structure of the partitioned table. You must not have any index structure built on the nonpartitioned table to be exchanged for existing global indexes of the partitioned table. The exchange command would fail.</p>
</li>
<li>
<p>Add the <code>sales_01_2001</code> table to the <code>sales</code> table.</p>
<p>In order to add this new data to the <code>sales</code> table, we must do two things. First, we must add a new partition to the <code>sales</code> table. We will use the <code>ALTER</code> <code>TABLE</code> ... <code>ADD</code> <code>PARTITION</code> statement. This will add an empty partition to the <code>sales</code> table:</p>
<pre>
ALTER TABLE sales ADD PARTITION sales_01_2001 
VALUES LESS THAN (TO_DATE('01-FEB-2001', 'DD-MON-YYYY'));
</pre>
<p>Then, we can add our newly created table to this partition using the <code>EXCHANGE</code> <code>PARTITION</code> operation. This will exchange the new, empty partition with the newly loaded table.</p>
<pre>
ALTER TABLE sales EXCHANGE PARTITION sales_01_2001 WITH TABLE sales_01_2001 
INCLUDING INDEXES WITHOUT VALIDATION UPDATE GLOBAL INDEXES;
  
</pre>
<p>The <code>EXCHANGE</code> operation will preserve the indexes and constraints that were already present on the <code>sales_01_2001</code> table. For unique constraints (such as the unique constraint on <code>sales_transaction_id</code>), you can use the <code>UPDATE</code> <code>GLOBAL</code> <code>INDEXES</code> clause, as shown previously. This will automatically maintain your global index structures as part of the partition maintenance operation and keep them accessible throughout the whole process. If there were only foreign-key constraints, the exchange operation would be instantaneous.</p>
</li>
</ol>
<p>The benefits of this partitioning technique are significant. First, the new data is loaded with minimal resource utilization. The new data is loaded into an entirely separate table, and the index processing and constraint processing are applied only to the new partition. If the <code>sales</code> table was 50 GB and had 12 partitions, then a new month's worth of data contains approximately 4 GB. Only the new month's worth of data must be indexed. None of the indexes on the remaining 46 GB of data must be modified at all. This partitioning scheme additionally ensures that the load processing time is directly proportional to the amount of new data being loaded, not to the total size of the <code>sales</code> table.</p>
<p>Second, the new data is loaded with minimal impact on concurrent queries. All of the operations associated with data loading are occurring on a separate <code>sales_01_2001</code> table. Therefore, none of the existing data or indexes of the <code>sales</code> table is affected during this data refresh process. The <code>sales</code> table and its indexes remain entirely untouched throughout this refresh process.</p>
<p>Third, in case of the existence of any global indexes, those are incrementally maintained as part of the exchange command. This maintenance does not affect the availability of the existing global index structures.</p>
<p>The exchange operation can be viewed as a publishing mechanism. Until the data warehouse administrator exchanges the <code>sales_01_2001</code> table into the <code>sales</code> table, end users cannot see the new data. Once the exchange has occurred, then any end user query accessing the <code>sales</code> table will immediately be able to see the <code>sales_01_2001</code> data.</p>
<p>Partitioning is useful not only for adding new data but also for removing and archiving data. Many data warehouses maintain a rolling window of data. For example, the data warehouse stores the most recent 36 months of <code>sales</code> data. Just as a new partition can be added to the <code>sales</code> table (as described earlier), an old partition can be quickly (and independently) removed from the <code>sales</code> table. These two benefits (reduced resources utilization and minimal end-user impact) are just as pertinent to removing a partition as they are to adding a partition.</p>
<p>Removing data from a partitioned table does not necessarily mean that the old data is physically deleted from the database. There are two alternatives for removing old data from a partitioned table. First, you can physically delete all data from the database by dropping the partition containing the old data, thus freeing the allocated space:</p>
<pre>
ALTER TABLE sales DROP PARTITION sales_01_1998;
</pre>
<p>Also, you can exchange the old partition with an empty table of the same structure; this empty table is created equivalent to steps 1 and 2 described in the load process. Assuming the new empty table stub is named <code>sales_archive_01_1998</code>, the following SQL statement will empty partition <code>sales_01_1998</code>:</p>
<pre>
ALTER TABLE sales EXCHANGE PARTITION sales_01_1998 
WITH TABLE sales_archive_01_1998 INCLUDING INDEXES WITHOUT VALIDATION 
UPDATE GLOBAL INDEXES;
</pre>
<p>Note that the old data is still existent as the exchanged, nonpartitioned table <code>sales_archive_01_1998</code>.</p>
<p>If the partitioned table was setup in a way that every partition is stored in a separate tablespace, you can archive (or transport) this table using Oracle Database's transportable tablespace framework before dropping the actual data (the tablespace). See <a href="transport.htm#BABHJGEE">"Transportation Using Transportable Tablespaces"</a> for further details regarding transportable tablespaces.</p>
<p>In some situations, you might not want to drop the old data immediately, but keep it as part of the partitioned table; although the data is no longer of main interest, there are still potential queries accessing this old, read-only data. You can use Oracle's data compression to minimize the space usage of the old data. We also assume that at least one compressed partition is already part of the partitioned table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="physical.htm#g1007265">Chapter 3, "Physical Design in Data Warehouses"</a> for a generic discussion of table compression</p>
</li>
<li>
<p><a class="olink VLDBG004" href="../../server.112/e25523/part_avail.htm#VLDBG004"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information regarding partitioning and table compression</p>
</li>
</ul>
</div>
<a id="CEGIJFBE"></a><a id="DWHSG8344"></a>
<div class="sect2">
<h3 class="sect2">Refresh Scenarios</h3>
<p>A typical scenario might not only need to compress old data, but also to merge several old partitions to reflect the granularity for a later backup of several merged partitions. Let us assume that a backup (partition) granularity is on a quarterly base for any quarter, where the oldest month is more than 36 months behind the most recent month. In this case, we are therefore compressing and merging <code>sales_01_1998</code>, <code>sales_02_1998</code>, and <code>sales_03_1998</code> into a new, compressed partition <code>sales_q1_1998</code>.</p>
<ol>
<li>
<p>Create the new merged partition in parallel in another tablespace. The partition will be compressed as part of the <code>MERGE</code> operation:</p>
<pre>
ALTER TABLE sales MERGE PARTITIONS sales_01_1998, sales_02_1998, sales_03_1998
 INTO PARTITION sales_q1_1998 TABLESPACE archive_q1_1998 
COMPRESS UPDATE GLOBAL INDEXES PARALLEL 4;
</pre></li>
<li>
<p>The partition <code>MERGE</code> operation invalidates the local indexes for the new merged partition. We therefore have to rebuild them:</p>
<pre>
ALTER TABLE sales MODIFY PARTITION sales_q1_1998 
REBUILD UNUSABLE LOCAL INDEXES;
</pre></li>
</ol>
<p>Alternatively, you can choose to create the new compressed table outside the partitioned table and exchange it back. The performance and the temporary space consumption is identical for both methods:</p>
<ol>
<li>
<p>Create an intermediate table to hold the new merged information. The following statement inherits all <code>NOT</code> <code>NULL</code> constraints from the original table by default:</p>
<pre>
CREATE TABLE sales_q1_1998_out TABLESPACE archive_q1_1998 
NOLOGGING COMPRESS PARALLEL 4 AS SELECT * FROM sales
WHERE time_id &gt;=  TO_DATE('01-JAN-1998','dd-mon-yyyy')
  AND time_id &lt; TO_DATE('01-APR-1998','dd-mon-yyyy');
</pre></li>
<li>
<p>Create the equivalent index structure for table <code>sales_q1_1998_out</code> than for the existing table <code>sales</code>.</p>
</li>
<li>
<p>Prepare the existing table sales for the exchange with the new compressed table <code>sales_q1_1998_out</code>. Because the table to be exchanged contains data actually covered in three partitions, we have to create one matching partition, having the range boundaries we are looking for. You simply have to drop two of the existing partitions. Note that you have to drop the lower two partitions <code>sales_01_1998</code> and <code>sales_02_1998</code>; the lower boundary of a range partition is always defined by the upper (exclusive) boundary of the previous partition:</p>
<pre>
ALTER TABLE sales DROP PARTITION sales_01_1998;
ALTER TABLE sales DROP PARTITION sales_02_1998;
 
</pre></li>
<li>
<p>You can now exchange table <code>sales_q1_1998_out</code> with partition <code>sales_03_1998</code>. Unlike what the name of the partition suggests, its boundaries cover Q1-1998.</p>
<pre>
ALTER TABLE sales EXCHANGE PARTITION sales_03_1998 
WITH TABLE sales_q1_1998_out INCLUDING INDEXES WITHOUT VALIDATION 
UPDATE GLOBAL INDEXES;
</pre></li>
</ol>
<p>Both methods apply to slightly different business scenarios: Using the <code>MERGE</code> <code>PARTITION</code> approach invalidates the local index structures for the affected partition, but it keeps all data accessible all the time. Any attempt to access the affected partition through one of the unusable index structures raises an error. The limited availability time is approximately the time for re-creating the local bitmap index structures. In most cases, this can be neglected, because this part of the partitioned table should not be accessed too often.</p>
<p>The CTAS approach, however, minimizes unavailability of any index structures close to zero, but there is a specific time window, where the partitioned table does not have all the data, because we dropped two partitions. The limited availability time is approximately the time for exchanging the table. Depending on the existence and number of global indexes, this time window varies. Without any existing global indexes, this time window is a matter of a fraction to few seconds.</p>
<p>These examples are a simplification of the data warehouse rolling window load scenario. Real-world data warehouse refresh characteristics are always more complex. However, the advantages of this rolling window approach are not diminished in more complex scenarios.</p>
<p>Note that before you add single or multiple compressed partitions to a partitioned table for the first time, all local bitmap indexes must be either dropped or marked unusable. After the first compressed partition is added, no additional actions are necessary for all subsequent operations involving compressed partitions. It is irrelevant how the compressed partitions are added to the partitioned table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink VLDBG004" href="../../server.112/e25523/part_avail.htm#VLDBG004"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information regarding partitioning and table compression</p>
</li>
<li>
<p><a class="olink ADMIN11630" href="../../server.112/e25494/tables.htm#ADMIN11630"><span class="italic">Oracle Database Administrator's Guide</span></a> for further details about partitioning and table compression.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="DWHSG8345"></a>
<div class="sect2"><a id="sthref414"></a>
<h3 class="sect2">Scenarios for Using Partitioning for Refreshing Data Warehouses</h3>
<p>This section contains two typical scenarios where partitioning is used with refresh.</p>
<a id="DWHSG8346"></a>
<div class="sect3"><a id="sthref415"></a>
<h4 class="sect3">Refresh Scenario 1</h4>
<p>Data is loaded daily. However, the data warehouse contains two years of data, so that partitioning by day might not be desired.</p>
<p>The solution is to partition by week or month (as appropriate). Use <code>INSERT</code> to add the new data to an existing partition. The <code>INSERT</code> operation only affects a single partition, so the benefits described previously remain intact. The <code>INSERT</code> operation could occur while the partition remains a part of the table. Inserts into a single partition can be parallelized:</p>
<pre>
INSERT /*+ APPEND*/ INTO sales PARTITION (sales_01_2001) 
SELECT * FROM new_sales;
</pre>
<p>The indexes of this <code>sales</code> partition will be maintained in parallel as well. An alternative is to use the <code>EXCHANGE</code> operation. You can do this by exchanging the <code>sales_01_2001</code> partition of the <code>sales</code> table and then using an <code>INSERT</code> operation. You might prefer this technique when dropping and rebuilding indexes is more efficient than maintaining them.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8347"></a>
<div class="sect3"><a id="sthref416"></a>
<h4 class="sect3">Refresh Scenario 2</h4>
<p>New data feeds, although consisting primarily of data for the most recent day, week, and month, also contain some data from previous time periods.</p>
<a id="DWHSG8348"></a>
<div class="sect4"><a id="sthref417"></a>
<h5 class="sect4">Solution 1</h5>
<p>Use parallel SQL operations (such as <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code>) to separate the new data from the data in previous time periods. Process the old data separately using other techniques.</p>
<p>New data feeds are not solely time based. You can also feed new data into a data warehouse with data from multiple operational systems on a business need basis. For example, the sales data from direct channels may come into the data warehouse separately from the data from indirect channels. For business reasons, it may furthermore make sense to keep the direct and indirect data in separate partitions.</p>
</div>
<!-- class="sect4" -->
<a id="DWHSG8349"></a>
<div class="sect4"><a id="sthref418"></a>
<h5 class="sect4">Solution 2</h5>
<p>Oracle supports composite range-list partitioning. The primary partitioning strategy of the sales table could be range partitioning based on <code>time_id</code> as shown in the example. However, the subpartitioning is a list based on the channel attribute. Each subpartition can now be loaded independently of each other (for each distinct channel) and added in a rolling window operation as discussed before. The partitioning strategy addresses the business needs in the most optimal manner.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006319"></a><a id="DWHSG03002"></a>
<div class="sect1">
<h2 class="sect1">Optimizing DML Operations During Refresh</h2>
<p>You can optimize DML performance through the following techniques:</p>
<ul>
<li>
<p><a href="#CEGFJDFI">Implementing an Efficient MERGE Operation</a></p>
</li>
<li>
<p><a href="#i1006375">Maintaining Referential Integrity</a></p>
</li>
<li>
<p><a href="#i1006385">Purging Data</a></p>
</li>
</ul>
<a id="CEGFJDFI"></a><a id="DWHSG8350"></a>
<div class="sect2">
<h3 class="sect2">Implementing an Efficient MERGE Operation</h3>
<p><a id="sthref419"></a>Commonly, the data that is extracted from a source system is not simply a list of new records that needs to be inserted into the data warehouse. Instead, this new data set is a combination of new records as well as modified records. For example, suppose that most of data extracted from the OLTP systems will be new sales transactions. These records are inserted into the warehouse's <code>sales</code> table, but some records may reflect modifications of previous transactions, such as returned merchandise or transactions that were incomplete or incorrect when initially loaded into the data warehouse. These records require updates to the <code>sales</code> table.</p>
<p>As a typical scenario, suppose that there is a table called <code>new_sales</code> that contains both inserts and updates that are applied to the <code>sales</code> table. When designing the entire data warehouse load process, it was determined that the <code>new_sales</code> table would contain records with the following semantics:</p>
<ul>
<li>
<p>If a given <code>sales_transaction_id</code> of a record in <code>new_sales</code> already exists in <code>sales</code>, then update the <code>sales</code> table by adding the <code>sales_dollar_amount</code> and <code>sales_quantity_sold</code> values from the <code>new_sales</code> table to the existing row in the <code>sales</code> table.</p>
</li>
<li>
<p>Otherwise, insert the entire new record from the <code>new_sales</code> table into the <code>sales</code> table.</p>
</li>
</ul>
<p>This <code>UPDATE-ELSE-INSERT</code> operation is often called a merge. A merge can be executed using one SQL statement.</p>
<div class="example">
<p class="titleinexample"><a id="i1006363"></a><a id="DWHSG8351"></a>Example 16-1 MERGE Operation</p>
<pre>
MERGE INTO sales s USING new_sales n
ON (s.sales_transaction_id = n.sales_transaction_id)
WHEN MATCHED THEN
UPDATE SET s.sales_quantity_sold = s.sales_quantity_sold + n.sales_quantity_sold,
 s.sales_dollar_amount = s.sales_dollar_amount + n.sales_dollar_amount
WHEN NOT MATCHED THEN INSERT (sales_transaction_id, sales_quantity_sold, 
sales_dollar_amount)
VALUES (n.sales_transcation_id, n.sales_quantity_sold, n.sales_dollar_amount);
</pre>
<p>In addition to using the <code>MERGE</code> statement for unconditional <code>UPDATE</code> <code>ELSE</code> <code>INSERT</code> functionality into a target table, you can also use it to:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>Perform an <code>UPDATE</code> only or <code>INSERT</code> only statement.</p>
</li>
<li>
<p>Apply additional <code>WHERE</code> conditions for the <code>UPDATE</code> or <code>INSERT</code> portion of the <code>MERGE</code> statement.</p>
</li>
<li>
<p>The <code>UPDATE</code> operation can even delete rows if a specific condition yields true.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="DWHSG8352"></a><a id="sthref420"></a>Example 16-2 Omitting the INSERT Clause</p>
<p>In some data warehouse applications, it is not allowed to add new rows to historical information, but only to update them. It may also happen that you do not want to update but only insert new information. The following example demonstrates <code>INSERT</code>-only with <code>UPDATE</code>-only functionality:</p>
<pre>
MERGE USING Product_Changes S     -- Source/Delta table
INTO Products D1                  -- Destination table 1
ON (D1.PROD_ID = S.PROD_ID)       -- Search/Join condition
WHEN MATCHED THEN UPDATE          -- update if join
SET D1.PROD_STATUS = S.PROD_NEW_STATUS
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8353"></a><a id="sthref421"></a>Example 16-3 Omitting the UPDATE Clause</p>
<p>The following statement illustrates an example of omitting an <code>UPDATE</code>:</p>
<pre>
MERGE USING New_Product S           -- Source/Delta table
INTO Products D2                    -- Destination table 2
ON (D2.PROD_ID = S.PROD_ID)         -- Search/Join condition
WHEN NOT MATCHED THEN               -- insert if no join
INSERT (PROD_ID, PROD_STATUS) VALUES (S.PROD_ID, S.PROD_NEW_STATUS)
</pre>
<p>When the <code>INSERT</code> clause is omitted, Oracle performs a regular join of the source and the target tables. When the <code>UPDATE</code> clause is omitted, Oracle performs an antijoin of the source and the target tables. This makes the join between the source and target table more efficient.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8354"></a><a id="sthref422"></a>Example 16-4 Skipping the UPDATE Clause</p>
<p>In some situations, you may want to skip the <code>UPDATE</code> operation when merging a given row into the table. In this case, you can use an optional <code>WHERE</code> clause in the <code>UPDATE</code> clause of the <code>MERGE</code>. As a result, the <code>UPDATE</code> operation only executes when a given condition is true. The following statement illustrates an example of skipping the <code>UPDATE</code> operation:</p>
<pre>
MERGE 
USING Product_Changes S                      -- Source/Delta table 
INTO Products P                              -- Destination table 1 
ON (P.PROD_ID = S.PROD_ID)                   -- Search/Join condition 
WHEN MATCHED THEN 
UPDATE                                       -- update if join 
SET P.PROD_LIST_PRICE = S.PROD_NEW_PRICE 
WHERE P.PROD_STATUS &lt;&gt; "OBSOLETE"            -- Conditional UPDATE
</pre>
<p>This shows how the <code>UPDATE</code> operation would be skipped if the condition <code>P.PROD_STATUS &lt;&gt; "OBSOLETE"</code> is not true. The condition predicate can refer to both the target and the source table.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8355"></a><a id="sthref423"></a>Example 16-5 Conditional Inserts with MERGE Statements</p>
<p>You may want to skip the <code>INSERT</code> operation when merging a given row into the table. So an optional <code>WHERE</code> clause is added to the <code>INSERT</code> clause of the <code>MERGE</code>. As a result, the <code>INSERT</code> operation only executes when a given condition is true. The following statement offers an example:</p>
<pre>
MERGE USING Product_Changes S                      -- Source/Delta table
INTO Products P                                    -- Destination table 1
ON (P.PROD_ID = S.PROD_ID)                         -- Search/Join condition
WHEN MATCHED THEN UPDATE                           -- update if join
SET P.PROD_LIST_PRICE = S.PROD_NEW_PRICE
WHERE P.PROD_STATUS &lt;&gt; "OBSOLETE"                  -- Conditional
WHEN NOT MATCHED THEN
INSERT (PROD_ID, PROD_STATUS, PROD_LIST_PRICE)     -- insert if not join
VALUES (S.PROD_ID, S.PROD_NEW_STATUS, S.PROD_NEW_PRICE)
WHERE S.PROD_STATUS &lt;&gt; "OBSOLETE";                 -- Conditional INSERT
</pre>
<p>This example shows that the <code>INSERT</code> operation would be skipped if the condition <code>S.PROD_STATUS &lt;&gt; "OBSOLETE"</code> is not true, and <code>INSERT</code> will only occur if the condition is true. The condition predicate can refer to the source table only. The condition predicate can only refer to the source table.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8356"></a><a id="sthref424"></a>Example 16-6 Using the DELETE Clause with MERGE Statements</p>
<p>You may want to cleanse tables while populating or updating them. To do this, you may want to consider using the <code>DELETE</code> clause in a <code>MERGE</code> statement, as in the following example:</p>
<pre>
MERGE USING Product_Changes S
INTO Products D ON (D.PROD_ID = S.PROD_ID)
WHEN MATCHED THEN
UPDATE SET D.PROD_LIST_PRICE =S.PROD_NEW_PRICE, D.PROD_STATUS = S.PROD_NEWSTATUS
DELETE WHERE (D.PROD_STATUS = "OBSOLETE")
WHEN NOT MATCHED THEN
INSERT (PROD_ID, PROD_LIST_PRICE, PROD_STATUS)
VALUES (S.PROD_ID, S.PROD_NEW_PRICE, S.PROD_NEW_STATUS);
</pre>
<p>Thus when a row is updated in <code>products</code>, Oracle checks the delete condition <code>D.PROD_STATUS = "OBSOLETE"</code>, and deletes the row if the condition yields true.</p>
<p>The <code>DELETE</code> operation is not as same as that of a complete <code>DELETE</code> statement. Only the rows from the destination of the <code>MERGE</code> can be deleted. The only rows that are affected by the <code>DELETE</code> are the ones that are updated by this <code>MERGE</code> statement. Thus, although a given row of the destination table meets the delete condition, if it does not join under the <code>ON</code> clause condition, it is not deleted.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8357"></a><a id="sthref425"></a>Example 16-7 Unconditional Inserts with MERGE Statements</p>
<p>You may want to insert all of the source rows into a table. In this case, the join between the source and target table can be avoided. By identifying special constant join conditions that always result to <code>FALSE</code>, for example, 1=0, such <code>MERGE</code> statements will be optimized and the join condition will be suppressed.</p>
<pre>
MERGE USING New_Product S       -- Source/Delta table 
INTO Products P                 -- Destination table 1 
ON (1 = 0)                      -- Search/Join condition 
WHEN NOT MATCHED THEN           -- insert if no join 
INSERT (PROD_ID, PROD_STATUS) VALUES (S.PROD_ID, S.PROD_NEW_STATUS)
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1006375"></a><a id="DWHSG8358"></a>
<div class="sect2">
<h3 class="sect2">Maintaining Referential Integrity</h3>
<p>In some data warehousing environments, you might want to insert new data into tables in order to guarantee referential integrity. For example, a data warehouse may derive <code>sales</code> from an operational system that retrieves data directly from cash registers. <code>sales</code> is refreshed nightly. However, the data for the <code>product</code> dimension table may be derived from a separate operational system. The <code>product</code> dimension table may only be refreshed once for each week, because the <code>product</code> table changes relatively slowly. If a new product was introduced on Monday, then it is possible for that product's <code>product_id</code> to appear in the <code>sales</code> data of the data warehouse before that <code>product_id</code> has been inserted into the data warehouses <code>product</code> table.</p>
<p>Although the sales transactions of the new product may be valid, this sales data will not satisfy the referential integrity constraint between the <code>product</code> dimension table and the <code>sales</code> fact table. Rather than disallow the new sales transactions, you might choose to insert the sales transactions into the <code>sales</code> table. However, you might also wish to maintain the referential integrity relationship between the <code>sales</code> and <code>product</code> tables. This can be accomplished by inserting new rows into the <code>product</code> table as placeholders for the unknown products.</p>
<p>As in previous examples, we assume that the new data for the <code>sales</code> table is staged in a separate table, <code>new_sales</code>. Using a single <code>INSERT</code> statement (which can be parallelized), the <code>product</code> table can be altered to reflect the new products:</p>
<pre>
INSERT INTO product
  (SELECT sales_product_id, 'Unknown Product Name', NULL, NULL ...
   FROM new_sales WHERE sales_product_id NOT IN
  (SELECT product_id FROM product));
</pre></div>
<!-- class="sect2" -->
<a id="i1006385"></a><a id="DWHSG8359"></a>
<div class="sect2">
<h3 class="sect2">Purging Data</h3>
<p><a id="sthref426"></a><a id="sthref427"></a>Occasionally, it is necessary<a id="sthref428"></a> to remove large amounts of data from a data warehouse. A very common scenario is the rolling window discussed previously, in which older data is rolled out of the data warehouse to make room for new data.</p>
<p>However, sometimes other data might need to be removed from a data warehouse. Suppose that a retail company has previously sold products from <code>XYZ</code> <code>Software</code>, and that <code>XYZ</code> <code>Software</code> has subsequently gone out of business. The business users of the warehouse may decide that they are no longer interested in seeing any data related to <code>XYZ</code> <code>Software</code>, so this data should be deleted.</p>
<p>One approach to removing a large volume of data is to use parallel delete as shown in the following statement:</p>
<pre>
DELETE FROM sales WHERE sales_product_id IN (SELECT product_id 
   FROM product WHERE product_category = 'XYZ Software');
</pre>
<p>This SQL statement spawns one parallel process for each partition. This approach is much more efficient than a serial <code>DELETE</code> statement, and none of the data in the <code>sales</code> table will need to be moved. However, this approach also has some disadvantages. When removing a large percentage of rows, the <code>DELETE</code> statement will leave many empty row-slots in the existing partitions. If new data is being loaded using a rolling window technique (or is being loaded using direct-path <code>INSERT</code> or load), then this storage space will not be reclaimed. Moreover, even though the <code>DELETE</code> statement is parallelized, there might be more efficient methods. An alternative method is to re-create the entire <code>sales</code> table, keeping the data for all product categories except <code>XYZ</code> <code>Software</code>.</p>
<pre>
CREATE TABLE sales2 AS SELECT * FROM sales, product
WHERE sales.sales_product_id = product.product_id 
AND product_category &lt;&gt; 'XYZ Software'
NOLOGGING PARALLEL (DEGREE 8)
#PARTITION ... ; #create indexes, constraints, and so on
DROP TABLE SALES;
RENAME SALES2 TO SALES;
</pre>
<p>This approach may be more efficient than a parallel delete. However, it is also costly in terms of the amount of disk space, because the <code>sales</code> table must effectively be instantiated twice.</p>
<p>An alternative method to utilize less space is to re-create the <code>sales</code> table one partition at a time:</p>
<pre>
CREATE TABLE sales_temp AS SELECT * FROM sales WHERE 1=0;
INSERT INTO sales_temp
SELECT * FROM sales PARTITION (sales_99jan), product
WHERE sales.sales_product_id = product.product_id
AND product_category &lt;&gt; 'XYZ Software';
&lt;create appropriate indexes and constraints on sales_temp&gt;
ALTER TABLE sales EXCHANGE PARTITION sales_99jan WITH TABLE sales_temp;
</pre>
<p>Continue this process for each partition in the <code>sales</code> table.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006419"></a><a id="DWHSG03003"></a>
<div class="sect1">
<h2 class="sect1">Refreshing Materialized Views</h2>
<p><a id="sthref429"></a><a id="sthref430"></a>When <a id="sthref431"></a>creating a materialized view, you have the option of specifying whether the refresh occurs <code>ON</code> <code>DEMAND</code> or <code>ON</code> <code>COMMIT</code>. In the case of <code>ON</code> <code>COMMIT</code>, the materialized view is changed every time a transaction commits, thus ensuring that the materialized view always contains the latest data. Alternatively, you can control the time when refresh of the materialized views occurs by specifying <code>ON</code> <code>DEMAND</code>. In this case, the materialized view can only be refreshed by calling one of the procedures in the <code>DBMS_MVIEW</code> package.</p>
<p><code>DBMS_MVIEW</code> provides three different types of refresh operations.</p>
<ul>
<li>
<p><code><a id="sthref432"></a>DBMS_MVIEW.REFRESH</code></p>
<p>Refresh one or more materialized views.</p>
</li>
<li>
<p><code><a id="sthref433"></a>DBMS_MVIEW.REFRESH_ALL_MVIEWS</code></p>
<p>Refresh all materialized views.</p>
</li>
<li>
<p><code><a id="sthref434"></a>DBMS_MVIEW.REFRESH_DEPENDENT</code></p>
<p>Refresh all materialized views that depend on a specified master table or materialized view or list of master tables or materialized views.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a href="#i1006462">"Manual Refresh Using the DBMS_MVIEW Package"</a> for more information</div>
</li>
</ul>
<p>Performing a refresh operation requires temporary space to rebuild the indexes and can require additional space for performing the refresh operation itself. Some sites might prefer not to refresh all of their materialized views at the same time: as soon as some underlying detail data has been updated, all materialized views using this data will become stale. Therefore, if you defer refreshing your materialized views, you can either rely on your chosen rewrite integrity level to determine whether or not a stale materialized view can be used for query rewrite, or you can temporarily disable query rewrite with an <code>ALTER</code> <code>SYSTEM</code> <code>SET</code> <code>QUERY_REWRITE_ENABLED = FALSE</code> statement. After refreshing the materialized views, you can re-enable query rewrite as the default for all sessions in the current database instance by specifying <code>ALTER</code> <code>SYSTEM</code> <code>SET</code> <code>QUERY_REWRITE_ENABLED</code> as <code>TRUE</code>. Refreshing a materialized view automatically updates all of its indexes. In the case of full refresh, this requires temporary sort space to rebuild all indexes during refresh. This is because the full refresh truncates or deletes the table before inserting the new full data volume. If insufficient temporary space is available to rebuild the indexes, then you must explicitly drop each index or mark it <code>UNUSABLE</code> prior to performing the refresh operation.</p>
<p>If you anticipate performing insert, update or delete operations on tables referenced by a materialized view concurrently with the refresh of that materialized view, and that materialized view includes joins and aggregation, Oracle recommends you use <code>ON</code> <code>COMMIT</code> fast refresh rather than <code>ON</code> <code>DEMAND</code> fast refresh.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink OLAUG" href="../../olap.112/e17123/toc.htm"><span class="italic">Oracle OLAP User's Guide</span></a> for information regarding the refresh of cube organized materialized views</div>
<a id="i1006446"></a><a id="DWHSG8360"></a>
<div class="sect2">
<h3 class="sect2">Complete Refresh</h3>
<p><a id="sthref435"></a>A complete refresh occurs when the materialized view is initially defined as <code>BUILD</code> <code>IMMEDIATE</code>, unless the materialized view references a prebuilt table. For materialized views using <code>BUILD</code> <code>DEFERRED</code>, a complete refresh must be requested before it can be used for the first time. A complete refresh may be requested at any time during the life of any materialized view. The refresh involves reading the detail tables to compute the results for the materialized view. This can be a very time-consuming process, especially if there are huge amounts of data to be read and processed. Therefore, you should always consider the time required to process a complete refresh before requesting it.</p>
<p>There are, however, cases when the only refresh method available for an already built materialized view is complete refresh because the materialized view does not satisfy the conditions specified in the following section for a fast refresh.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8361"></a>
<div class="sect2"><a id="sthref436"></a>
<h3 class="sect2">Fast Refresh</h3>
<p><a id="sthref437"></a>Most data warehouses have periodic incremental updates to their detail data. As described in <a href="basicmv.htm#i1006354">"Materialized View Schema Design"</a>, you can use the SQL*Loader or any bulk load utility to perform incremental loads of detail data. Fast refresh of your materialized views is usually efficient, because instead of having to recompute the entire materialized view, the changes are applied to the existing data. Thus, processing only the changes can result in a very fast refresh time.</p>
</div>
<!-- class="sect2" -->
<a id="i1008584"></a><a id="DWHSG8362"></a>
<div class="sect2">
<h3 class="sect2">Partition Change Tracking (PCT) Refresh</h3>
<p>Whe<a id="sthref438"></a><a id="sthref439"></a>n there have been some partition maintenance operations on the detail tables, this is the only method of fast refresh that can be used. PCT-based refresh on a materialized view is enabled only if all the conditions described in <a href="advmv.htm#i1006649">"Partition Change Tracking"</a> are satisfied.</p>
<p>In the absence of partition maintenance operations on detail tables, when you request a <code>FAST</code> method (<code>method =&gt; 'F'</code>) of refresh through procedures in <code>DBMS_MVIEW</code> package, Oracle uses a heuristic rule to try log-based rule fast refresh before choosing PCT refresh. Similarly, when you request a <code>FORCE</code> method (<code>method =&gt; '?'</code>), Oracle chooses the refresh method based on the following attempt order: log-based fast refresh, PCT refresh, and complete refresh. Alternatively, you can request the PCT method (<code>method =&gt; 'P'</code>), and Oracle uses the PCT method provided all PCT requirements are satisfied.</p>
<p>Oracle can use <code>TRUNCATE</code> <code>PARTITION</code> on a materialized view if it satisfies the conditions in <a href="advmv.htm#i1009128">"Benefits of Partitioning a Materialized View"</a> and hence, make the PCT refresh process more efficient.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8363"></a>
<div class="sect2"><a id="sthref440"></a>
<h3 class="sect2">ON COMMIT Refresh</h3>
<p>A materialized view can be refreshed automatically using the <code>ON</code> <code>COMMIT</code> method. Therefore, whenever a transaction commits which has updated the tables on which a materialized view is defined, those changes are automatically reflected in the materialized view. The advantage of using this approach is you never have to remember to refresh the materialized view. The only disadvantage is the time required to complete the commit will be slightly longer because of the extra processing involved. However, in a data warehouse, this should not be an issue because there is unlikely to be concurrent processes trying to update the same table.</p>
</div>
<!-- class="sect2" -->
<a id="i1006462"></a><a id="DWHSG8364"></a>
<div class="sect2">
<h3 class="sect2">Manual Refresh Using the DBMS_MVIEW Package</h3>
<p>When a materialized view is ref<a id="sthref441"></a><a id="sthref442"></a>reshed <code>ON</code> <code>DEMAND</code>, one of four refresh methods can be specified as shown in the following table. You can define a default option during the creation of the materialized view. <a href="#i1008349">Table 16-1</a> details the refresh options.</p>
<div class="tblformalwidemax">
<p class="titleintable"><a id="DWHSG8365"></a><a id="sthref443"></a><a id="sthref444"></a>Table 16-1 <a id="i1008349"></a><span class="bolditalic">ON DEMAND Refresh Methods</span></p>
<table class="cellalignment1383" title="ON DEMAND Refresh Methods" summary="ON DEMAND Refresh Methods" dir="ltr">
<thead>
<tr class="cellalignment1372">
<th class="cellalignment1382" id="r1c1-t6">Refresh Option</th>
<th class="cellalignment1382" id="r1c2-t6">Parameter</th>
<th class="cellalignment1382" id="r1c3-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r2c1-t6" headers="r1c1-t6">
<p><code>COMPLETE</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t6 r1c2-t6">
<p><code>C</code></p>
</td>
<td class="cellalignment1378" headers="r2c1-t6 r1c3-t6">
<p>Refreshes by recalculating the defining query of the materialized view.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r3c1-t6" headers="r1c1-t6">
<p><code>FAST</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t6 r1c2-t6">
<p><code>F</code></p>
</td>
<td class="cellalignment1378" headers="r3c1-t6 r1c3-t6">
<p>Refreshes by incrementally applying changes to the materialized view.</p>
<p>For local materialized views, it chooses the refresh method which is estimated by optimizer to be most efficient. The refresh methods considered are log-based <code>FAST</code> and <code>FAST_PCT</code>.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r4c1-t6" headers="r1c1-t6">
<p><code>FAST_PCT</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t6 r1c2-t6">
<p><code>P</code></p>
</td>
<td class="cellalignment1378" headers="r4c1-t6 r1c3-t6">
<p>Refreshes by recomputing the rows in the materialized view affected by changed partitions in the detail tables.</p>
</td>
</tr>
<tr class="cellalignment1372">
<td class="cellalignment1378" id="r5c1-t6" headers="r1c1-t6">
<p><code>FORCE</code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t6 r1c2-t6">
<p><code>?</code></p>
</td>
<td class="cellalignment1378" headers="r5c1-t6 r1c3-t6">
<p>Attempts a fast refresh. If that is not possible, it does a complete refresh.</p>
<p>For local materialized views, it chooses the refresh method which is estimated by optimizer to be most efficient. The refresh methods considered are log based <code>FAST</code>, <code>FAST_PCT</code>, and <code>COMPLETE</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p><a id="sthref445"></a>Three refresh procedures are available in the <code><a id="sthref446"></a>DBMS_MVIEW</code> package for performing <code>ON</code> <code>DEMAND</code> refresh. Each has its own unique set of parameters.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS027" href="../../appdev.112/e40758/d_mview.htm#ARPLS027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information about the <code>DBMS_MVIEW</code> package</p>
</li>
<li>
<p><a class="olink REPLN" href="../e10706/toc.htm"><span class="italic">Oracle Database Advanced Replication</span></a> for information showing how to use it in a replication environment</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="DWHSG8366"></a>
<div class="sect2"><a id="sthref447"></a>
<h3 class="sect2">Refresh Specific Materialized Views with REFRESH</h3>
<p>Use the <code><a id="sthref448"></a>DBMS_MVIEW.REFRESH</code> procedure to refresh one or more materialized views. Some parameters are used only for replication, so they are not mentioned here. The required parameters to use this procedure are:</p>
<ul>
<li>
<p>The comma-delimited list of materialized views to refresh</p>
</li>
<li>
<p>The refresh method: <code>F</code>-Fast, <code>P</code>-Fast_PCT, <code>?</code>-Force, <code>C</code>-Complete</p>
</li>
<li>
<p>The rollback segment to use</p>
</li>
<li>
<p>Refresh after errors (<code>TRUE</code> or <code>FALSE</code>)</p>
<p>A Boolean parameter. If set to <code>TRUE</code>, the <code>number_of_failures</code> output parameter is set to the number of refreshes that failed, and a generic error message indicates that failures occurred. The alert log for the instance gives details of refresh errors. If set to <code>FALSE</code>, the default, then refresh will stop after it encounters the first error, and any remaining materialized views in the list are not be refreshed.</p>
</li>
<li>
<p>The following four parameters are used by the replication process. For warehouse refresh, set them to <code>FALSE, 0,0,0</code>.</p>
</li>
<li>
<p>Atomic refresh (<code>TRUE</code> or <code>FALSE</code>)</p>
<p>If set to <code>TRUE</code>, then all refreshes are done in one transaction. If set to <code>FALSE</code>, then the refresh of each specified materialized view is done in a separate transaction. If set to <code>FALSE</code>, Oracle can optimize refresh by using parallel DML and truncate DDL on a materialized views. When a materialized view is refreshed in atomic mode, it is eligible for query rewrite if the rewrite integrity mode is set to <code>stale_tolerated</code>. Atomic refresh cannot be guaranteed when refresh is performed on nested views.</p>
</li>
</ul>
<p>For example, to perform a fast refresh on the materialized view <code>cal_month_sales_mv</code>, the <code>DBMS_MVIEW</code> package would be called as follows:</p>
<pre>
DBMS_MVIEW.REFRESH('CAL_MONTH_SALES_MV', 'F', '', TRUE, FALSE, 0,0,0, FALSE);
</pre>
<p>Multiple materialized views can be refreshed at the same time, and they do not all have to use the same refresh method. To give them different refresh methods, specify multiple method codes in the same order as the list of materialized views (without commas). For example, the following specifies that <code>cal_month_sales_mv</code> be completely refreshed and <code>fweek_pscat_sales_mv</code> receive a fast refresh:</p>
<pre>
DBMS_MVIEW.REFRESH('CAL_MONTH_SALES_MV, FWEEK_PSCAT_SALES_MV', 'CF', '', 
  TRUE, FALSE, 0,0,0, FALSE);
</pre>
<p>If the refresh method is not specified, the default refresh method as specified in the materialized view definition is used.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8367"></a>
<div class="sect2"><a id="sthref449"></a>
<h3 class="sect2">Refresh All Materialized Views with REFRESH_ALL_MVIEWS</h3>
<p><a id="sthref450"></a>An alternative to specifying the materialized views to refresh is to use the procedure <code>DBMS_MVIEW.REFRESH_ALL_MVIEWS</code>. This procedure refreshes all materialized views. If any of the materialized views fails to refresh, then the number of failures is reported.</p>
<p>The parameters for this procedure are:</p>
<ul>
<li>
<p>The number of failures (this is an <code>OUT</code> variable)</p>
</li>
<li>
<p>The refresh method: <code>F</code>-Fast, <code>P</code>-Fast_PCT, <code>?</code>-Force, <code>C</code>-Complete</p>
</li>
<li>
<p>Refresh after errors (<code>TRUE</code> or <code>FALSE</code>)</p>
<p>A Boolean parameter. If set to <code>TRUE</code>, the <code>number_of_failures</code> output parameter is set to the number of refreshes that failed, and a generic error message indicates that failures occurred. The alert log for the instance gives details of refresh errors. If set to <code>FALSE</code>, the default, then refresh stops after it encounters the first error, and any remaining materialized views in the list is not refreshed.</p>
</li>
<li>
<p>Atomic refresh (<code>TRUE</code> or <code>FALSE</code>)</p>
<p>If set to <code>TRUE</code>, then all refreshes are done in one transaction. If set to <code>FALSE</code>, then each of the materialized views is refreshed non-atomically in separate transactions. If set to <code>FALSE</code>, Oracle can optimize refresh by using parallel DML and truncate DDL on a materialized views. When a materialized view is refreshed in atomic mode, it is eligible for query rewrite if the rewrite integrity mode is set to <code>stale_tolerated</code>. Atomic refresh cannot be guaranteed when refresh is performed on nested views.</p>
</li>
</ul>
<p>An example of refreshing all materialized views is the following:</p>
<pre>
DBMS_MVIEW.REFRESH_ALL_MVIEWS(failures,'C','', TRUE, FALSE);
</pre></div>
<!-- class="sect2" -->
<a id="DWHSG8368"></a>
<div class="sect2"><a id="sthref451"></a>
<h3 class="sect2">Refresh Dependent Materialized Views with REFRESH_DEPENDENT</h3>
<p><a id="sthref452"></a>The third procedure, <code>DBMS_MVIEW.REFRESH_DEPENDENT</code>, refreshes only those materialized views that depend on a specific table or list of tables. For example, suppose the changes have been received for the <code>orders</code> table but not for <code>customer</code> payments. The refresh dependent procedure can be called to refresh only those materialized views that reference the <code>orders</code> table.</p>
<p>The parameters for this procedure are:</p>
<ul>
<li>
<p>The number of failures (this is an <code>OUT</code> variable)</p>
</li>
<li>
<p>The dependent table</p>
</li>
<li>
<p>The refresh method: <code>F</code>-Fast, <code>P</code>-Fast_PCT, <code>?</code>-Force, <code>C</code>-Complete</p>
</li>
<li>
<p>The rollback segment to use</p>
</li>
<li>
<p>Refresh after errors (<code>TRUE</code> or <code>FALSE</code>)</p>
<p>A Boolean parameter. If set to <code>TRUE</code>, the <code>number_of_failures</code> output parameter is set to the number of refreshes that failed, and a generic error message indicates that failures occurred. The alert log for the instance gives details of refresh errors. If set to <code>FALSE</code>, the default, then refresh stops after it encounters the first error, and any remaining materialized views in the list are not refreshed.</p>
</li>
<li>
<p>Atomic refresh (<code>TRUE</code> or <code>FALSE</code>)</p>
<p>If set to <code>TRUE</code>, then all refreshes are done in one transaction. If set to <code>FALSE</code>, then the refresh of each specified materialized view is done in a separate transaction. If set to <code>FALSE</code>, Oracle can optimize refresh by using parallel DML and truncate DDL on a materialized views. When a materialized view is refreshed in atomic mode, it is eligible for query rewrite if the rewrite integrity mode is set to <code>stale_tolerated</code>. Atomic refresh cannot be guaranteed when refresh is performed on nested views.</p>
</li>
<li>
<p>Whether it is nested or not</p>
<p>If set to <code>TRUE</code>, refresh all the dependent materialized views of the specified set of tables based on a dependency order to ensure the materialized views are truly fresh with respect to the underlying base tables.</p>
</li>
</ul>
<p>To perform a full refresh on all materialized views that reference the <code>customers</code> table, specify:</p>
<pre>
DBMS_MVIEW.REFRESH_DEPENDENT(failures, 'CUSTOMERS', 'C', '', FALSE, FALSE );
</pre></div>
<!-- class="sect2" -->
<a id="DWHSG8369"></a>
<div class="sect2"><a id="sthref453"></a>
<h3 class="sect2">Using Job Queues for Refresh</h3>
<p>Job queues can be used to refresh multiple materialized views in parallel. If queues are not available, fast refresh sequentially refreshes each view in the foreground process. To make queues available, you must set the <code><a id="sthref454"></a><a id="sthref455"></a>JOB_QUEUE_PROCESSES</code> parameter. This parameter defines the number of background job queue processes and determines how many materialized views can be refreshed concurrently. Oracle tries to balance the number of concurrent refreshes with the degree of parallelism of each refresh. The order in which the materialized views are refreshed is determined by dependencies imposed by nested materialized views and potential for efficient refresh by using query rewrite against other materialized views (See <a href="#i1007785">"Scheduling Refresh"</a> for details). This parameter is only effective when <code>atomic_refresh</code> is set to <code>FALSE</code>.</p>
<p><a id="sthref456"></a>If the process that is executing <code>DBMS_MVIEW.REFRESH</code> is interrupted or the instance is shut down, any refresh jobs that were executing in job queue processes will be requeued and will continue running. To remove these jobs, use the <code>DBMS_JOB.REMOVE</code> procedure.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8370"></a>
<div class="sect2"><a id="sthref457"></a>
<h3 class="sect2">When Fast Refresh is Possible</h3>
<p>Not all materialized views may be fast refreshable. Therefore, use the package <code>DBMS_MVIEW.EXPLAIN_MVIEW</code> to determine what refresh methods are available for a materialized view. See <a href="basicmv.htm#g1028195">Chapter 9, "Basic Materialized Views"</a> for further information about the <code>DBMS_MVIEW</code> package.</p>
<p>If you are not sure how to make a materialized view fast refreshable, you can use the <code>DBMS_ADVISOR.TUNE_MVIEW</code> procedure, which will provide a script containing the statements required to create a fast refreshable materialized view. See the <a class="olink PFGRF008" href="../../server.112/e41573/advisor.htm#PFGRF008"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8371"></a>
<div class="sect2"><a id="sthref458"></a>
<h3 class="sect2">Recommended Initialization Parameters for Parallelism</h3>
<p>The following initialization parameters need to be set properly for parallelism to be effective:</p>
<ul>
<li>
<p><code><a id="sthref459"></a><a id="sthref460"></a>PARALLEL_MAX_SERVERS</code> should be set high enough to take care of parallelism. You must consider the number of slaves needed for the refresh statement. For example, with a degree of parallelism of eight, you need 16 slave processes.</p>
</li>
<li>
<p><code>PGA_AGGREGA<a id="sthref461"></a><a id="sthref462"></a>TE_TARGET</code> should be set for the instance to manage the memory usage for sorts and joins automatically. If the memory parameters are set manually, <code>SORT_AREA_SIZE</code> should be less than <code>HASH_AREA_SIZE</code>.</p>
</li>
<li>
<p><code><a id="sthref463"></a><a id="sthref464"></a>OPTIMIZER_MODE</code> should equal <code>all_rows</code>.</p>
</li>
</ul>
<p>Remember to analyze all tables and indexes for better optimization.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink VLDBG010" href="../../server.112/e25523/parallel.htm#VLDBG010"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for further information</div>
</div>
<!-- class="sect2" -->
<a id="DWHSG8372"></a>
<div class="sect2"><a id="sthref465"></a>
<h3 class="sect2">Monitoring a Refresh</h3>
<p><a id="sthref466"></a><a id="sthref467"></a>While a job is running, you can query the <code>V$SESSION_LONGOPS</code> view to tell you the progress of each materialized view being refreshed.</p>
<pre>
SELECT * FROM V$SESSION_LONGOPS;
</pre>
<p>To look at the progress of which jobs are on which queue, use:</p>
<pre>
SELECT * FROM DBA_JOBS_RUNNING;
</pre></div>
<!-- class="sect2" -->
<a id="DWHSG8373"></a>
<div class="sect2"><a id="sthref468"></a>
<h3 class="sect2">Checking the Status of a Materialized View</h3>
<p>Three <a id="sthref469"></a>views are provided for checking the status of a materialized view: <code>DBA_MVEIWS</code>, <code>ALL_MVIEWS</code>, and <code>USER_MVIEWS</code>. To check if a materialized view is fresh or stale, issue the following statement:</p>
<pre>
SELECT MVIEW_NAME, STALENESS, LAST_REFRESH_TYPE, COMPILE_STATE 
FROM USER_MVIEWS ORDER BY MVIEW_NAME;

MVIEW_NAME            STALENESS      LAST_REF       COMPILE_STATE
----------            ---------      --------       -------------
CUST_MTH_SALES_MV     NEEDS_COMPILE  FAST           NEEDS_COMPILE
PROD_YR_SALES_MV      FRESH          FAST           VALID
</pre>
<p>If the <code>compile_state</code> column shows <code>NEEDS</code> <code>COMPILE</code>, the other displayed column values cannot be trusted as reflecting the true status. To revalidate the materialized view, issue the following statement:</p>
<pre>
ALTER MATERIALIZED VIEW [materialized_view_name] COMPILE;
</pre>
<p>Then reissue the <code>SELECT</code> statement.</p>
<a id="CEGGEIFG"></a><a id="DWHSG8374"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Viewing Partition Freshness</h4>
<p>Several views are available that enable you to verify the status of base table partitions and determine which ranges of materialized view data are fresh and which are stale. The views are as follows:</p>
<ul>
<li>
<p><code>*_USER_MVIEWS</code></p>
<p>To determine Partition Change Tracking (PCT) information for the materialized view.</p>
</li>
<li>
<p><code>*_USER_MVIEW_DETAIL_RELATIONS</code></p>
<p>To display partition information for the detail table a materialized view is based on.</p>
</li>
<li>
<p><code>*_USER_MVIEW_DETAIL_PARTITION</code></p>
<p>To determine which partitions are fresh.</p>
</li>
<li>
<p><code>*_USER_MVIEW_DETAIL_SUBPARTITION</code></p>
<p>To determine which subpartitions are fresh.</p>
</li>
</ul>
<p>The use of these views is illustrated in the following examples. <a href="#CACFEBFE">Figure 16-1</a> illustrates a range-list partitioned table and a materialized view based on it. The partitions are P1, P2, P3, and P4, while the subpartitions are SP1, SP2, and SP3.</p>
<div class="figure">
<p class="titleinfigure"><a id="CACFEBFE"></a><a id="DWHSG8375"></a>Figure 16-1 Determining PCT Freshness</p>
<img width="365" height="162" src="./dwhsg130.gif" alt="Description of Figure 16-1 follows" /><br />
<a id="sthref470" href="./img_text/dwhsg130.htm">Description of "Figure 16-1 Determining PCT Freshness"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="DWHSG8376"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref471"></a>
<h5 class="sect4">Examples of Using Views to Determine Freshness</h5>
<p>This section illustrates examples of determining the PCT and freshness information for materialized views and their detail tables.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8377"></a><a id="sthref472"></a>Example 16-8 Verifying the PCT Status of a Materialized View</p>
<p>Query <code>USER_MVIEWS</code> to access PCT information about the materialized view, as shown in the following:</p>
<pre>
SELECT MVIEW_NAME, NUM_PCT_TABLES, NUM_FRESH_PCT_REGIONS,
   NUM_STALE_PCT_REGIONS
FROM USER_MVIEWS
WHERE MVIEW_NAME = MV1;

MVIEW_NAME NUM_PCT_TABLES NUM_FRESH_PCT_REGIONS NUM_STALE_PCT_REGIONS
---------- -------------- --------------------- ---------------------
       MV1              1                     9                     3
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8378"></a><a id="sthref473"></a>Example 16-9 Verifying the PCT Status in a Materialized View's Detail Table</p>
<p>Query <code>USER_MVIEW_DETAIL_RELATIONS</code> to access PCT detail table information, as shown in the following:</p>
<pre>
SELECT MVIEW_NAME, DETAILOBJ_NAME, DETAILOBJ_PCT,
   NUM_FRESH_PCT_PARTITIONS, NUM_STALE_PCT_PARTITIONS
FROM USER_MVIEW_DETAIL_RELATIONS
WHERE MVIEW_NAME = MV1;
</pre></div>
<!-- class="example" -->
<pre>
MVIEW_NAME  DETAILOBJ_NAME  DETAIL_OBJ_PCT  NUM_FRESH_PCT_PARTITIONS  NUM_STALE_PCT_PARTITIONS
----------  --------------  --------------  ------------------------  ------------------------
        MV1             T1               Y                         3                         1
</pre>
<div class="example">
<p class="titleinexample"><a id="DWHSG8379"></a><a id="sthref474"></a>Example 16-10 Verifying Which Partitions are Fresh</p>
<p>Query <code>USER_MVIEW_DETAIL_PARTITION</code> to access PCT freshness information for partitions, as shown in the following:</p>
<pre>
SELECT MVIEW_NAME,DETAILOBJ_NAME,DETAIL_PARTITION_NAME,
   DETAIL_PARTITION_POSITION,FRESHNESS
FROM USER_MVIEW_DETAIL_PARTITION
WHERE MVIEW_NAME = MV1;
</pre>
<pre>
MVIEW_NAME  DETAILOBJ_NAME  DETAIL_PARTITION_NAME  DETAIL_PARTITION_POSITION  FRESHNESS
----------  --------------  ---------------------  -------------------------  ---------
       MV1               T1                    P1                          1      FRESH
       MV1               T1                    P2                          2      FRESH
       MV1               T1                    P3                          3      STALE
       MV1               T1                    P4                          4      FRESH
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8380"></a><a id="sthref475"></a>Example 16-11 Verifying Which Subpartitions are Fresh</p>
<p>Query <code>USER_MVIEW_DETAIL_SUBPARTITION</code> to access PCT freshness information for subpartitions, as shown in the following:</p>
<pre>
SELECT MVIEW_NAME,DETAILOBJ_NAME,DETAIL_PARTITION_NAME, DETAIL_SUBPARTITION_NAME,
    DETAIL_SUBPARTITION_POSITION,FRESHNESS
FROM USER_MVIEW_DETAIL_SUBPARTITION
WHERE MVIEW_NAME = MV1;
</pre>
<pre>
MVIEW_NAME DETAILOBJ DETAIL_PARTITION DETAIL_SUBPARTITION_NAME DETAIL_SUBPARTITION_POS FRESHNESS
---------- --------- ---------------- ------------------------ ----------------------- ---------
       MV1        T1               P1                      SP1                       1     FRESH
       MV1        T1               P1                      SP2                       1     FRESH
       MV1        T1               P1                      SP3                       1     FRESH
       MV1        T1               P2                      SP1                       1     FRESH
       MV1        T1               P2                      SP2                       1     FRESH
       MV1        T1               P2                      SP3                       1     FRESH
       MV1        T1               P3                      SP1                       1     STALE
       MV1        T1               P3                      SP2                       1     STALE
       MV1        T1               P3                      SP3                       1     STALE
       MV1        T1               P4                      SP1                       1     FRESH
       MV1        T1               P4                      SP2                       1     FRESH
       MV1        T1               P4                      SP3                       1     FRESH
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007785"></a><a id="DWHSG8381"></a>
<div class="sect2">
<h3 class="sect2">Scheduling Refresh</h3>
<p>Very<a id="sthref476"></a> often you have multiple materialized views in the database. Some of these can be computed by rewriting against others. This is very common in data warehousing environment where you may have nested materialized views or materialized views at different levels of some hierarchy.</p>
<p>In such cases, you should create the materialized views as <code>BUILD DEFERRED</code>, and then issue one of the refresh procedures in <code>DBMS_MVIEW</code> package to refresh all the materialized views. Oracle Database computes the dependencies and refreshes the materialized views in the right order. Consider the example of a complete hierarchical cube described in <a href="aggreg.htm#i1012592">"Examples of Hierarchical Cube Materialized Views"</a>. Suppose all the materialized views have been created as <code>BUILD DEFERRED</code>. Creating the materialized views as <code>BUILD DEFERRED</code> only creates the metadata for all the materialized views. And, then, you can just call one of the refresh procedures in <code>DBMS_MVIEW</code> package to refresh all the materialized views in the right order:</p>
<pre>
DECLARE numerrs PLS_INTEGER;
BEGIN DBMS_MVIEW.REFRESH_DEPENDENT (
   number_of_failures =&gt; numerrs, list=&gt;'SALES', method =&gt; 'C');
DBMS_OUTPUT.PUT_LINE('There were ' || numerrs || ' errors during refresh');
END;
/
</pre>
<p>The procedure refreshes the materialized views in the order of their dependencies (first <code>sales_hierarchical_mon_cube_mv</code>, followed by <code>sales_hierarchical_qtr_cube_mv</code>, then, <code>sales_hierarchical_yr_cube_mv</code> and finally, <code>sales_hierarchical_all_cube_mv</code>). Each of these materialized views gets rewritten against the one prior to it in the list).</p>
<p>The same kind of rewrite can also be used while doing PCT refresh. PCT refresh recomputes rows in a materialized view corresponding to changed rows in the detail tables. And, if there are other fresh materialized views available at the time of refresh, it can go directly against them as opposed to going against the detail tables.</p>
<p>Hence, it is always beneficial to pass a list of materialized views to any of the refresh procedures in <code>DBMS_MVIEW</code> package (irrespective of the method specified) and let the procedure figure out the order of doing refresh on materialized views.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8382"></a>
<div class="sect2"><a id="sthref477"></a>
<h3 class="sect2">Tips for Refreshing Materialized Views with Aggregates</h3>
<p>Following are some guidelines for using the refresh mechanism for materialized views with aggregates.</p>
<ul>
<li>
<p>For fast refresh, create materialized view logs on all detail tables involved in a materialized view with the <code>ROWID</code>, <code>SEQUENCE</code> and <code>INCLUDING</code> <code>NEW</code> <code>VALUES</code> clauses.</p>
<p>Include all columns from the table likely to be used in materialized views in the materialized view logs.</p>
<p>Fast refresh may be possible even if the <code>SEQUENCE</code> option is omitted from the materialized view log. If it can be determined that only inserts or deletes will occur on all the detail tables, then the materialized view log does not require the <code>SEQUENCE</code> clause. However, if updates to multiple tables are likely or required or if the specific update scenarios are unknown, make sure the <code>SEQUENCE</code> clause is included.</p>
</li>
<li>
<p>Use Oracle's bulk loader utility or direct-path <code>INSERT</code> (<code>INSERT</code> with the <code>APPEND</code> hint for loads).</p>
<p>This is a lot more efficient than conventional insert. During loading, disable all constraints and re-enable when finished loading. Note that materialized view logs are required regardless of whether you use direct load or conventional DML.</p>
<p>Try to optimize the sequence of conventional mixed DML operations, direct-path <code>INSERT</code> and the fast refresh of materialized views. You can use fast refresh with a mixture of conventional DML and direct loads. Fast refresh can perform significant optimizations if it finds that only direct loads have occurred, as illustrated in the following:</p>
<ol>
<li>
<p>Direct-path <code>INSERT</code> (SQL*Loader or <code>INSERT /*+ APPEND */</code>) into the detail table</p>
</li>
<li>
<p>Refresh materialized view</p>
</li>
<li>
<p>Conventional mixed DML</p>
</li>
<li>
<p>Refresh materialized view</p>
</li>
</ol>
<p>You can use fast refresh with conventional mixed DML (<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>) to the detail tables. However, fast refresh will be able to perform significant optimizations in its processing if it detects that only inserts or deletes have been done to the tables, such as:</p>
<ul>
<li>
<p>DML <code>INSERT</code> or <code>DELETE</code> to the detail table</p>
</li>
<li>
<p>Refresh materialized views</p>
</li>
<li>
<p>DML update to the detail table</p>
</li>
<li>
<p>Refresh materialized view</p>
</li>
</ul>
<p>Even more optimal is the separation of <code>INSERT</code> and <code>DELETE</code>.</p>
<p>If possible, refresh should be performed after each type of data change (as shown earlier) rather than issuing only one refresh at the end. If that is not possible, restrict the conventional DML to the table to inserts only, to get much better refresh performance. Avoid mixing deletes and direct loads.</p>
<p>Furthermore, for refresh <code>ON</code> <code>COMMIT</code>, Oracle keeps track of the type of DML done in the committed transaction. Therefore, do not perform direct-path <code>INSERT</code> and DML to other tables in the same transaction, as Oracle may not be able to optimize the refresh phase.</p>
<p>For <code>ON</code> <code>COMMIT</code> materialized views, where refreshes automatically occur at the end of each transaction, it may not be possible to isolate the DML statements, in which case keeping the transactions short will help. However, if you plan to make numerous modifications to the detail table, it may be better to perform them in one transaction, so that refresh of the materialized view will be performed just once at commit time rather than after each update.</p>
</li>
<li>
<p>Oracle recommends partitioning the tables because it enables you to use:</p>
<ul>
<li>
<p>Parallel DML</p>
<p>For large loads or refresh, enabling parallel DML helps shorten the length of time for the operation.</p>
</li>
<li>
<p>Partition Change Tracking (PCT) fast refresh</p>
<p>You can refresh your materialized views fast after partition maintenance operations on the detail tables. <a href="advmv.htm#i1006649">"Partition Change Tracking"</a> for details on enabling PCT for materialized views.</p>
</li>
</ul>
</li>
<li>
<p>Partitioning the materialized view also helps refresh performance as refresh can update the materialized view using parallel DML. For example, assume that the detail tables and materialized view are partitioned and have a parallel clause. The following sequence would enable Oracle to parallelize the refresh of the materialized view.</p>
<ol>
<li>
<p>Bulk load into the detail table.</p>
</li>
<li>
<p>Enable parallel DML with an <code>ALTER</code> <code>SESSION</code> <code>ENABLE</code> <code>PARALLEL</code> <code>DML</code> statement.</p>
</li>
<li>
<p>Refresh the materialized view.</p>
</li>
</ol>
</li>
<li>
<p>For refresh using <code>DBMS_MVIEW.REFRESH</code>, set the parameter <code>atomic_refresh</code> to <code>FALSE</code>.</p>
<ul>
<li>
<p>For <code>COMPLETE</code> refresh, this will <code>TRUNCATE</code> to delete existing rows in the materialized view, which is faster than a delete.</p>
</li>
<li>
<p>For <code>PCT</code> refresh, if the materialized view is partitioned appropriately, this will use <code>TRUNCATE</code> <code>PARTITION</code> to delete rows in the affected partitions of the materialized view, which is faster than a delete.</p>
</li>
<li>
<p>For <code>FAST</code> or <code>FORCE</code> refresh, if <code>COMPLETE</code> or PCT refresh is chosen, this will be able to use the <code>TRUNCATE</code> optimizations described earlier.</p>
</li>
</ul>
</li>
<li>
<p>When using <code>DBMS_MVIEW.REFRESH</code> with <code>JOB_QUEUES</code>, remember to set <code>atomic</code> to <code>FALSE</code>. Otherwise, <code>JOB_QUEUES</code> is not used. Set the number of job queue processes greater than the number of processors.</p>
<p>If job queues are enabled and there are many materialized views to refresh, it is faster to refresh all of them in a single command than to call them individually.</p>
</li>
<li>
<p>Use <code>REFRESH</code> <code>FORCE</code> to ensure refreshing a materialized view so that it can definitely be used for query rewrite. The best refresh method is chosen. If a fast refresh cannot be done, a complete refresh is performed.</p>
</li>
<li>
<p>Refresh all the materialized views in a single procedure call. This gives Oracle an opportunity to schedule refresh of all the materialized views in the right order taking into account dependencies imposed by nested materialized views and potential for efficient refresh by using query rewrite against other materialized views.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="DWHSG8383"></a>
<div class="sect2"><a id="sthref478"></a>
<h3 class="sect2">Tips for Refreshing Materialized Views Without Aggregates</h3>
<p>If a materialized view contains joins but no aggregates, then having an index on each of the join column rowids in the detail table will enhance refresh performance greatly, because this type of materialized view tends to be much larger than materialized views containing aggregates. For example, consider the following materialized view:</p>
<pre>
CREATE MATERIALIZED VIEW detail_fact_mv BUILD IMMEDIATE AS
SELECT s.rowid "sales_rid", t.rowid "times_rid", c.rowid "cust_rid",
   c.cust_state_province, t.week_ending_day, s.amount_sold
FROM sales s, times t, customers c 
WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id;
 
</pre>
<p>Indexes should be created on columns <code>sales_rid</code>, <code>times_rid</code> and <code>cust_rid</code>. Partitioning is highly recommended, as is enabling parallel DML in the session before invoking refresh, because it will greatly enhance refresh performance.</p>
<p>This type of materialized view can also be fast refreshed if DML is performed on the detail table. It is recommended that the same procedure be applied to this type of materialized view as for a single table aggregate. That is, perform one type of change (direct-path <code>INSERT</code> or DML) and then refresh the materialized view. This is because Oracle Database can perform significant optimizations if it detects that only one type of change has been done.</p>
<p>Also, Oracle recommends that the refresh be invoked after each table is loaded, rather than load all the tables and then perform the refresh.</p>
<p>For refresh <code>ON</code> <code>COMMIT</code>, Oracle keeps track of the type of DML done in the committed transaction. Oracle therefore recommends that you do not perform direct-path and conventional DML to other tables in the same transaction because Oracle may not be able to optimize the refresh phase. For example, the following is not recommended:</p>
<ol>
<li>
<p>Direct load new data into the fact table</p>
</li>
<li>
<p>DML into the store table</p>
</li>
<li>
<p>Commit</p>
</li>
</ol>
<p>Also, try not to mix different types of conventional DML statements if possible. This would again prevent using various optimizations during fast refresh. For example, try to avoid the following:</p>
<ol>
<li>
<p>Insert into the fact table</p>
</li>
<li>
<p>Delete from the fact table</p>
</li>
<li>
<p>Commit</p>
</li>
</ol>
<p>If many updates are needed, try to group them all into one transaction because refresh will be performed just once at commit time, rather than after each update.</p>
<p>In a data warehousing environment, assuming that the materialized view has a parallel clause, the following sequence of steps is recommended:</p>
<ol>
<li>
<p>Bulk load into the fact table</p>
</li>
<li>
<p>Enable parallel DML</p>
</li>
<li>
<p>An <code>ALTER</code> <code>SESSION</code> <code>ENABLE</code> <code>PARALLEL</code> <code>DML</code> statement</p>
</li>
<li>
<p>Refresh the materialized view</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="DWHSG8384"></a>
<div class="sect2"><a id="sthref479"></a>
<h3 class="sect2">Tips for Refreshing Nested Materialized Views</h3>
<p><a id="sthref480"></a><a id="sthref481"></a>All underlying objects are treated as ordinary tables when refreshing materialized views. If the <code>ON</code> <code>COMMIT</code> refresh option is specified, then all the materialized views are refreshed in the appropriate order at commit time. In other words, Oracle builds a partially ordered set of materialized views and refreshes them such that, after the successful completion of the refresh, all the materialized views are fresh. The status of the materialized views can be checked by querying the appropriate <code>USER_</code>, <code>DBA_</code>, or <code>ALL_MVIEWS</code> view.</p>
<p>If any of the materialized views are defined as <code>ON</code> <code>DEMAND</code> refresh (irrespective of whether the refresh method is <code>FAST</code>, <code>FORCE</code>, or <code>COMPLETE</code>), you will need to refresh them in the correct order (taking into account the dependencies between the materialized views) because the nested materialized view will be refreshed with respect to the current contents of the other materialized views (whether fresh or not). This can be achieved by invoking the refresh procedure against the materialized view at the top of the nested hierarchy and specifying the <code>nested</code> parameter as <code>TRUE</code>.</p>
<p>If a refresh fails during commit time, the list of materialized views that has not been refreshed is written to the alert log, and you must manually refresh them along with all their dependent materialized views.</p>
<p>Use the same <code>DBMS_MVIEW</code> procedures on nested materialized views that you use on regular materialized views.</p>
<p>These procedures have the following behavior when used with nested materialized views:</p>
<ul>
<li>
<p>If <code>REFRESH</code> is applied to a materialized view <code>my_mv</code> that is built on other materialized views, then <code>my_mv</code> will be refreshed with respect to the current contents of the other materialized views (that is, the other materialized views will not be made fresh first) unless you specify <code>nested =&gt; TRUE</code>.</p>
</li>
<li>
<p>If <code>REFRESH_DEPENDENT</code> is applied to materialized view <code>my_mv</code>, then only materialized views that directly depend on <code>my_mv</code> will be refreshed (that is, a materialized view that depends on a materialized view that depends on <code>my_mv</code> will not be refreshed) unless you specify <code>nested =&gt; TRUE</code>.</p>
</li>
<li>
<p>If <code>REFRESH_ALL_MVIEWS</code> is used, the order in which the materialized views will be refreshed is guaranteed to respect the dependencies between nested materialized views.</p>
</li>
<li>
<p><code>GET_MV_DEPENDENCIES</code> provides a list of the immediate (or direct) materialized view dependencies for an object.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="DWHSG8385"></a>
<div class="sect2"><a id="sthref482"></a>
<h3 class="sect2">Tips for Fast Refresh with UNION ALL</h3>
<p>You can use fast<a id="sthref483"></a><a id="sthref484"></a> refresh for materialized views that use the <code>UNION</code> <code>ALL</code> operator by providing a maintenance column in the definition of the materialized view. For example, a materialized view with a <code>UNION</code> <code>ALL</code> operator can be made fast refreshable as follows:</p>
<pre>
CREATE MATERIALIZED VIEW fast_rf_union_all_mv AS
SELECT x.rowid AS r1, y.rowid AS r2, a, b, c, 1 AS marker
FROM x, y WHERE x.a = y.b 
UNION ALL 
SELECT p.rowid, r.rowid, a, c, d, 2 AS marker
FROM p, r WHERE p.a = r.y;
</pre>
<p>The form of a maintenance marker column, column <code>MARKER</code> in the example, must be <code>numeric_or_string_literal</code> <code>AS</code> <code>column_alias</code>, where each <code>UNION</code> <code>ALL</code> member has a distinct value for <code>numeric_or_string_literal</code>.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG0319"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref485"></a>
<h3 class="sect2">Tips for Fast Refresh with Commit SCN-Based Materialized View Logs</h3>
<p>You can often improve fast refresh performance by ensuring that your materialized view logs on the base table contain a <code>WITH</code> <code>COMMIT</code> <code>SCN</code> clause, often significantly. By optimizing materialized view log processing <code>WITH</code> <code>COMMIT</code> <code>SCN</code>, the fast refresh process can save time. The following example illustrates how to use this clause:</p>
<pre>
CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID
 (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold),
COMMIT SCN INCLUDING NEW VALUES;
</pre>
<p>The materialized view refresh will then automatically use the commit SCN-based materialized view log to save refresh time.</p>
<p>Note that only new materialized view logs can take advantage of <code>COMMIT</code> <code>SCN</code>. Existing materialized view logs cannot be altered to add <code>COMMIT</code> <code>SCN</code> unless they are dropped and recreated.</p>
<p>When a materialized view is created on both base tables with timestamp-based materialized view logs and base tables with commit SCN-based materialized view logs, an error (ORA-32414) will be raised stating that materialized view logs are not compatible with each other for fast refresh.</p>
</div>
<!-- class="sect2" -->
<a id="DWHSG8386"></a>
<div class="sect2"><a id="sthref486"></a>
<h3 class="sect2">Tips After Refreshing Materialized Views</h3>
<p>After you have performed a load or incremental load and rebuilt the detail table indexes, you must re-enable integrity constraints (if any) and refresh the materialized views and materialized view indexes that are derived from that detail data. In a data warehouse environment, referential integrity constraints are normally enabled with the <code>NOVALIDATE</code> or <code>RELY</code> options. An important decision to make before performing a refresh operation is whether the refresh needs to be recoverable. Because materialized view data is redundant and can always be reconstructed from the detail tables, it might be preferable to disable logging on the materialized view. To disable logging and run incremental refresh non-recoverably, use the <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> ... <code>NOLOGGING</code> statement prior to refreshing.</p>
<p>If the materialized view is being refreshed using the <code>ON</code> <code>COMMIT</code> method, then, following refresh operations, consult the alert log <code>alert_</code><span class="italic">SID</span><code>.log</code> and the trace file <code>ora_</code><span class="italic">SID</span><code>_number.trc</code> to check that no errors have occurred.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006759"></a><a id="DWHSG03009"></a>
<div class="sect1">
<h2 class="sect1">Using Materialized Views with Partitioned Tables</h2>
<p>A major maintenance <a id="sthref487"></a><a id="sthref488"></a>component of a data warehouse is synchronizing (refreshing) the materialized views when the detail data changes. Partitioning the underlying detail tables can reduce the amount of time taken to perform the refresh task. This is possible because partitioning enables refresh to use parallel DML to update the materialized view. Also, it enables the use of Partition Change Tracking.</p>
<a id="DWHSG8387"></a>
<div class="sect2"><a id="sthref489"></a>
<h3 class="sect2">Fast Refresh with Partition Change Tracking</h3>
<p>In a data warehous<a id="sthref490"></a>e, changes to the detail tables can often entail partition maintenance operations, such as <code>DROP</code>, <code>EXCHANGE</code>, <code>MERGE</code>, and <code>ADD</code> <code>PARTITION</code>. To maintain the materialized view after such operations used to require manual maintenance (see also <code>CONSIDER</code> <code>FRESH</code>) or complete refresh. You now have the option of using an addition to fast refresh known as Partition Change Tracking (PCT) refresh.</p>
<p>For PCT to be available, the detail tables must be partitioned. The partitioning of the materialized view itself has no bearing on this feature. If PCT refresh is possible, it will occur automatically and no user intervention is required in order for it to occur. See <a href="advmv.htm#i1006649">"Partition Change Tracking"</a> for PCT requirements.</p>
<p>The following examples illustrate the use of this feature. In <a href="#CEGFHDDC">"PCT Fast Refresh Scenario 1"</a>, assume <code>sales</code> is a partitioned table using the <code>time_id</code> column and <code>products</code> is partitioned by the <code>prod_category</code> column. The table <code>times</code> is not a partitioned table.</p>
<a id="CEGFHDDC"></a><a id="DWHSG8388"></a>
<div class="sect3">
<h4 class="sect3">PCT Fast Refresh Scenario 1</h4>
<ol>
<li>
<p>The following materialized view satisfies requirements for PCT.</p>
<pre>
CREATE MATERIALIZED VIEW cust_mth_sales_mv
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.time_id, s.prod_id, SUM(s.quantity_sold), SUM(s.amount_sold),
       p.prod_name, t.calendar_month_name, COUNT(*),
       COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY t.calendar_month_name, s.prod_id, p.prod_name, s.time_id;
</pre></li>
<li>
<p>You can use the <code>DBMS_MVIEW.EXPLAIN_MVIEW</code> procedure to determine which tables will allow PCT refresh.</p>
<pre>
MVNAME              CAPABILITY_NAME   POSSIBLE  RELATED_TEXT  MSGTXT
-----------------   ---------------   --------  ------------  ----------------
CUST_MTH_SALES_MV   PCT               Y         SALES
CUST_MTH_SALES_MV   PCT_TABLE         Y         SALES
CUST_MTH_SALES_MV   PCT_TABLE         N         PRODUCTS      no partition key
                                                              or PMARKER
                                                              in SELECT list
CUST_MTH_SALES_MV   PCT_TABLE         N         TIMES         relation is not
                                                              partitionedtable
</pre>
<p>As can be seen from the partial sample output from <code>EXPLAIN_MVIEW</code>, any partition maintenance operation performed on the <code>sales</code> table will allow PCT fast refresh. However, PCT is not possible after partition maintenance operations or updates to the <code>products</code> table as there is insufficient information contained in <code>cust_mth_sales_mv</code> for PCT refresh to be possible. Note that the <code>times</code> table is not partitioned and hence can never allow for PCT refresh. Oracle Database will apply PCT refresh if it can determine that the materialized view has sufficient information to support PCT for all the updated tables. You can verify which partitions are fresh and stale with views such as <code>DBA_MVIEWS</code> and <code>DBA_MVIEW_DETAIL_PARTITION</code>.</p>
<p>See <a href="basicmv.htm#i1008271">"Analyzing Materialized View Capabilities"</a> for information on how to use this procedure and also some details regarding PCT-related views.</p>
</li>
<li>
<p>Suppose at some later point, a <code>SPLIT</code> operation of one partition in the sales table becomes necessary.</p>
<pre>
ALTER TABLE SALES
SPLIT PARTITION month3 AT (TO_DATE('05-02-1998', 'DD-MM-YYYY'))
INTO (PARTITION month3_1 TABLESPACE summ,
      PARTITION month3 TABLESPACE summ);
 
</pre></li>
<li>
<p>Insert some data into the <code>sales</code> table.</p>
</li>
<li>
<p>Fast refresh <code>cust_mth_sales_mv</code> using the <code>DBMS_MVIEW.REFRESH</code> procedure.</p>
<pre>
EXECUTE DBMS_MVIEW.REFRESH('CUST_MTH_SALES_MV', 'F',
   '',TRUE,FALSE,0,0,0,FALSE);
</pre></li>
</ol>
<pre>
</pre>
<p>Fast refresh will automatically do a PCT refresh as it is the only fast refresh possible in this scenario. However, fast refresh will not occur if a partition maintenance operation occurs when any update has taken place to a table on which PCT is not enabled. This is shown in <a href="#i1006863">"PCT Fast Refresh Scenario 2"</a>.</p>
<p><a href="#CEGFHDDC">"PCT Fast Refresh Scenario 1"</a> would also be appropriate if the materialized view was created using the <code>PMARKER</code> clause as illustrated in the following:</p>
<pre>
CREATE MATERIALIZED VIEW cust_sales_marker_mv
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT DBMS_MVIEW.PMARKER(s.rowid) s_marker, SUM(s.quantity_sold),
  SUM(s.amount_sold), p.prod_name, t.calendar_month_name, COUNT(*),
  COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY DBMS_MVIEW.PMARKER(s.rowid),
         p.prod_name, t.calendar_month_name;
</pre></div>
<!-- class="sect3" -->
<a id="i1006863"></a><a id="DWHSG8389"></a>
<div class="sect3">
<h4 class="sect3">PCT Fast Refresh Scenario 2</h4>
<p>In <a href="#i1006863">"PCT Fast Refresh Scenario 2"</a>, the first three steps are the same as in <a href="#CEGFHDDC">"PCT Fast Refresh Scenario 1"</a>. Then, the <code>SPLIT</code> partition operation to the <code>sales</code> table is performed, but before the materialized view refresh occurs, records are inserted into the <code>times</code> table.</p>
<ol>
<li>
<p>The same as in <a href="#CEGFHDDC">"PCT Fast Refresh Scenario 1"</a>.</p>
</li>
<li>
<p>The same as in <a href="#CEGFHDDC">"PCT Fast Refresh Scenario 1"</a>.</p>
</li>
<li>
<p>The same as in <a href="#CEGFHDDC">"PCT Fast Refresh Scenario 1"</a>.</p>
</li>
<li>
<p>After issuing the same <code>SPLIT</code> operation, as shown in <a href="#CEGFHDDC">"PCT Fast Refresh Scenario 1"</a>, some data will be inserted into the <code>times</code> table.</p>
<pre>
ALTER TABLE SALES
SPLIT PARTITION month3 AT (TO_DATE('05-02-1998', 'DD-MM-YYYY'))
INTO (PARTIITION month3_1 TABLESPACE summ,
      PARTITION month3 TABLESPACE summ);
</pre></li>
<li>
<p>Refresh <code>cust_mth_sales_mv</code>.</p>
<pre>
EXECUTE DBMS_MVIEW.REFRESH('CUST_MTH_SALES_MV', 'F',
    '',TRUE,FALSE,0,0,0,FALSE);
ORA-12052: cannot fast refresh materialized view SH.CUST_MTH_SALES_MV
</pre></li>
</ol>
<p>The materialized view is not fast refreshable because DML has occurred to a table on which PCT fast refresh is not possible. To avoid this occurring, Oracle recommends performing a fast refresh immediately after any partition maintenance operation on detail tables for which partition tracking fast refresh is available.</p>
<p>If the situation in <a href="#i1006863">"PCT Fast Refresh Scenario 2"</a> occurs, there are two possibilities; perform a complete refresh or switch to the <code>CONSIDER</code> <code>FRESH</code> option outlined in the following, if suitable. However, it should be noted that <code>CONSIDER</code> <code>FRESH</code> and partition change tracking fast refresh are not compatible. Once the <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> <code>cust_mth_sales_mv</code> <code>CONSIDER</code> <code>FRESH</code> statement has been issued, PCT refresh will no longer be applied to this materialized view, until a complete refresh is done. Moreover, you should not use <code>CONSIDER</code> <code>FRESH</code> unless you have taken manual action to ensure that the materialized view is indeed fresh.</p>
<p>A common situation in a data warehouse is the use of rolling windows of data. In this case, the detail table and the materialized view may contain say the last 12 months of data. Every month, new data for a month is added to the table and the oldest month is deleted (or maybe archived). PCT refresh provides a very efficient mechanism to maintain the materialized view in this case.</p>
</div>
<!-- class="sect3" -->
<a id="DWHSG8390"></a>
<div class="sect3"><a id="sthref491"></a>
<h4 class="sect3">PCT Fast Refresh Scenario 3</h4>
<ol>
<li>
<p>The new data is usually added to the detail table by adding a new partition and exchanging it with a table containing the new data.</p>
<pre>
ALTER TABLE sales ADD PARTITION month_new ...
ALTER TABLE sales EXCHANGE PARTITION month_new month_new_table
  
</pre></li>
<li>
<p>Next, the oldest partition is dropped or truncated.</p>
<pre>
ALTER TABLE sales DROP PARTITION month_oldest;
</pre></li>
<li>
<p>Now, if the materialized view satisfies all conditions for PCT refresh.</p>
<pre>
EXECUTE DBMS_MVIEW.REFRESH('CUST_MTH_SALES_MV', 'F', '', TRUE, FALSE,0,0,0,FALSE);
</pre></li>
</ol>
<p>Fast refresh will automatically detect that PCT is available and perform a PCT refresh.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DWHSG8391"></a>
<div class="sect2"><a id="sthref492"></a>
<h3 class="sect2">Fast Refresh with CONSIDER FRESH</h3>
<p>In a data warehouse, you may often wish to accumulate historical information in the materialized view even though this information is no longer in the detailed tables. In this case, you could maintain the materialized view using the <code>ALTER</code> <code>MATERIALIZED</code> <code>VIEW</code> <span class="italic">materialized_view_name</span> <code>CONSIDER</code> <code>FRESH</code> statement.</p>
<p>Note that <code>CONSIDER</code> <code>FRESH</code> declares that the contents of the materialized view are <code>FRESH</code> (in sync with the detail tables). Care must be taken when using this option in this scenario in conjunction with query rewrite because you may see unexpected results.</p>
<p>After using <code>CONSIDER</code> <code>FRESH</code> in an historical scenario, you will be able to apply traditional fast refresh after DML and direct loads to the materialized view, but not PCT fast refresh. This is because if the detail table partition at one time contained data that is currently kept in aggregated form in the materialized view, PCT refresh in attempting to resynchronize the materialized view with that partition could delete historical data which cannot be recomputed.</p>
<p>Assume the <code>sales</code> table stores the prior year's data and the <code>cust_mth_sales_mv</code> keeps the prior 10 years of data in aggregated form.</p>
<ol>
<li>
<p>Remove old data from a partition in the <code>sales</code> table:</p>
<pre>
ALTER TABLE sales TRUNCATE PARTITION month1;
</pre>
<p>The materialized view is now considered stale and requires a refresh because of the partition operation. However, as the detail table no longer contains all the data associated with the partition fast refresh cannot be attempted.</p>
</li>
<li>
<p>Therefore, alter the materialized view to tell Oracle Database to consider it fresh.</p>
<pre>
ALTER MATERIALIZED VIEW cust_mth_sales_mv CONSIDER FRESH;
</pre>
<p>This statement informs Oracle Database that <code>cust_mth_sales_mv</code> is fresh for your purposes. However, the materialized view now has a status that is neither known fresh nor known stale. Instead, it is <code>UNKNOWN</code>. If the materialized view has query rewrite enabled in <code>QUERY_REWRITE_INTEGRITY = stale_tolerated</code> mode, it will be used for rewrite.</p>
</li>
<li>
<p>Insert data into <code>sales</code>.</p>
</li>
<li>
<p>Refresh the materialized view.</p>
<pre>
EXECUTE DBMS_MVIEW.REFRESH('CUST_MTH_SALES_MV', 'F', '', TRUE, FALSE,0,0,0,FALSE);
</pre>
<p>Because the fast refresh detects that only <code>INSERT</code> statements occurred against the sales table it will update the materialized view with the new data. However, the status of the materialized view will remain <code>UNKNOWN</code>. The only way to return the materialized view to <code>FRESH</code> status is with a complete refresh which, also will remove the historical data from the materialized view.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1371">
<tr>
<td class="cellalignment1378">
<table class="cellalignment1376">
<tr>
<td class="cellalignment1375"><a href="transform.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1375"><a href="cdc.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1380">
<table class="cellalignment1374">
<tr>
<td class="cellalignment1375"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1375"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1375"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1375"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1375"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1375"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
