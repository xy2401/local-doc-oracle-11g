<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Loading and Transformation</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 070" />
<meta name="dcterms.created" content="2013-07-04T23:23:17Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Warehousing Guide" />
<meta name="dcterms.identifier" content="E25554-02" />
<meta name="dcterms.isVersionOf" content="DWHSG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="transport.htm" title="Previous" type="text/html" />
<link rel="Next" href="refresh.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25554.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">23/35</span> <!-- End Header --><a id="g1014534"></a><a id="DWHSG014"></a><a id="i1007484"></a>
<h1 class="chapter"><span class="secnum">15</span> Loading and Transformation</h1>
<p>This chapter helps you create and manage a data warehouse, and discusses:</p>
<ul>
<li>
<p><a href="#i1006197">Overview of Loading and Transformation in Data Warehouses</a></p>
</li>
<li>
<p><a href="#i1006247">Loading Mechanisms</a></p>
</li>
<li>
<p><a href="#BABGEFIC">Transformation Mechanisms</a></p>
</li>
<li>
<p><a href="#CACGBFBA">Error Logging and Handling Mechanisms</a></p>
</li>
<li>
<p><a href="#i1006922">Loading and Transformation Scenarios</a></p>
</li>
</ul>
<a id="i1006197"></a><a id="DWHSG8304"></a>
<div class="sect1">
<h2 class="sect1">Overview of Loading and Transformation in Data Warehouses</h2>
<p><a id="sthref379"></a>Data transformations are often the most complex and, in terms of processing time, the most costly part of the extraction, transformation, and loading (ETL) process. They can range from simple data conversions to extremely complex data scrubbing techniques. Many, if not all, data transformations can occur within an Oracle database, although transformations are often implemented outside of the database (for example, on flat files) as well.</p>
<p>This chapter introduces techniques for implementing scalable and efficient data transformations within the Oracle Database. The examples in this chapter are relatively simple. Real-world data transformations are often considerably more complex. However, the transformation techniques introduced in this chapter meet the majority of real-world data transformation requirements, often with more scalability and less programming than alternative approaches.</p>
<p>This chapter does not seek to illustrate all of the typical transformations that would be encountered in a data warehouse, but to demonstrate the types of fundamental technology that can be applied to implement these transformations and to provide guidance in how to choose the best techniques.</p>
<a id="DWHSG8305"></a>
<div class="sect2"><a id="sthref380"></a>
<h3 class="sect2">Transformation Flow</h3>
<p>From an architectural perspective, you can transform your data in two ways:</p>
<ul>
<li>
<p><a href="#i1006213">Multistage Data Transformation</a></p>
</li>
<li>
<p><a href="#BABEAIHD">Pipelined Data Transformation</a></p>
</li>
<li>
<p><a href="#BABHAEFF">Staging Area</a></p>
</li>
</ul>
<a id="i1006213"></a><a id="DWHSG8306"></a>
<div class="sect3">
<h4 class="sect3">Multistage Data Transformation</h4>
<p>The data<a id="sthref381"></a> transformation logic for most data warehouses consists of multiple steps. For example, in transforming new records to be inserted into a sales table, there may be separate logical transformation steps to validate each dimension key.</p>
<p><a href="#BABCAHAJ">Figure 15-1</a> offers a graphical way of looking at the transformation logic.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABCAHAJ"></a><a id="DWHSG8307"></a>Figure 15-1 Multistage Data Transformation</p>
<img width="551" height="336" src="./dwhsg025.gif" alt="Description of Figure 15-1 follows" /><br />
<a id="sthref382" href="./img_text/dwhsg025.htm">Description of "Figure 15-1 Multistage Data Transformation"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When using Oracle Database as a transformation engine, a common strategy is to implement each transformation as a separate SQL operation and to create a separate, temporary staging table (such as the tables <code>new_sales_step1</code> and <code>new_sales_step2</code> in <a href="#BABCAHAJ">Figure 15-1</a>) to store the incremental results for each step. This load-then-transform strategy also provides a natural checkpointing scheme to the entire transformation process, which enables the process to be more easily monitored and restarted. However, a disadvantage to multistaging is that the space and time requirements increase.</p>
<p>It may also be possible to combine many simple logical transformations into a single SQL statement or single PL/SQL procedure. Doing so may provide better performance than performing each step independently, but it may also introduce difficulties in modifying, adding, or dropping individual transformations, as well as recovering from failed transformations.</p>
</div>
<!-- class="sect3" -->
<a id="BABEAIHD"></a><a id="DWHSG8308"></a>
<div class="sect3">
<h4 class="sect3">Pipelined Data Transformation</h4>
<p>The ETL process flow can be changed dramatically and the database becomes an integral part of the ETL solution<a id="sthref383"></a>.</p>
<p>The new functionality renders some of the former necessary process steps obsolete while some others can be remodeled to enhance the data flow and the data transformation to become more scalable and non-interruptive. The task shifts from serial transform-then-load process (with most of the tasks done outside the database) or load-then-transform process, to an enhanced transform-while-loading.</p>
<p>Oracle offers a wide variety of new capabilities to address all the issues and tasks relevant in an ETL scenario. It is important to understand that the database offers toolkit functionality rather than trying to address a one-size-fits-all solution. The underlying database has to enable the most appropriate ETL process flow for a specific customer need, and not dictate or constrain it from a technical perspective. <a href="#i1007647">Figure 15-2</a> illustrates the new functionality, which is discussed throughout later sections.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1007647"></a><a id="DWHSG8309"></a>Figure 15-2 Pipelined Data Transformation</p>
<img width="551" height="212" src="./dwhsg107.gif" alt="Description of Figure 15-2 follows" /><br />
<a id="sthref384" href="./img_text/dwhsg107.htm">Description of "Figure 15-2 Pipelined Data Transformation"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="BABHAEFF"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Staging Area</h4>
<p>The overall speed of your load is determined by how quickly the raw data can be read from the staging area and written to the target table in the database. It is highly recommended that you stage your raw data across as many physical disks as possible to ensure the reading of the raw data is not a bottleneck during the load.</p>
<p>An excellent place to stage the data is in an Oracle Database File System (DBFS). DBFS creates a mountable file system which can be used to access files stored in the database as SecureFile LOBs. DBFS is similar to NFS in that it provides a shared network file system that looks like a local file system. Oracle recommends that you create the DBFS in a separate database from the data warehouse, and that the file system be mounted using the <code>DIRECT_IO</code> option to avoid contention on the system page cache while moving the raw data files in and out of the file system. More information on setting up DBFS can be found in <a class="olink ADLOB" href="../../appdev.112/e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006247"></a><a id="DWHSG8310"></a>
<div class="sect1">
<h2 class="sect1">Loading Mechanisms</h2>
<p>You can use the following mechanisms for loading a data warehouse:</p>
<ul>
<li>
<p><a href="#BABJDJIC">Loading a Data Warehouse with SQL*Loader</a></p>
</li>
<li>
<p><a href="#i1006296">Loading a Data Warehouse with External Tables</a></p>
</li>
<li>
<p><a href="#i1006366">Loading a Data Warehouse with OCI and Direct-Path APIs</a></p>
</li>
<li>
<p><a href="#i1006369">Loading a Data Warehouse with Export/Import</a></p>
</li>
</ul>
<a id="BABJDJIC"></a><a id="DWHSG8311"></a>
<div class="sect2">
<h3 class="sect2">Loading a Data Warehouse with SQL*Loader</h3>
<p><a id="sthref385"></a>Before any data transformations can occur within the database, the raw data must become accessible for the database. One approach is to load it into the database. <a href="transport.htm#g1007787">Chapter 14, "Transportation in Data Warehouses"</a>, discusses several techniques for transporting data to an Oracle data warehouse. Perhaps the most common technique for transporting data is by way of flat files.</p>
<p>SQL*Loader is used to move data from flat files into an Oracle data warehouse. During this data load, SQL*Loader can also be used to implement basic data transformations. When using direct-path SQL*Loader, basic data manipulation, such as datatype conversion and simple <code>NULL</code> handling, can be automatically resolved during the data load. Most data warehouses use direct-path loading for performance reasons.</p>
<p>The conventional-path loader provides broader capabilities for data transformation than a direct-path loader: SQL functions can be applied to any column as those values are being loaded. This provides a rich capability for transformations during the data load. However, the conventional-path loader is slower than direct-path loader. For these reasons, the conventional-path loader should be considered primarily for loading and transforming smaller amounts of data.</p>
<p>The following is a simple example of a SQL*Loader controlfile to load data into the <code>sales</code> table of the <code>sh</code> sample schema from an external file <code>sh_sales.dat</code>. The external flat file <code>sh_sales.dat</code> consists of sales transaction data, aggregated on a daily level. Not all columns of this external file are loaded into <code>sales</code>. This external file is also used asa source for loading the second fact table of the <code>sh</code> sample schema, which is done using an external table:</p>
<p>The following shows the control file (<code>sh_sales.ctl</code>) loading the <code>sales</code> table:</p>
<pre>
LOAD DATA INFILE sh_sales.dat APPEND INTO TABLE sales
FIELDS TERMINATED BY "|"
(PROD_ID, CUST_ID, TIME_ID, CHANNEL_ID, PROMO_ID, QUANTITY_SOLD, AMOUNT_SOLD)
 
</pre>
<p>It can be loaded with the following command:</p>
<pre>
$  sqlldr control=sh_sales.ctl direct=true
Username:
Password:
</pre></div>
<!-- class="sect2" -->
<a id="i1006296"></a><a id="DWHSG8312"></a>
<div class="sect2">
<h3 class="sect2">Loading a Data Warehouse with External Tables</h3>
<p>Another appr<a id="sthref386"></a><a id="sthref387"></a>oach for handling external data sources is using external tables. Oracle's external table feature enables you to use external data as a virtual table that can be queried and joined directly and in parallel without requiring the external data to be first loaded in the database. You can then use SQL, PL/SQL, and Java to access the external data.</p>
<p>External tables enable the pipelining of the loading phase with the transformation phase. The transformation process can be merged with the loading process without any interruption of the data streaming. It is no longer necessary to stage the data inside the database for further processing inside the database, such as comparison or transformation. For example, the conversion functionality of a conventional load can be used for a direct-path <code>INSERT</code> <code>AS</code> <code>SELECT</code> statement in conjunction with the <code>SELECT</code> from an external table.</p>
<p>The main difference between external tables and regular tables is that externally organized tables are read-only. No DML operations (<code>UPDATE</code>/<code>INSERT</code>/<code>DELETE</code>) are possible and no indexes can be created on them.</p>
<p>External tables are mostly compliant with the existing SQL*Loader functionality and provide superior functionality in most cases. External tables are especially useful for environments where the complete external source has to be joined with existing database objects or when the data has to be transformed in a complex manner. For example, unlike SQL*Loader, you can apply any arbitrary SQL transformation and use the direct path insert method. In addition, you can specify a program to be executed (such as <code>zcat</code>) that processes files (such as compressed data files) and enables Oracle Database to use the output (such as uncompressed data files), which means you can load large amounts of compressed data without first uncompressing it on a disk.</p>
<p>You can create an external table named <code>sales_transactions_ext</code>, representing the structure of the complete sales transaction data, represented in the external file <code>sh_sales.gz</code>. The product department is especially interested in a cost analysis on product and time. We thus create a fact table named <code>cost</code> in the <code>sh</code> schema. The operational source data is the same as for the <code>sales</code> fact table. However, because we are not investigating every dimensional information that is provided, the data in the <code>cost</code> fact table has a coarser granularity than in the <code>sales</code> fact table, for example, all different distribution channels are aggregated.</p>
<p>We cannot load the data into the <code>cost</code> fact table without applying the previously mentioned aggregation of the detailed information, due to the suppression of some of the dimensions.</p>
<p>The external table framework offers a solution to solve this. Unlike SQL*Loader, where you would have to load the data before applying the aggregation, you can combine the loading and transformation within a single SQL DML statement, as shown in the following. You do not have to stage the data temporarily before inserting into the target table.</p>
<p>The object directories must already exist, and point to the directory containing the <code>sh_sales.gz</code> file as well as the directory containing the bad and log files.</p>
<pre>
CREATE TABLE sales_transactions_ext
(PROD_ID NUMBER, CUST_ID NUMBER,
 TIME_ID DATE, CHANNEL_ID NUMBER,
 PROMO_ID NUMBER, QUANTITY_SOLD NUMBER,
 AMOUNT_SOLD NUMBER(10,2), UNIT_COST NUMBER(10,2),
 UNIT_PRICE NUMBER(10,2))
ORGANIZATION external (TYPE oracle_loader
  DEFAULT DIRECTORY data_file_dir ACCESS PARAMETERS
  (RECORDS DELIMITED BY NEWLINE CHARACTERSET US7ASCII
    PREPROCESSOR EXECDIR:'zcat' 
    BADFILE log_file_dir:'sh_sales.bad_xt'
    LOGFILE log_file_dir:'sh_sales.log_xt'
    FIELDS TERMINATED BY "|" LDRTRIM
    ( PROD_ID, CUST_ID,
      TIME_ID         DATE(10) "YYYY-MM-DD", 
      CHANNEL_ID, PROMO_ID, QUANTITY_SOLD, AMOUNT_SOLD,
      UNIT_COST, UNIT_PRICE))
  location ('sh_sales.gz') 
)REJECT LIMIT UNLIMITED;
</pre>
<p>The external table can now be used from within the database, accessing some columns of the external data only, grouping the data, and inserting it into the <code>costs</code> fact table:</p>
<pre>
INSERT /*+ APPEND */ INTO COSTS
(TIME_ID, PROD_ID, UNIT_COST, UNIT_PRICE)
SELECT TIME_ID, PROD_ID, AVG(UNIT_COST), AVG(amount_sold/quantity_sold)
FROM sales_transactions_ext GROUP BY time_id, prod_id;
</pre>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for a complete description of external table syntax</p>
</li>
<li>
<p><a class="olink SUTIL" href="../e22490/toc.htm"><span class="italic">Oracle Database Utilities</span></a> for usage examples</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006366"></a><a id="DWHSG8313"></a>
<div class="sect2">
<h3 class="sect2">Loading a Data Warehouse with OCI and Direct-Path APIs</h3>
<p>OCI and direct-path APIs are frequently used when the transformation and computation are done outside the database and there is no need for flat file staging.</p>
</div>
<!-- class="sect2" -->
<a id="i1006369"></a><a id="DWHSG8314"></a>
<div class="sect2">
<h3 class="sect2">Loading a Data Warehouse with Export/Import</h3>
<p>Export and import are used when the data is inserted as is into the target system. No complex extractions are possible. See <a href="extract.htm#g1008480">Chapter 13, "Extraction in Data Warehouses"</a> for further information.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABGEFIC"></a><a id="DWHSG8315"></a>
<div class="sect1">
<h2 class="sect1">Transformation Mechanisms</h2>
<p>You have the following cho<a id="sthref388"></a>ices for transforming data inside the database:</p>
<ul>
<li>
<p><a href="#i1006396">Transforming Data Using SQL</a></p>
</li>
<li>
<p><a href="#i1006601">Transforming Data Using PL/SQL</a></p>
</li>
<li>
<p><a href="#i1006605">Transforming Data Using Table Functions</a></p>
</li>
</ul>
<a id="i1006396"></a><a id="DWHSG8316"></a>
<div class="sect2">
<h3 class="sect2">Transforming Data Using SQL</h3>
<p><a id="sthref389"></a>Once data is loaded into the database, data transformations can be executed using SQL operations. There are four basic techniques for implementing SQL data transformations:</p>
<ul>
<li>
<p><a href="#i1006416">CREATE TABLE ... AS SELECT And INSERT /*+APPEND*/ AS SELECT</a></p>
</li>
<li>
<p><a href="#i1006438">Transforming Data Using UPDATE</a></p>
</li>
<li>
<p><a href="#i1006441">Transforming Data Using MERGE</a></p>
</li>
<li>
<p><a href="#i1006530">Transforming Data Using Multitable INSERT</a></p>
</li>
</ul>
<a id="i1006416"></a><a id="DWHSG8317"></a>
<div class="sect3">
<h4 class="sect3">CREATE TABLE ... AS SELECT And INSERT /*+APPEND*/ AS SELECT</h4>
<p>The <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statement (CTAS) is a powerful tool for manipulating large sets of data. As shown in the following example, many data transformations can be expressed in standard SQL, and CTAS provides a mechanism for efficiently executing a SQL query and storing the results of that query in a new database table. The <code>INSERT</code> /*+<code>APPEND</code>*/ ... <code>AS</code> <code>SELECT</code> statement offers the same capabilities with existing database tables.</p>
<p>In a data warehouse environment, CTAS is typically run in parallel using <code>NOLOGGING</code> mode for best performance.</p>
<p>A simple and common type of data transformation is data substitution. In a data substitution transformation, some or all of the values of a single column are modified. For example, our <code>sales</code> table has a <code>channel_id</code> column. This column indicates whether a given sales transaction was made by a company's own sales force (a direct sale) or by a distributor (an indirect sale).</p>
<p>You may receive data from multiple source systems for your data warehouse. Suppose that one of those source systems processes only direct sales, and thus the source system does not know indirect sales channels. When the data warehouse initially receives sales data from this system, all sales records have a <code>NULL</code> value for the <code>sales.channel_id</code> field. These <code>NULL</code> values must be set to the proper key value. For example, you can do this efficiently using a SQL function as part of the insertion into the target sales table statement. The structure of source table <code>sales_activity_direct</code> is as follows:</p>
<pre>
DESC sales_activity_direct
Name           Null?    Type
------------   -----    ----------------
SALES_DATE              DATE
PRODUCT_ID              NUMBER
CUSTOMER_ID             NUMBER
PROMOTION_ID            NUMBER
AMOUNT                  NUMBER
QUANTITY                NUMBER
</pre>
<p>The following SQL statement inserts data from <code>sales_activity_direct</code> into the <code>sales</code> table of the sample schema, using a SQL function to truncate the sales date values to the midnight time and assigning a fixed channel ID of 3.</p>
<pre>
INSERT /*+ APPEND NOLOGGING PARALLEL */
INTO sales SELECT product_id, customer_id, TRUNC(sales_date), 3,
       promotion_id, quantity, amount
FROM sales_activity_direct;
</pre></div>
<!-- class="sect3" -->
<a id="i1006438"></a><a id="DWHSG8318"></a>
<div class="sect3">
<h4 class="sect3">Transforming Data Using UPDATE</h4>
<p>Another technique for implementing a data substitution is to use an <code>UPDATE</code> statement to modify the <code>sales.channel_id</code> column. An <code>UPDATE</code> provides the correct result. However, if the data substitution transformations require that a very large percentage of the rows (or all of the rows) be modified, then, it may be more efficient to use a CTAS statement than an <code>UPDATE</code>.</p>
</div>
<!-- class="sect3" -->
<a id="i1006441"></a><a id="DWHSG8319"></a>
<div class="sect3">
<h4 class="sect3">Transforming Data Using MERGE</h4>
<p>Oracle Database's merge functionality extends SQL, by introducing the SQL keyword <code>MERGE</code>, in order to provide the ability to update or insert a row conditionally into a table or out of line single table views. Conditions are specified in the <code>ON</code> clause. This is, besides pure bulk loading, one of the most common operations in data warehouse synchronization.</p>
<a id="DWHSG8320"></a>
<div class="sect4"><a id="sthref390"></a>
<h5 class="sect4">Merge Examples</h5>
<p>The following discusses various implementations of a merge. The examples assume that new data for the dimension table products is propagated to the data warehouse and has to be either inserted or updated. The table <code>products_delta</code> has the same structure as <code>products</code>.</p>
<div class="example">
<p class="titleinexample"><a id="i1006454"></a><a id="DWHSG8321"></a>Example 15-1 Merge Operation Using SQL</p>
<pre>
MERGE INTO products t USING products_delta s
ON (t.prod_id=s.prod_id)
WHEN MATCHED THEN UPDATE SET
  t.prod_list_price=s.prod_list_price, t.prod_min_price=s.prod_min_price
WHEN NOT MATCHED THEN INSERT (prod_id, prod_name, prod_desc, prod_subcategory,
  prod_subcategory_desc, prod_category, prod_category_desc, prod_status, 
  prod_list_price, prod_min_price)
VALUES (s.prod_id, s.prod_name, s.prod_desc, s.prod_subcategory, 
  s.prod_subcategory_desc, s.prod_category, s.prod_category_desc, 
  s.prod_status, s.prod_list_price, s.prod_min_price);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1006530"></a><a id="DWHSG8322"></a>
<div class="sect3">
<h4 class="sect3">Transforming Data Using Multitable INSERT</h4>
<p>Many times, external data sources have to be segregated based on logical attributes for insertion into different target objects. It is also frequent in data warehouse environments to fan out the same source data into several target objects. Multitable inserts provide a new SQL statement for these kinds of transformations, where data can either end up in several or exactly one target, depending on the business transformation rules. This insertion can be done conditionally based on business rules or unconditionally.</p>
<p>It offers the benefits of the <code>INSERT</code> ... <code>SELECT</code> statement when multiple tables are involved as targets. In doing so, it avoids the drawbacks of the two obvious alternatives. You either had to deal with <span class="italic">n</span> independent <code>INSERT</code> &hellip; <code>SELECT</code> statements, thus processing the same source data <span class="italic">n</span> times and increasing the transformation workload <span class="italic">n</span> times. Alternatively, you had to choose a procedural approach with a per-row determination how to handle the insertion. This solution lacked direct access to high-speed access paths available in SQL.</p>
<p>As with the existing <code>INSERT</code> ... <code>SELECT</code> statement, the new statement can be parallelized and used with the direct-load mechanism for faster performance.</p>
<div class="example">
<p class="titleinexample"><a id="DWHSG8323"></a><a id="sthref391"></a>Example 15-2 Unconditional Insert</p>
<p>The following statement aggregates the transactional sales information, stored in <code>sales_activity_direct</code>, on a daily basis and inserts into both the <code>sales</code> and the <code>costs</code> fact table for the current day.</p>
<pre>
INSERT ALL
   INTO sales VALUES (product_id, customer_id, today, 3, promotion_id,
                      quantity_per_day, amount_per_day)
   INTO costs VALUES (product_id, today, promotion_id, 3,
                      product_cost, product_price)
SELECT TRUNC(s.sales_date) AS today, s.product_id, s.customer_id,
  s.promotion_id, SUM(s.amount) AS amount_per_day, SUM(s.quantity)
  quantity_per_day, p.prod_min_price*0.8 AS product_cost, p.prod_list_price 
  AS product_price
FROM sales_activity_direct s, products p
WHERE s.product_id = p.prod_id AND TRUNC(sales_date) = TRUNC(SYSDATE)
GROUP BY TRUNC(sales_date), s.product_id, s.customer_id, s.promotion_id, 
  p.prod_min_price*0.8, p.prod_list_price;
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8324"></a><a id="sthref392"></a>Example 15-3 Conditional ALL Insert</p>
<p>The following statement inserts a row into the <code>sales</code> and <code>costs</code> tables for all sales transactions with a valid promotion and stores the information about multiple identical orders of a customer in a separate table <code>cum_sales_activity</code>. It is possible two rows will be inserted for some sales transactions, and none for others.</p>
<pre>
INSERT ALL
WHEN promotion_id IN (SELECT promo_id FROM promotions) THEN
   INTO sales VALUES (product_id, customer_id, today, 3, promotion_id,
                       quantity_per_day, amount_per_day)
   INTO costs VALUES (product_id, today, promotion_id, 3,
                      product_cost, product_price)
WHEN num_of_orders &gt; 1 THEN
   INTO cum_sales_activity VALUES (today, product_id, customer_id,
     promotion_id, quantity_per_day, amount_per_day, num_of_orders)
SELECT TRUNC(s.sales_date) AS today, s.product_id, s.customer_id,
   s.promotion_id, SUM(s.amount) AS amount_per_day, SUM(s.quantity)
   quantity_per_day, COUNT(*) num_of_orders, p.prod_min_price*0.8
   AS product_cost, p.prod_list_price AS product_price
FROM sales_activity_direct s, products p
WHERE s.product_id = p.prod_id
AND TRUNC(sales_date) = TRUNC(SYSDATE)
GROUP BY TRUNC(sales_date), s.product_id, s.customer_id,
 s.promotion_id, p.prod_min_price*0.8, p.prod_list_price;
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="i1006570"></a><a id="DWHSG8325"></a>Example 15-4 Conditional FIRST Insert</p>
<p>The following statement inserts into an appropriate shipping manifest according to the total quantity and the weight of a product order. An exception is made for high value orders, which are also sent by express, unless their weight classification is not too high. All incorrect orders, in this simple example represented as orders without a quantity, are stored in a separate table. It assumes the existence of appropriate tables <code>large_freight_shipping</code>, <code>express_shipping</code>, <code>default_shipping</code>, and <code>incorrect_sales_order</code>.</p>
<pre>
INSERT FIRST WHEN (sum_quantity_sold &gt; 10 AND prod_weight_class &lt; 5) AND
sum_quantity_sold &gt;=1) OR (sum_quantity_sold &gt; 5 AND prod_weight_class &gt; 5) THEN
  INTO large_freight_shipping VALUES
      (time_id, cust_id, prod_id, prod_weight_class, sum_quantity_sold)
  WHEN sum_amount_sold &gt; 1000 AND sum_quantity_sold &gt;=1 THEN
  INTO express_shipping VALUES
      (time_id, cust_id, prod_id, prod_weight_class,
       sum_amount_sold, sum_quantity_sold)
WHEN (sum_quantity_sold &gt;=1) THEN INTO default_shipping VALUES
      (time_id, cust_id, prod_id, sum_quantity_sold)
ELSE INTO incorrect_sales_order VALUES (time_id, cust_id, prod_id)
SELECT s.time_id, s.cust_id, s.prod_id, p.prod_weight_class,
       SUM(amount_sold) AS sum_amount_sold,
       SUM(quantity_sold) AS sum_quantity_sold
FROM sales s, products p
WHERE s.prod_id = p.prod_id AND s.time_id = TRUNC(SYSDATE)
GROUP BY s.time_id, s.cust_id, s.prod_id, p.prod_weight_class;
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="DWHSG8326"></a><a id="sthref393"></a>Example 15-5 Mixed Conditional and Unconditional Insert</p>
<p>The following example inserts new customers into the <code>customers</code> table and stores all new customers with <code>cust_credit_limit</code> higher then 4500 in an additional, separate table for further promotions.</p>
<pre>
INSERT FIRST WHEN cust_credit_limit &gt;= 4500 THEN INTO customers
  INTO customers_special VALUES (cust_id, cust_credit_limit)
  ELSE INTO customers
SELECT * FROM customers_new;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="refresh.htm#g1018554">Chapter 16, "Maintaining the Data Warehouse"</a> for more information regarding <code>MERGE</code> operations</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006601"></a><a id="DWHSG8327"></a>
<div class="sect2">
<h3 class="sect2">Transforming Data Using PL/SQL</h3>
<p>In a data warehouse environment, you can use procedural languages such as PL/SQL to implement complex transformations in the Oracle Database. Whereas CTAS operates on entire tables and emphasizes parallelism, PL/SQL provides a row-based approached and can accommodate very sophisticated transformation rules. For example, a PL/SQL procedure could open multiple cursors and read data from multiple source tables, combine this data using complex business rules, and finally insert the transformed data into one or more target table. It would be difficult or impossible to express the same sequence of operations using standard SQL statements.</p>
<p>Using a procedural language, a specific transformation (or number of transformation steps) within a complex ETL processing can be encapsulated, reading data from an intermediate staging area and generating a new table object as output. A previously generated transformation input table and a subsequent transformation will consume the table generated by this specific transformation. Alternatively, these encapsulated transformation steps within the complete ETL process can be integrated seamlessly, thus streaming sets of rows between each other without the necessity of intermediate staging. You can use table functions to implement such behavior.</p>
</div>
<!-- class="sect2" -->
<a id="i1006605"></a><a id="DWHSG8328"></a>
<div class="sect2">
<h3 class="sect2">Transforming Data Using Table Functions</h3>
<p>Table functions provide the support for pipelined and parallel execution of transformations implemented in PL/SQL, C, or Java. Scenarios as mentioned earlier can be done without requiring the use of intermediate staging tables, which interrupt the data flow through various transformations steps.</p>
<a id="DWHSG8329"></a>
<div class="sect3"><a id="sthref394"></a>
<h4 class="sect3">What is a Table Function?</h4>
<p>A table function is defined as a function that can produce a set of rows as output. Additionally, table functions can take a set of rows as input. Prior to Oracle9<span class="italic">i</span>, PL/SQL functions:</p>
<ul>
<li>
<p>Could not take cursors as input.</p>
</li>
<li>
<p>Could not be parallelized or pipelined.</p>
</li>
</ul>
<p>Now, functions are not limited in these ways. Table functions extend database functionality by allowing:</p>
<ul>
<li>
<p>Multiple rows to be returned from a function.</p>
</li>
<li>
<p>Results of SQL subqueries (that select multiple rows) to be passed directly to functions.</p>
</li>
<li>
<p>Functions take cursors as input.</p>
</li>
<li>
<p>Functions can be parallelized.</p>
</li>
<li>
<p>Returning result sets incrementally for further processing as soon as they are created. This is called incremental pipelining</p>
</li>
</ul>
<p>Table functions can be defined in PL/SQL using a native PL/SQL interface, or in Java or C using the Oracle Data Cartridge Interface (ODCI).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS" href="../../appdev.112/e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink ADDCI" href="../../appdev.112/e10765/toc.htm"><span class="italic">Oracle Database Data Cartridge Developer's Guide</span></a></p>
</li>
</ul>
</div>
<p><a href="#i1006638">Figure 15-3</a> illustrates a typical aggregation where you input a set of rows and output a set of rows, in that case, after performing a <code>SUM</code> operation.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006638"></a><a id="DWHSG8330"></a>Figure 15-3 Table Function Example</p>
<img width="425" height="150" src="./dwhsg084.gif" alt="Description of Figure 15-3 follows" /><br />
<a id="sthref395" href="./img_text/dwhsg084.htm">Description of "Figure 15-3 Table Function Example"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The pseudocode for this operation would be similar to:</p>
<pre>
INSERT INTO Out SELECT * FROM ("Table Function"(SELECT * FROM In));
</pre>
<p>The table function takes the result of the <code>SELECT</code> on <code>In</code> as input and delivers a set of records in a different format as output for a direct insertion into <code>Out</code>.</p>
<p>Additionally, a table function can fan out data within the scope of an atomic transaction. This can be used for many occasions like an efficient logging mechanism or a fan out for other independent transformations. In such a scenario, a single staging table is needed.</p>
<div class="figure">
<p class="titleinfigure"><a id="DWHSG8331"></a><a id="sthref396"></a>Figure 15-4 Pipelined Parallel Transformation with Fanout</p>
<img width="463" height="142" src="./dwhsg079.gif" alt="Description of Figure 15-4 follows" /><br />
<a id="sthref397" href="./img_text/dwhsg079.htm">Description of "Figure 15-4 Pipelined Parallel Transformation with Fanout"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The pseudocode for this would be similar to:</p>
<pre>
INSERT INTO target SELECT * FROM (tf2(SELECT * 
FROM (tf1(SELECT * FROM source))));
</pre>
<p>This inserts into <code>target</code> and, as part of <code>tf1</code>, into <code>Stage</code> <code>Table</code> <code>1</code> within the scope of an atomic transaction.</p>
<pre>
INSERT INTO target SELECT * FROM tf3(SELT * FROM stage_table1);
</pre>
<div class="example">
<p class="titleinexample"><a id="CACFHAGG"></a><a id="DWHSG8332"></a>Example 15-6 Table Functions Fundamentals</p>
<p>The following examples demonstrate the fundamentals of table functions, without the usage of complex business rules implemented inside those functions. They are chosen for demonstration purposes only, and are all implemented in PL/SQL.</p>
<p>Table functions return sets of records and can take cursors as input. Besides the <code>sh</code> sample schema, you have to set up the following database objects before using the examples:</p>
<pre>
CREATE TYPE product_t AS OBJECT (
      prod_id                  NUMBER(6)
    , prod_name                VARCHAR2(50)
    , prod_desc                VARCHAR2(4000)
    , prod_subcategory         VARCHAR2(50)
    , prod_subcategory_desc    VARCHAR2(2000)
    , prod_category            VARCHAR2(50)
    , prod_category_desc       VARCHAR2(2000)
    , prod_weight_class        NUMBER(2)
    , prod_unit_of_measure     VARCHAR2(20)
    , prod_pack_size           VARCHAR2(30)
    , supplier_id              NUMBER(6)
    , prod_status              VARCHAR2(20)
    , prod_list_price          NUMBER(8,2)
    , prod_min_price           NUMBER(8,2)
);
/
CREATE TYPE product_t_table AS TABLE OF product_t;
/
COMMIT;

CREATE OR REPLACE PACKAGE cursor_PKG AS
  TYPE product_t_rec IS RECORD (
      prod_id                   NUMBER(6)
    , prod_name                 VARCHAR2(50)
    , prod_desc                 VARCHAR2(4000)
    , prod_subcategory          VARCHAR2(50)
    , prod_subcategory_desc     VARCHAR2(2000)
    , prod_category             VARCHAR2(50)
    , prod_category_desc        VARCHAR2(2000)
    , prod_weight_class         NUMBER(2)
    , prod_unit_of_measure      VARCHAR2(20)
    , prod_pack_size            VARCHAR2(30)
    , supplier_id               NUMBER(6)
    , prod_status               VARCHAR2(20)
    , prod_list_price           NUMBER(8,2)
    , prod_min_price            NUMBER(8,2));
  TYPE product_t_rectab IS TABLE OF product_t_rec;
  TYPE strong_refcur_t IS REF CURSOR RETURN product_t_rec;
  TYPE refcur_t IS REF CURSOR;
END;
/

REM artificial help table, used later
CREATE TABLE obsolete_products_errors (prod_id NUMBER, msg VARCHAR2(2000));
</pre>
<p>The following example demonstrates a simple filtering; it shows all obsolete products except the <code>prod_category</code> Electronics. The table function returns the result set as a set of records and uses a weakly typed <code>REF</code> <code>CURSOR</code> as input.</p>
<pre>
CREATE OR REPLACE FUNCTION obsolete_products(cur cursor_pkg.refcur_t)
RETURN product_t_table
IS
    prod_id                   NUMBER(6); 
    prod_name                 VARCHAR2(50);
    prod_desc                 VARCHAR2(4000);
    prod_subcategory          VARCHAR2(50);
    prod_subcategory_desc     VARCHAR2(2000);
    prod_category             VARCHAR2(50);
    prod_category_desc        VARCHAR2(2000);
    prod_weight_class         NUMBER(2);
    prod_unit_of_measure      VARCHAR2(20);
    prod_pack_size            VARCHAR2(30);
    supplier_id               NUMBER(6);
    prod_status               VARCHAR2(20);
    prod_list_price           NUMBER(8,2);
    prod_min_price            NUMBER(8,2);
    sales NUMBER:=0;
    objset product_t_table := product_t_table();
    i NUMBER := 0;
BEGIN
   LOOP
     -- Fetch from cursor variable
     FETCH cur INTO prod_id, prod_name, prod_desc, prod_subcategory, 
    prod_subcategory_desc, prod_category, prod_category_desc, prod_weight_class,
    prod_unit_of_measure, prod_pack_size, supplier_id, prod_status, 
    prod_list_price, prod_min_price;
     EXIT WHEN cur%NOTFOUND; -- exit when last row is fetched
     -- Category Electronics is not meant to be obsolete and will be suppressed
     IF prod_status='obsolete' AND prod_category != 'Electronics' THEN
     -- append to collection
     i:=i+1;
     objset.extend;
     objset(i):=product_t( prod_id, prod_name, prod_desc, prod_subcategory,
     prod_subcategory_desc, prod_category, prod_category_desc, 
     prod_weight_class, prod_unit_of_measure, prod_pack_size, supplier_id, 
     prod_status, prod_list_price, prod_min_price);
     END IF;
   END LOOP;
   CLOSE cur;
   RETURN objset;
END;
/
</pre>
<p>You can use the table function in a SQL statement to show the results. Here we use additional SQL functionality for the output:</p>
<pre>
SELECT DISTINCT UPPER(prod_category), prod_status
FROM TABLE(obsolete_products(
   CURSOR(SELECT prod_id, prod_name, prod_desc, prod_subcategory,
   prod_subcategory_desc, prod_category, prod_category_desc, prod_weight_class,
   prod_unit_of_measure, prod_pack_size,
   supplier_id, prod_status, prod_list_price, prod_min_price
          FROM products)));
</pre>
<p>The following example implements the same filtering than the first one. The main differences between those two are:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>This example uses a strong typed <code>REF</code> <code>CURSOR</code> as input and can be parallelized based on the objects of the strong typed cursor, as shown in one of the following examples.</p>
</li>
<li>
<p>The table function returns the result set incrementally as soon as records are created.</p>
</li>
</ul>
<pre>
CREATE OR REPLACE FUNCTION 
  obsolete_products_pipe(cur cursor_pkg.strong_refcur_t) RETURN product_t_table
PIPELINED
PARALLEL_ENABLE (PARTITION cur BY ANY) IS
    prod_id                 NUMBER(6);
    prod_name               VARCHAR2(50);
    prod_desc               VARCHAR2(4000);
    prod_subcategory        VARCHAR2(50);
    prod_subcategory_desc   VARCHAR2(2000);
    prod_category           VARCHAR2(50);
    prod_category_desc      VARCHAR2(2000);
    prod_weight_class       NUMBER(2);
    prod_unit_of_measure   VARCHAR2(20);
    prod_pack_size         VARCHAR2(30);
    supplier_id            NUMBER(6);
    prod_status            VARCHAR2(20);
    prod_list_price        NUMBER(8,2);
    prod_min_price         NUMBER(8,2);
    sales NUMBER:=0;
BEGIN
 LOOP
     -- Fetch from cursor variable
     FETCH cur INTO prod_id, prod_name, prod_desc, prod_subcategory,
     prod_subcategory_desc, prod_category, prod_category_desc, 
     prod_weight_class, prod_unit_of_measure, prod_pack_size, supplier_id, 
     prod_status, prod_list_price, prod_min_price;
     EXIT WHEN cur%NOTFOUND; -- exit when last row is fetched
     IF prod_status='obsolete' AND prod_category !='Electronics' THEN
       PIPE ROW (product_t( prod_id, prod_name, prod_desc, prod_subcategory,
 prod_subcategory_desc, prod_category, prod_category_desc, prod_weight_class,
 prod_unit_of_measure, prod_pack_size, supplier_id, prod_status, 
 prod_list_price, prod_min_price));
     END IF;
   END LOOP;
   CLOSE cur;
   RETURN;
END;
/
</pre>
<p>You can use the table function as follows:</p>
<pre>
SELECT DISTINCT prod_category,
                DECODE(prod_status,'obsolete','NO LONGER AVAILABLE','N/A')
FROM TABLE(obsolete_products_pipe(
  CURSOR(SELECT prod_id, prod_name, prod_desc, prod_subcategory,
         prod_subcategory_desc, prod_category, prod_category_desc,
         prod_weight_class, prod_unit_of_measure, prod_pack_size,
         supplier_id, prod_status, prod_list_price, prod_min_price
         FROM products)));
</pre>
<p>We now change the degree of parallelism for the input table products and issue the same statement again:</p>
<pre>
ALTER TABLE products PARALLEL 4;
</pre>
<p>The session statistics show that the statement has been parallelized:</p>
<pre>
SELECT * FROM V$PQ_SESSTAT WHERE statistic='Queries Parallelized';

STATISTIC              LAST_QUERY  SESSION_TOTAL
--------------------   ----------  -------------
Queries Parallelized            1              3

1 row selected.
</pre>
<p>Table functions are also capable to fanout results into persistent table structures. This is demonstrated in the next example. The function filters returns all obsolete products except a those of a specific <code>prod_category</code> (default Electronics), which was set to status <code>obsolete</code> by error. The result set of the table function consists of all other obsolete product categories. The detected wrong <code>prod_id</code> IDs are stored in a separate table structure <code>obsolete_products_error</code>. Note that if a table function is part of an autonomous transaction, it must <code>COMMIT</code> or <code>ROLLBACK</code> before each <code>PIPE</code> <code>ROW</code> statement to avoid an error in the callings subprogram. Its result set consists of all other obsolete product categories. It furthermore demonstrates how normal variables can be used in conjunction with table functions:</p>
<pre>
CREATE OR REPLACE FUNCTION obsolete_products_dml(cur cursor_pkg.strong_refcur_t,
 prod_cat varchar2 DEFAULT 'Electronics') RETURN product_t_table
PIPELINED
PARALLEL_ENABLE (PARTITION cur BY ANY) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    prod_id                   NUMBER(6);
    prod_name                 VARCHAR2(50);
    prod_desc                 VARCHAR2(4000);
    prod_subcategory          VARCHAR2(50);
    prod_subcategory_desc     VARCHAR2(2000);
    prod_category             VARCHAR2(50);
    prod_category_desc        VARCHAR2(2000);
    prod_weight_class         NUMBER(2);
    prod_unit_of_measure      VARCHAR2(20);
    prod_pack_size            VARCHAR2(30);
    supplier_id               NUMBER(6);
    prod_status               VARCHAR2(20);
    prod_list_price           NUMBER(8,2);
    prod_min_price            NUMBER(8,2);
    sales                     NUMBER:=0;
BEGIN
   LOOP
     -- Fetch from cursor variable
     FETCH cur INTO prod_id, prod_name, prod_desc, prod_subcategory, 
  prod_subcategory_desc, prod_category, prod_category_desc, prod_weight_class,
  prod_unit_of_measure, prod_pack_size, supplier_id, prod_status,
     prod_list_price, prod_min_price;
     EXIT WHEN cur%NOTFOUND; -- exit when last row is fetched
     IF prod_status='obsolete' THEN
       IF prod_category=prod_cat THEN
          INSERT INTO obsolete_products_errors VALUES
          (prod_id, 'correction: category '||UPPER(prod_cat)||' still
   available');
          COMMIT;
       ELSE
       PIPE ROW (product_t( prod_id, prod_name, prod_desc, prod_subcategory,
 prod_subcategory_desc, prod_category, prod_category_desc, prod_weight_class,
 prod_unit_of_measure, prod_pack_size, supplier_id, prod_status, 
 prod_list_price, prod_min_price));
       END IF;
     END IF;
   END LOOP;
   CLOSE cur;
   RETURN;
END;
/
</pre>
<p>The following query shows all obsolete product groups except the <code>prod_category</code> Electronics, which was wrongly set to status <code>obsolete</code>:</p>
<pre>
SELECT DISTINCT prod_category, prod_status FROM TABLE(obsolete_products_dml(
CURSOR(SELECT prod_id, prod_name, prod_desc, prod_subcategory, 
  prod_subcategory_desc, prod_category, prod_category_desc, prod_weight_class,
  prod_unit_of_measure, prod_pack_size, supplier_id, prod_status, 
  prod_list_price, prod_min_price
FROM products)));
</pre>
<p>As you can see, there are some products of the <code>prod_category</code> Electronics that were obsoleted by accident:</p>
<pre>
SELECT DISTINCT msg FROM obsolete_products_errors;
</pre>
<p>Taking advantage of the second input variable, you can specify a different product group than Electronics to be considered:</p>
<pre>
SELECT DISTINCT prod_category, prod_status
FROM TABLE(obsolete_products_dml(
CURSOR(SELECT prod_id, prod_name, prod_desc, prod_subcategory,
  prod_subcategory_desc, prod_category, prod_category_desc, prod_weight_class,
  prod_unit_of_measure, prod_pack_size, supplier_id, prod_status,
  prod_list_price, prod_min_price
FROM products),'Photo'));
</pre>
<p>Because table functions can be used like a normal table, they can be nested, as shown in the following:</p>
<pre>
SELECT DISTINCT prod_category, prod_status
FROM TABLE(obsolete_products_dml(CURSOR(SELECT * 
FROM TABLE(obsolete_products_pipe(CURSOR(SELECT prod_id, prod_name, prod_desc,
 prod_subcategory, prod_subcategory_desc, prod_category, prod_category_desc,
 prod_weight_class, prod_unit_of_measure, prod_pack_size, supplier_id, 
 prod_status, prod_list_price, prod_min_price
FROM products))))));
</pre>
<p>The biggest advantage of Oracle Database's ETL is its toolkit functionality, where you can combine any of the latter discussed functionality to improve and speed up your ETL processing. For example, you can take an external table as input, join it with an existing table and use it as input for a parallelized table function to process complex business logic. This table function can be used as input source for a <code>MERGE</code> operation, thus streaming the new information for the data warehouse, provided in a flat file within one single statement through the complete ETL process.</p>
<p>See <a class="olink LNPLS" href="../../appdev.112/e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for details about table functions and the PL/SQL programming. For details about table functions implemented in other languages, see <a class="olink ADDCI" href="../../appdev.112/e10765/toc.htm"><span class="italic">Oracle Database Data Cartridge Developer's Guide</span></a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CACGBFBA"></a><a id="DWHSG8333"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Error Logging and Handling Mechanisms</h2>
<p>Ha<a id="sthref398"></a><a id="sthref399"></a><a id="sthref400"></a>ving data that is not clean is very common when loading and transforming data, especially when dealing with data coming from a variety of sources, including external ones. If this dirty data causes you to abort a long-running load or transformation operation, a lot of time and resources is wasted. The following sections discuss the two main causes of errors and how to address them:</p>
<ul>
<li>
<p><a href="#CACGBFCD">Business Rule Violations</a></p>
</li>
<li>
<p><a href="#CACHFHEG">Data Rule Violations (Data Errors)</a></p>
</li>
</ul>
<a id="CACGBFCD"></a><a id="DWHSG8334"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Business Rule<a id="sthref401"></a> Violations</h3>
<p>Data that is logically not clean violates business rules that are known prior to any data consumption. Most of the time, handling these kind of errors will be incorporated into the loading or transformation process. However, in situations where the error identification for all records would become too expensive and the business rule can be enforced as a data rule violation, for example, testing hundreds of columns to see if they are <code>NOT</code> <code>NULL</code>, programmers often choose to handle even known possible logical error cases more generically. An example of this is shown in <a href="#BABJCCDD">"Data Error Scenarios"</a>.</p>
<p>Incorporating logical rules can be as easy as applying filter conditions on the data input stream or as complex as feeding the dirty data into a different transformation workflow. Some examples are as follows:</p>
<ul>
<li>
<p>Filtering of logical data errors using SQL. Data that does not adhere to certain conditions is filtered out prior to being processed.</p>
</li>
<li>
<p>Identifying and separating logical data errors. In simple cases, this can be accomplished using SQL, as shown in <a href="#i1006454">Example 15-1, "Merge Operation Using SQL"</a>, or in more complex cases in a procedural approach, as shown in <a href="#CACFHAGG">Example 15-6, "Table Functions Fundamentals"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACHFHEG"></a><a id="DWHSG8335"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Data Rule<a id="sthref402"></a> Violations (Data Errors)</h3>
<p>Unlike logical errors, data rule violations are not usually anticipated by the load or transformation process. Such unexpected data rule violations (also known as data errors) that are not handled from an operation cause the operation to fail. Data rule violations are error conditions that happen inside the database and cause a statement to fail. Examples of this are data type conversion errors or constraint violations.</p>
<p>In the past, SQL did not offer a way to handle data errors on a row level as part of its bulk processing. The only way to handle data errors inside the database was to use PL/SQL. Now, however, you can log data errors into a special error table while the DML operation continues.</p>
<p>The following sections briefly discuss exception handling with PL/SQL and DML error logging tables.</p>
<a id="BABHGHEJ"></a><a id="DWHSG8336"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Handling Data Errors in PL/SQL</h4>
<p>The following statement is an example of how error handling can be done using PL/SQL. Note that you have to use procedural record-level processing to catch any errors. This statement is a rough equivalent of the statement discussed in <a href="#BABDCGJJ">"Handling Data Errors with an Error Logging Table"</a>.</p>
<pre>
DECLARE
errm number default 0;
BEGIN
FOR crec IN (SELECT product_id, customer_id, TRUNC(sales_date) sd,
                   promotion_id, quantity, amount
             FROM sales_activity_direct) loop
 
BEGIN
 INSERT INTO sales VALUES (crec.product_id, crec.customer_id,
                           crec.sd, 3, crec.promotion_id,
                           crec.quantity, crec.amount);
exception
WHEN others then
 errm := sqlerrm;
 INSERT INTO sales_activity_error
        VALUES (errm, crec.product_id, crec.customer_id, crec.sd,
                crec.promotion_id, crec.quantity, crec.amount);
END;
END loop;
END;
/
</pre></div>
<!-- class="sect3" -->
<a id="BABDCGJJ"></a><a id="DWHSG8337"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Handling Data Errors with an Error Logging Table</h4>
<p>DML error<a id="sthref403"></a> logging extends existing DML functionality by enabling you to specify the name of an error logging table into which Oracle Database should record errors encountered during DML operations. This enables you to complete the DML operation in spite of any errors, and to take corrective action on the erroneous rows at a later time.</p>
<p>This DML error logging table consists of several mandatory control columns and a set of user-defined columns that represent either all or a subset of the columns of the target table of the DML operation using a data type that is capable of storing potential errors for the target column. For example, you need a <code>VARCHAR2</code> data type in the error logging table to store <code>TO_NUM</code> data type conversion errors for a <code>NUMBER</code> column in the target table. You<a id="sthref404"></a> should use the <code>DBMS_ERRLOG</code> package to create the DML error logging tables. See the <a class="olink ARPLS680" href="../../appdev.112/e40758/d_errlog.htm#ARPLS680"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about this package and the structure of the logging table.</p>
<p>The column name mapping between the DML target table and an error logging table determines which columns besides the control columns is logged for a DML operation.</p>
<p>The following statement illustrates how to enhance the example in <a href="#i1006396">"Transforming Data Using SQL"</a> with DML error logging:</p>
<pre>
INSERT /*+ APPEND PARALLEL */
INTO sales SELECT product_id, customer_id, TRUNC(sales_date), 3,
   promotion_id, quantity, amount
FROM sales_activity_direct
LOG ERRORS INTO sales_activity_errors('load_20040802')
REJECT LIMIT UNLIMITED
</pre>
<p>All data errors are logged into table <code>sales_activity_errors</code>, identified by the optional tag <code>load_20040802</code>. The <code>INSERT</code> statement succeeds even in the presence of data errors. Note that you have to create the DML error logging table prior to using this statement.</p>
<p>If <code>REJECT</code> <code>LIMIT</code> <code>X</code> had been specified, the statement would have failed with the error message of <code>error X=1</code>. The error message can be different for different reject limits. In the case of a failing statement, only the DML statement is rolled back, not the insertion into the DML error logging table. The error logging table will contain X+1 rows.</p>
<p>A DML error logging table can be in a different schema than the executing user, but you must fully specify the table name in that case. Optionally, the name of the DML error logging table can be omitted; Oracle then assumes a default name for the table as generated by <a id="sthref405"></a><a id="sthref406"></a>the <code>DBMS_ERRLOG</code> package.</p>
<p>Oracle Database logs the following errors during DML operations:</p>
<ul>
<li>
<p>Column values that are too large.</p>
</li>
<li>
<p>Constraint violations (<code>NOT</code> <code>NULL</code>, unique, referential, and check constraints).</p>
</li>
<li>
<p>Errors raised during trigger execution.</p>
</li>
<li>
<p>Errors resulting from type conversion between a column in a subquery and the corresponding column of the table.</p>
</li>
<li>
<p>Partition mapping errors.</p>
</li>
</ul>
<p>The following conditions cause the statement to fail and roll back without invoking the error logging capability:</p>
<ul>
<li>
<p>Violated deferred constraints.</p>
</li>
<li>
<p>Out of space errors.</p>
</li>
<li>
<p>Any direct-path <code>INSERT</code> operation (<code>INSERT</code> or <code>MERGE</code>) that raises a unique constraint or index violation.</p>
</li>
<li>
<p>Any <code>UPDATE</code> operation (<code>UPDATE</code> or <code>MERGE</code>) that raises a unique constraint or index violation.</p>
</li>
</ul>
<p>In addition, you cannot track errors in the error logging table for <code>LONG</code>, <code>LOB</code>, or object type columns. See <a class="olink SQLRF55101" href="../../server.112/e41084/statements_9014.htm#SQLRF55101"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information on restrictions when using error logging.</p>
<p>DML error logging can be applied to any kind of DML operation. Several examples are discussed in the following section.</p>
<p>Note that SQL*Loader as an external load utility offers the functionality of logging data errors as well, but lacks the advantage of the integrated ETL processing inside the database.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006922"></a><a id="DWHSG8338"></a>
<div class="sect1">
<h2 class="sect1">Loading and Transformation Scenarios</h2>
<p>The following sections offer examp<a id="sthref407"></a>les of typical loading and transformation tasks:</p>
<ul>
<li>
<p><a href="#i1007128">Key Lookup Scenario</a></p>
</li>
<li>
<p><a href="#i1007148">Business Rule Violation Scenario</a></p>
</li>
<li>
<p><a href="#BABJCCDD">Data Error Scenarios</a></p>
</li>
<li>
<p><a href="#i1007148">Business Rule Violation Scenario</a></p>
</li>
<li>
<p><a href="#i1007172">Pivoting Scenarios</a></p>
</li>
</ul>
<a id="i1007128"></a><a id="DWHSG8339"></a>
<div class="sect2">
<h3 class="sect2">Key Lookup Scenario</h3>
<p><a id="sthref408"></a>A typical transformation is the key lookup. For example, suppose that sales transaction data has been loaded into a retail data warehouse. Although the data warehouse's <code>sales</code> table contains a <code>product_id</code> column, the sales transaction data extracted from the source system contains Uniform Price Codes (UPC) instead of product IDs. Therefore, it is necessary to transform the UPC codes into product IDs before the new sales transaction data can be inserted into the <code>sales</code> table.</p>
<p>In order to execute this transformation, a lookup table must relate the <code>product_id</code> values to the UPC codes. This table might be the <code>product</code> dimension table, or perhaps another table in the data warehouse that has been created specifically to support this transformation. For this example, we assume that there is a table named <code>product</code>, which has a <code>product_id</code> and an <code>upc_code</code> column.</p>
<p>This data substitution transformation can be implemented using the following CTAS statement:</p>
<pre>
CREATE TABLE temp_sales_step2 NOLOGGING PARALLEL AS SELECT sales_transaction_id,
  product.product_id sales_product_id, sales_customer_id, sales_time_id,
  sales_channel_id, sales_quantity_sold, sales_dollar_amount
FROM  temp_sales_step1, product
WHERE temp_sales_step1.upc_code = product.upc_code;
</pre>
<p>This CTAS statement converts each valid UPC code to a valid <code>product_id</code> value. If the ETL process has guaranteed that each UPC code is valid, then this statement alone may be sufficient to implement the entire transformation.</p>
</div>
<!-- class="sect2" -->
<a id="i1007148"></a><a id="DWHSG8340"></a>
<div class="sect2">
<h3 class="sect2">Business Rule Violation Scenario</h3>
<p>In the preceding example, if you must also handle new sales data that does not have valid UPC codes (a logical data error), you can use an additional CTAS statement to identify the invalid rows:</p>
<pre>
CREATE TABLE temp_sales_step1_invalid NOLOGGING PARALLEL AS
SELECT * FROM temp_sales_step1 s
WHERE NOT EXISTS (SELECT 1 FROM product p WHERE p.upc_code=s.upc_code);
</pre>
<p>This invalid data is now stored in a separate table, <code>temp_sales_step1_invalid</code>, and can be handled separately by the ETL process.</p>
<p>Another way to handle invalid data is to modify the original CTAS to use an outer join, as in the following statement:</p>
<pre>
CREATE TABLE temp_sales_step2 NOLOGGING PARALLEL AS
SELECT sales_transaction_id, product.product_id sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id, sales_quantity_sold,
   sales_dollar_amount
FROM  temp_sales_step1, product
WHERE temp_sales_step1.upc_code = product.upc_code (+);
</pre>
<p>Using this outer join, the sales transactions that originally contained invalidated UPC codes are assigned a <code>product_id</code> of <code>NULL</code>. These transactions can be handled later. Alternatively, you could use a multi-table insert, separating the values with a <code>product_id</code> of <code>NULL</code> into a separate table; this might be a beneficial approach when the expected error count is relatively small compared to the total data volume. You do not have to touch the large target table but only a small one for a subsequent processing.</p>
<pre>
INSERT /*+ APPEND PARALLEL */ FIRST
WHEN sales_product_id IS NOT NULL THEN
   INTO temp_sales_step2
   VALUES (sales_transaction_id, sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id,
   sales_quantity_sold, sales_dollar_amount)
ELSE
   INTO temp_sales_step1_invalid
   VALUES (sales_transaction_id, sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id,
   sales_quantity_sold, sales_dollar_amount)
SELECT sales_transaction_id, product.product_id sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id,
   sales_quantity_sold, sales_dollar_amount
FROM temp_sales_step1, product
WHERE temp_sales_step1.upc_code = product.upc_code (+);
</pre>
<p>Note that for this solution, the empty tables <code>temp_sales_step2</code> and <code>temp_sales_step1_invalid</code> must already exist.</p>
<p>Additional approaches to handling invalid UPC codes exist. Some data warehouses may choose to insert null-valued <code>product_id</code> values into their <code>sales</code> table, while others may not allow any new data from the entire batch to be inserted into the <code>sales</code> table until all invalid UPC codes have been addressed. The correct approach is determined by the business requirements of the data warehouse. Irrespective of the specific requirements, exception handling can be addressed by the same basic SQL techniques as transformations.</p>
</div>
<!-- class="sect2" -->
<a id="BABJCCDD"></a><a id="DWHSG8341"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Data Error Scenarios</h3>
<p>If the quality of the data is unknown, the example discussed in the preceding section could be enhanced to handle unexpected data errors, for example, data type conversion errors, as shown in the following:</p>
<pre>
INSERT /*+ APPEND PARALLEL */ FIRST
WHEN sales_product_id IS NOT NULL THEN
INTO temp_sales_step2
VALUES (sales_transaction_id, sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id,
   sales_quantity_sold, sales_dollar_amount)
LOG ERRORS INTO sales_step2_errors('load_20040804')
REJECT LIMIT UNLIMITED
ELSE
INTO temp_sales_step1_invalid
VALUES (sales_transaction_id, sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id,
   sales_quantity_sold, sales_dollar_amount)
LOG ERRORS INTO sales_step2_errors('load_20040804')
REJECT LIMIT UNLIMITED
SELECT sales_transaction_id, product.product_id sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id,
   sales_quantity_sold, sales_dollar_amount
FROM temp_sales_step1, product
WHERE temp_sales_step1.upc_code = product.upc_code (+);
</pre>
<p>This statement tracks the logical data error of not having a valid product UPC code in table <code>temp_sales_step1_invalid</code> and all other possible errors in a DML error logging table called <code>sales_step2_errors</code>. Note that an error logging table can be used for several DML operations.</p>
<p>An alternative to this approach would be to enforce the business rule of having a valid UPC code on the database level with a <code>NOT</code> <code>NULL</code> constraint. Using an outer join, all orders not having a valid UPC code would be mapped to a <code>NULL</code> value and then treated as data errors. This DML error logging capability is used to track these errors in the following statement:</p>
<pre>
INSERT /*+ APPEND PARALLEL */
INTO temp_sales_step2
VALUES (sales_transaction_id, sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id,
   sales_quantity_sold, sales_dollar_amount)
SELECT sales_transaction_id, product.product_id sales_product_id,
   sales_customer_id, sales_time_id, sales_channel_id,
   sales_quantity_sold, sales_dollar_amount
FROM temp_sales_step1, product
WHERE temp_sales_step1.upc_code = product.upc_code (+)
LOG ERRORS INTO sales_step2_errors('load_20040804')
REJECT LIMIT UNLIMITED;
</pre>
<p>The error logging table contains all records that would have caused the DML operation to fail. You can use its content to analyze and correct any error. The content in the error logging table is preserved for any DML operation, irrespective of the success of the DML operation itself. Let us assume the following SQL statement failed because the reject limit was reached:</p>
<pre>
SQL&gt; INSERT /*+ APPEND NOLOGGING PARALLEL */ INTO sales_overall
2 SELECT * FROM sales_activity_direct
3 LOG ERRORS INTO err$_sales_overall ('load_test2')
4 REJECT LIMIT 10;
SELECT * FROM sales_activity_direct
*
ERROR at line 2:
ORA-01722: invalid number
</pre>
<p>The <a id="sthref409"></a>name of the error logging table, <code>err$_sales_overall</code>, is the default derived by using the <code>DBMS_ERRLOG</code> package. See <a class="olink ARPLS680" href="../../appdev.112/e40758/d_errlog.htm#ARPLS680"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information.</p>
<p>The error message raised by Oracle occurs where the first after the error limit is reached. The next error (number 11) is the one that raised an error. The error message that is displayed is based on the error that exceeded the limit, so, for example, the ninth error could be different from the eleventh error.</p>
<p>The target table <code>sales_overall</code> will not show any records being entered (assumed that the table was empty before), but the error logging table will contain 11 rows (<code>REJECT</code> <code>LIMIT</code> <code>+</code> <code>1</code>)</p>
<pre>
SQL&gt; SELECT COUNT(*) FROM sales_overall;
COUNT(*)
----------
0

SQL&gt; SELECT COUNT(*) FROM err$_sales_overall;
COUNT(*)
----------
11
</pre>
<p>A DML error logging table consists of several fixed control columns that are mandatory for every error logging table. Besides the Oracle error number, Oracle enforces storing the error message as well. In many cases, the error message provides additional information to analyze and resolve the root cause for the data error. The following SQL output of a DML error logging table shows this difference. Note that the second output contains the additional information for rows that were rejected due to <code>NOT</code> <code>NULL</code> violations.</p>
<pre>
SQL&gt; SELECT DISTINCT ora_err_number$ FROM err$_sales_overall;

ORA_ERR_NUMBER$
---------------
           1400
           1722
           1830
           1847

SQL&gt; SELECT DISTINCT ora_err_number$, ora_err_mesg$ FROM err$_sales_overall;

ORA_ERR_NUMBER$       ORA_ERR_MESG$
           1400       ORA-01400: cannot insert NULL into
                      ("SH"."SALES_OVERALL"."CUST_ID")
           1400       ORA-01400: cannot insert NULL into
                      ("SH"."SALES_OVERALL"."PROD_ID")
           1722       ORA-01722: invalid number
           1830       ORA-01830: date format picture ends before
                      converting entire input string
           1847       ORA-01847: day of month must be between 1 and last
                      day of month
</pre>
<p>See <a class="olink ADMIN10261" href="../../server.112/e25494/tables.htm#ADMIN10261"><span class="italic">Oracle Database Administrator's Guide</span></a> for a detailed description of control columns.</p>
</div>
<!-- class="sect2" -->
<a id="i1007172"></a><a id="DWHSG8342"></a>
<div class="sect2">
<h3 class="sect2">Pivoting Scenarios</h3>
<p><a id="sthref410"></a>A data warehouse can<a id="sthref411"></a> receive data from many different sources. Some of these source systems may not be relational databases and may store data in very different formats from the data warehouse. For example, suppose that you receive a set of sales records from a nonrelational database having the form:</p>
<pre>
product_id, customer_id, weekly_start_date, sales_sun, sales_mon, sales_tue,
  sales_wed, sales_thu, sales_fri, sales_sat
</pre>
<p>The input table looks like the following:</p>
<pre>
SELECT * FROM sales_input_table;

PRODUCT_ID CUSTOMER_ID WEEKLY_ST  SALES_SUN  SALES_MON  SALES_TUE  SALES_WED SALES_THU  SALES_FRI  SALES_SAT
---------- ----------- --------- ---------- ---------- ---------- -------------------- ---------- ----------
       111         222 01-OCT-00        100        200        300        400       500        600        700
       222         333 08-OCT-00        200        300        400        500       600        700        800
       333         444 15-OCT-00        300        400        500        600       700        800        900
</pre>
<pre>
</pre>
<p>In your data warehouse, you would want to store the records in a more typical relational form in a fact table <code>sales</code> of the <code>sh</code> sample schema:</p>
<pre>
prod_id, cust_id, time_id, amount_sold
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
A number of constraints on the <code>sales</code> table have been disabled for purposes of this example, because the example ignores a number of table columns for the sake of brevity.</div>
<p>Thus, you need to build a transformation such that each record in the input stream must be converted into seven records for the data warehouse's <code>sales</code> table. This operation is commonly referred to as <a href="glossary.htm#i997077"><span class="xrefglossterm">pivoting</span></a>, and Oracle Database offers several ways to do this.</p>
<p>The result of the previous example will resemble the following:</p>
<pre>
SELECT prod_id, cust_id, time_id, amount_sold FROM sales;

   PROD_ID    CUST_ID   TIME_ID   AMOUNT_SOLD
---------- ----------   --------- -----------
       111        222   01-OCT-00         100
       111        222   02-OCT-00         200
       111        222   03-OCT-00         300
       111        222   04-OCT-00         400
       111        222   05-OCT-00         500
       111        222   06-OCT-00         600
       111        222   07-OCT-00         700
       222        333   08-OCT-00         200
       222        333   09-OCT-00         300
       222        333   10-OCT-00         400
       222        333   11-OCT-00         500
       222        333   12-OCT-00         600
       222        333   13-OCT-00         700
       222        333   14-OCT-00         800
       333        444   15-OCT-00         300
       333        444   16-OCT-00         400
       333        444   17-OCT-00         500
       333        444   18-OCT-00         600
       333        444   19-OCT-00         700
       333        444   20-OCT-00         800
       333        444   21-OCT-00         900
</pre>
<div class="example">
<p class="titleinexample"><a id="DWHSG8343"></a><a id="sthref412"></a>Example 15-7 Pivoting</p>
<p>The following example uses the multitable insert syntax to insert into the demo table <code>sh.sales</code> some data from an input table with a different structure. The multitable <code>INSERT</code> statement looks like the following:</p>
<pre>
INSERT ALL INTO sales (prod_id, cust_id, time_id, amount_sold)
      VALUES (product_id, customer_id, weekly_start_date, sales_sun)
      INTO sales (prod_id, cust_id, time_id, amount_sold)
      VALUES (product_id, customer_id, weekly_start_date+1, sales_mon)
      INTO sales (prod_id, cust_id, time_id, amount_sold)
      VALUES (product_id, customer_id, weekly_start_date+2, sales_tue)
      INTO sales (prod_id, cust_id, time_id, amount_sold)
      VALUES (product_id, customer_id, weekly_start_date+3, sales_wed)
      INTO sales (prod_id, cust_id, time_id, amount_sold)
      VALUES (product_id, customer_id, weekly_start_date+4, sales_thu)
      INTO sales (prod_id, cust_id, time_id, amount_sold)
      VALUES (product_id, customer_id, weekly_start_date+5, sales_fri)
      INTO sales (prod_id, cust_id, time_id, amount_sold)
      VALUES (product_id, customer_id, weekly_start_date+6, sales_sat)
SELECT product_id, customer_id, weekly_start_date, sales_sun,
      sales_mon, sales_tue, sales_wed, sales_thu, sales_fri, sales_sat
FROM sales_input_table;
</pre>
<p>This statement only scans the source table once and then inserts the appropriate data for each day.</p>
</div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="analysis.htm#BCFHHHHF">"Pivoting Operations"</a> for more information regarding pivoting</p>
</li>
<li>
<p><a class="olink SQLRF01702" href="../../server.112/e41084/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code>pivot_clause</code> syntax</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1371">
<tr>
<td class="cellalignment1378">
<table class="cellalignment1376">
<tr>
<td class="cellalignment1375"><a href="transport.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1375"><a href="refresh.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1380">
<table class="cellalignment1374">
<tr>
<td class="cellalignment1375"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1375"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1375"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1375"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1375"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1375"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
