<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Eliminating Performance Bottlenecks</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.1 Build 005" />
<meta name="dcterms.created" content="2012-02-07T20:3:13Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database 2 Day + Data Warehousing Guide" />
<meta name="dcterms.identifier" content="E25555-03" />
<meta name="dcterms.isVersionOf" content="TDPDW" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2007, 2012,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="tdpdw_optimize.htm" title="Previous" type="text/html" />
<link rel="Next" href="tdpdw_bandr.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25555.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/20</span> <!-- End Header --><a id="CACJFFGI"></a>
<h1 class="chapter"><span class="secnum">10</span> <a id="TDPDW008"></a>Eliminating Performance Bottlenecks</h1>
<p>This chapter describes how to identify and reduce performance issues and contains the following topics:</p>
<ul>
<li>
<p><a href="#CACCIICD">Verifying That SQL Runs Efficiently</a></p>
</li>
<li>
<p><a href="#CIHBEBGD">Improving Performance by Minimizing Resource Use</a></p>
</li>
<li>
<p><a href="#CIHDIIIA">Using Resources Optimally</a></p>
</li>
</ul>
<a id="CACCIICD"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="TDPDW0081"></a>Verifying That SQL Runs Efficiently</h2>
<p>An important aspect of ensuring that your system performs well is to eliminate performance problems. This section describes some methods of finding and eliminating these bottlenecks, and contains the following topics:</p>
<ul>
<li>
<p><a href="#CACBGEEH">Analyzing Optimizer Statistics</a></p>
</li>
<li>
<p><a href="#CACCCEFF">Analyzing an Execution Plan</a></p>
</li>
<li>
<p><a href="#CACCGFJE">Using Hints to Improve Data Warehouse Performance</a></p>
</li>
<li>
<p><a href="#CACFGIHA">Using Advisors to Verify SQL Performance</a></p>
</li>
</ul>
<a id="CACBGEEH"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="TDPDW00811"></a>Analyzing Optimizer Statistics</h3>
<p><span class="bold">Optimizer</span> <a id="sthref248"></a><a id="sthref249"></a><span class="bold">statistics</span> are a collection of data that describes more details about the database and the objects in the database. These statistics are stored in the data dictionary and are used by the query optimizer to choose the best execution plan for each SQL statement. Optimizer statistics include the following:</p>
<ul>
<li>
<p><a id="sthref250"></a>Table statistics (number of rows, blocks, and the average row length)</p>
</li>
<li>
<p><a id="sthref251"></a>Column statistics (number of distinct values in a column, number of null values in a column, and data distribution)</p>
</li>
<li>
<p><a id="sthref252"></a>Index statistics (number of leaf blocks, levels, and clustering factor)</p>
</li>
<li>
<p><a id="sthref253"></a>System statistics (CPU and I/O performance and utilization)</p>
</li>
</ul>
<p>The optimizer statistics are stored in the data dictionary. They can be viewed using data dictionary views similar to the following:</p>
<pre>
SELECT * FROM DBA_TAB_STATISTICS;
</pre>
<p>Because the objects in a database can constantly change, statistics must be regularly updated so that they accurately describe these database objects. Statistics are maintained automatically by Oracle Database, or you can maintain the optimizer statistics manually using the <a id="sthref254"></a><code>DBMS_STATS</code> package.</p>
</div>
<!-- class="sect2" -->
<a id="CACCCEFF"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="TDPDW00812"></a>Analyzing an Execution Plan</h3>
<p>To execute <a id="sthref255"></a><a id="sthref256"></a>a SQL statement, Oracle Database may perform many steps. Each of these steps either retrieves rows of data physically from the database or prepares them in some way for the user issuing the statement. The combination of the steps Oracle Database uses to execute a statement is called an execution plan. An execution plan includes an access path for each table that the statement accesses and an ordering of the tables (the join order) with the appropriate join method.</p>
<p>You can examine the execution plan chosen by the optimizer for a SQL statement by using the <a id="sthref257"></a><code>EXPLAIN</code> <code>PLAN</code> statement. When the statement is issued, the optimizer chooses an execution plan and then inserts data describing the plan into a database table. Issue the <code>EXPLAIN</code> <code>PLAN</code> statement and then query the output table.</p>
<p>General guidelines for using the <code>EXPLAIN</code> <code>PLAN</code> statement are:</p>
<ul>
<li>
<p>To use the SQL script <a id="sthref258"></a><code>UTLXPLAN.SQL</code> to create a sample output table called <code>PLAN_TABLE</code> in your schema.</p>
</li>
<li>
<p>To include the <code>EXPLAIN</code> <code>PLAN</code> <code>FOR</code> clause before the SQL statement.</p>
</li>
<li>
<p>After issuing the <code>EXPLAIN</code> <code>PLAN</code> statement, to use one of the scripts or packages provided by Oracle Database to display the most recent plan table output.</p>
</li>
<li>
<p>The execution order in <code>EXPLAIN</code> <code>PLAN</code> output begins with the line that is indented farthest to the right. If two lines are indented equally, then the top line is usually executed first.</p>
</li>
</ul>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref259"></a>
<h4 class="sect3"><a id="TDPDW00833"></a>Example: Analyzing Explain Plan Output</h4>
<p>The following statement shows the output of two <code>EXPLAIN</code> <code>PLAN</code> statements, one with dynamic pruning and one with static pruning.</p>
<p class="subhead2"><a id="sthref260"></a>To analyze EXPLAIN PLAN output:</p>
<pre>
EXPLAIN PLAN FOR
SELECT p.prod_name
, c.channel_desc
, SUM(s.amount_sold) revenue
FROM products p
, channels c
, sales s
WHERE s.prod_id = p.prod_id
AND s.channel_id = c.channel_id
AND s.time_id BETWEEN '01-12-2001' AND '31-12-2001'
GROUP BY p.prod_name
, c.channel_desc;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
</pre>
<pre>
WITHOUT TO_DATE
---------------------------------------------------------------------------------------------------
| Id| Operation                              |      Name    |Rows|Bytes|Cost  | Time |Pstart|Pstop|
                                                                        (%CPU)
---------------------------------------------------------------------------------------------------
|  0|SELECT STATEMENT                        |              | 252|15876|305(1)|00:00:06|    |     |
|  1| HASH GROUP BY                          |              | 252|15876|305(1)|00:00:06|    |     |
| *2|  FILTER                                |              |    |     |      |        |    |     |
| *3|   HASH JOIN                            |              |2255| 138K|304(1)|00:00:06|    |     |
|  4|    TABLE ACCESS FULL                   |     PRODUCTS |  72| 2160|  2(0)|00:00:01|    |     |
|  5|    MERGE JOIN                          |              |2286|75438|302(1)|00:00:06|    |     |
|  6|     TABLE ACCESS BY INDEX ROWID        |     CHANNELS |   5|   65|  2(0)|00:00:01|    |     |
|  7|      INDEX FULL SCAN                   |  CHANNELS_PK |   5|     |  1(0)|00:00:01|    |     |
| *8|     SORT JOIN                          |              |2286|45720|299(1)|00:00:06|    |     |
|  9|      PARTITION RANGE ITERATOR          |              |2286|45720|298(0)|00:00:06| KEY|  KEY|
| 10|       TABLE ACCESS BY LOCAL INDEX ROWID|        SALES |2286|45720|298(0)|00:00:06| KEY|  KEY|
| 11|        BITMAP CONVERSION TO ROWIDS     |              |    |     |      |        |    |     |
|*12|         BITMAP INDEX RANGE SCAN        |SALES_TIME_BIX|    |     |      |        | KEY|  KEY|
---------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(TO_DATE('01-12-2001')&lt;=TO_DATE('31-12-2001'))
   3 - access("S"."PROD_ID"="P"."PROD_ID")
   8 - access("S"."CHANNEL_ID"="C"."CHANNEL_ID")
       filter("S"."CHANNEL_ID"="C"."CHANNEL_ID")
  12 - access("S"."TIME_ID"&gt;='01-12-2001' AND "S"."TIME_ID"&lt;='31-12-2001')
Note the values of KEY KEY for Pstart and Pstop.
 
WITH TO_DATE
--------------------------------------------------------------------------------------------------
|Id| Operation                 | Name   | Rows  | Bytes |Cost(%CPU)| Time     | Pstart| Pstop |
--------------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT          |        |   252 | 15876 |   31 (20)| 00:00:01 |       |       |
| 1|  HASH GROUP BY            |        |   252 | 15876 |   31 (20)| 00:00:01 |       |       |
|*2|   HASH JOIN               |        | 21717 |  1336K|   28 (11)| 00:00:01 |       |       |
| 3|    TABLE ACCESS FULL      |PRODUCTS|    72 |  2160 |    2  (0)| 00:00:01 |       |       |
|*4|    HASH JOIN              |        | 21717 |   699K|   26 (12)| 00:00:01 |       |       |
| 5|     TABLE ACCESS FULL     |CHANNELS|     5 |    65 |    3  (0)| 00:00:01 |       |       |
| 6|     PARTITION RANGE SINGLE|        | 21717 |   424K|   22 (10)| 00:00:01 |    20 |    20 |
|*7|      TABLE ACCESS FULL    |SALES   | 21717 |   424K|   22 (10)| 00:00:01 |    20 |    20 |
---------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("S"."PROD_ID"="P"."PROD_ID")
   4 - access("S"."CHANNEL_ID"="C"."CHANNEL_ID")
   7 - filter("S"."TIME_ID"&gt;=TO_DATE('2001-12-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') AND
              "S"."TIME_ID"&lt;=TO_DATE('2001-12-31 00:00:00', 'yyyy-mm-dd hh24:mi:ss'))
Note the values of 20 20 for Pstart and Pstop.
</pre>
<p>The first execution plan shows dynamic pruning using the <code>KEY</code> values for <code>Pstart</code> and <code>Pstop</code> respectively. Dynamic pruning means that the database will have to determine at execution time which partition or partitions to access. With static pruning, the database knows at parse time which partition or partitions to access, which leads to more efficient execution.</p>
<p>You can frequently improve the execution plan by using explicit date conversions. Using explicit date conversions is a <span class="italic">best</span> <span class="italic">practice</span> for optimal partition pruning and index usage.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACCGFJE"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="TDPDW00813"></a>Using Hints to Improve Data Warehouse Performance</h3>
<p>Hints enable you to ma<a id="sthref261"></a><a id="sthref262"></a>ke decisions usually made by the optimizer. As an application developer, you might have information about your data that the optimizer does not know. Hints provide a mechanism to instruct the optimizer to choose a certain query execution plan based on specific criteria.</p>
<p>For example, you might know that a certain index is more selective for certain queries. Based on this information, you might be able to choose a more efficient execution plan than the optimizer. In this case, use hints to instruct the optimizer to use the optimal execution plan.</p>
<p>By default, Oracle Warehouse Builder includes hints to optimize a typical data load.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink WBDOD" href="../../owb.112/e10582/toc.htm"><span class="italic">Oracle Warehouse Builder Sources and Targets Guide</span></a></div>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref263"></a>
<h4 class="sect3"><a id="TDPDW00835"></a>Example: Using Hints to Improve Data Warehouse Performance</h4>
<p>Suppose you want to quickly run a summary across the sales table for last year while the system is otherwise idle. In this case, you could issue the following statement.</p>
<p class="subhead2"><a id="sthref264"></a>To use a hint to improve data warehouse performance:</p>
<pre>
SELECT /*+ PARALLEL(s,16) */ SUM(amount_sold)
FROM sales s
WHERE s.time_id BETWEEN TO_DATE('01-JAN-2005','DD-MON-YYYY')
  AND TO_DATE('31-DEC-2005','DD-MON-YYYY');
</pre>
<p>Another common use for hints in data warehouses is to ensure that records are efficiently loaded using compression. For this, you use the <code>APPEND</code> hint, as shown in the following SQL:</p>
<pre>
...
INSERT /* +APPEND */ INTO my_materialized_view
...
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACFGIHA"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="TDPDW00814"></a>Using Advisors to Verify SQL Performance</h3>
<p>Using the<a id="sthref265"></a><a id="sthref266"></a><a id="sthref267"></a><a id="sthref268"></a> SQL Tuning Advisor and SQL Access Advisor, you can invoke the query optimizer in advisory mode to examine a SQL statement or set of SQL statements, and provide recommendations to improve their efficiency. The SQL Tuning Advisor and SQL Access Advisor can make various types of recommendations, such as creating SQL profiles, restructuring SQL statements, creating additional indexes or materialized views, and refreshing optimizer statistics. Additionally, Oracle Enterprise Manager enables you to accept and implement many of these recommendations in very few steps.</p>
<p>The SQL Access Advisor is primarily responsible for making schema modification recommendations, such as adding or dropping indexes and materialized views. It also recommends a partitioning strategy. The SQL Tuning Advisor makes other types of recommendations, such as creating SQL profiles and restructuring SQL statements. In some cases where significant performance improvements can be gained by creating a new index, the SQL Tuning Advisor may recommend doing so. However, these recommendations must be verified by running the SQL Access Advisor with a SQL workload that contains a set of representative SQL statements.</p>
<p class="subhead2"><a id="sthref269"></a><a id="TDPDW00836"></a>Example: Using the SQL Tuning Advisor to Verify SQL Performance</p>
<p>You can use the SQL Tuning Advisor to tune a single SQL statement or multiple SQL statements. When tuning multiple SQL statements, remember the SQL Tuning Advisor does not recognize interdependencies between the SQL statements. Instead, it is just meant to be a convenient way for you to run the SQL Tuning Advisor for a large number of SQL statements.</p>
<p><span class="bold">To run the SQL Tuning Advisor to verify SQL performance:</span></p>
<ol>
<li>
<p>Go to the Advisor Central page, then click <span class="bold">SQL</span> <span class="bold">Advisors</span>.</p>
<p>The SQL Advisors page is displayed.</p>
</li>
<li>
<p>Click <span class="bold">Schedule</span> <span class="bold">SQL</span> <span class="bold">Tuning</span> <span class="bold">Advisor</span>.</p>
<p>The Schedule SQL Tuning Advisor page is displayed. A suggested name will be in the <span class="bold">Name</span> field, which you can modify. Then select <span class="bold">Comprehensive</span> to have a comprehensive analysis performed. Select <span class="bold">Immediately</span> for the Schedule. Select a appropriate SQL Tuning Set, and then click <span class="bold">OK</span>.</p>
</li>
<li>
<p>The Processing page is displayed. Then the Recommendations page shows the recommendations for improving performance. Click <span class="bold">View</span> <span class="bold">Recommendations</span>.</p>
<p>The Recommendations page is displayed.</p>
</li>
<li>
<p>The recommendation is to create an index, which you can implement by clicking <span class="bold">Implement</span>. You may also want to run the SQL Access Advisor.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHBEBGD"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="TDPDW0082"></a>Improving Performance by Minimizing Resource Use</h2>
<p>You can minimize re<a id="sthref270"></a><a id="sthref271"></a><a id="sthref272"></a>source use, and improve your data warehouse's performance through the use of the following capabilities:</p>
<ul>
<li>
<p><a href="#CIHJDAHD">Improving Performance: Partitioning</a></p>
</li>
<li>
<p><a href="#CIHBDGEF">Improving Performance: Query Rewrite and Materialized Views</a></p>
</li>
<li>
<p><a href="#CIHBGHHG">Improving Performance: Indexes</a></p>
</li>
<li>
<p><a href="#BABGGHEF">Improving Performance: Compression</a></p>
</li>
</ul>
<a id="CIHJDAHD"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="TDPDW00821"></a>Improving Performance: Partitioning</h3>
<p>Data warehous<a id="sthref273"></a>es often contain large tables and require techniques both for managing these large tables and for providing good query performance across these large tables. This section describes partitioning, a key method for addressing these requirements. Two capabilities relevant for query performance in a data warehouse are partition pruning and partitionwise joins.</p>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref274"></a>
<h4 class="sect3"><a id="TDPDW00838"></a>Improving Performance: Partition Pruning</h4>
<p>Partition <a id="sthref275"></a>pruning is an essential performance feature for data warehouses. In partition pruning, the optimizer analyzes <code>FROM</code> and <code>WHERE</code> clauses in SQL statements to eliminate unneeded partitions when building the partition access list. This enables Oracle Database to perform operations only on those partitions that are relevant to the SQL statement. Oracle Database prunes partitions when you use range, <code>LIKE</code>, equality, and <code>IN</code>-list predicates on the range or list partitioning columns, and when you use equality and <code>IN</code>-list predicates on the hash partitioning columns.</p>
<p>Partition pruning dramatically reduces the amount of data retrieved from disk and shortens the use of processing time, which improves query performance and resource use. If you partition the index and table on different columns (with a global partitioned index), partition pruning eliminates index partitions even when the partitions of the underlying table cannot be eliminated.</p>
<p>Depending upon the actual SQL statement, Oracle Database may use static or dynamic pruning. Static pruning occurs at compile time; the information about the partitions is accessed beforehand, dynamic pruning occurs at run time; the partitions are accessed by a statement and are not known beforehand. A sample scenario for static pruning is a SQL statement that contains a <code>WHERE</code> clause with a constant literal on the partition key column. An example of dynamic pruning is the use of operators or functions in the <code>WHERE</code> clause.</p>
<p>Partition pruning affects the statistics of the objects where pruning will occur and will affect the execution plan of a statement.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref276"></a>
<h4 class="sect3"><a id="TDPDW00851"></a>Improving Performance: Partitionwise Joins</h4>
<p>Partitionwi<a id="sthref277"></a>se joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. This significantly reduces response time and improves the use of both CPU and memory resources. In Oracle Real Application Clusters environments, partitionwise joins also avoid or at least limit the data traffic over the interconnection, which is the key to achieving good scalability for massive join operations.</p>
<p>Partitionwise joins can be full or partial. Oracle Database decides which type of join to use.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref278"></a>
<h4 class="sect3"><a id="TDPDW00850"></a>Example: Evaluating Partitioning with the SQL Access Advisor</h4>
<p>You should always consider partitioning in data warehousing environments.</p>
<p><span class="bold">To evaluat<a id="sthref279"></a>e partitioning:</span></p>
<ol>
<li>
<p>In the Advisor Central page, click <span class="bold">SQL</span> <span class="bold">Advisors</span>.</p>
<p>The SQL Advisors page is displayed.</p>
</li>
<li>
<p>Click <span class="bold">SQL</span> <span class="bold">Access</span> <span class="bold">Advisor</span>.</p>
<p>The SQL Access Advisor page is displayed.</p>
</li>
<li>
<p>From the Initial Options menu, select <span class="bold">Use</span> <span class="bold">Default</span> <span class="bold">Options</span> and click <span class="bold">Continue</span>.</p>
</li>
<li>
<p>From the Workload Sources, select <span class="bold">Current</span> <span class="bold">and</span> <span class="bold">Recent</span> <span class="bold">SQL</span> <span class="bold">Activity</span> and click <span class="bold">Next</span>.</p>
<p>The Recommendation Options page is displayed.</p>
</li>
<li>
<p>Select <span class="bold">Partitioning</span> and then <span class="bold">Comprehensive</span> <span class="bold">Mode</span>, then click <span class="bold">Next</span>.</p>
<p>The Schedule page is displayed.</p>
</li>
<li>
<p>Enter <code>SQLACCESStest1</code> into the <span class="bold">Task</span> <span class="bold">Name</span> field and click <span class="bold">Next</span>.</p>
<p>The Review page is displayed. Click <span class="bold">Submit</span>.</p>
</li>
<li>
<p>Click <span class="bold">Submit</span>.</p>
<p>The Confirmation page is displayed.</p>
</li>
<li>
<p>Select your task and click <span class="bold">View</span> <span class="bold">Result</span>. The Results for Task page is displayed, showing possible improvements as a result of partitioning.</p>
<div class="figure">
<p class="titleinfigure"><a id="sthref280"></a>Figure 10-1 Partitioning Results</p>
<img width="918" height="384" src="img/partit2.gif" alt="Description of Figure 10-1 follows" title="Description of Figure 10-1 follows" /><br />
<a id="sthref281" href="img_text/partit2.htm">Description of "Figure 10-1 Partitioning Results"</a><br />
<br /></div>
<!-- class="figure" --></li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHBDGEF"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="TDPDW0822"></a>Improving Performance: Query Rewrite and Materialized Views</h3>
<p>In data <a id="sthref282"></a><a id="sthref283"></a><a id="sthref284"></a>warehouses, you can use materialized views to compute and store aggregated data such as the sum of sales. You can also use materialized views to compute joins with or without aggregations, and they are very useful for frequently executed expensive joins between large tables and expensive calculations. A materialized view eliminates the overhead associated with expensive joins and aggregations for a large or important class of queries because it computes and stores summarized data before processing large joins or queries. Materialized views in these environments are often referred to as summaries.</p>
<p>One of the major benefits of creating and maintaining materialized views is the ability to use the query rewrite feature, which transforms a SQL statement expressed in terms of tables or views into a statement accessing one or more materialized views that are defined on the detail tables. The transformation is transparent to the user or application, requiring no intervention and no reference to the materialized view in the SQL statement. Because the query rewrite feature is transparent, materialized views can be added or dropped just like indexes without invalidating the SQL in the application code.</p>
<p>When underlying tables contain large amounts of data, it is a resource intensive and time-consuming process to compute the required aggregates or to compute joins between these tables. In these cases, queries can take minutes or even hours to return the answer. Because materialized views contain already computed aggregates and joins, Oracle Database uses the powerful query rewrite process to quickly answer the query using materialized views.</p>
</div>
<!-- class="sect2" -->
<a id="CIHBGHHG"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="TDPDW00823"></a>Improving Performance: Indexes</h3>
<p>Bitmap inde<a id="sthref285"></a>xes are widely used in data warehousing environments. The environments typically have large amounts of data and ad hoc queries, but a low level of concurrent DML transactions. Fully indexing a large table with a traditional <a id="sthref286"></a>B-tree index can be prohibitively expensive in terms of disk space because the indexes can be several times larger than the data in the table. Bitmap indexes are typically only a fraction of the size of the indexed data in the table. For such applications, bitmap indexing provides the following:</p>
<ul>
<li>
<p>Reduced response time for large classes of ad hoc queries</p>
</li>
<li>
<p>Reduced storage requirements compared to other indexing techniques</p>
</li>
<li>
<p>Dramatic performance gains even on hardware with a relatively small number of CPUs or a small amount of memory</p>
</li>
<li>
<p>Efficient maintenance during parallel DML and loads</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABGGHEF"></a><a id="TDPDW12080"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Improving <a id="sthref287"></a>Performance: <a id="sthref288"></a>Compression</h3>
<p>During bulk-load operations, Oracle Database can compress the data being loaded. Oracle Database handles data transformation and compression internally and requires no application changes to use compression. Compression can help improve performance for queries that scan large amounts of data, by reducing the amount of I/O required to scan that data.</p>
<p>No special installation is required to configure this feature. However, to use this feature, the database compatibility parameter must be set to <code>11.2.0</code> or higher.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Hybrid Columnar Compression is a feature of certain Oracle storage systems. See <a class="olink CNCPT" href="../e40540/toc.htm"><span class="italic">Oracle Database Concepts</span></a> for more information.</div>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref289"></a>
<h4 class="sect3"><a id="TDPDW12081"></a>Improving Performance: DBMS_COMPRESSION Package</h4>
<p>The PL/SQL package <a id="sthref290"></a><code>DBMS_COMPRESSION</code> provides a <a id="sthref291"></a>compression advisor interface to help choose the correct compression level for an application. The compression advisor analyzes the objects in the database and estimates the possible compression ratios that could be achieved.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS236" href="../../appdev.112/e40758/d_compress.htm#ARPLS236"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information regarding the <code>DBMS_COMPRESSION</code> package</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref292"></a>
<h4 class="sect3"><a id="TDPDW12082"></a>Improving Performance: table_compress clause of CREATE TABLE and ALTER TABLE</h4>
<p>The <a id="sthref293"></a><code><span class="codeinlineitalic">table_compress</span></code> clause of the <code>CREATE</code> <code>TABLE</code> and <code>ALTER</code> <code>TABLE</code> statements provides <a id="sthref294"></a><code>COMPRESS</code>, which takes a parameter for compression level. Use <code>COMPRESS</code> to instruct the database whether to compress data segments to reduce disk use. All forms of table compression are generally useful in OLAP environments and data warehouses, where the number of insert and update operations is small; some forms are also useful in OLTP environments.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For compression to be enabled on a table, it must be turned on at table creation time, or the table must be changed to enable it.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHDIIIA"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="TDPDW0083"></a>Using Resources Optimally</h2>
<p>You can maximize how resources are used in your system by ensuring that operations run in parallel whenever possible. Database operations run faster if they are not constrained by resources. The operation may be constrained by CPU resources, I/O capacity, memory, or interconnection traffic (in a cluster). To improve the performance of database operations, you focus on the performance problem and try to eliminate it (so that the problem might shift to another resource). Oracle Database provides functions to optimize the use of available resources and to avoid using unnecessary resources.</p>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref295"></a>
<h3 class="sect2"><a id="TDPDW00831"></a>Optimizing Performance with Parallel Execution</h3>
<p>Parallel execu<a id="sthref296"></a><a id="sthref297"></a>tion dramatically reduces response time for data-intensive operations on large databases typically associated with a decision support system (DSS) and data warehouses. You can also implement parallel execution on certain types of online transaction processing (OLTP) and hybrid systems. Parallel execution is sometimes called parallelism. Parallelism is breaking down a task so that, instead of one process doing all the work in a query, many processes do part of the work at the same time. An example of this is when four processes handle four different quarters in a year instead of one process handling all four quarters by itself. The improvement in performance can be quite high. Parallel execution improves processing for the following:</p>
<ul>
<li>
<p>Queries requiring large table scans, joins, or partitioned index scans</p>
</li>
<li>
<p>Creation of large indexes</p>
</li>
<li>
<p>Creation of large tables (including materialized views)</p>
</li>
<li>
<p>Bulk insert, update, merge, and delete operations</p>
</li>
</ul>
<p>You can also use parallel execution to access object types within an Oracle database. For example, you can use parallel execution to access large objects (LOBs).</p>
<p>Parallel execution benefits systems with all of the following characteristics:</p>
<ul>
<li>
<p>Symmetric multiprocessors (SMPs), clusters, or massively parallel systems</p>
</li>
<li>
<p>Sufficient I/O bandwidth</p>
</li>
<li>
<p>Underutilized or intermittently used CPUs (for example, systems where CPU usage is typically less than 30 percent)</p>
</li>
<li>
<p>Sufficient memory to support additional memory-intensive processes, such as sorts, hashing, and I/O buffers</p>
</li>
</ul>
<p>If your system lacks any of these characteristics, then parallel execution might not significantly improve performance. In fact, parallel execution might reduce system performance on overutilized systems or systems with small I/O bandwidth.</p>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref298"></a>
<h4 class="sect3"><a id="TDPDW00840"></a>How Parallel Execution Works</h4>
<p>Parallel ex<a id="sthref299"></a>ecution divides the task of running a SQL statement into multiple small units, each of which is executed by a separate process. Also, the incoming data (tables, indexes, partitions) can be divided into parts called <span class="bold">granules</span>. The user shadow process takes on the role as parallel execution coordinator or query coordinator. The query coordinator performs the following tasks:</p>
<ul>
<li>
<p>Parses the query and determines the degree of parallelism</p>
</li>
<li>
<p>Allocates one or two sets of slaves (threads or processes)</p>
</li>
<li>
<p>Controls the query and sends instructions to the parallel query slaves</p>
</li>
<li>
<p>Determines which tables or indexes must be scanned by the parallel query slaves</p>
</li>
<li>
<p>Produces the final output to the user</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref300"></a>
<h4 class="sect3"><a id="TDPDW00841"></a>Setting the Degree of Parallelism</h4>
<p>The par<a id="sthref301"></a>allel execution coordinator may enlist two or more of the instance's parallel execution servers to process a SQL statement. The number of parallel execution servers associated with a single operation is known as the <span class="bold">degree of parallelism</span> or DOP.</p>
<p>A single operation is a part of a SQL statement, such as an <code>ORDER</code> <code>BY</code> operation or a full table scan to perform a join on a non-indexed column table.</p>
<p>The degree of parallelism is specified in the following ways:</p>
<ul>
<li>
<p>At the statement level with <code>PARALLEL</code> hints</p>
</li>
<li>
<p>At the session level by issuing the <code>ALTER</code> <code>SESSION</code> <code>FORCE</code> <code>PARALLEL</code> statement</p>
</li>
<li>
<p>At the table level in the table's definition</p>
</li>
<li>
<p>At the index level in the index's definition</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref302"></a>
<h4 class="sect3"><a id="TDPDW00842"></a>Example: Setting the Degree of Parallelism</h4>
<p>Suppose that you want to set the DOP to 4 on a table.</p>
<p class="subhead2"><a id="sthref303"></a>To set the degree of parallelism:</p>
<p>Issue the following statement:</p>
<pre>
ALTER TABLE orders PARALLEL 4;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref304"></a>
<h3 class="sect2"><a id="TDPDW00832"></a>About Wait Events</h3>
<p><span class="bold">Wait</span> <span class="bold">events</span><a id="sthref305"></a> are statistics that are incremented by a server process to indicate that the server process had to wait for an event to complete before being able to continue processing. A session could wait for a variety of reasons, including waiting for more input, waiting for the operating system to complete a service such as a disk write operation, or it could wait for a lock or latch.</p>
<p>When a session is waiting for resources, it is not doing any useful work. A large number of wait events is a source of concern. Wait event data reveals various symptoms of problems that might be affecting performance, such as latch contention, buffer contention, and I/O contention.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1433">
<tr>
<td class="cellalignment1440">
<table class="cellalignment1438">
<tr>
<td class="cellalignment1437"><a href="tdpdw_optimize.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1437"><a href="tdpdw_bandr.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2007, 2012,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1442">
<table class="cellalignment1436">
<tr>
<td class="cellalignment1437"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1437"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1437"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1437"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1437"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1437"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
