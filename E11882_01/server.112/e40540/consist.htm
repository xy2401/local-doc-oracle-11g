<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Data Concurrency and Consistency</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1056" />
<meta name="dcterms.created" content="2015-05-25T13:34:2Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Concepts" />
<meta name="dcterms.identifier" content="E40540-04" />
<meta name="dcterms.isVersionOf" content="CNCPT" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="part_txn.htm" title="Previous" type="text/html" />
<link rel="Next" href="transact.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e40540.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/30</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='consist'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="CNCPT020" class="chapter"><a id="g43931"></a> <a id="i13945"></a>
<h1 class="chapter"><span class="secnum">9</span> Data Concurrency and Consistency</h1>
<p>This chapter explains how Oracle Database maintains consistent data in a multiuser database environment.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i5700">Introduction to Data Concurrency and Consistency</a></p>
</li>
<li>
<p><a href="#BABEAFAH">Overview of Oracle Database Transaction Isolation Levels</a></p>
</li>
<li>
<p><a href="#i5704">Overview of the Oracle Database Locking Mechanism</a></p>
</li>
<li>
<p><a href="#BABBCEGC">Overview of Automatic Locks</a></p>
</li>
<li>
<p><a href="#i5269">Overview of Manual Data Locks</a></p>
</li>
<li>
<p><a href="#CIHJDIDC">Overview of User-Defined Locks</a></p>
</li>
</ul>
<a id="i5700"></a>
<div id="CNCPT121" class="sect1">
<h2 class="sect1">Introduction to Data Concurrency and Consistency</h2>
<p>In a single-user database, a user can modify data without concern for other users modifying the same data at the same time. However, in a multiuser database, statements within multiple simultaneous <a href="glossary.htm#CHDJEBHA"><span class="xrefglossterm">transactions</span></a> can update the same data. Transactions executing simultaneously must produce meaningful and consistent results. Therefore, a multiuser database must provide the following:</p>
<ul>
<li>
<p><a id="sthref1121"></a><span class="bold">Data concurrency</span>, which ensures that users can access data at the same time</p>
</li>
<li>
<p><span class="bold"><a id="sthref1122"></a>Data consistency</span>, which ensures that each user sees a consistent view of the data, including visible changes made by the user's own transactions and committed transactions of other users</p>
</li>
</ul>
<p>To describe consistent transaction behavior when transactions run concurrently, database researchers have defined a transaction isolation model called<a id="sthref1123"></a><a id="sthref1124"></a> <span class="bold">serializability</span>. A serializable transaction operates in an environment that makes it appear as if no other users were modifying data in the database.</p>
<p>While this degree of isolation between transactions is generally desirable, running many applications in serializable mode can seriously compromise application throughput. Complete isolation of concurrently running transactions could mean that one transaction cannot perform an insertion into a table being queried by another transaction. In short, real-world considerations usually require a compromise between perfect transaction isolation and performance.</p>
<p>Oracle Database maintains data consistency by using a<a id="sthref1125"></a><a id="sthref1126"></a> <span class="bold">multiversion consistency model</span> and various types of <a href="glossary.htm#CHDHEBFJ"><span class="xrefglossterm">locks</span></a> and transactions. In this way, the database can present a view of data to multiple concurrent users, with each view consistent to a point in time. Because different versions of <a href="glossary.htm#CHDBACIH"><span class="xrefglossterm">data blocks</span></a> can exist simultaneously, transactions can read the version of data committed at the point in time required by a <a href="glossary.htm#CHDGABIG"><span class="xrefglossterm">query</span></a> and return results that are consistent to a single point in time.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="datainte.htm#g20134">Chapter 5, "Data Integrity"</a> and <a href="transact.htm#g11401">Chapter 10, "Transactions"</a></div>
<a id="BABEAGIA"></a>
<div id="CNCPT221" class="sect2">
<h3 class="sect2">Multiversion Read Consistency</h3>
<p><a id="sthref1127"></a><a id="sthref1128"></a>In Oracle Database, <span class="bold">multiversioning</span> is the ability to simultaneously materialize multiple versions of data. Oracle Database maintains<a id="sthref1129"></a> <span class="bold">multiversion read consistency</span>, which means that database queries have the following characteristics:</p>
<ul>
<li>
<p>Read-consistent queries</p>
<p>The data returned by a query is committed and consistent with respect to a single point in time.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
Oracle Database <span class="italic">never</span> permits<a id="sthref1130"></a><a id="sthref1131"></a> <span class="bold">dirty reads</span>, which occur when a transaction reads uncommitted data in another transaction.</div>
<p>To illustrate the problem with dirty reads, suppose one transaction updates a <a href="glossary.htm#CBACIBFC"><span class="xrefglossterm">column</span></a> value without committing. A second transaction reads the updated and dirty (uncommitted) value. The first <a href="glossary.htm#CBAHEBIG"><span class="xrefglossterm">session</span></a> rolls back the transaction so that the column has its old value, but the second transaction proceeds using the updated value, corrupting the database. Dirty reads compromise <a href="glossary.htm#CBACGDCA"><span class="xrefglossterm">data integrity</span></a>, violate <a href="glossary.htm#CHDEJJHC"><span class="xrefglossterm">foreign keys</span></a>, and ignore unique constraints.</p>
</li>
<li>
<p>Nonblocking queries</p>
<p>Readers and writers of data do not block one another (see <a href="#BABHIGGC">"Summary of Locking Behavior"</a>).</p>
</li>
</ul>
<div id="CNCPT88960" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1132"></a>
<h4 class="sect3">Statement-Level Read Consistency</h4>
<p>Oracle Database always enforces<a id="sthref1133"></a><a id="sthref1134"></a> <span class="bold">statement-level read consistency</span>, which guarantees that data returned by a single query is committed and consistent with respect to a single point in time. The point in time to which a single SQL statement is consistent depends on the transaction isolation level and the nature of the query:</p>
<ul>
<li>
<p>In the read committed isolation level, this point is the time at which the <span class="italic">statement</span> was opened. For example, if a <code >SELECT</code> statement opens at <a href="glossary.htm#CHDBFAEG"><span class="xrefglossterm">SCN</span></a> 1000, then this statement is consistent to SCN 1000.</p>
</li>
<li>
<p>In a serializable or read-only transaction this point is the time the <span class="italic">transaction</span> began. For example, if a transaction begins at SCN 1000, and if multiple <code dir="ltr">SELECT</code> statements occur in this transaction, then each statement is consistent to SCN 1000.</p>
</li>
<li>
<p>In a Flashback Query operation (<code dir="ltr">SELECT ... AS OF</code>), the <code dir="ltr">SELECT</code> statement explicitly specifies the point in time. For example, you can query a table as it appeared last Thursday at 2 p.m.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADFNS01003" href="../../appdev.112/e41502/adfns_flashback.htm#ADFNS01003"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> to learn about Flashback Query</div>
</div>
<!-- class="sect3" -->
<div id="CNCPT88961" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1135"></a>
<h4 class="sect3">Transaction-Level Read Consistency</h4>
<p>Oracle Database can also provide read consistency to all queries in a transaction, known <a id="sthref1136"></a><a id="sthref1137"></a><a id="sthref1138"></a>as <span class="bold">transaction-level read consistency</span>. In this case, each statement in a transaction sees data from the <span class="italic">same</span> point in time, which is the time at which the transaction began.</p>
<p>Queries made by a serializable transaction see changes made by the transaction itself. For example, a transaction that updates <code dir="ltr">employees</code> and then queries <code dir="ltr">employees</code> will see the updates. Transaction-level read consistency produces repeatable reads and does not expose a query to phantom reads.</p>
</div>
<!-- class="sect3" -->
<a id="BABDDAGC"></a>
<div id="CNCPT88962" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Read Consistency and Undo Segments</h4>
<p>To manage the multiversion read consistency model, the database must create a read-consistent set of data when a table is simultaneously queried and updated. Oracle Database achieves this goal through <a href="glossary.htm#CHDDFBFI"><span class="xrefglossterm">undo data</span></a>.</p>
<p>Whenever a user modifies data, Oracle Database creates undo entries, which it writes to <a id="sthref1139"></a><a id="sthref1140"></a>undo <a href="glossary.htm#CHDCFJBF"><span class="xrefglossterm">segments</span></a> (<a href="logical.htm#CHDGJJEJ">"Undo Segments"</a>). The undo segments contain the old values of data that have been changed by uncommitted or recently committed transactions. Thus, multiple versions of the same data, all at different points in time, can exist in the database. The database can use snapshots of data at different points in time to provide <span class="bold">read-consistent views</span> of the data and enable nonblocking queries.</p>
<p>Read consistency is guaranteed in single-instance and <a id="sthref1141"></a><a id="sthref1142"></a>Oracle Real Application Clusters (Oracle RAC) environments. Oracle RAC uses a cache-to-cache block transfer mechanism known as Cache Fusion to transfer read-consistent images of data blocks from one database instance to another.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="cncptdev.htm#CHDHCHIC">"Internal LOBs"</a> to learn about read consistency mechanisms for LOBs</p>
</li>
<li>
<p><a class="olink TDPRC117" href="../../rac.112/e17264/intro_tdprc.htm#TDPRC117"><span class="italic">Oracle Database 2 Day + Real Application Clusters Guide</span></a> to learn about Cache Fusion</p>
</li>
</ul>
</div>
<div id="CNCPT88963" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1143"></a>
<h5 class="sect4">Read Consistency: Example</h5>
<p><a href="#BABFDBAJ">Figure 9-1</a> shows a query that uses undo data to provide statement-level read consistency in the read committed isolation level.</p>
<div id="CNCPT88964" class="figure">
<p class="titleinfigure"><a id="BABFDBAJ"></a>Figure 9-1 Read Consistency in the Read Committed Isolation Level</p>
<img width="501" height="539" src="img/cncpt069.gif" alt="Description of Figure 9-1 follows" /><br />
<a id="sthref1144" href="img_text/cncpt069.htm">Description of "Figure 9-1 Read Consistency in the Read Committed Isolation Level"</a><br />
<br /></div>
<!-- class="figure" -->
<p>As the database retrieves data blocks on behalf of a query, the database ensures that the data in each block reflects the contents of the block when the query began. The database rolls back changes to the block as needed to reconstruct the block to the point in time the query started processing.</p>
<p>The database uses a mechanism called an <a id="sthref1145"></a><a href="glossary.htm#CHDBFAEG"><span class="xrefglossterm">SCN</span></a> to guarantee the order of transactions. As the <code dir="ltr">SELECT</code> statement enters the execution phase, the database determines the SCN recorded at the time the query began executing. In <a href="#BABFDBAJ">Figure 9-1</a>, this SCN is 10023. The query only sees committed data with respect to SCN 10023.</p>
<p>In <a href="#BABFDBAJ">Figure 9-1</a>, blocks with SCNs <span class="italic">after</span> 10023 indicate changed data, as shown by the two blocks with SCN 10024. The <code dir="ltr">SELECT</code> statement requires a version of the block that is consistent with committed changes. The database copies current data blocks to a new buffer and applies undo data to reconstruct previous versions of the blocks. These reconstructed data blocks are called<a id="sthref1146"></a><a id="sthref1147"></a> <span class="bold">consistent read (CR) clones</span>.</p>
<p>In <a href="#BABFDBAJ">Figure 9-1</a>, the database creates two CR clones: one block consistent to SCN 10006 and the other block consistent to SCN 10021. The database returns the reconstructed data for the query. In this way, Oracle Database prevents dirty reads.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="memory.htm#i10221">"Database Buffer Cache"</a> and <a href="transact.htm#CHDIAFFH">"System Change Numbers (SCNs)"</a></div>
</div>
<!-- class="sect4" -->
<div id="CNCPT88965" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1148"></a>
<h5 class="sect4">Read Consistency and Transaction Tables</h5>
<p>The database uses information in the <a href="glossary.htm#CHDFIFBE"><span class="xrefglossterm">block header</span></a>, also called an <a href="glossary.htm#BGBFFCAA"><span class="xrefglossterm">interested transaction list (ITL)</span></a><a id="sthref1149"></a><a id="sthref1150"></a>, to determine whether a transaction was uncommitted when the database began modifying the block. The block header of every segment block contains an ITL.</p>
<p>Entries in the ITL describe which transactions have rows locked and which rows in the block contain committed and uncommitted changes. The ITL points to the transaction table in the undo segment, which provides information about the timing of changes made to the database.</p>
<p>In a sense, the block header contains a recent history of transactions that affected each row in the block. The <code dir="ltr">INITRANS</code> parameter of the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> and <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statements controls the amount of <a id="sthref1151"></a>transaction history that is kept.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF54481" href="../../server.112/e41084/statements_7002.htm#SQLRF54481"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code dir="ltr">INITRANS</code> parameter</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i5338"></a>
<div id="CNCPT1313" class="sect2">
<h3 class="sect2">Locking Mechanisms</h3>
<p><a id="sthref1152"></a><a id="sthref1153"></a><a id="sthref1154"></a>In general, multiuser databases use some form of data locking to solve the problems associated with data concurrency, consistency, and integrity. <span class="bold">Locks</span> are mechanisms that prevent destructive interaction between transactions accessing the same resource.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i5704">"Overview of the Oracle Database Locking Mechanism"</a></div>
</div>
<!-- class="sect2" -->
<a id="CIHJADHG"></a>
<div id="CNCPT1312" class="sect2">
<h3 class="sect2">ANSI/ISO Transaction Isolation Levels</h3>
<p><a id="sthref1155"></a><a id="sthref1156"></a><a id="sthref1157"></a><a id="sthref1158"></a>The SQL standard, which has been adopted by both ANSI and ISO/IEC, defines four levels of <span class="bold">transaction isolation</span>. These levels have differing degrees of impact on transaction processing throughput.</p>
<p>These isolation levels are defined in terms of phenomena that must be prevented between concurrently executing transactions. The preventable phenomena are:</p>
<ul>
<li>
<p><a id="sthref1159"></a><a id="sthref1160"></a>Dirty reads</p>
<p>A transaction reads data that has been written by another transaction that has not been committed yet.</p>
</li>
<li>
<p><a id="sthref1161"></a><a id="sthref1162"></a>Nonrepeatable (fuzzy) reads</p>
<p>A transaction rereads data it has previously read and finds that another committed transaction has modified or deleted the data. For example, a user queries a row and then later queries the same row, only to discover that the data has changed.</p>
</li>
<li>
<p><a id="sthref1163"></a><a id="sthref1164"></a>Phantom reads</p>
<p>A transaction reruns a <a href="glossary.htm#CHDGABIG"><span class="xrefglossterm">query</span></a> returning a set of rows that satisfies a search condition and finds that another committed transaction has inserted additional rows that satisfy the condition.</p>
<p>For example, a transaction queries the number of employees. Five minutes later it performs the same query, but now the number has increased by one because another user inserted a record for a new hire. More data satisfies the query criteria than before, but unlike in a fuzzy read the previously read data is unchanged.</p>
</li>
</ul>
<p><a id="sthref1165"></a><a id="sthref1166"></a>The SQL standard defines four levels of isolation in terms of the phenomena that a transaction running at a particular isolation level is permitted to experience. <a href="#g35628">Table 9-1</a> shows the levels.</p>
<div id="CNCPT88966" class="tblformal">
<p class="titleintable"><a id="sthref1167"></a><a id="g35628"></a>Table 9-1 Preventable Read Phenomena by Isolation Level</p>
<table class="cellalignment1458" title="Preventable Read Phenomena by Isolation Level" summary="Preventable Phenomena by Isolation Level" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t9"><span class="bold">Isolation Level</span></th>
<th class="cellalignment1459" id="r1c2-t9">Dirty Read</th>
<th class="cellalignment1459" id="r1c3-t9">Nonrepeatable Read</th>
<th class="cellalignment1459" id="r1c4-t9">Phantom Read</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t9" headers="r1c1-t9">
<p><a id="sthref1168"></a>Read uncommitted</p>
</td>
<td class="cellalignment1455" headers="r2c1-t9 r1c2-t9">
<p>Possible</p>
</td>
<td class="cellalignment1455" headers="r2c1-t9 r1c3-t9">
<p>Possible</p>
</td>
<td class="cellalignment1455" headers="r2c1-t9 r1c4-t9">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t9" headers="r1c1-t9">
<p>Read committed</p>
</td>
<td class="cellalignment1455" headers="r3c1-t9 r1c2-t9">
<p>Not possible</p>
</td>
<td class="cellalignment1455" headers="r3c1-t9 r1c3-t9">
<p>Possible</p>
</td>
<td class="cellalignment1455" headers="r3c1-t9 r1c4-t9">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r4c1-t9" headers="r1c1-t9">
<p>Repeatable read</p>
</td>
<td class="cellalignment1455" headers="r4c1-t9 r1c2-t9">
<p>Not possible</p>
</td>
<td class="cellalignment1455" headers="r4c1-t9 r1c3-t9">
<p>Not possible</p>
</td>
<td class="cellalignment1455" headers="r4c1-t9 r1c4-t9">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r5c1-t9" headers="r1c1-t9">
<p>Serializable</p>
</td>
<td class="cellalignment1455" headers="r5c1-t9 r1c2-t9">
<p>Not possible</p>
</td>
<td class="cellalignment1455" headers="r5c1-t9 r1c3-t9">
<p>Not possible</p>
</td>
<td class="cellalignment1455" headers="r5c1-t9 r1c4-t9">
<p>Not possible</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Oracle Database offers the read committed (default) and serializable isolation levels. Also, the database offers a read-only mode.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BABEAFAH">"Overview of Oracle Database Transaction Isolation Levels"</a> to learn about read committed, serializable, and read-only isolation levels</p>
</li>
<li>
<p><a class="olink SQLRF019" href="../../server.112/e41084/ap_standard_sql.htm#SQLRF019"><span class="italic">Oracle Database SQL Language Reference</span></a> for a discussion of Oracle Database conformance to SQL standards</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABEAFAH"></a>
<div id="CNCPT621" class="sect1">
<h2 class="sect1">Overview of Oracle Database Transaction Isolation Levels</h2>
<p><a href="#g35628">Table 9-1</a> summarizes the ANSI standard for transaction isolation levels. The standard is defined in terms of the phenomena that are either permitted or prevented for each isolation level. Oracle Database provides the transaction isolation levels:</p>
<ul>
<li>
<p><a href="#BABEIHGJ">Read Committed Isolation Level</a></p>
</li>
<li>
<p><a href="#BABCJIDI">Serializable Isolation Level</a></p>
</li>
<li>
<p><a href="#BABGEGBC">Read-Only Isolation Level</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS99999" href="../../appdev.112/e41502/adfns_sqlproc.htm#ADFNS99999"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> to learn more about transaction isolation levels</p>
</li>
<li>
<p><a class="olink SQLRF55422" href="../../server.112/e41084/statements_10005.htm#SQLRF55422"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a class="olink LNPLS00608" href="../../appdev.112/e25519/static.htm#LNPLS00608"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> to learn about <code dir="ltr">SET TRANSACTION ISOLATION LEVEL</code></p>
</li>
</ul>
</div>
<a id="BABEIHGJ"></a>
<div id="CNCPT1319" class="sect2">
<h3 class="sect2">Read Committed Isolation Level</h3>
<p><a id="sthref1169"></a><a id="sthref1170"></a>In the <span class="bold">read committed isolation level</span>, which is the default, every query executed by a transaction sees only data committed before the query&mdash;not the transaction&mdash;began. This level of isolation is appropriate for database environments in which few transactions are likely to conflict.</p>
<p>A query in a read committed transaction avoids reading data that commits while the query is in progress. For example, if a query is halfway through a scan of a million-row table, and if a different transaction commits an update to row 950,000, then the query does not see this change when it reads row 950,000. However, because the database does not prevent other transactions from modifying data read by a query, other transactions may change data <span class="italic">between</span> query executions. Thus, a transaction that runs the same query twice may experience fuzzy reads and phantoms.</p>
<a id="BABHFAIJ"></a>
<div id="CNCPT050" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Read Consistency in the Read Committed Isolation Level</h4>
<p><a id="sthref1171"></a>A consistent result set is provided for every query, guaranteeing data consistency, with no action by the user. <a id="sthref1172"></a>An <a href="glossary.htm#CHDFBHGG"><span class="xrefglossterm">implicit query</span></a>, such as a query implied by a <code dir="ltr">WHERE</code> clause in an <code dir="ltr">UPDATE</code> statement, is guaranteed a consistent set of results. However, each statement in an implicit query does not see the changes made by the DML statement itself, but sees the data as it existed before changes were made.</p>
<p>If a <code dir="ltr">SELECT</code> list contains a PL/SQL function, then the database applies statement-level read consistency at the statement level for SQL run within the PL/SQL function code, rather than at the parent SQL level. For example, a function could access a table whose data is changed and committed by another user. For each execution of the <code dir="ltr">SELECT</code> in the function, a new read-consistent snapshot is established.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="sqllangu.htm#CHDFDJCH">"Subqueries and Implicit Queries"</a></div>
</div>
<!-- class="sect3" -->
<div id="CNCPT051" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1173"></a>
<h4 class="sect3">Conflicting Writes in Read Committed Transactions</h4>
<p>In a read committed transaction, <a id="sthref1174"></a><a id="sthref1175"></a><a id="sthref1176"></a>a <span class="bold">conflicting write</span> occurs when the transaction attempts to change a row updated by an uncommitted concurrent transaction, sometimes called <a id="sthref1177"></a><a id="sthref1178"></a>a <span class="bold">blocking transaction</span>. The read committed transaction waits for the blocking transaction to end and release its row lock. The options are as follows:</p>
<ul>
<li>
<p>If the blocking transaction rolls back, then the waiting transaction proceeds to change the previously locked row as if the other transaction never existed.</p>
</li>
<li>
<p>If the blocking transaction commits and releases its locks, then the waiting transaction proceeds with its intended update to the newly changed row.</p>
</li>
</ul>
<p><a href="#BABGEACA">Table 9-2</a> shows how transaction 1, which can be either serializable or read committed, interacts with read committed transaction 2. <a href="#BABGEACA">Table 9-2</a> shows a classic situation known as <a id="sthref1179"></a><a id="sthref1180"></a>a <span class="bold">lost update</span> (see <a href="#CIHFGFEJ">"Use of Locks"</a>). The update made by transaction 1 is not in the table <span class="italic">even though transaction 1 committed it</span>. Devising a strategy to handle lost updates is an important part of application development.</p>
<div id="CNCPT88967" class="tblruleformalwidemax">
<p class="titleintable"><a id="sthref1181"></a><a id="BABGEACA"></a>Table 9-2 Conflicting Writes and Lost Updates in a READ COMMITTED Transaction</p>
<table class="cellalignment1460" title="Conflicting Writes and Lost Updates in a READ COMMITTED Transaction" summary="Read committed transaction" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t13">Session 1</th>
<th class="cellalignment1459" id="r1c2-t13">Session 2</th>
<th class="cellalignment1459" id="r1c3-t13">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t13" headers="r1c1-t13">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name
IN ('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               6200
Greene              9500
</pre></td>
<td class="cellalignment1455" headers="r2c1-t13 r1c2-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r2c1-t13 r1c3-t13">
<p>Session 1 queries the salaries for Banda, Greene, and Hintz. No employee named Hintz is found.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t13" headers="r1c1-t13">
<pre dir="ltr">
SQL&gt; UPDATE employees SET salary
= 7000 WHERE last_name = 'Banda';
</pre></td>
<td class="cellalignment1455" headers="r3c1-t13 r1c2-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r3c1-t13 r1c3-t13">
<p>Session 1 begins a transaction by updating the Banda salary. The default isolation level for transaction 1 is <code dir="ltr">READ COMMITTED</code>.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r4c1-t13" headers="r1c1-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r4c1-t13 r1c2-t13">
<pre dir="ltr">
SQL&gt; SET TRANSACTION ISOLATION
LEVEL READ COMMITTED;
</pre></td>
<td class="cellalignment1455" headers="r4c1-t13 r1c3-t13">
<p>Session 2 begins transaction 2 and sets the isolation level explicitly to <code dir="ltr">READ COMMITTED</code>.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r5c1-t13" headers="r1c1-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r5c1-t13 r1c2-t13">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name IN
('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               6200
Greene              9500
</pre></td>
<td class="cellalignment1455" headers="r5c1-t13 r1c3-t13">
<p>Transaction 2 queries the salaries for Banda, Greene, and Hintz. Oracle Database uses read consistency to show the salary for Banda before the uncommitted update made by transaction 1.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r6c1-t13" headers="r1c1-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r6c1-t13 r1c2-t13">
<pre dir="ltr">
SQL&gt; UPDATE employees SET salary =
9900 WHERE last_name = 'Greene';
</pre></td>
<td class="cellalignment1455" headers="r6c1-t13 r1c3-t13">
<p>Transaction 2 updates the salary for Greene successfully because transaction 1 locked only the Banda row (see <a href="#BABIGJBI">"Row Locks (TX)"</a>).</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r7c1-t13" headers="r1c1-t13">
<pre dir="ltr">
SQL&gt; INSERT INTO employees
(employee_id, last_name, email,
hire_date, job_id) VALUES (210,
'Hintz', 'JHINTZ', SYSDATE,
'SH_CLERK');
</pre></td>
<td class="cellalignment1455" headers="r7c1-t13 r1c2-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r7c1-t13 r1c3-t13">
<p>Transaction 1 inserts a row for employee Hintz, but does not commit.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r8c1-t13" headers="r1c1-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r8c1-t13 r1c2-t13">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name IN 
('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               6200
Greene              9900
</pre></td>
<td class="cellalignment1455" headers="r8c1-t13 r1c3-t13">
<p>Transaction 2 queries the salaries for employees Banda, Greene, and Hintz.</p>
<p>Transaction 2 sees its own update to the salary for Greene. Transaction 2 does not see the uncommitted update to the salary for Banda or the insertion for Hintz made by transaction 1.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r9c1-t13" headers="r1c1-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r9c1-t13 r1c2-t13">
<pre dir="ltr">
SQL&gt; UPDATE employees SET salary =
6300 WHERE last_name = 'Banda';

-- prompt does not return 
</pre></td>
<td class="cellalignment1455" headers="r9c1-t13 r1c3-t13">
<p>Transaction 2 attempts to update the row for Banda, which is currently locked by transaction 1, creating a conflicting write. Transaction 2 waits until transaction 1 ends.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r10c1-t13" headers="r1c1-t13">
<pre dir="ltr">
SQL&gt; COMMIT;
</pre></td>
<td class="cellalignment1455" headers="r10c1-t13 r1c2-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r10c1-t13 r1c3-t13">
<p>Transaction 1 commits its work, ending the transaction.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r11c1-t13" headers="r1c1-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r11c1-t13 r1c2-t13">
<pre dir="ltr">
1 row updated.
 
SQL&gt;
</pre></td>
<td class="cellalignment1455" headers="r11c1-t13 r1c3-t13">
<p>The lock on the Banda row is now released, so transaction 2 proceeds with its update to the salary for Banda.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r12c1-t13" headers="r1c1-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r12c1-t13 r1c2-t13">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name IN
('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               6300
Greene              9900
Hintz
</pre></td>
<td class="cellalignment1455" headers="r12c1-t13 r1c3-t13">
<p>Transaction 2 queries the salaries for employees Banda, Greene, and Hintz. The Hintz insert committed by transaction 1 is now visible to transaction 2. Transaction 2 sees its own update to the Banda salary.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r13c1-t13" headers="r1c1-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r13c1-t13 r1c2-t13">
<pre dir="ltr">
COMMIT;
</pre></td>
<td class="cellalignment1455" headers="r13c1-t13 r1c3-t13">
<p>Transaction 2 commits its work, ending the transaction.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r14c1-t13" headers="r1c1-t13">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name
IN ('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               6300
Greene              9900
Hintz
</pre></td>
<td class="cellalignment1455" headers="r14c1-t13 r1c2-t13">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r14c1-t13 r1c3-t13">
<p>Session 1 queries the rows for Banda, Greene, and Hintz. The salary for Banda is 6300, which is the update made by transaction 2. The update of Banda's salary to 7000 made by transaction 1 is now "lost."</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwidemax" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABCJIDI"></a>
<div id="CNCPT1320" class="sect2">
<h3 class="sect2">Serializable Isolation Level</h3>
<p><a id="sthref1182"></a><a id="sthref1183"></a><a id="sthref1184"></a><a id="sthref1185"></a>In the <span class="bold">serialization isolation level</span>, a transaction sees only changes committed at the time the transaction&mdash;not the query&mdash;began and changes made by the transaction itself. A serializable transaction operates in an environment that makes it appear as if no other users were modifying data in the database.</p>
<p>Serializable isolation is suitable for environments:</p>
<ul>
<li>
<p>With large databases and short transactions that update only a few rows</p>
</li>
<li>
<p>Where the chance that two concurrent transactions will modify the same rows is relatively low</p>
</li>
<li>
<p>Where relatively long-running transactions are primarily read only</p>
</li>
</ul>
<p>In serializable isolation, the read consistency normally obtained at the statement level extends to the entire transaction. Any row read by the transaction is assured to be the same when reread. Any query is guaranteed to return the same results for the duration of the transaction, so changes made by other transactions are not visible to the query regardless of how long it has been running. Serializable transactions do not experience dirty reads, fuzzy reads, or phantom reads.</p>
<p>Oracle Database permits a serializable transaction to modify a row only if changes to the row made by other transactions were <span class="italic">already</span> committed when the serializable transaction began. The database generates an error when a serializable transaction tries to update or delete data changed by a different transaction that committed <span class="italic">after</span> the serializable transaction began:</p>
<pre dir="ltr">
ORA-08177: Cannot serialize access for this transaction
</pre>
<p>When a serializable transaction fails with the <code dir="ltr">ORA-08177</code> error, an application can take several actions, including the following:</p>
<ul>
<li>
<p>Commit the work executed to that point</p>
</li>
<li>
<p>Execute additional (but different) statements, perhaps after rolling back to a <a href="glossary.htm#CHDHJFJE"><span class="xrefglossterm">savepoint</span></a> established earlier in the transaction</p>
</li>
<li>
<p>Roll back the entire transaction</p>
</li>
</ul>
<p><a href="#BABDGDII">Table 9-3</a> shows how a serializable transaction interacts with other transactions. If the serializable transaction does not try to change a row committed by another transaction after the serializable transaction began, then a <span class="bold">serialized access problem</span> is avoided.</p>
<div id="CNCPT88968" class="tblruleformalwidemax">
<p class="titleintable"><a id="sthref1186"></a><a id="BABDGDII"></a>Table 9-3 Serializable Transaction</p>
<table class="cellalignment1460" title="Serializable Transaction" summary="Read committed transaction" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t14">Session 1</th>
<th class="cellalignment1459" id="r1c2-t14">Session 2</th>
<th class="cellalignment1459" id="r1c3-t14">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t14" headers="r1c1-t14">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name 
IN ('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               6200
Greene              9500
</pre></td>
<td class="cellalignment1455" headers="r2c1-t14 r1c2-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r2c1-t14 r1c3-t14">
<p>Session 1 queries the salaries for Banda, Greene, and Hintz. No employee named Hintz is found.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t14" headers="r1c1-t14">
<pre dir="ltr">
SQL&gt; UPDATE employees SET salary
= 7000 WHERE last_name = 'Banda';
</pre></td>
<td class="cellalignment1455" headers="r3c1-t14 r1c2-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r3c1-t14 r1c3-t14">
<p>Session 1 begins transaction 1 by updating the Banda salary. The default isolation level for is <code dir="ltr">READ COMMITTED</code>.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r4c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r4c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; SET TRANSACTION ISOLATION
LEVEL SERIALIZABLE;
</pre></td>
<td class="cellalignment1455" headers="r4c1-t14 r1c3-t14">
<p>Session 2 begins transaction 2 and sets it to the <code dir="ltr">SERIALIZABLE</code> isolation level.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r5c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r5c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name 
IN ('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               6200
Greene              9500
</pre></td>
<td class="cellalignment1455" headers="r5c1-t14 r1c3-t14">
<p>Transaction 2 queries the salaries for Banda, Greene, and Hintz. Oracle Database uses read consistency to show the salary for Banda <span class="italic">before</span> the uncommitted update made by transaction 1.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r6c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r6c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; UPDATE employees SET salary =
9900 WHERE last_name = 'Greene';
</pre></td>
<td class="cellalignment1455" headers="r6c1-t14 r1c3-t14">
<p>Transaction 2 updates the Greene salary successfully because only the Banda row is locked.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r7c1-t14" headers="r1c1-t14">
<pre dir="ltr">
SQL&gt; INSERT INTO employees
(employee_id, last_name, email,
hire_date, job_id) VALUES (210,
'Hintz', 'JHINTZ', SYSDATE,
'SH_CLERK');
</pre></td>
<td class="cellalignment1455" headers="r7c1-t14 r1c2-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r7c1-t14 r1c3-t14">
<p>Transaction 1 inserts a row for employee Hintz.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r8c1-t14" headers="r1c1-t14">
<pre dir="ltr">
SQL&gt; COMMIT;
</pre></td>
<td class="cellalignment1455" headers="r8c1-t14 r1c2-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r8c1-t14 r1c3-t14">
<p>Transaction 1 commits its work, ending the transaction.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r9c1-t14" headers="r1c1-t14">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name 
IN ('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               7000
Greene              9500
Hintz
</pre></td>
<td class="cellalignment1455" headers="r9c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name IN
('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               6200
Greene              9900
</pre></td>
<td class="cellalignment1455" headers="r9c1-t14 r1c3-t14">
<p>Session 1 queries the salaries for employees Banda, Greene, and Hintz and sees changes committed by transaction 1. Session 1 does not see the uncommitted Greene update made by transaction 2.</p>
<p>Transaction 2 queries the salaries for employees Banda, Greene, and Hintz. Oracle Database read consistency ensures that the Hintz insert and Banda update committed by transaction 1 are <span class="italic">not</span> visible to transaction 2. Transaction 2 sees its own update to the Banda salary.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r10c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r10c1-t14 r1c2-t14">
<pre dir="ltr">
COMMIT;
</pre></td>
<td class="cellalignment1455" headers="r10c1-t14 r1c3-t14">
<p>Transaction 2 commits its work, ending the transaction.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r11c1-t14" headers="r1c1-t14">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary
FROM employees WHERE last_name
IN ('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               7000
Greene              9900
Hintz
</pre></td>
<td class="cellalignment1455" headers="r11c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary 
FROM employees WHERE last_name 
IN ('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               7000
Greene              9900
Hintz
</pre></td>
<td class="cellalignment1455" headers="r11c1-t14 r1c3-t14">
<p>Both sessions query the salaries for Banda, Greene, and Hintz. Each session sees all committed changes made by transaction 1 and transaction 2.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r12c1-t14" headers="r1c1-t14">
<pre dir="ltr">
SQL&gt; UPDATE employees SET salary
= 7100 WHERE last_name = 'Hintz';
</pre></td>
<td class="cellalignment1455" headers="r12c1-t14 r1c2-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r12c1-t14 r1c3-t14">
<p>Session 1 begins transaction 3 by updating the Hintz salary. The default isolation level for transaction 3 is <code dir="ltr">READ COMMITTED</code>.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r13c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r13c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; SET TRANSACTION ISOLATION
LEVEL SERIALIZABLE;
</pre></td>
<td class="cellalignment1455" headers="r13c1-t14 r1c3-t14">
<p>Session 2 begins transaction 4 and sets it to the <code dir="ltr">SERIALIZABLE</code> isolation level.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r14c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r14c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; UPDATE employees SET salary =
7200 WHERE last_name = 'Hintz';

-- prompt does not return
</pre></td>
<td class="cellalignment1455" headers="r14c1-t14 r1c3-t14">
<p>Transaction 4 attempts to update the salary for Hintz, but is blocked because transaction 3 locked the Hintz row (see <a href="#BABIGJBI">"Row Locks (TX)"</a>). Transaction 4 queues behind transaction 3.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r15c1-t14" headers="r1c1-t14">
<pre dir="ltr">
SQL&gt; COMMIT;
</pre></td>
<td class="cellalignment1455" headers="r15c1-t14 r1c2-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r15c1-t14 r1c3-t14">
<p>Transaction 3 commits its update of the Hintz salary, ending the transaction.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r16c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r16c1-t14 r1c2-t14">
<pre dir="ltr">
UPDATE employees SET salary = 7200
WHERE last_name = 'Hintz'
*
ERROR at line 1:
ORA-08177: can't serialize access
for this transaction
</pre></td>
<td class="cellalignment1455" headers="r16c1-t14 r1c3-t14">
<p>The commit that ends transaction 3 causes the Hintz update in transaction 4 to fail with the <code dir="ltr">ORA-08177</code> error. The problem error occurs because transaction 3 committed the Hintz update <span class="italic">after</span> transaction 4 began.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r17c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r17c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; ROLLBACK;
</pre></td>
<td class="cellalignment1455" headers="r17c1-t14 r1c3-t14">
<p>Session 2 rolls back transaction 4, which ends the transaction.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r18c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r18c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; SET TRANSACTION ISOLATION
LEVEL SERIALIZABLE;
</pre></td>
<td class="cellalignment1455" headers="r18c1-t14 r1c3-t14">
<p>Session 2 begins transaction 5 and sets it to the <code dir="ltr">SERIALIZABLE</code> isolation level.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r19c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r19c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; SELECT last_name, salary 
FROM employees WHERE last_name 
IN ('Banda','Greene','Hintz');
 
LAST_NAME         SALARY
------------- ----------
Banda               7100
Greene              9500
Hintz               7100
</pre></td>
<td class="cellalignment1455" headers="r19c1-t14 r1c3-t14">
<p>Transaction 5 queries the salaries for Banda, Greene, and Hintz. The Hintz salary update committed by transaction 3 is visible.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r20c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r20c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; UPDATE employees SET salary =
7200 WHERE last_name = 'Hintz';

1 row updated.
</pre></td>
<td class="cellalignment1455" headers="r20c1-t14 r1c3-t14">
<p>Transaction 5 updates the Hintz salary to a different value. Because the Hintz update made by transaction 3 committed <span class="italic">before</span> the start of transaction 5, the serialized access problem is avoided.</p>
<p><span class="bold">Note:</span> If a different transaction updated and committed the Hintz row after transaction transaction 5 began, then the serialized access problem would occur again.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r21c1-t14" headers="r1c1-t14">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r21c1-t14 r1c2-t14">
<pre dir="ltr">
SQL&gt; COMMIT;
</pre></td>
<td class="cellalignment1455" headers="r21c1-t14 r1c3-t14">
<p>Session 2 commits the update without any problems, ending the transaction.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwidemax" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transact.htm#i8072">"Overview of Transaction Control"</a></div>
</div>
<!-- class="sect2" -->
<a id="BABGEGBC"></a>
<div id="CNCPT88969" class="sect2">
<h3 class="sect2">Read-Only Isolation Level</h3>
<p><a id="sthref1187"></a><a id="sthref1188"></a><a id="sthref1189"></a><a id="sthref1190"></a>The <span class="bold">read-only isolation</span> level is similar to the serializable isolation level, but read-only transactions do not permit data to be modified in the transaction unless the user is <code dir="ltr">SYS</code>. Thus, read-only transactions are not susceptible to the <code dir="ltr">ORA-08177</code> error. Read-only transactions are useful for generating reports in which the contents must be consistent with respect to the time when the transaction began.</p>
<p>Oracle Database achieves read consistency by reconstructing data as needed from the undo segments. Because undo segments are used in a circular fashion, the database can overwrite undo data. Long-running reports run the risk that undo data required for read consistency may have been reused by a different transaction, raising a <code dir="ltr">snapshot too old</code> error. <a id="sthref1191"></a>Setting an <span class="bold">undo retention period</span>, which is the minimum amount of time that the database attempts to retain old undo data before overwriting it, appropriately avoids this problem.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="logical.htm#CHDGJJEJ">"Undo Segments"</a></p>
</li>
<li>
<p><a class="olink ADMIN11465" href="../../server.112/e25494/undo.htm#ADMIN11465"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to set the undo retention period</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5704"></a>
<div id="CNCPT1331" class="sect1">
<h2 class="sect1">Overview of the Oracle Database Locking Mechanism</h2>
<p>A <span class="bold">lock</span> is a mechanism that prevents <span class="bold">destructive interactions</span>, which are interactions that incorrectly update data or incorrectly alter underlying data structures, between transactions accessing shared data. Locks play a crucial role in maintaining database concurrency and consistency.</p>
<a id="BABHIGGC"></a>
<div id="CNCPT88970" class="sect2">
<h3 class="sect2">Summary of Locking Behavior</h3>
<p>The database maintains several different types of locks, depending on the operation that acquired the lock. In general, the database uses two types of locks: <span class="bold">exclusive locks</span> and <span class="bold">share locks</span>. Only one exclusive lock can be obtained on a resource such as a row or a table, but many share locks can be obtained on a single resource.</p>
<p>Locks affect the interaction of readers and writers. A <span class="bold">reader</span> is a query of a resource, whereas a <span class="bold">writer</span> is a statement modifying a resource. The following rules summarize the locking behavior of Oracle Database for readers and writers:</p>
<ul>
<li>
<p>A row is locked only when modified by a writer.</p>
<p>When a statement updates one row, the transaction acquires a lock for this row only. By locking table data at the row level, the database minimizes contention for the same data. Under normal circumstances<a id="sthref1192" href="#sthref1192" onclick='footdisplay(1,"When processing a distributed two-phase commit, the database may briefly prevent read access in special circumstances. Specifically, if a query starts between the prepare and commit phases and attempts to read the data before the commit, then the database may escalate a lock from row-level to block-level to guarantee read consistency.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a> the database does not escalate a row lock to the block or table level.</p>
</li>
<li>
<p>A writer of a row blocks a concurrent writer of the same row.</p>
<p>If one transaction is modifying a row, then a row lock prevents a different transaction from modifying the same row simultaneously.</p>
</li>
<li>
<p>A reader never blocks a writer.</p>
<p>Because a reader of a row does not lock it, a writer can modify this row. The only exception is a <code dir="ltr">SELECT ... FOR UPDATE</code> statement, which is a special type of <code dir="ltr">SELECT</code> statement that <span class="italic">does</span> lock the row that it is reading.</p>
</li>
<li>
<p>A writer never blocks a reader.</p>
<p>When a row is being changed by a writer, the database uses <a href="glossary.htm#CHDDFBFI"><span class="xrefglossterm">undo data</span></a> data to provide readers with a consistent view of the row.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Readers of data may have to wait for writers of the same data blocks in very special cases of pending <a href="glossary.htm#CHDDCCEC"><span class="xrefglossterm">distributed transactions</span></a>.</div>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF55370" href="../../server.112/e41084/statements_10002.htm#SQLRF55370"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about <code dir="ltr">SELECT ... FOR UPDATE</code></p>
</li>
<li>
<p><a class="olink ADMIN12233" href="../../server.112/e25494/ds_txns.htm#ADMIN12233"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn about waits associated with in-doubt distributed transactions</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHFGFEJ"></a>
<div id="CNCPT1332" class="sect2">
<h3 class="sect2">Use of Locks</h3>
<p>In a single-user database, locks are not necessary because only one user is modifying information. However, when multiple users are accessing and modifying data, the database must provide a way to prevent concurrent modification of the same data. Locks achieve the following important database requirements:</p>
<ul>
<li>
<p>Consistency</p>
<p>The data a session is viewing or changing must not be changed by other sessions until the user is finished.</p>
</li>
<li>
<p>Integrity</p>
<p>The data and structures must reflect all changes made to them in the correct sequence.</p>
</li>
</ul>
<p>Oracle Database provides data concurrency, consistency, and integrity among transactions through its locking mechanisms.<a id="sthref1193"></a><a id="sthref1194"></a> Locking is performed automatically and requires no user action.</p>
<p>The need for locks can be illustrated by a concurrent update of a single row. In the following example, a simple web-based application presents the end user with an employee email and phone number. The application uses an <code dir="ltr">UPDATE</code> statement such as the following to modify the data:</p>
<pre dir="ltr">
UPDATE employees
SET    email = ?, phone_number = ?
WHERE  employee_id = ?
AND    email = ?
AND    phone_number = ?
</pre>
<p>In the preceding <code dir="ltr">UPDATE</code> statement, the email and phone number values in the <code dir="ltr">WHERE</code> clause are the original, unmodified values for the specified employee. This update ensures that the row that the application modifies was not changed after the application last read and displayed it to the user. In this way, the application avoids the <a href="glossary.htm#CHDBBEGJ"><span class="xrefglossterm">lost update</span></a> database problem in which one user overwrites changes made by another user, effectively losing the update by the second user (<a href="#BABGEACA">Table 9-2</a> shows an example of a lost update).</p>
<p><a href="#BABGADIC">Table 9-4</a> shows the sequence of events when two sessions attempt to modify the same row in the <code dir="ltr">employees</code> table at roughly the same time.</p>
<div id="CNCPT88971" class="tblruleformalwidemax">
<p class="titleintable"><a id="sthref1195"></a><a id="BABGADIC"></a>Table 9-4 Row Locking Example</p>
<table class="cellalignment1460" title="Row Locking Example" summary="Example of three concurrent transactions" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t19">Time</th>
<th class="cellalignment1459" id="r1c2-t19">Session 1</th>
<th class="cellalignment1459" id="r1c3-t19">Session 2</th>
<th class="cellalignment1459" id="r1c4-t19">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t19" headers="r1c1-t19">
<p>t0</p>
</td>
<td class="cellalignment1455" headers="r2c1-t19 r1c2-t19">
<pre dir="ltr">
SELECT employee_id, email, 
       phone_number 
FROM   hr.employees 
WHERE  last_name = 'Himuro';

EMPLOYEE_ID EMAIL   PHONE_NUMBER
----------- ------- ------------
        118 GHIMURO 515.127.4565
</pre></td>
<td class="cellalignment1455" headers="r2c1-t19 r1c3-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r2c1-t19 r1c4-t19">
<p>In session 1, the <code dir="ltr">hr1</code> user queries <code dir="ltr">hr.employees</code> for the Himuro record and displays the employee_id (<code dir="ltr">118</code>), email (<code dir="ltr">GHIMURO</code>), and phone number (<code dir="ltr">515.127.4565</code>) attributes.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t19" headers="r1c1-t19">
<p>t1</p>
</td>
<td class="cellalignment1455" headers="r3c1-t19 r1c2-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r3c1-t19 r1c3-t19">
<pre dir="ltr">
SELECT employee_id, email, 
       phone_number 
FROM   hr.employees 
WHERE  last_name = 'Himuro';

EMPLOYEE_ID EMAIL   PHONE_NUMBER
----------- ------- ------------
        118 GHIMURO 515.127.4565
</pre></td>
<td class="cellalignment1455" headers="r3c1-t19 r1c4-t19">
<p>In session 2, the <code dir="ltr">hr2</code> user queries <code dir="ltr">hr.employees</code> for the Himuro record and displays the employee_id (<code dir="ltr">118</code>), email (<code dir="ltr">GHIMURO</code>), and phone number (<code dir="ltr">515.127.4565</code>) attributes.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r4c1-t19" headers="r1c1-t19">
<p>t2</p>
</td>
<td class="cellalignment1455" headers="r4c1-t19 r1c2-t19">
<pre dir="ltr">
UPDATE hr.employees 
SET phone_number='515.555.1234' 
WHERE employee_id=118
AND email='GHIMURO'
AND phone_number='515.127.4565';

1 row updated.
</pre></td>
<td class="cellalignment1455" headers="r4c1-t19 r1c3-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r4c1-t19 r1c4-t19">
<p>In session 1, the <code dir="ltr">hr1</code> user updates the phone number in the row to <code dir="ltr">515.555.1234</code>, which acquires a lock on the <code dir="ltr">GHIMURO</code> row.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r5c1-t19" headers="r1c1-t19">
<p>t3</p>
</td>
<td class="cellalignment1455" headers="r5c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment1455" headers="r5c1-t19 r1c3-t19">
<pre dir="ltr">
UPDATE hr.employees 
SET phone_number='515.555.1235' 
WHERE employee_id=118
AND email='GHIMURO'
AND phone_number='515.127.4565';

-- SQL*Plus does not show
-- a row updated message or
-- return the prompt.
</pre></td>
<td class="cellalignment1455" headers="r5c1-t19 r1c4-t19">
<p>In session 2, the <code dir="ltr">hr2</code> user attempts to update the same row, but is blocked because <code dir="ltr">hr1</code> is currently processing the row.</p>
<p>The attempted update by <code dir="ltr">hr2</code> occurs almost simultaneously with the <code dir="ltr">hr1</code> update.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r6c1-t19" headers="r1c1-t19">
<p>t4</p>
</td>
<td class="cellalignment1455" headers="r6c1-t19 r1c2-t19">
<pre dir="ltr">
COMMIT;

Commit complete.
</pre></td>
<td class="cellalignment1455" headers="r6c1-t19 r1c3-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r6c1-t19 r1c4-t19">
<p>In session 1, the <code dir="ltr">hr1</code> user commits the transaction.</p>
<p>The commit makes the change for Himuro permanent and unblocks session 2, which has been waiting.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r7c1-t19" headers="r1c1-t19">
<p>t5</p>
</td>
<td class="cellalignment1455" headers="r7c1-t19 r1c2-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r7c1-t19 r1c3-t19">
<pre dir="ltr">
0 rows updated.
</pre></td>
<td class="cellalignment1455" headers="r7c1-t19 r1c4-t19">
<p>In session 2, the <code dir="ltr">hr2</code> user discovers that the <code dir="ltr">GHIMURO</code> row was modified in such a way that it no longer matches its predicate.</p>
<p>Because the predicates do not match, session 2 updates no records.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r8c1-t19" headers="r1c1-t19">
<p>t6</p>
</td>
<td class="cellalignment1455" headers="r8c1-t19 r1c2-t19">
<pre dir="ltr">
UPDATE hr.employees 
SET phone_number='515.555.1235' 
WHERE employee_id=118
AND email='GHIMURO'
AND phone_number='515.555.1234';

1 row updated.
</pre></td>
<td class="cellalignment1455" headers="r8c1-t19 r1c3-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r8c1-t19 r1c4-t19">
<p>In session 1, the <code dir="ltr">hr1</code> user realizes that it updated the <code dir="ltr">GHIMURO</code> row with the wrong phone number. The user starts a new transaction and updates the phone number in the row to <code dir="ltr">515.555.1235</code>, which locks the <code dir="ltr">GHIMURO</code> row.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r9c1-t19" headers="r1c1-t19">
<p>t7</p>
</td>
<td class="cellalignment1455" headers="r9c1-t19 r1c2-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r9c1-t19 r1c3-t19">
<pre dir="ltr">
SELECT employee_id, email, 
       phone_number 
FROM   hr.employees 
WHERE  last_name = 'Himuro';

EMPLOYEE_ID EMAIL   PHONE_NUMBER
----------- ------- ------------
        118 GHIMURO 515.555.1234
</pre></td>
<td class="cellalignment1455" headers="r9c1-t19 r1c4-t19">
<p>In session 2, the <code dir="ltr">hr2</code> user queries <code dir="ltr">hr.employees</code> for the Himuro record. The record shows the phone number update committed by session 1 at t4. Oracle Database read consistency ensures that session 2 does not see the uncommitted change made at t6.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r10c1-t19" headers="r1c1-t19">
<p>t8</p>
</td>
<td class="cellalignment1455" headers="r10c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment1455" headers="r10c1-t19 r1c3-t19">
<pre dir="ltr">
UPDATE hr.employees 
SET phone_number='515.555.1235' 
WHERE employee_id=118
AND email='GHIMURO'
AND phone_number='515.555.1234';

-- SQL*Plus does not show
-- a row updated message or
-- return the prompt.
</pre></td>
<td class="cellalignment1455" headers="r10c1-t19 r1c4-t19">
<p>In session 2, the <code dir="ltr">hr2</code> user attempts to update the same row, but is blocked because <code dir="ltr">hr1</code> is currently processing the row.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r11c1-t19" headers="r1c1-t19">
<p>t9</p>
</td>
<td class="cellalignment1455" headers="r11c1-t19 r1c2-t19">
<pre dir="ltr">
ROLLBACK;

Rollback complete.
</pre></td>
<td class="cellalignment1455" headers="r11c1-t19 r1c3-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r11c1-t19 r1c4-t19">
<p>In session 1, the <code dir="ltr">hr1</code> user rolls back the transaction, which ends it.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r12c1-t19" headers="r1c1-t19">
<p>t10</p>
</td>
<td class="cellalignment1455" headers="r12c1-t19 r1c2-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r12c1-t19 r1c3-t19">
<pre dir="ltr">
1 row updated.
</pre></td>
<td class="cellalignment1455" headers="r12c1-t19 r1c4-t19">
<p>In session 2, the update of the phone number succeeds because the session 1 update was rolled back. The <code dir="ltr">GHIMURO</code> row matches its predicate, so the update succeeds.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r13c1-t19" headers="r1c1-t19">
<p>t11</p>
</td>
<td class="cellalignment1455" headers="r13c1-t19 r1c2-t19">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r13c1-t19 r1c3-t19">
<pre dir="ltr">
COMMIT;

Commit complete.
</pre></td>
<td class="cellalignment1455" headers="r13c1-t19 r1c4-t19">
<p>Session 2 commits the update, ending the transaction.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwidemax" -->
<p>Oracle Database automatically obtains necessary locks when executing SQL statements. For example, before the database permits a session to modify data, the session must first lock the data. The lock gives the session exclusive control over the data so that no other transaction can modify the locked data until the lock is released.</p>
<p>Because the locking mechanisms of Oracle Database are tied closely to transaction control, application designers need only define transactions properly, and Oracle Database automatically manages locking. Users never need to lock any resource explicitly, although Oracle Database also enables users to lock data manually.</p>
<p>The following sections explain concepts that are important for understanding how Oracle Database achieves data concurrency.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS393" href="../../appdev.112/e40758/w_optlock.htm#ARPLS393"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn about the <code dir="ltr">OWA_OPT_LOCK</code> package, which contains subprograms that can help prevent lost updates</div>
</div>
<!-- class="sect2" -->
<a id="CIHDFIII"></a>
<div id="CNCPT1333" class="sect2">
<h3 class="sect2">Lock Modes</h3>
<p><a id="sthref1196"></a><a id="sthref1197"></a><a id="sthref1198"></a>Oracle Database automatically uses the lowest <a id="sthref1199"></a>applicable level of <span class="bold">restrictiveness</span> to provide the highest degree of data concurrency yet also provide fail-safe data integrity. The less restrictive the level, the more available the data is for access by other users. Conversely, the more restrictive the level, the more limited other transactions are in the types of locks that they can acquire.</p>
<p>Oracle Database uses two modes of locking in a multiuser database:</p>
<ul>
<li>
<p><a id="sthref1200"></a><a id="sthref1201"></a>Exclusive lock mode</p>
<p>This mode prevents the associated resource from being shared. A transaction obtains an exclusive lock when it modifies data. The first transaction to lock a resource exclusively is the only transaction that can alter the resource until the exclusive lock is released.</p>
</li>
<li>
<p><a id="sthref1202"></a><a id="sthref1203"></a>Share lock mode</p>
<p>This mode allows the associated resource to be shared, depending on the operations involved. Multiple users reading data can share the data, holding share locks to prevent concurrent access by a writer who needs an exclusive lock. Several transactions can acquire share locks on the same resource.</p>
</li>
</ul>
<p>Assume that a transaction uses a <code dir="ltr">SELECT ...</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement to select a single table row. The transaction acquires an exclusive row lock and a row share table lock. The row lock allows other sessions to modify any rows <span class="italic">other than</span> the locked row, while the table lock prevents sessions from altering the structure of the table. Thus, the database permits as many statements as possible to execute.</p>
</div>
<!-- class="sect2" -->
<a id="BABFAHDD"></a>
<div id="CNCPT88972" class="sect2">
<h3 class="sect2">Lock Conversion and Escalation</h3>
<p>Oracle Database performs<a id="sthref1204"></a> <span class="bold">lock conversion</span> as necessary. In lock conversion, the database automatically converts a table lock of lower restrictiveness to one of higher restrictiveness.</p>
<p>For example, suppose a transaction issues a <code dir="ltr">SELECT ...</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> for an employee and later updates the locked row. In this case, the database automatically converts the row share table lock to a row exclusive table lock. A transaction holds exclusive row locks for all rows inserted, updated, or deleted within the transaction. Because row locks are acquired at the highest degree of restrictiveness, no lock conversion is required or performed.</p>
<p>Lock conversion is different from <span class="bold"><a id="sthref1205"></a><a id="sthref1206"></a>lock escalation</span>, which occurs when numerous locks are held at one level of granularity (for example, rows) and a database raises the locks to a higher level of granularity (for example, table). If a user locks many rows in a table, then some databases automatically escalate the row locks to a single table. The number of locks decreases, but the restrictiveness of what is locked increases.</p>
<p><span class="italic">Oracle Database never escalates locks.</span> Lock escalation greatly increases the likelihood of deadlocks. Assume that a system is trying to escalate locks on behalf of transaction 1 but cannot because of the locks held by transaction 2. A deadlock is created if transaction 2 also requires lock escalation of the same data before it can proceed.</p>
</div>
<!-- class="sect2" -->
<a id="CIHJAGGI"></a>
<div id="CNCPT1334" class="sect2">
<h3 class="sect2">Lock Duration</h3>
<p>Oracle Database automatically releases a lock when some event occurs so that the transaction no longer requires the resource. In most cases, the database holds locks acquired by statements within a transaction for the duration of the transaction. <a id="sthref1207"></a>These locks prevent destructive interference such as dirty reads, lost updates, and destructive <a href="glossary.htm#CHDFBCII"><span class="xrefglossterm">DDL</span></a> from concurrent transactions.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A table lock taken on a child table because of an unindexed foreign key is held for the duration of the statement, not the transaction. Also, as explained in <a href="#CIHJDIDC">"Overview of User-Defined Locks"</a>, the <code dir="ltr">DBMS_LOCK</code> package enables user-defined locks to be released and allocated at will and even held over transaction boundaries.</div>
<p>Oracle Database releases all locks acquired by the statements within a transaction when it commits or rolls back. Oracle Database also releases locks acquired after a <a href="glossary.htm#CHDHJFJE"><span class="xrefglossterm">savepoint</span></a> when rolling back to the savepoint. However, only transactions not waiting for the previously locked resources can acquire locks on the now available resources. Waiting transactions continue to wait until after the original transaction commits or rolls back completely (see <a href="transact.htm#CHDGIIFB">Table 10-2</a> for an example).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transact.htm#CHDGHIBB">"Rollback to Savepoint"</a></div>
</div>
<!-- class="sect2" -->
<a id="BABDDBCG"></a>
<div id="CNCPT1336" class="sect2">
<h3 class="sect2">Locks and Deadlocks</h3>
<p><a id="sthref1208"></a><a id="sthref1209"></a><a id="sthref1210"></a><a id="sthref1211"></a>A <span class="bold">deadlock</span> is a situation in which two or more users are waiting for data locked by each other. Deadlocks prevent some transactions from continuing to work.</p>
<p>Oracle Database automatically detects deadlocks and resolves them by rolling back one statement involved in the deadlock, releasing one set of the conflicting row locks. The database returns a corresponding message to the transaction that undergoes <a id="sthref1212"></a><a id="sthref1213"></a><a href="glossary.htm#CHDBCFDG"><span class="xrefglossterm">statement-level rollback</span></a>. The statement rolled back belongs to the transaction that detects the deadlock. Usually, the signalled transaction should be rolled back explicitly, but it can retry the rolled-back statement after waiting.</p>
<p><a href="#BABICGEE">Table 9-5</a> illustrates two transactions in a deadlock.</p>
<div id="CNCPT88973" class="tblruleformalwidemax">
<p class="titleintable"><a id="sthref1214"></a><a id="BABICGEE"></a>Table 9-5 Deadlocked Transactions</p>
<table class="cellalignment1460" title="Deadlocked Transactions" summary="Read committed transaction" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t23">Time</th>
<th class="cellalignment1459" id="r1c2-t23">Session 1</th>
<th class="cellalignment1459" id="r1c3-t23">Session 2</th>
<th class="cellalignment1459" id="r1c4-t23">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t23" headers="r1c1-t23">
<p>t0</p>
</td>
<td class="cellalignment1455" headers="r2c1-t23 r1c2-t23">
<pre dir="ltr">
SQL&gt; UPDATE employees 
  SET salary = salary*1.1
  WHERE employee_id = 100;

1 row updated.
</pre></td>
<td class="cellalignment1455" headers="r2c1-t23 r1c3-t23">
<pre dir="ltr">
SQL&gt; UPDATE employees
  SET  salary = salary*1.1
  WHERE employee_id = 200;

1 row updated.
</pre></td>
<td class="cellalignment1455" headers="r2c1-t23 r1c4-t23">
<p>Session 1 starts transaction 1 and updates the salary for employee 100. Session 2 starts transaction 2 and updates the salary for employee 200. No problem exists because each transaction locks only the row that it attempts to update.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t23" headers="r1c1-t23">
<p>t1</p>
</td>
<td class="cellalignment1455" headers="r3c1-t23 r1c2-t23">
<pre dir="ltr">
SQL&gt; UPDATE employees 
  SET salary = salary*1.1
  WHERE employee_id = 200;

-- prompt does not return
</pre></td>
<td class="cellalignment1455" headers="r3c1-t23 r1c3-t23">
<pre dir="ltr">
SQL&gt; UPDATE employees
   salary = salary*1.1
  WHERE employee_id = 100;

-- prompt does not return
</pre></td>
<td class="cellalignment1455" headers="r3c1-t23 r1c4-t23">
<p>Transaction 1 attempts to update the employee 200 row, which is currently locked by transaction 2. Transaction 2 attempts to update the employee 100 row, which is currently locked by transaction 1.</p>
<p>A deadlock results because neither transaction can obtain the resource it needs to proceed or terminate. No matter how long each transaction waits, the conflicting locks are held.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r4c1-t23" headers="r1c1-t23">
<p>t2</p>
</td>
<td class="cellalignment1455" headers="r4c1-t23 r1c2-t23">
<pre dir="ltr">
UPDATE employees
       *
ERROR at line 1:
ORA-00060: deadlock detected
while waiting for resource

SQL&gt;
</pre></td>
<td class="cellalignment1455" headers="r4c1-t23 r1c3-t23">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r4c1-t23 r1c4-t23">
<p>Transaction 1 signals the deadlock and rolls back the <code dir="ltr">UPDATE</code> statement issued at t1. However, the update made at t0 is not rolled back. The prompt is returned in session 1.</p>
<p><span class="bold">Note:</span> Only one session in the deadlock actually gets the deadlock error, but either session could get the error.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r5c1-t23" headers="r1c1-t23">
<p>t3</p>
</td>
<td class="cellalignment1455" headers="r5c1-t23 r1c2-t23">
<pre dir="ltr">
SQL&gt; COMMIT;

Commit complete.
</pre></td>
<td class="cellalignment1455" headers="r5c1-t23 r1c3-t23">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r5c1-t23 r1c4-t23">
<p>Session 1 commits the update made at t0, ending transaction 1. The update unsuccessfully attempted at t1 is not committed.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r6c1-t23" headers="r1c1-t23">
<p>t4</p>
</td>
<td class="cellalignment1455" headers="r6c1-t23 r1c2-t23">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r6c1-t23 r1c3-t23">
<pre dir="ltr">
1 row updated.

SQL&gt;
</pre></td>
<td class="cellalignment1455" headers="r6c1-t23 r1c4-t23">
<p>The update at t1 in transaction 2, which was being blocked by transaction 1, is executed. The prompt is returned.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r7c1-t23" headers="r1c1-t23">
<p>t5</p>
</td>
<td class="cellalignment1455" headers="r7c1-t23 r1c2-t23">
<pre dir="ltr">
</pre></td>
<td class="cellalignment1455" headers="r7c1-t23 r1c3-t23">
<pre dir="ltr">
SQL&gt; COMMIT;

Commit complete.
</pre></td>
<td class="cellalignment1455" headers="r7c1-t23 r1c4-t23">
<p>Session 2 commits the updates made at t0 and t1, which ends transaction 2.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwidemax" -->
<p>Deadlocks most often occur when transactions explicitly override the default locking of Oracle Database. Because Oracle Database does not escalate locks and does not use read locks for queries, but does use row-level (rather than page-level) locking, deadlocks occur infrequently.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i5269">"Overview of Manual Data Locks"</a></p>
</li>
<li>
<p><a class="olink ADFNS00203" href="../../appdev.112/e41502/adfns_sqlproc.htm#ADFNS00203"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> to learn how to handle deadlocks when you lock tables explicitly</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBCEGC"></a>
<div id="CNCPT1339" class="sect1">
<h2 class="sect1">Overview of Automatic Locks</h2>
<p><a id="sthref1215"></a><a id="sthref1216"></a>Oracle Database automatically locks a resource on behalf of a transaction to prevent other transactions from doing something that requires exclusive access to the same resource. <a id="sthref1217"></a>The database automatically acquires different types of locks at different levels of restrictiveness depending on the resource and the operation being performed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The database never locks rows when performing simple reads.</div>
<p>Oracle Database locks are divided into the following categories.</p>
<div class="inftblinformal">
<table class="cellalignment1460" title="Categories of Locks" summary="Locks" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t26">Lock</th>
<th class="cellalignment1459" id="r1c2-t26">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t26" headers="r1c1-t26">DML Locks</td>
<td class="cellalignment1455" headers="r2c1-t26 r1c2-t26">Protect data. For example, table locks lock entire tables, while row locks lock selected rows. See <a href="#i34218">"DML Locks"</a>.</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t26" headers="r1c1-t26">DDL Locks</td>
<td class="cellalignment1455" headers="r3c1-t26 r1c2-t26">Protect the structure of schema objects&mdash;for example, the dictionary definitions of tables and views. See <a href="#i5281">"DDL Locks"</a>.</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r4c1-t26" headers="r1c1-t26">System Locks</td>
<td class="cellalignment1455" headers="r4c1-t26 r1c2-t26">Protect internal database structures such as data files. Latches, mutexes, and internal locks are entirely automatic. See <a href="#CIHJBIBB">"System Locks"</a>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<a id="i34218"></a>
<div id="CNCPT1340" class="sect2">
<h3 class="sect2">DML Locks</h3>
<p><a id="sthref1218"></a><a id="sthref1219"></a>A DML lock, also called a <span class="bold">data lock</span>, guarantees the integrity of data accessed concurrently by multiple users. For example, a DML lock prevents two customers from buying the last copy of a book available from an online bookseller. DML locks prevent destructive interference of simultaneous conflicting DML or DDL operations.</p>
<p>DML statements automatically acquire the following types of locks:</p>
<ul>
<li>
<p><a href="#BABIGJBI">Row Locks (TX)</a></p>
</li>
<li>
<p><a href="#BABDDFHB">Table Locks (TM)</a></p>
</li>
</ul>
<p>In the following sections, the acronym in parentheses after each type of lock or lock mode is the abbreviation used in the Locks Monitor of Oracle Enterprise Manager (Enterprise Manager). Enterprise Manager might display TM for any table lock, rather than indicate the mode of table lock (such as RS or SRX).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cncptdba.htm#CHDHBAAI">"Oracle Enterprise Manager"</a></div>
<a id="BABIGJBI"></a>
<div id="CNCPT1341" class="sect3">
<h4 class="sect3">Row Locks (TX)</h4>
<p><a id="sthref1220"></a><a id="sthref1221"></a><a id="sthref1222"></a><a id="sthref1223"></a><a id="sthref1224"></a>A <span class="bold">row lock</span>, also called a <span class="bold">TX lock</span>, is a lock on a single row of table. A transaction acquires a row lock for each row modified by an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, <code dir="ltr">MERGE</code>, or <code dir="ltr">SELECT</code> <code dir="ltr">... FOR</code> <code dir="ltr">UPDATE</code> statement. The row lock exists until the transaction commits or rolls back.</p>
<p>Row locks primarily serve as a queuing mechanism to prevent two transactions from modifying the same row. The database always locks a modified row in exclusive mode so that other transactions cannot modify the row until the transaction holding the lock commits or rolls back. Row locking provides the finest grain locking possible and so provides the best possible concurrency and throughput.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a transaction terminates because of database<a id="sthref1225"></a> <a href="glossary.htm#CHDGCEHD"><span class="xrefglossterm">instance failure</span></a>, then block-level recovery makes a row available before the entire transaction is recovered.</div>
<p>If a transaction obtains a lock for a row, then the transaction also acquires a lock for the table containing the row. The table lock prevents conflicting DDL operations that would override data changes in a current transaction. <a href="#BABJHGCE">Figure 9-2</a> illustrates an update of the third row in a table. Oracle Database automatically places an exclusive lock on the updated row and a subexclusive lock on the table.</p>
<div id="CNCPT88974" class="figure">
<p class="titleinfigure"><a id="BABJHGCE"></a>Figure 9-2 Row and Table Locks</p>
<img width="663" height="293" src="img/cncpt265.gif" alt="Description of Figure 9-2 follows" /><br />
<a id="sthref1226" href="img_text/cncpt265.htm">Description of "Figure 9-2 Row and Table Locks"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="CNCPT88975" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1227"></a>
<h5 class="sect4">Row Locks and Concurrency</h5>
<p><a href="#BABGHCDD">Table 9-6</a> illustrates how Oracle Database uses row locks for concurrency<a id="sthref1228"></a><a id="sthref1229"></a>. Three sessions query the same rows simultaneously. Session 1 and 2 proceed to make uncommitted updates to different rows, while session 3 makes no updates. Each session sees its own uncommitted updates but not the uncommitted updates of any other session.</p>
<div id="CNCPT88976" class="tblruleformalwidemax">
<p class="titleintable"><a id="sthref1230"></a><a id="BABGHCDD"></a>Table 9-6 Data Concurrency Example</p>
<table class="cellalignment1460" title="Data Concurrency Example" summary="Example of three concurrent transactions" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t29">Time</th>
<th class="cellalignment1459" id="r1c2-t29">Session 1</th>
<th class="cellalignment1459" id="r1c3-t29">Session 2</th>
<th class="cellalignment1459" id="r1c4-t29">Session 3</th>
<th class="cellalignment1459" id="r1c5-t29">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t29" headers="r1c1-t29">
<p>t0</p>
</td>
<td class="cellalignment1455" headers="r2c1-t29 r1c2-t29">
<pre dir="ltr">
SELECT employee_id, 
salary FROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          512
101          600
</pre></td>
<td class="cellalignment1455" headers="r2c1-t29 r1c3-t29">
<pre dir="ltr">
SELECT employee_id, 
salary FROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          512
101          600
</pre></td>
<td class="cellalignment1455" headers="r2c1-t29 r1c4-t29">
<pre dir="ltr">
SELECT employee_id, 
salary FROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          512
101          600
</pre></td>
<td class="cellalignment1455" headers="r2c1-t29 r1c5-t29">
<p>Three different sessions simultaneously query the ID and salary of employees 100 and 101. The results returned by each query are identical.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t29" headers="r1c1-t29">
<p>t1</p>
</td>
<td class="cellalignment1455" headers="r3c1-t29 r1c2-t29">
<pre dir="ltr">
UPDATE hr.employees
SET salary=salary+100  
WHERE employee_id=100;
</pre></td>
<td class="cellalignment1455" headers="r3c1-t29 r1c3-t29">&nbsp;</td>
<td class="cellalignment1455" headers="r3c1-t29 r1c4-t29">&nbsp;</td>
<td class="cellalignment1455" headers="r3c1-t29 r1c5-t29">
<p>Session 1 updates the salary of employee 100, but does not commit. In the update, the writer acquires a row-level lock for the updated row only, thereby preventing other writers from modifying this row.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r4c1-t29" headers="r1c1-t29">
<p>t2</p>
</td>
<td class="cellalignment1455" headers="r4c1-t29 r1c2-t29">
<pre dir="ltr">
SELECT employee_id, 
salary FROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          <span class="bold">612</span>
101          600
</pre></td>
<td class="cellalignment1455" headers="r4c1-t29 r1c3-t29">
<pre dir="ltr">
SELECT employee_id, 
salary FROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          512
101          600
</pre></td>
<td class="cellalignment1455" headers="r4c1-t29 r1c4-t29">
<pre dir="ltr">
SELECT employee_id, 
salary FROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          512
101          600
</pre></td>
<td class="cellalignment1455" headers="r4c1-t29 r1c5-t29">
<p>Each session simultaneously issues the original query. Session 1 shows the salary of 612 resulting from the t1 update. The readers in session 2 and 3 return rows immediately and do not wait for session 1 to end its transaction. The database uses multiversion read consistency to show the salary as it existed before the update in session 1.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r5c1-t29" headers="r1c1-t29">
<p>t3</p>
</td>
<td class="cellalignment1455" headers="r5c1-t29 r1c2-t29">&nbsp;</td>
<td class="cellalignment1455" headers="r5c1-t29 r1c3-t29">
<pre dir="ltr">
UPDATE hr.employees  
SET salary=salary+100  
WHERE employee_id=101;
</pre></td>
<td class="cellalignment1455" headers="r5c1-t29 r1c4-t29">&nbsp;</td>
<td class="cellalignment1455" headers="r5c1-t29 r1c5-t29">
<p>Session 2 updates the salary of employee 101, but does not commit the transaction. In the update, the writer acquires a row-level lock for the updated row only, preventing other writers from modifying this row.</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r6c1-t29" headers="r1c1-t29">
<p>t4</p>
</td>
<td class="cellalignment1455" headers="r6c1-t29 r1c2-t29">
<pre dir="ltr">
SELECT employee_id, 
salary FROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          <span class="bold">612</span>
101          600
</pre></td>
<td class="cellalignment1455" headers="r6c1-t29 r1c3-t29">
<pre dir="ltr">
SELECT employee_id, 
salaryFROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          512
101          <span class="bold">700</span>
</pre></td>
<td class="cellalignment1455" headers="r6c1-t29 r1c4-t29">
<pre dir="ltr">
SELECT employee_id, 
salary FROM employees 
WHERE  employee_id
IN ( 100, 101 );

EMPLOYEE_ID  SALARY
-----------  ------
100          512
101          600
</pre></td>
<td class="cellalignment1455" headers="r6c1-t29 r1c5-t29">
<p>Each session simultaneously issues the original query. Session 1 shows the salary of 612 resulting from the t1 update, but not the salary update for employee 101 made in session 2. The reader in session 2 shows the salary update made in session 2, but not the salary update made in session 1. The reader in session 3 uses read consistency to show the salaries before modification by session 1 and 2.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwidemax" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF55505" href="../../server.112/e41084/ap_locks001.htm#SQLRF55505"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink REFRN30121" href="../../server.112/e40402/dynviews_2027.htm#REFRN30121"><span class="italic">Oracle Database Reference</span></a> to learn about <code dir="ltr">V$LOCK</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<div id="CNCPT88977" class="sect4"><a id="sthref1231"></a>
<h5 class="sect4">Storage of Row Locks</h5>
<p>Unlike some databases, which use a lock manager to maintain a list of locks in memory, Oracle Database stores lock information in the <a id="sthref1232"></a><a href="glossary.htm#CBAGAGDD"><span class="xrefglossterm">data block</span></a> that contains the locked row<a id="sthref1233"></a>.</p>
<p>The database uses a queuing mechanism for acquisition of row locks. If a transaction requires a lock for an unlocked row, then the transaction places a lock in the data block. Each row modified by this transaction points to a copy of the transaction ID stored in the <a id="sthref1234"></a><a href="glossary.htm#CHDFIFBE"><span class="xrefglossterm">block header</span></a> (see <a href="logical.htm#i4894">"Overview of Data Blocks"</a>).</p>
<p>When a transaction ends, the transaction ID remains in the block header. If a different transaction wants to modify a row, then it uses the transaction ID to determine whether the lock is active. If the lock is active, then the session asks to be notified when the lock is released. Otherwise, the transaction acquires the lock.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN30291" href="../../server.112/e40402/dynviews_3114.htm#REFRN30291"><span class="italic">Oracle Database Reference</span></a> to learn about <code dir="ltr">V$TRANSACTION</code></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABDDFHB"></a>
<div id="CNCPT1342" class="sect3">
<h4 class="sect3">Table Locks (TM)</h4>
<p><a id="sthref1235"></a><a id="sthref1236"></a>A <span class="bold">table lock</span>, also called a <span class="bold">TM lock</span>, is acquired by a transaction when a table is modified by an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, <code dir="ltr">MERGE</code>, <code dir="ltr">SELECT</code> with the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause, or <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement. DML operations require table locks to reserve DML access to the table on behalf of a transaction and to prevent DDL operations that would conflict with the transaction.</p>
<p>A table lock can be held in any of the following modes:</p>
<ul>
<li>
<p><a id="sthref1237"></a>Row Share (RS)</p>
<p>This lock, also called a <span class="bold">subshare table lock (SS)</span>, indicates that the transaction holding the lock on the table has locked rows in the table and intends to update them. A row share lock is the least restrictive mode of table lock, offering the highest degree of concurrency for a table.</p>
</li>
<li>
<p><a id="sthref1238"></a>Row Exclusive Table Lock (RX)</p>
<p>This lock, also called a <span class="bold">subexclusive table lock (SX)</span>, generally indicates that the transaction holding the lock has updated table rows or issued <code dir="ltr">SELECT ... FOR UPDATE</code>. An SX lock allows other transactions to query, insert, update, delete, or lock rows concurrently in the same table. Therefore, SX locks allow multiple transactions to obtain simultaneous SX and subshare table locks for the same table.</p>
</li>
<li>
<p><a id="sthref1239"></a>Share Table Lock (S)</p>
<p>A share table lock held by a transaction allows other transactions to query the table (without using <code dir="ltr">SELECT ... FOR UPDATE</code>), but updates are allowed only if a single transaction holds the share table lock. Because multiple transactions may hold a share table lock concurrently, holding this lock is not sufficient to ensure that a transaction can modify the table.</p>
</li>
<li>
<p><a id="sthref1240"></a>Share Row Exclusive Table Lock (SRX)</p>
<p>This lock, also called a <span class="bold">share-subexclusive table lock (SSX)</span>, is more restrictive than a share table lock. Only one transaction at a time can acquire an SSX lock on a given table. An SSX lock held by a transaction allows other transactions to query the table (except for <code dir="ltr">SELECT ...</code> <code dir="ltr">FOR UPDATE</code>) but not to update the table.</p>
</li>
<li>
<p><a id="sthref1241"></a>Exclusive Table Lock (X)</p>
<p>This lock is the most restrictive, prohibiting other transactions from performing any type of DML statement or placing any type of lock on the table.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF55504" href="../../server.112/e41084/ap_locks001.htm#SQLRF55504"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink ADFNS007" href="../../appdev.112/e41502/adfns_sqlproc.htm#ADFNS007"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> to learn more about table locks</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABCAHDJ"></a>
<div id="CNCPT88978" class="sect3">
<h4 class="sect3">Locks and Foreign Keys</h4>
<p>Oracle Database <a id="sthref1242"></a><a id="sthref1243"></a><a id="sthref1244"></a>maximizes the concurrency control of parent keys in relation to dependent foreign keys. In heap-organized tables, locking behavior depends on the indexing of foreign key columns. If foreign keys are not indexed, then the child table will probably be locked more frequently, deadlocks will occur, and concurrency will be decreased. For this reason, Oracle recommends indexing foreign keys in most cases except when the matching unique or primary key is never updated or deleted.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Additional considerations apply to non-heap data structures such as index-organized tables and table clusters.</div>
<a id="BABCFHGF"></a>
<div id="CNCPT88979" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Locks and Unindexed Foreign Keys</h5>
<p>When both of the following conditions are true, the database acquires a full table lock on the child table:</p>
<ul>
<li>
<p>No index exists on the foreign key column of the child table.</p>
</li>
<li>
<p>A session modifies a primary key in the parent table (for example, deletes a row or modifies primary key attributes) or merges rows into the parent table. Inserts into the parent table do not acquire table locks on the child table.</p>
<p>Suppose that <code dir="ltr">hr.departments</code> table is a parent of <code dir="ltr">hr.employees</code>, which contains the unindexed foreign key <code dir="ltr">department_id</code>. <a href="#i8589">Figure 9-3</a> shows a session modifying the primary key attributes of department 60 in the <code dir="ltr">departments</code> table.</p>
</li>
</ul>
<div id="CNCPT88980" class="figure">
<p class="titleinfigure"><a id="i8589"></a>Figure 9-3 Locking Mechanisms with Unindexed Foreign Key</p>
<img width="668" height="569" src="img/cncpt308.gif" alt="Description of Figure 9-3 follows" /><br />
<a id="sthref1245" href="img_text/cncpt308.htm">Description of "Figure 9-3 Locking Mechanisms with Unindexed Foreign Key"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In <a href="#i8589">Figure 9-3</a>, the database acquires a full table lock on <code dir="ltr">employees</code> during the primary key modification of department 60. This lock enables other sessions to query but not update the <code dir="ltr">employees</code> table. For example, employee phone numbers cannot be updated. The table lock on <code dir="ltr">employees</code> releases immediately after the primary key modification on the <code dir="ltr">departments</code> table completes. If multiple rows in <code dir="ltr">departments</code> undergo primary key modifications, then a table lock on <code dir="ltr">employees</code> is obtained and released once for each row that is modified in <code dir="ltr">departments</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
DML on a child table does not acquire a table lock on the parent table.</div>
</div>
<!-- class="sect4" -->
<div id="CNCPT88981" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1246"></a>
<h5 class="sect4">Locks and Indexed Foreign Keys</h5>
<p>When both of the following conditions are true, the database does <span class="italic">not</span> acquire a full table lock on the child table:</p>
<ul>
<li>
<p>A foreign key column in the child table is indexed.</p>
</li>
<li>
<p>A session modifies a primary key in the parent table (for example, deletes a row or modifies primary key attributes) or merges rows into the parent table.</p>
</li>
</ul>
<p>A lock on the parent table prevents transactions from acquiring exclusive table locks, but does not prevent DML on the parent <span class="italic">or</span> child table during the primary key modification. This situation is preferable if primary key modifications occur on the parent table while updates occur on the child table.</p>
<p><a href="#i8605">Figure 9-4</a> shows child table <code dir="ltr">employees</code> with an indexed <code dir="ltr">department_id</code> column. A transaction deletes department 280 from <code dir="ltr">departments</code>. This deletion does not cause the database to acquire a full table lock on the <code dir="ltr">employees</code> table as in the scenario described in <a href="#BABCFHGF">"Locks and Unindexed Foreign Keys"</a>.</p>
<div id="CNCPT88982" class="figure">
<p class="titleinfigure"><a id="i8605"></a>Figure 9-4 Locking Mechanisms with Indexed Foreign Key</p>
<img width="668" height="593" src="img/cncpt309.gif" alt="Description of Figure 9-4 follows" /><br />
<a id="sthref1247" href="img_text/cncpt309.htm">Description of "Figure 9-4 Locking Mechanisms with Indexed Foreign Key"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If the child table specifies <code dir="ltr">ON DELETE CASCADE</code>, then deletions from the parent table can result in deletions from the child table. For example, the deletion of department 280 can cause the deletion of records from <code dir="ltr">employees</code> for employees in the deleted department. In this case, waiting and locking rules are the same as if you deleted rows from the child table after deleting rows from the parent table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="datainte.htm#CHDIIGBG">"Foreign Key Constraints"</a></p>
</li>
<li>
<p><a href="indexiot.htm#i5671">"Overview of Indexes"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i5281"></a>
<div id="CNCPT1351" class="sect2">
<h3 class="sect2">DDL Locks</h3>
<p><a id="sthref1248"></a><a id="sthref1249"></a><a id="sthref1250"></a><a id="sthref1251"></a>A <span class="bold">data dictionary (DDL) lock</span> protects the definition of a <a href="glossary.htm#CHDICIIC"><span class="xrefglossterm">schema object</span></a> while an ongoing DDL operation acts on or refers to the object. Only individual schema objects that are modified or referenced are locked during DDL operations. The database never locks the whole <a href="glossary.htm#CHDJCHJA"><span class="xrefglossterm">data dictionary</span></a>.</p>
<p>Oracle Database acquires a DDL lock automatically on behalf of any DDL transaction requiring it. Users cannot explicitly request DDL locks. For example, if a user creates a <a href="glossary.htm#CHDCCGFA"><span class="xrefglossterm">stored procedure</span></a>, then Oracle Database automatically acquires DDL locks for all schema objects referenced in the procedure definition. The DDL locks prevent these objects from being altered or dropped before procedure compilation is complete.</p>
<a id="i5288"></a>
<div id="CNCPT1352" class="sect3">
<h4 class="sect3">Exclusive DDL Locks</h4>
<p><a id="sthref1252"></a>An <span class="bold">exclusive DDL lock</span> prevents other sessions from obtaining a DDL or DML lock. Most DDL operations, except for those described in <a href="#CIHIGAFG">"Share DDL Locks"</a>, require exclusive DDL locks for a resource to prevent destructive interference with other DDL operations that might modify or reference the same schema object. For example, <code dir="ltr">DROP TABLE</code> is not allowed to drop a table while <code dir="ltr">ALTER TABLE</code> is adding a column to it, and vice versa.</p>
<p>Exclusive DDL locks last for the duration of DDL statement execution and automatic commit. During the acquisition of an exclusive DDL lock, if another DDL lock is held on the schema object by another operation, then the acquisition waits until the older DDL lock is released and then proceeds.</p>
</div>
<!-- class="sect3" -->
<a id="CIHIGAFG"></a>
<div id="CNCPT1353" class="sect3">
<h4 class="sect3">Share DDL Locks</h4>
<p><a id="sthref1253"></a><a id="sthref1254"></a>A <span class="bold">share DDL lock</span> for a resource prevents destructive interference with conflicting DDL operations, but allows data concurrency for similar DDL operations.</p>
<p>For example, when a <code dir="ltr">CREATE</code> <code dir="ltr">PROCEDURE</code> statement is run, the containing transaction acquires share DDL locks for all referenced tables. Other transactions can concurrently create procedures that reference the same tables and acquire concurrent share DDL locks on the same tables, but no transaction can acquire an exclusive DDL lock on any referenced table.</p>
<p>A share DDL lock lasts for the duration of DDL statement execution and automatic commit. Thus, a transaction holding a share DDL lock is guaranteed that the definition of the referenced schema object remains constant during the transaction.</p>
</div>
<!-- class="sect3" -->
<a id="CIHCFBIJ"></a>
<div id="CNCPT1354" class="sect3">
<h4 class="sect3">Breakable Parse Locks</h4>
<p><a id="sthref1255"></a><a id="sthref1256"></a>A <span class="bold">parse lock</span> is held by a SQL statement or PL/SQL program unit for each schema object that it references. Parse locks are acquired so that the associated <a id="sthref1257"></a><a href="glossary.htm#CHDEEJGC"><span class="xrefglossterm">shared SQL area</span></a> can be invalidated if a referenced object is altered or dropped. A parse lock is called a <span class="bold">breakable parse lock</span> because it does not disallow any DDL operation and can be broken to allow conflicting DDL operations.</p>
<p>A parse lock is acquired in the <a id="sthref1258"></a><a href="glossary.htm#CBAIACIC"><span class="xrefglossterm">shared pool</span></a> during the parse phase of SQL statement execution. The lock is held as long as the shared SQL area for that statement remains in the shared pool.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="memory.htm#i10223">"Shared Pool"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHJBIBB"></a>
<div id="CNCPT1357" class="sect2">
<h3 class="sect2">System Locks</h3>
<p><a id="sthref1259"></a><a id="sthref1260"></a><a id="sthref1261"></a><a id="sthref1262"></a>Oracle Database uses various types of system locks to protect internal database and memory structures. These mechanisms are inaccessible to users because users have no control over their occurrence or duration.</p>
<a id="CIHGBBAF"></a>
<div id="CNCPT1358" class="sect3">
<h4 class="sect3">Latches</h4>
<p><a id="sthref1263"></a><a id="sthref1264"></a><a id="sthref1265"></a><span class="bold">Latches</span> are simple, low-level serialization mechanisms that coordinate multiuser access to shared data structures, objects, and files. Latches protect shared memory resources from corruption when accessed by multiple processes. Specifically, latches protect data structures from the following situations:</p>
<ul>
<li>
<p>Concurrent modification by multiple sessions</p>
</li>
<li>
<p>Being read by one session while being modified by another session</p>
</li>
<li>
<p>Deallocation (aging out) of memory while being accessed</p>
</li>
</ul>
<p>Typically, a single latch protects multiple objects in the SGA. For example, <a href="glossary.htm#CHDBJJGB"><span class="xrefglossterm">background processes</span></a> such as DBW<span class="italic">n</span> and LGWR allocate memory from the <a id="sthref1266"></a><a href="glossary.htm#CBAIACIC"><span class="xrefglossterm">shared pool</span></a> to create data structures. To allocate this memory, these processes use a shared pool latch that serializes access to prevent two processes from trying to inspect or modify the shared pool simultaneously. After the memory is allocated, other processes may need to access shared pool areas such as the <a href="glossary.htm#CHDCFADC"><span class="xrefglossterm">library cache</span></a>, which is required for parsing. In this case, processes latch only the library cache, not the entire shared pool.</p>
<p>Unlike <span class="bold">enqueue latches</span> such as row locks, latches do not permit sessions to queue. When a latch becomes available, the first session to request the latch obtains exclusive access to it. <span class="bold"><a id="sthref1267"></a><a id="sthref1268"></a><a id="sthref1269"></a>Latch spinning</span> occurs when a process repeatedly requests a latch in a loop, whereas <span class="bold">latch sleeping</span> occurs when a process releases the CPU before renewing the latch request.</p>
<p>Typically, an Oracle process acquires a latch for an extremely short time while manipulating or looking at a data structure. For example, while processing a salary update of a single employee, the database may obtain and release thousands of latches. The implementation of latches is operating system-dependent, especially in respect to whether and how long a process waits for a latch.</p>
<p>An increase in latching means a decrease in concurrency. For example, excessive <a id="sthref1270"></a><a href="glossary.htm#CHDCGEBJ"><span class="xrefglossterm">hard parse</span></a> operations create contention for the library cache latch. The <code dir="ltr">V$LATCH</code> view contains detailed latch usage statistics for each latch, including the number of times each latch was requested and waited for.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="sqllangu.htm#CHDHFFHA">"SQL Parsing"</a></p>
</li>
<li>
<p><a class="olink REFRN30108" href="../../server.112/e40402/dynviews_2015.htm#REFRN30108"><span class="italic">Oracle Database Reference</span></a> to learn about <code dir="ltr">V$LATCH</code></p>
</li>
<li>
<p><a class="olink PFGRF02410" href="../../server.112/e41573/instance_tune.htm#PFGRF02410"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn about wait event statistics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="CNCPT88983" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1271"></a>
<h4 class="sect3">Mutexes</h4>
<p><a id="sthref1272"></a><a id="sthref1273"></a>A <span class="bold">mutual exclusion object (mutex)</span> is a low-level mechanism that prevents an object in memory from aging out or from being corrupted when accessed by concurrent processes. A mutex is similar to a latch, but whereas a latch typically protects a group of objects, a mutex protects a single object.</p>
<p>Mutexes provide several benefits:</p>
<ul>
<li>
<p>A mutex can reduce the possibility of contention.</p>
<p>Because a latch protects multiple objects, it can become a bottleneck when processes attempt to access any of these objects concurrently. By serializing access to an individual object rather than a group, a mutex increases availability.</p>
</li>
<li>
<p>A mutex consumes less memory than a latch.</p>
</li>
<li>
<p>When in shared mode, a mutex permits concurrent reference by multiple sessions.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CIHIGICD"></a>
<div id="CNCPT1359" class="sect3">
<h4 class="sect3">Internal Locks</h4>
<p><a id="sthref1274"></a><a id="sthref1275"></a>Internal locks are higher-level, more complex mechanisms than latches and mutexes and serve various purposes. The database uses the following types of internal locks:</p>
<ul>
<li>
<p><a id="CNCPT1360"></a>Dictionary cache locks</p>
<p><a id="sthref1276"></a><a id="sthref1277"></a><a id="sthref1278"></a>These locks are of very short duration and are held on entries in dictionary caches while the entries are being modified or used. They guarantee that statements being parsed do not see inconsistent object definitions. Dictionary cache locks can be shared or exclusive. Shared locks are released when the parse is complete, whereas exclusive locks are released when the DDL operation is complete.</p>
</li>
<li>
<p><a id="CNCPT1361"></a>File and log management locks</p>
<p><a id="sthref1279"></a><a id="sthref1280"></a><a id="sthref1281"></a>These locks protect various files. <a id="sthref1282"></a>For example, an internal lock protects the <a href="glossary.htm#CHDDFGEC"><span class="xrefglossterm">control file</span></a> so that only one process at a time can change it. Another lock coordinates the use and archiving of the online redo log files. Data files are locked to ensure that multiple instances mount a database in shared mode or that one instance mounts it in exclusive mode. Because file and log locks indicate the status of files, these locks are necessarily held for a long time.</p>
</li>
<li>
<p><a id="CNCPT1362"></a>Tablespace and undo segment locks</p>
<p><a id="sthref1283"></a><a id="sthref1284"></a><a id="sthref1285"></a><a id="sthref1286"></a>These locks protect <a href="glossary.htm#CHDBACCD"><span class="xrefglossterm">tablespaces</span></a> and undo segments. For example, all instances accessing a database must agree on whether a tablespace is online or offline. Undo segments are locked so that only one database instance can write to a segment.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="memory.htm#BABEJJEG">"Data Dictionary Cache"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5269"></a>
<div id="CNCPT1363" class="sect1">
<h2 class="sect1">Overview of Manual Data Locks</h2>
<p><a id="sthref1287"></a><a id="sthref1288"></a><a id="sthref1289"></a><a id="sthref1290"></a><a id="sthref1291"></a>Oracle Database performs locking automatically to ensure data concurrency, data integrity, and statement-level read consistency. However, you can manually override the Oracle Database default locking mechanisms. Overriding the default locking is useful in situations such as the following:</p>
<ul>
<li>
<p>Applications require transaction-level read consistency or <span class="bold">repeatable reads</span>.</p>
<p>In this case, queries must produce consistent data for the duration of the transaction, not reflecting changes by other transactions. You can achieve transaction-level read consistency by using explicit locking, read-only transactions, serializable transactions, or by overriding default locking.</p>
</li>
<li>
<p>Applications require that a transaction have exclusive access to a resource so that the transaction does not have to wait for other transactions to complete.</p>
</li>
</ul>
<p>You can override <a id="sthref1292"></a>Oracle Database automatic locking at the session or transaction level. At the session level, a session can set the required transaction isolation level with the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> statement. At the transaction level, transactions that include the following SQL statements override Oracle Database default locking:</p>
<ul>
<li>
<p>The <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> statement</p>
</li>
<li>
<p>The <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement (which locks either a table or, when used with views, the base tables)</p>
</li>
<li>
<p>The <code dir="ltr">SELECT</code> <code dir="ltr">...</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement</p>
</li>
</ul>
<p>Locks acquired by the preceding statements are released after the transaction ends or a rollback to savepoint releases them.</p>
<p>If Oracle Database default locking is overridden at any level, then the database administrator or application developer should ensure that the overriding locking procedures operate correctly. The locking procedures must satisfy the following criteria: data integrity is guaranteed, data concurrency is acceptable, and deadlocks are not possible or are appropriately handled.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF01605" href="../../server.112/e41084/statements_9015.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a> for descriptions of <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> and <code dir="ltr">SELECT</code> ... <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code></p>
</li>
<li>
<p><a class="olink ADFNS00203" href="../../appdev.112/e41502/adfns_sqlproc.htm#ADFNS00203"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> to learn how to manually lock tables</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CIHJDIDC"></a>
<div id="CNCPT1364" class="sect1">
<h2 class="sect1">Overview of User-Defined Locks</h2>
<p><a id="sthref1293"></a><a id="sthref1294"></a>With Oracle Database Lock Management services, you can define your own locks for a specific application. For example, you might create a lock to serialize access to a message log on the file system. Because a reserved user lock is the same as an Oracle Database lock, it has all the Oracle Database lock functionality including deadlock detection. User locks never conflict with Oracle Database locks, because they are identified with the prefix <code dir="ltr">UL</code>.</p>
<p>The Oracle Database Lock Management services are available through procedures in the <code dir="ltr">DBMS_LOCK</code> package. You can include statements in PL/SQL blocks that:</p>
<ul>
<li>
<p>Request a lock of a specific type</p>
</li>
<li>
<p>Give the lock a unique name recognizable in another procedure in the same or in another instance</p>
</li>
<li>
<p>Change the lock type</p>
</li>
<li>
<p>Release the lock</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS1002" href="../../appdev.112/e41502/adfns_sqlproc.htm#ADFNS1002"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for more information about Oracle Database Lock Management services</p>
</li>
<li>
<p><a class="olink ARPLS021" href="../../appdev.112/e40758/d_lock.htm#ARPLS021"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about <code dir="ltr">DBMS_LOCK</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;When processing a distributed two-phase commit, the database may briefly prevent read access in special circumstances. Specifically, if a query starts between the prepare and commit phases and attempts to read the data before the commit, then the database may escalate a lock from row-level to block-level to guarantee read consistency.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1448">
<tr>
<td class="cellalignment1455">
<table class="cellalignment1453">
<tr>
<td class="cellalignment1452"><a href="part_txn.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1452"><a href="transact.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1457">
<table class="cellalignment1451">
<tr>
<td class="cellalignment1452"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1452"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1452"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1452"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1452"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1452"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
