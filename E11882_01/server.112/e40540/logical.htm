<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Logical Storage Structures</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1056" />
<meta name="dcterms.created" content="2015-05-25T13:34:3Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Concepts" />
<meta name="dcterms.identifier" content="E40540-04" />
<meta name="dcterms.isVersionOf" content="CNCPT" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="physical.htm" title="Previous" type="text/html" />
<link rel="Next" href="part_inarch.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e40540.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">19/30</span> <!-- End Header -->
<div id="CNCPT004" class="chapter"><a id="g23847"></a> <a id="i8531"></a>
<h1 class="chapter"><span class="secnum">12</span> Logical Storage Structures</h1>
<p><a id="sthref1450"></a><a id="sthref1451"></a>This chapter describes the nature of and relationships among logical storage structures. These structures are created and recognized by Oracle Database and are not known to the operating system.</p>
<p><a id="sthref1452"></a><a id="sthref1453"></a><a id="sthref1454"></a>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i19599">Introduction to Logical Storage Structures</a></p>
</li>
<li>
<p><a href="#i4894">Overview of Data Blocks</a></p>
</li>
<li>
<p><a href="#i4896">Overview of Extents</a></p>
</li>
<li>
<p><a href="#i10405">Overview of Segments</a></p>
</li>
<li>
<p><a href="#i2006">Overview of Tablespaces</a></p>
</li>
</ul>
<a id="i19599"></a>
<div id="CNCPT301" class="sect1">
<h2 class="sect1">Introduction to Logical Storage Structures<a id="sthref1455"></a><a id="sthref1456"></a><a id="sthref1457"></a></h2>
<p><a id="sthref1458"></a><a id="sthref1459"></a><a id="sthref1460"></a><a id="sthref1461"></a>Oracle Database allocates logical space for all data in the database. The logical units of database space allocation are data blocks, extents, segments, and tablespaces. At a physical level, the data is stored in data files on disk (see <a href="physical.htm#g21431">Chapter 11, "Physical Storage Structures"</a>). The data in the data files is stored in operating system blocks.</p>
<p><a href="#BABDADHH">Figure 12-1</a> is an entity-relationship diagram for physical and logical storage. The crow's foot notation represents a one-to-many relationship.</p>
<div id="CNCPT89000" class="figure">
<p class="titleinfigure"><a id="BABDADHH"></a>Figure 12-1 Logical and Physical Storage</p>
<img width="227" height="263" src="img/cncpt227.gif" alt="Description of Figure 12-1 follows" /><br />
<a id="sthref1462" href="img_text/cncpt227.htm">Description of "Figure 12-1 Logical and Physical Storage"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="CNCPT3000" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1463"></a>
<h3 class="sect2">Logical Storage Hierarchy</h3>
<p><a href="#i10251">Figure 12-2</a> shows the relationships among data blocks, extents, and segments within a tablespace. In this example, a segment has two extents stored in different data files.</p>
<div id="CNCPT89001" class="figure">
<p class="titleinfigure"><a id="i10251"></a>Figure 12-2 Segments, Extents, and Data Blocks Within a Tablespace</p>
<img width="491" height="326" src="img/cncpt027.gif" alt="Description of Figure 12-2 follows" /><br />
<a id="sthref1464" href="img_text/cncpt027.htm">Description of "Figure 12-2 Segments, Extents, and Data Blocks Within a Tablespace"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a id="sthref1465"></a><a id="sthref1466"></a><a id="sthref1467"></a>At the finest level of granularity, Oracle Database stores data in data blocks. One logical <a href="glossary.htm#i432306"><span class="xrefglossterm">data block</span></a> corresponds to a specific number of bytes of physical disk space, for example, 2 KB. Data blocks are the smallest units of storage that Oracle Database can use or allocate.</p>
<p><a id="sthref1468"></a>An <a href="glossary.htm#i432386"><span class="xrefglossterm">extent</span></a> is a set of logically contiguous data blocks allocated for storing a specific type of information. In <a href="#i10251">Figure 12-2</a>, the 24 KB extent has 12 data blocks, while the 72 KB extent has 36 data blocks.</p>
<p><a id="sthref1469"></a>A <a href="glossary.htm#i432714"><span class="xrefglossterm">segment</span></a> is a set of extents allocated for a specific database object, such as a <a href="glossary.htm#i432801"><span class="xrefglossterm">table</span></a>. For example, the data for the <code dir="ltr">employees</code> table is stored in its own <a href="glossary.htm#CHDDJICF"><span class="xrefglossterm">data segment</span></a>, whereas each <a href="glossary.htm#i432409"><span class="xrefglossterm">index</span></a> for <code dir="ltr">employees</code> is stored in its own <a href="glossary.htm#CHDGDDBB"><span class="xrefglossterm">index segment</span></a>. Every database object that consumes storage consists of a single segment.</p>
<p>Each segment belongs to one and only one <a href="glossary.htm#i996731"><span class="xrefglossterm">tablespace</span></a>. Thus, all extents for a segment are stored in the same tablespace. Within a tablespace, a segment can include extents from multiple data files, as shown in <a href="#i10251">Figure 12-2</a>. For example, one extent for a segment may be stored in <code dir="ltr">users01.dbf</code>, while another is stored in <code dir="ltr">users02.dbf</code>. A single extent can never span data files.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="physical.htm#i2004">"Overview of Data Files"</a></div>
</div>
<!-- class="sect2" -->
<a id="i4345"></a>
<div id="CNCPT1095" class="sect2">
<h3 class="sect2">Logical Space Management</h3>
<p>Oracle Database must use <span class="bold">logical space management</span> to track and allocate the extents in a tablespace. When a database object requires an extent, the database must have a method of finding and providing it. Similarly, when an object no longer requires an extent, the database must have a method of making the free extent available.</p>
<p>Oracle Databa<a id="sthref1470"></a>se manages space within a tablespace based on the type that you create. You can create either of the following types of tablespaces:</p>
<ul>
<li>
<p>Locally managed tablespaces (default)</p>
<p>The database uses bitmaps in the tablespaces themselves to manage extents. Thus, locally managed tablespaces have a part of the tablespace set aside for a bitmap. Within a tablespace, the database can manage segments with <span class="bold">automatic segment space management (ASSM)</span> or <span class="bold">manual segment space management (MSSM)</span>.</p>
</li>
<li>
<p>Dictionary-managed tablespaces</p>
<p>The database uses the <a href="glossary.htm#CHDJJJGD"><span class="xrefglossterm">data dictionary</span></a> to manage extents (see <a href="datadict.htm#i1012">"Overview of the Data Dictionary"</a>).</p>
</li>
</ul>
<p><a href="#BABDJBGD">Figure 12-3</a> shows the alternatives for logical space management in a tablespace.</p>
<div id="CNCPT89002" class="figure">
<p class="titleinfigure"><a id="BABDJBGD"></a>Figure 12-3 Logical Space Management</p>
<img width="450" height="183" src="img/cncpt268.gif" alt="Description of Figure 12-3 follows" /><br />
<a id="sthref1471" href="img_text/cncpt268.htm">Description of "Figure 12-3 Logical Space Management"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="i5042"></a>
<div id="CNCPT1096" class="sect3">
<h4 class="sect3">Locally Managed Tablespaces</h4>
<p><a id="sthref1472"></a><a id="sthref1473"></a><a id="sthref1474"></a><a id="sthref1475"></a>A locally managed tablespace maintains a bitmap in the data file header to track free and used space in the data file body. Each bit corresponds to a group of blocks. When space is allocated or freed, Oracle Database changes the bitmap values to reflect the new status of the blocks.</p>
<p>The following graphic is a conceptual representation of bitmap-managed storage. A <code dir="ltr">1</code> in the header refers to used space, whereas a <code dir="ltr">0</code> refers to free space.</p>
<img width="632" height="333" src="img/cncpt332.gif" alt="Description of cncpt332.gif follows" /><br />
<a id="sthref1476" href="img_text/cncpt332.htm">Description of the illustration cncpt332.gif</a><br />
<br />
<p>A locally managed tablespace has the following advantages:</p>
<ul>
<li>
<p>Avoids using the data dictionary to manage extents</p>
<p>Recursive operations can occur in dictionary-managed tablespaces if consuming or releasing space in an extent results in another operation that consumes or releases space in a data dictionary table or undo segment.</p>
</li>
<li>
<p>Tracks adjacent free space automatically</p>
<p>In this way, the database eliminates the need to coalesce free extents.</p>
</li>
<li>
<p>Determines the size of locally managed extents automatically</p>
<p>Alternatively, all extents can have the same size in a locally managed tablespace and override object storage options.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle strongly recommends the use of locally managed tablespaces with Automatic Segment Space Management.</div>
<p><span class="bold">Segment space management</span> is an attribute inherited from the tablespace that contains the segment. Within a locally managed tablespace, the database can manage segments automatically or manually. For example, segments in tablespace <code dir="ltr">users</code> can be managed automatically while segments in tablespace <code dir="ltr">tools</code> are managed manually.</p>
<a id="BABCCHFE"></a>
<div id="CNCPT7668" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Automatic Segment Space Management</h5>
<p>The ASSM method uses bitmaps to manage space. Bitmaps provide the following advantages:</p>
<ul>
<li>
<p>Simplified administration</p>
<p>ASSM avoids the need to manually determine correct settings for many storage parameters. Only one crucial SQL parameter controls space allocation: <code dir="ltr">PCTFREE</code>. This parameter specifies the percentage of space to be reserved in a block for future updates (see <a href="#BABBAJHC">"Percentage of Free Space in Data Blocks"</a>).</p>
</li>
<li>
<p>Increased concurrency</p>
<p>Multiple <a href="glossary.htm#CHDJEBHA"><span class="xrefglossterm">transactions</span></a> can search separate lists of free data blocks, thereby reducing contention and waits. For many standard workloads, application performance with ASSM is better than the performance of a well-tuned application that uses MSSM.</p>
</li>
<li>
<p>Dynamic affinity of space to instances in an Oracle Real Application Clusters (Oracle RAC) environment</p>
</li>
</ul>
<p>ASSM is more efficient and is the default for permanent, locally managed tablespaces.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This chapter assumes the use of ASSM in all of its discussions of logical storage space.</div>
</div>
<!-- class="sect4" -->
<div id="CNCPT7669" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1477"></a>
<h5 class="sect4">Manual Segment Space Management</h5>
<p>The legacy MSSM method uses a linked list called a <span class="bold">free list</span> to manage free space in the segment. For a database object that has free space, a free list keeps track of blocks under the <a href="glossary.htm#CHDIJHII"><span class="xrefglossterm">high water mark</span></a> (HWM), which is the dividing line between segment space that is used and not yet used. As blocks are used, the database puts blocks on or removes blocks from the free list as needed.</p>
<p>In addition to <code dir="ltr">PCTFREE</code>, MSSM requires you to control space allocation with SQL parameters such as <code dir="ltr">PCTUSED</code>, <code dir="ltr">FREELISTS</code>, and <code dir="ltr">FREELIST GROUPS</code>. <code dir="ltr">PCTUSED</code> sets the percentage of free space that must exist in a currently used block for the database to put it on the free list. For example, if you set <code dir="ltr">PCTUSED</code> to <code dir="ltr">40</code> in a <code dir="ltr">CREATE TABLE</code> statement, then you cannot insert rows into a block in the segment until less than 40% of the block space is used.</p>
<p>As an illustration, suppose you insert a row into a table. The database checks a free list of the table for the first available block. If the row cannot fit in the block, and if the used space in the block is greater than or equal to <code dir="ltr">PCTUSED</code>, then the database takes the block off the list and searches for another block. If you delete rows from the block, then the database checks whether used space in the block is now less than <code dir="ltr">PCTUSED</code>. If so, then the database places the block at the beginning of the free list.</p>
<p>An object may have multiple free lists. In this way, multiple sessions performing DML on a table can use different lists, which can reduce contention. Each database session uses only one free list for the duration of its session.</p>
<p>As shown in <a href="#BABJABGH">Figure 12-4</a>, you can also create an object with one or more <span class="bold">free list groups</span>, which are collections of free lists. Each group has a <span class="bold">master free list</span> that manages the individual <span class="bold">process free lists</span> in the group. Space overhead for free lists, especially for free list groups, can be significant.</p>
<div id="CNCPT89176" class="figure">
<p class="titleinfigure"><a id="BABJABGH"></a>Figure 12-4 Free List Groups</p>
<img width="324" height="276" src="img/cncpt320.gif" alt="Description of Figure 12-4 follows" /><br />
<a id="sthref1478" href="img_text/cncpt320.htm">Description of "Figure 12-4 Free List Groups"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Managing segment space manually can be complex. You must adjust <code dir="ltr">PCTFREE</code> and <code dir="ltr">PCTUSED</code> to reduce row migration (see <a href="#BABEEAAE">"Chained and Migrated Rows"</a>) and avoid wasting space. For example, if every used block in a segment is half full, and if <code dir="ltr">PCTUSED</code> is 40, then the database does not permit inserts into any of these blocks. Because of the difficulty of fine-tuning space allocation parameters, Oracle strongly recommends ASSM. In ASSM, <code dir="ltr">PCTFREE</code> determines whether a new row can be inserted into a block, but it does not use free lists and ignores <code dir="ltr">PCTUSED</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11360" href="../../server.112/e25494/tspaces.htm#ADMIN11360"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn about locally managed tablespaces</p>
</li>
<li>
<p><a class="olink ADMQS12054" href="../../server.112/e10897/storage.htm#ADMQS12054"><span class="italic">Oracle Database 2 Day DBA</span></a> and <a class="olink ADMIN10065" href="../../server.112/e25494/tspaces.htm#ADMIN10065"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn more about automatic segment space management</p>
</li>
<li>
<p><a class="olink SQLRF30011" href="../../server.112/e41084/clauses007.htm#SQLRF30011"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about storage parameters such as <code dir="ltr">PCTFREE</code> and <code dir="ltr">PCTUSED</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BJEGAIGG"></a>
<div id="CNCPT1098" class="sect3">
<h4 class="sect3">Dictionary-Managed Tablespaces</h4>
<p><a id="sthref1479"></a><a id="sthref1480"></a><a id="sthref1481"></a><a id="sthref1482"></a>A dictionary-managed tablespace uses the data dictionary to manage its extents. Oracle Database updates tables in the data dictionary whenever an extent is allocated or freed for reuse. For example, when a table needs an extent, the database queries the data dictionary tables, and searches for free extents. If the database finds space, then it modifies one data dictionary table and inserts a row into another. In this way, the database manages space by modifying and moving data.</p>
<p>The SQL that the database executes in the background to obtain space for database objects is <span class="bold">recursive SQL</span>. Frequent use of recursive SQL can have a negative impact on performance because updates to the data dictionary must be serialized. Locally managed tablespaces, which are the default, avoid this performance problem.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11392" href="../../server.112/e25494/tspaces.htm#ADMIN11392"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to migrate tablespaces from dictionary-managed to locally managed</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i4894"></a>
<div id="CNCPT302" class="sect1">
<h2 class="sect1">Overview of Data Blocks</h2>
<p><a id="sthref1483"></a><a id="sthref1484"></a><a id="sthref1485"></a>Oracle Database manages the logical storage space in the data files of a database in units called <span class="bold">data blocks</span>, also called <span class="bold">Oracle blocks</span> or <span class="bold">pages</span>. A data block is the minimum unit of database I/O.</p>
<a id="BABCICFD"></a>
<div id="CNCPT250" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Data Blocks and Operating System Blocks</h3>
<p>At the physical level, database data is stored in disk files made up of operating system blocks. An <span class="bold">operating system block</span> is the minimum unit of data that the operating system can read or write. In contrast, an Oracle block is a logical storage structure whose size and structure are not known to the operating system.</p>
<p><a href="#BABDCGIB">Figure 12-5</a> shows that operating system blocks may differ in size from data blocks. The database requests data in multiples of data blocks, not operating system blocks.</p>
<div id="CNCPT89003" class="figure">
<p class="titleinfigure"><a id="BABDCGIB"></a>Figure 12-5 Data Blocks and Operating System Blocks</p>
<img width="225" height="248" src="img/cncpt293.gif" alt="Description of Figure 12-5 follows" /><br />
<a id="sthref1486" href="img_text/cncpt293.htm">Description of "Figure 12-5 Data Blocks and Operating System Blocks"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When the database requests a data block, the operating system translates this operation into a requests for data in permanent storage. The logical separation of data blocks from operating system blocks has the following implications:</p>
<ul>
<li>
<p>Applications do not need to determine the physical addresses of data on disk.</p>
</li>
<li>
<p>Database data can be striped or mirrored on multiple physical disks.</p>
</li>
</ul>
<a id="BABIEBGC"></a>
<div id="CNCPT7670" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Database Block Size</h4>
<p>Every database has a <span class="bold">database block size</span>. The <code dir="ltr">DB_BLOCK_SIZE</code> initialization parameter sets the data block size for a database when it is created. The size is set for the <code dir="ltr">SYSTEM</code> and <code dir="ltr">SYSAUX</code> tablespaces and is the default for all other tablespaces. The database block size cannot be changed except by re-creating the database.</p>
<p>If <code dir="ltr">DB_BLOCK_SIZE</code> is not set, then the default data block size is operating system-specific. The standard data block size for a database is 4 KB or 8 KB. If the size differs for data blocks and operating system blocks, then the data block size must be a multiple of the operating system block size.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN10031" href="../../server.112/e40402/initparams050.htm#REFRN10031"><span class="italic">Oracle Database Reference</span></a> to learn about the <code dir="ltr">DB_BLOCK_SIZE</code> initialization parameter</p>
</li>
<li>
<p><a class="olink ADMIN11106" href="../../server.112/e25494/create.htm#ADMIN11106"><span class="italic">Oracle Database Administrator's Guide</span></a> and <a class="olink PFGRF94404" href="../../server.112/e41573/iodesign.htm#PFGRF94404"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn how to choose block sizes</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="CNCPT7671" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1487"></a>
<h4 class="sect3">Tablespace Block Size</h4>
<p>You can create individual tablespaces whose block size differs from the <code dir="ltr">DB_BLOCK_SIZE</code> setting. A nonstandard block size can be useful when moving a <a href="glossary.htm#CHDIIFFG"><span class="xrefglossterm">transportable tablespace</span></a> to a different platform.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11107" href="../../server.112/e25494/create.htm#ADMIN11107"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to specify a nonstandard block size for a tablespace</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHEIFJC"></a>
<div id="CNCPT1046" class="sect2">
<h3 class="sect2">Data Block Format</h3>
<p><a id="sthref1488"></a>Every data block has a <span class="bold">format</span> or internal structure that enables the database to track the data and free space in the block. This format is similar whether the data block contains table, index, or <a href="glossary.htm#CHDJGGGF"><span class="xrefglossterm">table cluster</span></a> data. <a href="#i4902">Figure 12-6</a> shows the format of an uncompressed data block (see <a href="#BABGEAAF">"Data Block Compression"</a> to learn about compressed blocks).</p>
<div id="CNCPT89004" class="figure">
<p class="titleinfigure"><a id="i4902"></a>Figure 12-6 Data Block Format</p>
<img width="372" height="320" src="img/cncpt028.gif" alt="Description of Figure 12-6 follows" /><br />
<a id="sthref1489" href="img_text/cncpt028.htm">Description of "Figure 12-6 Data Block Format"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="CIHHDIII"></a>
<div id="CNCPT1050" class="sect3">
<h4 class="sect3">Data Block Overhead</h4>
<p>Oracle Database uses the <a href="glossary.htm#CHDGHHEI"><span class="xrefglossterm">block overhead</span></a> to manage the block itself. The block overhead is not available to store user data. As shown in <a href="#i4902">Figure 12-6</a>, the block overhead includes the following parts:</p>
<ul>
<li>
<p><a id="sthref1490"></a>Block header</p>
<p>This part contains general information about the block, including disk address and segment type. For blocks that are transaction-managed, the <a href="glossary.htm#CHDHJIAJ"><span class="xrefglossterm">block header</span></a> contains active and historical transaction information.</p>
<p>A <span class="bold">transaction entry</span> is required for every transaction that updates the block. Oracle Database initially reserves space in the block header for transaction entries. In data blocks allocated to segments that support transactional changes, free space can also hold transaction entries when the header space is depleted. The space required for transaction entries is operating system dependent. However, transaction entries in most operating systems require approximately 23 bytes.</p>
</li>
<li>
<p><a id="sthref1491"></a>Table directory</p>
<p>For a <a href="glossary.htm#CHDBJDCA"><span class="xrefglossterm">heap-organized table</span></a>, this directory contains metadata about tables whose rows are stored in this block. Multiple tables can store rows in the same block.</p>
</li>
<li>
<p>Row directory</p>
<p><a id="sthref1492"></a><a id="sthref1493"></a><a id="sthref1494"></a>For a heap-organized table, this directory describes the location of rows in the data portion of the block.</p>
<p>After space has been allocated in the row directory, the database does not reclaim this space after row deletion. Thus, a block that is currently empty but formerly had up to 50 rows continues to have 100 bytes allocated for the row directory. The database reuses this space only when new rows are inserted in the block.</p>
</li>
</ul>
<p>Some parts of the block overhead are fixed in size, but the total size is variable. On average, the block overhead totals 84 to 107 bytes.</p>
</div>
<!-- class="sect3" -->
<a id="CIHJJBDD"></a>
<div id="CNCPT1051" class="sect3">
<h4 class="sect3">Row Format</h4>
<p>The row data part of the block contains the actual data, such as table rows or index key entries. <a id="sthref1495"></a><a id="sthref1496"></a>Just as every data block has an internal format, every row has a <span class="bold">row format</span> that enables the database to track the data in the row.</p>
<p>Oracle Database stores rows as variable-length records. A row is contained in one or more <span class="bold">row pieces</span>. Each row piece has a <span class="bold">row header</span> and <span class="bold">column data</span>.</p>
<p><a href="#i20134">Figure 12-7</a> shows the format of a row.</p>
<div id="CNCPT89005" class="figure">
<p class="titleinfigure"><a id="i20134"></a>Figure 12-7 The Format of a Row Piece</p>
<img width="479" height="395" src="img/cncpt043.gif" alt="Description of Figure 12-7 follows" /><br />
<a id="sthref1497" href="img_text/cncpt043.htm">Description of "Figure 12-7 The Format of a Row Piece"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="CNCPT89006" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1498"></a>
<h5 class="sect4">Row Header</h5>
<p>Oracle Database uses the row header to manage the row piece stored in the block. The row header contains information such as the following:</p>
<ul>
<li>
<p>Columns in the row piece</p>
</li>
<li>
<p>Pieces of the row located in other data blocks</p>
<p>If an entire row can be inserted into a single data block, then Oracle Database stores the row as one row piece. However, if all of the row data cannot be inserted into a single block or an update causes an existing row to outgrow its block, then the database stores the row in multiple row pieces (see <a href="#BABEEAAE">"Chained and Migrated Rows"</a>). A data block usually contains only one row piece per row.</p>
</li>
<li>
<p>Cluster keys for <a href="glossary.htm#BGBCACEI"><span class="xrefglossterm">table clusters</span></a> (see <a href="tablecls.htm#i25478">"Overview of Table Clusters"</a>)</p>
</li>
</ul>
<p>A row fully contained in one block has at least 3 bytes of row header.</p>
</div>
<!-- class="sect4" -->
<div id="CNCPT89007" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1499"></a>
<h5 class="sect4">Column Data</h5>
<p>After the row header, the column data section stores the actual data in the row. The row piece usually stores columns in the order listed in the <code dir="ltr">CREATE TABLE</code> statement, but this order is not guaranteed. For example, columns of type <code dir="ltr">LONG</code> are created last.</p>
<p>As shown in <a href="#i20134">Figure 12-7</a>, for each column in a row piece, Oracle Database stores the column length and data separately. The space required depends on the data type. If the data type of a column is variable length, then the space required to hold a value can grow and shrink with updates to the data.</p>
<p>Each row has a slot in the row directory of the data block header. The slot points to the beginning of the row.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="tablecls.htm#i20438">"Table Storage"</a> and <a href="indexiot.htm#CBBFIFAB">"Index Storage"</a></div>
</div>
<!-- class="sect4" -->
<a id="BABFFFCE"></a>
<div id="CNCPT89008" class="sect4">
<h5 class="sect4">Rowid Format</h5>
<p>Oracle Database uses a <a href="glossary.htm#CHDEFIHG"><span class="xrefglossterm">rowid</span></a> to uniquely identify a row. Internally, the rowid is a structure that holds information that the database needs to access a row. A rowid is not physically stored in the database, but is inferred from the file and block on which the data is stored.</p>
<p>An <span class="bold">extended rowid</span> includes a data object number. This rowid type uses a base 64 encoding of the physical address for each row. The encoding characters are <code dir="ltr">A-Z</code>, <code dir="ltr">a-z</code>, <code dir="ltr">0-9</code>, <code dir="ltr">+</code>, and <code dir="ltr">/</code>.</p>
<p><a href="#BABJJJIB">Example 12-1</a> queries the <code dir="ltr">ROWID</code> <a href="glossary.htm#CHDJADFD"><span class="xrefglossterm">pseudocolumn</span></a> to show the extended rowid of the row in the <code dir="ltr">employees</code> table for employee 100.</p>
<div id="CNCPT89009" class="example">
<p class="titleinexample"><a id="BABJJJIB"></a>Example 12-1 ROWID Pseudocolumn</p>
<pre dir="ltr">
SQL&gt; SELECT ROWID FROM employees WHERE employee_id = 100;
 
ROWID
------------------
AAAPecAAFAAAABSAAA
</pre></div>
<!-- class="example" -->
<p><a href="#CBBFDAHG">Figure 12-8</a> illustrates the format of an extended rowid.</p>
<div id="CNCPT89010" class="figure">
<p class="titleinfigure"><a id="CBBFDAHG"></a>Figure 12-8 ROWID Format</p>
<img width="536" height="90" src="img/cncpt249.gif" alt="Description of Figure 12-8 follows" /><br />
<a id="sthref1500" href="img_text/cncpt249.htm">Description of "Figure 12-8 ROWID Format"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a id="sthref1501"></a><a id="sthref1502"></a><a id="sthref1503"></a><a id="sthref1504"></a>An extended rowid is displayed in a four-piece format, <code dir="ltr">OOOOOOFFFBBBBBBRRR</code>, with the format divided into the following components:</p>
<ul>
<li>
<p><code dir="ltr">OOOOOO</code></p>
<p>The <span class="bold">data object number</span> identifies the segment (data object <code dir="ltr">AAAPec</code> in <a href="#BABJJJIB">Example 12-1</a>). A data object number is assigned to every database segment. Schema objects in the same segment, such as a <a href="glossary.htm#CHDJGGGF"><span class="xrefglossterm">table cluster</span></a>, have the same data object number.</p>
</li>
<li>
<p><code dir="ltr">FFF</code></p>
<p>The tablespace-relative <span class="bold">data file number</span> identifies the data file that contains the row (file <code dir="ltr">AAF</code> in <a href="#BABJJJIB">Example 12-1</a>).</p>
</li>
<li>
<p><code dir="ltr">BBBBBB</code></p>
<p>The <span class="bold">data block number</span> identifies the block that contains the row (block <code dir="ltr">AAAABS</code> in <a href="#BABJJJIB">Example 12-1</a>). Block numbers are relative to their data file, not their tablespace. Thus, two rows with identical block numbers could reside in different data files of the same tablespace.</p>
</li>
<li>
<p><code dir="ltr">RRR</code></p>
<p>The <span class="bold">row number</span> identifies the row in the block (row <code dir="ltr">AAA</code> in <a href="#BABJJJIB">Example 12-1</a>).</p>
</li>
</ul>
<p>After a rowid is assigned to a row piece, the rowid can change in special circumstances. For example, if <span class="bold">row movement</span> is enabled, then the rowid can change because of partition key updates, Flashback Table operations, shrink table operations, and so on. If row movement is disabled, then a rowid can change if the row is exported and imported using Oracle Database utilities.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Internally, the database performs row movement as if the row were physically deleted and reinserted. However, row movement is considered an update, which has implications for triggers.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="tablecls.htm#CBBBHABC">"Rowid Data Types"</a></p>
</li>
<li>
<p><a class="olink SQLRF50998" href="../../server.112/e41084/sql_elements001.htm#SQLRF50998"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about rowids</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGEAAF"></a>
<div id="CNCPT89139" class="sect2">
<h3 class="sect2">Data Block Compression</h3>
<p><a id="CNCPT89140"></a><a id="sthref1505"></a>The <a id="sthref1506"></a>database can use <a href="glossary.htm#CHDJCICJ"><span class="xrefglossterm">table compression</span></a> to eliminate duplicate values in a data block (see <a href="tablecls.htm#CBBFAAII">"Table Compression"</a>). This section describes the format of data blocks that use compression.</p>
<p>The format of a data block that uses basic and advanced row compression is essentially the same as an uncompressed block. The difference is that a <span class="bold">symbol table</span> at the beginning of the block stores duplicate values for the rows and columns. The database replaces occurrences of these values with a short reference to the symbol table.</p>
<p>Assume that the rows in <a href="#BABDHEFC">Example 12-2</a> are stored in a data block for the seven-column <code dir="ltr">sales</code> table.</p>
<div id="CNCPT89141" class="example">
<p class="titleinexample"><a id="BABDHEFC"></a>Example 12-2 Rows in sales Table</p>
<pre dir="ltr">
2190,13770,25-NOV-00,S,9999,23,161
2225,15720,28-NOV-00,S,9999,25,1450
34005,120760,29-NOV-00,P,9999,44,2376
9425,4750,29-NOV-00,I,9999,11,979
1675,46750,29-NOV-00,S,9999,19,1121
</pre></div>
<!-- class="example" -->
<p>When basic or advanced row compression is applied to this table, the database replaces duplicate values with a symbol reference. <a href="#BABHACII">Example 12-3</a> is a conceptual representation of the compression in which the symbol <code dir="ltr">*</code> replaces <code dir="ltr">29-NOV-00</code> and <code dir="ltr">%</code> replaces <code dir="ltr">9999</code>.</p>
<div id="CNCPT89142" class="example">
<p class="titleinexample"><a id="BABHACII"></a>Example 12-3 OLTP Compressed Rows in sales Table</p>
<pre dir="ltr">
2190,13770,25-NOV-00,S,%,23,161
2225,15720,28-NOV-00,S,%,25,1450
34005,120760,*,P,%,44,2376
9425,4750,*,I,%,11,979
1675,46750,*,S,%,19,1121
</pre></div>
<!-- class="example" -->
<p><a href="#BABCFDJG">Table 12-1</a> conceptually represents the symbol table that maps symbols to values.</p>
<div id="CNCPT89143" class="tblformal">
<p class="titleintable"><a id="sthref1507"></a><a id="BABCFDJG"></a>Table 12-1 Symbol Table</p>
<table class="cellalignment1458" title="Symbol Table" summary="Symbol values" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t12">Symbol</th>
<th class="cellalignment1459" id="r1c2-t12">Value</th>
<th class="cellalignment1459" id="r1c3-t12">Column</th>
<th class="cellalignment1459" id="r1c4-t12">Rows</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t12" headers="r1c1-t12">
<p>*</p>
</td>
<td class="cellalignment1455" headers="r2c1-t12 r1c2-t12">
<p>29-NOV-00</p>
</td>
<td class="cellalignment1455" headers="r2c1-t12 r1c3-t12">
<p>3</p>
</td>
<td class="cellalignment1455" headers="r2c1-t12 r1c4-t12">
<p>958-960</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t12" headers="r1c1-t12">
<p>%</p>
</td>
<td class="cellalignment1455" headers="r3c1-t12 r1c2-t12">
<p>9999</p>
</td>
<td class="cellalignment1455" headers="r3c1-t12 r1c3-t12">
<p>5</p>
</td>
<td class="cellalignment1455" headers="r3c1-t12 r1c4-t12">
<p>956-960</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="i13690"></a>
<div id="CNCPT1053" class="sect2">
<h3 class="sect2">Space Management in Data Blocks<a id="sthref1508"></a><a id="sthref1509"></a></h3>
<p>As the database fills a data block from the bottom up, the amount of <span class="bold">free space</span> between the row data and the block header decreases. This free space can also shrink during updates, as when changing a trailing null to a nonnull value. The database manages free space in the data block to optimize performance and avoid wasted space.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This section assumes the use of automatic segment space management.</div>
<a id="BABBAJHC"></a>
<div id="CNCPT1057" class="sect3">
<h4 class="sect3">Percentage of Free Space in Data Blocks</h4>
<p><a id="sthref1510"></a><a id="sthref1511"></a>The <code dir="ltr">PCTFREE</code> storage parameter is essential to how the database manages free space. This SQL parameter sets the minimum percentage of a data block reserved as free space for updates to existing rows. Thus, <code dir="ltr">PCTFREE</code> is important for preventing row migration and avoiding wasted space.</p>
<p>For example, assume that you create a table that will require only occasional updates, most of which will not increase the size of the existing data. You specify the <code dir="ltr">PCTFREE</code> parameter within a <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement as follows:</p>
<pre dir="ltr">
CREATE TABLE test_table (n NUMBER) PCTFREE 20;
</pre>
<p><a href="#BABHHIDA">Figure 12-9</a> shows how a <code dir="ltr">PCTFREE</code> setting of <code dir="ltr">20</code> affects space management. The database adds rows to the block over time, causing the row data to grow upwards toward the block header, which is itself expanding downward toward the row data. The <code dir="ltr">PCTFREE</code> setting ensures that <span class="italic">at least</span> 20% of the data block is free. For example, the database prevents an <code dir="ltr">INSERT</code> statement from filling the block so that the row data and header occupy a combined 90% of the total block space, leaving only 10% free.</p>
<div id="CNCPT89011" class="figure">
<p class="titleinfigure"><a id="BABHHIDA"></a>Figure 12-9 PCTFREE</p>
<img width="462" height="341" src="img/cncpt029.gif" alt="Description of Figure 12-9 follows" /><br />
<a id="sthref1512" href="img_text/cncpt029.htm">Description of "Figure 12-9 PCTFREE"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
This discussion does not apply to <a href="glossary.htm#CHDHHDDI"><span class="xrefglossterm">LOB</span></a> data types, which do not use the <code dir="ltr">PCTFREE</code> storage parameter or free lists. See <a href="cncptdev.htm#CHDHBGHD">"Overview of LOBs"</a>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF52292" href="../../server.112/e41084/clauses007.htm#SQLRF52292"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax and semantics of the <code dir="ltr">PCTFREE</code> parameter</div>
</div>
<!-- class="sect3" -->
<div id="CNCPT1054" class="sect3"><a id="sthref1513"></a>
<h4 class="sect3">Optimization of Free Space in Data Blocks</h4>
<p>While the percentage of free space cannot be <span class="italic">less</span> than <code dir="ltr">PCTFREE</code>, the amount of free space can be <span class="italic">greater</span>. <a id="sthref1514"></a>For example, a <code dir="ltr">PCTFREE</code> setting of 20% prevents the total amount of free space from dropping to 5% of the block, but permits 50% of the block to be free space. The following SQL statements can increase free space:</p>
<ul>
<li>
<p><code dir="ltr">DELETE</code> statements</p>
</li>
<li>
<p><code dir="ltr">UPDATE</code> statements that either update existing values to smaller values or increase existing values and force a row to migrate</p>
</li>
<li>
<p><code dir="ltr">INSERT</code> statements on a table that uses OLTP compression</p>
<p>If inserts fill a block with data, then the database invokes block compression, which may result in the block having more free space.</p>
</li>
</ul>
<p>The space released is available for <code dir="ltr">INSERT</code> statements under the following conditions:</p>
<ul>
<li>
<p>If the <code dir="ltr">INSERT</code> statement is in the same transaction and after the statement that frees space, then the statement can use the space.</p>
</li>
<li>
<p>If the <code dir="ltr">INSERT</code> statement is in a separate transaction from the statement that frees space (perhaps run by another user), then the statement can use the space made available only after the other transaction commits and only if the space is needed.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11630" href="../../server.112/e25494/tables.htm#ADMIN11630"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn about OLTP compression</div>
<div id="CNCPT89012" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1515"></a>
<h5 class="sect4">Coalescing Fragmented Space</h5>
<p><a id="sthref1516"></a>Released space may or may not be contiguous with the main area of free space in a data block, as shown in <a href="#BABJHCCE">Figure 12-10</a>. Noncontiguous free space is called <span class="bold">fragmented space</span>.</p>
<div id="CNCPT89013" class="figure">
<p class="titleinfigure"><a id="BABJHCCE"></a>Figure 12-10 Data Block with Fragmented Space</p>
<img width="272" height="329" src="img/cncpt210.gif" alt="Description of Figure 12-10 follows" /><br />
<a id="sthref1517" href="img_text/cncpt210.htm">Description of "Figure 12-10 Data Block with Fragmented Space"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Oracle Database automatically and transparently coalesces the free space of a data block <span class="italic">only</span> when the following conditions are true:</p>
<ul>
<li>
<p>An <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement attempts to use a block that contains sufficient free space to contain a new row piece.</p>
</li>
<li>
<p>The free space is fragmented so that the row piece cannot be inserted in a contiguous section of the block.</p>
</li>
</ul>
<p>After coalescing, the amount of free space is identical to the amount before the operation, but the space is now contiguous. <a href="#BABIIACD">Figure 12-11</a> shows a data block after space has been coalesced.</p>
<div id="CNCPT89014" class="figure">
<p class="titleinfigure"><a id="BABIIACD"></a>Figure 12-11 Data Block After Coalescing Free Space</p>
<img width="270" height="329" src="img/cncpt211.gif" alt="Description of Figure 12-11 follows" /><br />
<a id="sthref1518" href="img_text/cncpt211.htm">Description of "Figure 12-11 Data Block After Coalescing Free Space"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Oracle Database performs coalescing only in the preceding situations because otherwise performance would decrease because of the continuous coalescing of the free space in data blocks.</p>
</div>
<!-- class="sect4" -->
<a id="BABICEEC"></a>
<div id="CNCPT89015" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Reuse of Index Space</h5>
<p>The database can reuse space within an index block. For example, if you insert a value into a column and delete it, and if an index exists on this column, then the database can reuse the index slot when a row requires it.</p>
<p>The database can reuse an index block itself. Unlike a table block, an index block only becomes free when it is empty. The database places the empty block on the free list of the index structure and makes it eligible for reuse. However, Oracle Database does not automatically compact the index: an <code dir="ltr">ALTER INDEX REBUILD</code> or <code dir="ltr">COALESCE</code> statement is required.</p>
<p><a href="#BABIBCII">Figure 12-12</a> represents an index of the <code dir="ltr">employees.department_id</code> column before the index is coalesced. The first three leaf blocks are only partially full, as indicated by the gray fill lines.</p>
<div id="CNCPT89165" class="figure">
<p class="titleinfigure"><a id="BABIBCII"></a>Figure 12-12 Index Before Coalescing</p>
<img width="662" height="474" src="img/cncpt294.gif" alt="Description of Figure 12-12 follows" /><br />
<a id="sthref1519" href="img_text/cncpt294.htm">Description of "Figure 12-12 Index Before Coalescing"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#BABJACFA">Figure 12-13</a> shows the index in <a href="#BABIBCII">Figure 12-12</a> after the index has been coalesced. The first two leaf blocks are now full, as indicated by the gray fill lines, and the third leaf block has been freed.</p>
<div id="CNCPT89166" class="figure">
<p class="titleinfigure"><a id="BABJACFA"></a>Figure 12-13 Index After Coalescing</p>
<img width="662" height="474" src="img/cncpt295.gif" alt="Description of Figure 12-13 follows" /><br />
<a id="sthref1520" href="img_text/cncpt295.htm">Description of "Figure 12-13 Index After Coalescing"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11720" href="../../server.112/e25494/indexes.htm#ADMIN11720"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to coalesce and rebuild indexes</p>
</li>
<li>
<p><a class="olink SQLRF00617" href="../../server.112/e41084/functions030.htm#SQLRF00617"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code dir="ltr">COALESCE</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABEEAAE"></a>
<div id="CNCPT1055" class="sect3">
<h4 class="sect3">Chained and Migrated Rows</h4>
<p><a id="sthref1521"></a><a id="sthref1522"></a><a id="sthref1523"></a>Oracle Database must manage rows that are too large to fit into a single block. The following situations are possible:</p>
<ul>
<li>
<p>The row is too large to fit into one data block when it is first inserted.</p>
<p>In <a href="glossary.htm#CHDBBFFC"><span class="xrefglossterm">row chaining</span></a>, Oracle Database stores the data for the row in a <span class="bold">chain</span> of one or more data blocks reserved for the segment. Row chaining most often occurs with large rows. Examples include rows that contain a column of data type <code dir="ltr">LONG</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, a <code dir="ltr">VARCHAR2(4000)</code> column in a 2 KB block, or a row with a huge number of columns. Row chaining in these cases is unavoidable.</p>
</li>
<li>
<p><a id="sthref1524"></a>A row that originally fit into one data block is updated so that the overall row length increases, but insufficient free space exists to hold the updated row.</p>
<p>In <a href="glossary.htm#CHDCDHDF"><span class="xrefglossterm">row migration</span></a>, Oracle Database moves the entire row to a new data block, assuming the row can fit in a new block. <a id="sthref1525"></a>The original row piece of a migrated row contains a pointer or "forwarding address" to the new block containing the migrated row. The rowid of a migrated row does not change.</p>
</li>
<li>
<p>A row has more than 255 columns.</p>
<p>Oracle Database can only store 255 columns in a row piece. Thus, if you insert a row into a table that has 1000 columns, then the database creates 4 row pieces, typically chained over multiple blocks.</p>
</li>
</ul>
<p><a href="#BABFBDIH">Figure 12-14</a> depicts shows the insertion of a large row in a data block. The row is too large for the left block, so the database chains the row by placing the first row piece in the left block and the second row piece in the right block.</p>
<div id="CNCPT89017" class="figure">
<p class="titleinfigure"><a id="BABFBDIH"></a>Figure 12-14 Row Chaining</p>
<img width="506" height="330" src="img/cncpt316.gif" alt="Description of Figure 12-14 follows" /><br />
<a id="sthref1526" href="img_text/cncpt316.htm">Description of "Figure 12-14 Row Chaining"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#BABBGEGE">Figure 12-15</a>, the left block contains a row that is updated so that the row is now too large for the block. The database moves the entire row to the right block and leaves a pointer to the migrated row in the left block.</p>
<div id="CNCPT89167" class="figure">
<p class="titleinfigure"><a id="BABBGEGE"></a>Figure 12-15 Row Migration</p>
<img width="509" height="329" src="img/cncpt306.gif" alt="Description of Figure 12-15 follows" /><br />
<a id="sthref1527" href="img_text/cncpt306.htm">Description of "Figure 12-15 Row Migration"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When a row is chained or migrated, the I/O needed to retrieve the data increases. This situation results because Oracle Database must scan multiple blocks to retrieve the information for the row. For example, if the database performs one I/O to read an index and one I/O to read a nonmigrated table row, then an additional I/O is required to obtain the data for a migrated row.</p>
<p>The Segment Advisor, which can be run both manually and automatically, is an Oracle Database component that identifies segments that have space available for reclamation. The advisor can offer advice about objects that have significant free space or too many chained rows.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="tablecls.htm#i4383">"Row Storage"</a> and <a href="tablecls.htm#i20957">"Rowids of Row Pieces"</a></p>
</li>
<li>
<p><a class="olink ADMQS0625" href="../../server.112/e10897/storage.htm#ADMQS0625"><span class="italic">Oracle Database 2 Day DBA</span></a> and <a class="olink ADMIN01401" href="../../server.112/e25494/schema.htm#ADMIN01401"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to reclaim wasted space</p>
</li>
<li>
<p><a class="olink PFGRF94470" href="../../server.112/e41573/instance_tune.htm#PFGRF94470"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn about reducing chained and migrated rows</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i4896"></a>
<div id="CNCPT303" class="sect1">
<h2 class="sect1">Overview of Extents</h2>
<p><a id="sthref1528"></a><a id="sthref1529"></a><a id="sthref1530"></a>A<a id="sthref1531"></a><a id="sthref1532"></a>n <span class="bold">extent</span> is a logical unit of database storage space allocation made up of contiguous data blocks. Data blocks in an extent are logically contiguous but can be physically spread out on disk because of RAID striping and file system implementations.</p>
<a id="CIHEFHDF"></a>
<div id="CNCPT1060" class="sect2">
<h3 class="sect2">Allocation of Extents</h3>
<p>By default, the database allocates an <span class="bold">initial extent</span> for a data segment when the segment is created. An extent is always contained in one data file.</p>
<p>Although no data has been added to the segment, the data blocks in the initial extent are reserved for this segment exclusively. The first data block of every segment contains a directory of the extents in the segment. <a href="#BABFIFCF">Figure 12-16</a> shows the initial extent in a segment in a data file that previously contained no data.</p>
<div id="CNCPT89018" class="figure">
<p class="titleinfigure"><a id="BABFIFCF"></a>Figure 12-16 Initial Extent of a Segment</p>
<img width="512" height="278" src="img/cncpt274.gif" alt="Description of Figure 12-16 follows" /><br />
<a id="sthref1533" href="img_text/cncpt274.htm">Description of "Figure 12-16 Initial Extent of a Segment"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a id="sthref1534"></a>If the initial extent become full, and if more space is required, then the database automatically allocates an <span class="bold">incremental extent</span> for this segment. An incremental extent is a subsequent extent created for the segment.</p>
<p>The allocation algorithm depends on whether the tablespace is locally managed or dictionary-managed. In the locally managed case, the database searches the bitmap of a data file for adjacent free blocks. If the data file has insufficient space, then the database looks in another data file. Extents for a segment are always in the same tablespace but may be in different data files.</p>
<p><a href="#BABGHIED">Figure 12-17</a> shows that the database can allocate extents for a segment in any data file in the tablespace. For example, the segment can allocate the initial extent in <code dir="ltr">users01.dbf</code>, allocate the first incremental extent in <code dir="ltr">users02.dbf</code>, and allocate the next extent in <code dir="ltr">users01.dbf</code>.</p>
<div id="CNCPT89019" class="figure">
<p class="titleinfigure"><a id="BABGHIED"></a>Figure 12-17 Incremental Extent of a Segment</p>
<img width="675" height="324" src="img/cncpt278.gif" alt="Description of Figure 12-17 follows" /><br />
<a id="sthref1535" href="img_text/cncpt278.htm">Description of "Figure 12-17 Incremental Extent of a Segment"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The blocks of a newly allocated extent, although they were free, may not be empty of old data. In ASSM, Oracle Database formats the blocks of a newly allocated extent when it starts using the extent, but only as needed (see <a href="#BABEEGEJ">"Segment Space and the High Water Mark"</a>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This section applies to serial operations, in which one <a href="glossary.htm#i432734"><span class="xrefglossterm">server process</span></a> parses and runs a statement. Extents are allocated differently in parallel SQL statements, which entail multiple server processes.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11660" href="../../server.112/e25494/tables.htm#ADMIN11660"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manually allocate extents</div>
</div>
<!-- class="sect2" -->
<a id="CIHDACAC"></a>
<div id="CNCPT1063" class="sect2">
<h3 class="sect2">Deallocation of Extents</h3>
<p>In general, the extents of a user segment do not return to the tablespace unless you drop the object using a <code dir="ltr">DROP</code> command. In Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2), you can also drop the segment using the <code dir="ltr">DBMS_SPACE_ADMIN</code> package. For example, if you delete all rows in a table, then the database does not reclaim the data blocks for use by other objects in the tablespace.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In an undo segment, Oracle Database periodically deallocates one or more extents if it has the <code dir="ltr">OPTIMAL</code> size specified or if the database is in <a href="glossary.htm#i997760"><span class="xrefglossterm">automatic undo management mode</span></a> (see <a href="#i10698">"Undo Tablespaces"</a>).</div>
<p>In some circumstances, you can manually deallocate space. The Oracle Segment Advisor helps determine whether an object has space available for reclamation based on the level of fragmentation in the object. The following techniques can free extents:</p>
<ul>
<li>
<p>You can use an <span class="bold">online segment shrink</span> to reclaim fragmented space in a segment. Segment shrink is an online, in-place operation. In general, data compaction leads to better cache utilization and requires fewer blocks to be read in a <a href="glossary.htm#CHDCGIFF"><span class="xrefglossterm">full table scan</span></a>.</p>
</li>
<li>
<p>You can move the data of a nonpartitioned table or table partition into a new segment, and optionally into a different tablespace for which you have quota.</p>
</li>
<li>
<p>You can rebuild or coalesce the index (see <a href="#BABICEEC">"Reuse of Index Space"</a>).</p>
</li>
<li>
<p>You can <span class="bold">truncate</span> a table or table cluster, which removes all rows. By default, Oracle Database deallocates all space used by the removed rows except that specified by the <code dir="ltr">MINEXTENTS</code> storage parameter. In Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2), you can also use <code dir="ltr">TRUNCATE</code> with the <code dir="ltr">DROP ALL STORAGE</code> option to drop entire segments.</p>
</li>
<li>
<p>You can deallocate unused space, which frees the unused space at the high water mark end of the database segment and makes the space available for other segments in the tablespace (see <a href="#BABEEGEJ">"Segment Space and the High Water Mark"</a>).</p>
</li>
</ul>
<p>When extents are freed, Oracle Database modifies the bitmap in the data file for locally managed tablespaces to reflect the regained extents as available space. Any data in the blocks of freed extents becomes inaccessible.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN01401" href="../../server.112/e25494/schema.htm#ADMIN01401"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to reclaim segment space</div>
</div>
<!-- class="sect2" -->
<a id="i17502"></a>
<div id="CNCPT1061" class="sect2">
<h3 class="sect2">Storage Parameters for Extents</h3>
<p>Every segment is defined by <span class="bold"><a id="sthref1536"></a><a id="sthref1537"></a><a id="sthref1538"></a>storage parameters</span> expressed in terms of extents. These parameters control how Oracle Database allocates free space for a segment.</p>
<p>The storage settings are determined in the following order of precedence, with setting higher on the list overriding settings lower on the list:</p>
<ol>
<li>
<p>Segment storage clause</p>
</li>
<li>
<p>Tablespace storage clause</p>
</li>
<li>
<p>Oracle Database default</p>
</li>
</ol>
<p>A locally managed tablespace can have either uniform extent sizes or variable extent sizes determined automatically by the system:</p>
<ul>
<li>
<p>For <span class="bold">uniform extents</span>, you can specify an extent size or use the default size of 1 MB. All extents in the tablespace are of this size. Locally managed temporary tablespaces can only use this type of allocation.</p>
</li>
<li>
<p>For <span class="bold">automatically allocated extents</span>, Oracle Database determines the optimal size of additional extents.</p>
</li>
</ul>
<p>For locally managed tablespaces, some storage parameters cannot be specified at the tablespace level. However, you can specify these parameters at the segment level. In this case, the databases uses all parameters together to compute the initial size of the segment. Internal algorithms determine the subsequent size of each extent.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink ADMIN11361" href="../../server.112/e25494/tspaces.htm#ADMIN11361"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn about extent management considerations when creating a locally managed tablespace</p>
</li>
<li>
<p><a class="olink SQLRF30013" href="../../server.112/e41084/clauses009.htm#SQLRF30013"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about options in the storage clause</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i10405"></a>
<div id="CNCPT304" class="sect1">
<h2 class="sect1">Overview of Segments</h2>
<p>A segment is a set of extents that contains all the data for a logical storage structure within a tablespace. For example, Oracle Database allocates one or more extents to form the data segment for a table. The database also allocates one or more extents to form the index segment for a table.<a id="sthref1539"></a><a id="sthref1540"></a><a id="sthref1541"></a><a id="sthref1542"></a><a id="sthref1543"></a><a id="sthref1544"></a></p>
<p>As explained in <a href="#i4345">"Logical Space Management"</a>, Oracle Database manages segment space automatically or manually. This section assumes the use of ASSM.</p>
<a id="i10303"></a>
<div id="CNCPT1070" class="sect2">
<h3 class="sect2">User Segments</h3>
<p><a id="sthref1545"></a><a id="sthref1546"></a>A single data segment in a database stores the data for one user object. There are different types of segments. Examples of <span class="bold">user segments</span> include:</p>
<ul>
<li>
<p><a id="sthref1547"></a>Table, table partition, or table cluster</p>
</li>
<li>
<p><a href="glossary.htm#CHDHHDDI"><span class="xrefglossterm">LOB</span></a> or LOB partition</p>
</li>
<li>
<p>Index or index partition</p>
</li>
</ul>
<p>Each nonpartitioned object and object partition is stored in its own segment. For example, if an index has five partitions, then five segments contain the index data.</p>
<a id="BABCHJFH"></a>
<div id="CNCPT998" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">User Segment Creation</h4>
<p>By default, the database uses <span class="bold">deferred segment creation</span> to update only database metadata when creating tables and indexes. Starting in Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2), the database also defers segment creation when creating partitions. When a user inserts the first row into a table or partition, the database creates segments for the table or partition, its LOB columns, and its indexes.</p>
<p>Deferred segment creation enables you to avoid using database resources unnecessarily. For example, installation of an application can create thousands of objects, consuming significant disk space. Many of these objects may never be used.</p>
<p>You can use the <code dir="ltr">DBMS_SPACE_ADMIN</code> package to manage segments for empty objects. Starting with Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2), you can use this PL/SQL package to do the following:</p>
<ul>
<li>
<p>Manually materialize segments for empty tables or partitions that do not have segments created</p>
</li>
<li>
<p>Remove segments from empty tables or partitions that currently have an empty segment allocated</p>
</li>
</ul>
<p>To best illustrate the relationship between object creation and segment creation, assume that deferred segment creation is disabled. You create a table as follows:</p>
<pre dir="ltr">
CREATE TABLE test_table (my_column NUMBER);
</pre>
<p>As shown in <a href="#BABCHBJC">Figure 12-18</a>, the database creates one segment for the table.</p>
<div id="CNCPT89020" class="figure">
<p class="titleinfigure"><a id="BABCHBJC"></a>Figure 12-18 Creation of a User Segment</p>
<img width="455" height="119" src="img/cncpt246.gif" alt="Description of Figure 12-18 follows" /><br />
<a id="sthref1548" href="img_text/cncpt246.htm">Description of "Figure 12-18 Creation of a User Segment"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When you create a table with a <a href="glossary.htm#i432585"><span class="xrefglossterm">primary key</span></a> or unique key, Oracle Database automatically creates an index for this key. <a id="sthref1549"></a>Again assume that deferred segment creation is disabled. You create a table as follows:</p>
<pre dir="ltr">
CREATE TABLE lob_table (my_column NUMBER PRIMARY KEY, clob_column CLOB);
</pre>
<p><a href="#BABJJADA">Figure 12-19</a> shows that the data for <code dir="ltr">lob_table</code> is stored in one segment, while the implicitly created index is in a different segment. Also, the CLOB data is stored in its own segment, as is its associated CLOB index (see <a href="cncptdev.htm#CHDHCHIC">"Internal LOBs"</a>). Thus, the <code dir="ltr">CREATE TABLE</code> statement results in the creation of <span class="italic">four</span> different segments.</p>
<div id="CNCPT89021" class="figure">
<p class="titleinfigure"><a id="BABJJADA"></a>Figure 12-19 Multiple Segments</p>
<img width="455" height="321" src="img/cncpt245.gif" alt="Description of Figure 12-19 follows" /><br />
<a id="sthref1550" href="img_text/cncpt245.htm">Description of "Figure 12-19 Multiple Segments"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The segments of a table and the index for this table do not have to occupy the same tablespace.</div>
<p>The database allocates one or more extents when a segment is created. Storage parameters for the object determine how the extents for each segment are allocated (see <a href="#i17502">"Storage Parameters for Extents"</a>). The parameters affect the efficiency of data retrieval and storage for the data segment associated with the object.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN13319" href="../../server.112/e25494/tables.htm#ADMIN13319"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manage deferred segment creation</p>
</li>
<li>
<p><a class="olink REPLN265" href="../../server.112/e10706/repmview.htm#REPLN265"><span class="italic">Oracle Database Advanced Replication</span></a> for information on materialized views and materialized view logs</p>
</li>
<li>
<p><a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">CREATE TABLE</code> syntax</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i5696"></a>
<div id="CNCPT1072" class="sect2">
<h3 class="sect2">Temporary Segments</h3>
<p><a id="sthref1551"></a><a id="sthref1552"></a>When processing a <a href="glossary.htm#CHDCAGGJ"><span class="xrefglossterm">query</span></a>, Oracle Database often requires temporary workspace for intermediate stages of SQL statement execution. Typical operations that may require a <a href="glossary.htm#i996732"><span class="xrefglossterm">temporary segment</span></a> include sorting, <a href="glossary.htm#CHDJAJHF"><span class="xrefglossterm">hashing</span></a>, and merging bitmaps. While creating an index, Oracle Database also places index segments into temporary segments and then converts them into permanent segments when the index is complete.</p>
<p>Oracle Database does not create a temporary segment if an operation can be performed in memory. However, if memory use is not possible, then the database automatically allocates a temporary segment on disk.</p>
<a id="CIHCFAEI"></a>
<div id="CNCPT1076" class="sect3">
<h4 class="sect3"><a id="sthref1553"></a>Allocation of Temporary Segments for Queries</h4>
<p><a id="sthref1554"></a><a id="sthref1555"></a>Oracle Database<a id="sthref1556"></a> allocates temporary segments for queries as needed during a use<a id="sthref1557"></a>r session and drops them when the query completes. Changes to temporary segments are not recorded in the <a href="glossary.htm#i997641"><span class="xrefglossterm">online redo log</span></a>, except for space management operations on the temporary segment (see <a href="physical.htm#i1006163">"Overview of the Online Redo Log"</a>).</p>
<p>The database creates temporary segments in the temporary tablespace assigned to the user. The default storage characteristics of the tablespace determine the characteristics of the extents in the temporary segment. Because allocation and deallocation of temporary segments occurs frequently, the best practice is to create at least one special tablespace for temporary segments. The database distributes I/O across disks and avoids fragmenting <code dir="ltr">SYSTEM</code> and other tablespaces with temporary segments.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When <code dir="ltr">SYSTEM</code> is locally managed, you must define a default temporary tablespace at database creation. A locally managed <code dir="ltr">SYSTEM</code> tablespace cannot be used for default temporary storage.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11366" href="../../server.112/e25494/tspaces.htm#ADMIN11366"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to create temporary tablespaces</p>
</li>
<li>
<p><a class="olink SQLRF01403" href="../../server.112/e41084/statements_7003.htm#SQLRF01403"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">CREATE TEMPORARY TABLESPACE</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CIHBCGDA"></a>
<div id="CNCPT1077" class="sect3">
<h4 class="sect3">Allocation of Temporary Segments for Temporary Tables and Indexes</h4>
<p><a id="sthref1558"></a><a id="sthref1559"></a>Oracle Database can also allocate temporary segments for <a href="glossary.htm#CHDBDHDC"><span class="xrefglossterm">temporary tables</span></a> and their indexes. Temporary tables hold data that exists only for the duration of a transaction or session. Each session accesses only the extents allocated for the session and cannot access extents allocated for other sessions.</p>
<p>Oracle Database allocates segments for a temporary table when the first <code dir="ltr">INSERT</code> into that table occurs. The insertion can occur explicitly or because of <code dir="ltr">CREATE TABLE AS SELECT</code>. The first <code dir="ltr">INSERT</code> into a temporary table allocates the segments for the table and its indexes, creates the root page for the indexes, and allocates any <code dir="ltr">LOB</code> segments.</p>
<p>Segments for a temporary table are allocated in a temporary tablespace of the current user. Assume that the temporary tablespace assigned to <code dir="ltr">user1</code> is <code dir="ltr">temp1</code> and the temporary tablespace assigned to <code dir="ltr">user2</code> is <code dir="ltr">temp2</code>. In this case, <code dir="ltr">user1</code> stores temporary data in the <code dir="ltr">temp1</code> segments, while <code dir="ltr">user2</code> stores temporary data in the <code dir="ltr">temp2</code> segments.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="tablecls.htm#CBBBADBI">"Temporary Tables"</a></p>
</li>
<li>
<p><a class="olink ADMIN11633" href="../../server.112/e25494/tables.htm#ADMIN11633"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to create temporary tables</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGJJEJ"></a>
<div id="CNCPT305" class="sect2">
<h3 class="sect2">Undo Segments</h3>
<p><a id="sthref1560"></a><a id="sthref1561"></a>Oracle Database maintains records of the actions of transactions, collectively known as <a href="glossary.htm#CHDGJGEC"><span class="xrefglossterm">undo data</span></a>. Oracle Database uses undo to do the following:</p>
<ul>
<li>
<p>Roll back an <a href="glossary.htm#CHDDFIDD"><span class="xrefglossterm">active transaction</span></a></p>
</li>
<li>
<p>Recover a terminated transaction</p>
</li>
<li>
<p>Provide <a href="glossary.htm#CHDIECGD"><span class="xrefglossterm">read consistency</span></a></p>
</li>
<li>
<p>Perform some logical flashback operations</p>
</li>
</ul>
<p>Oracle Database stores undo data inside the database rather than in external logs. Undo data is stored in blocks that are updated just like data blocks, with changes to these blocks generating redo. In this way, Oracle Database can efficiently access undo data without needing to read external logs.</p>
<p>Undo data is stored in an <a href="glossary.htm#CHDGFEJI"><span class="xrefglossterm">undo tablespace</span></a>. Oracle Database provides a fully automated mechanism, known as <a href="glossary.htm#i997760"><span class="xrefglossterm">automatic undo management mode</span></a>, for managing undo segments and space in an undo tablespace.</p>
<div id="CNCPT89184" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1562"></a>
<h4 class="sect3">Undo Segments and Transactions</h4>
<p>When a transaction starts, the database binds (assigns) the transaction to an undo segment, and therefore to a <a href="glossary.htm#CHDGCICD"><span class="xrefglossterm">transaction table</span></a>, in the current undo tablespace. In rare circumstances, if the database instance does not have a designated undo tablespace, then the transaction binds to the system undo segment.</p>
<p>Multiple active transactions can write concurrently to the same undo segment or to different segments. For example, transactions T1 and T2 can both write to undo segment U1, or T1 can write to U1 while T2 writes to undo segment U2.</p>
<p>Conceptually, the extents in an undo segment form a ring. Transactions write to one undo extent, and then to the next extent in the ring, and so on in cyclical fashion. <a href="#BABGAFCA">Figure 12-20</a> shows two transactions, T1 and T2, which begin writing in the third extent (E3) of an undo segment and continue writing to the fourth extent (E4).</p>
<div id="CNCPT89185" class="figure">
<p class="titleinfigure"><a id="BABGAFCA"></a>Figure 12-20 Ring of Allocated Extents in an Undo Segment</p>
<img width="429" height="338" src="img/cncpt328.gif" alt="Description of Figure 12-20 follows" /><br />
<a id="sthref1563" href="img_text/cncpt328.htm">Description of "Figure 12-20 Ring of Allocated Extents in an Undo Segment "</a><br />
<br /></div>
<!-- class="figure" -->
<p>At any given time, a transaction writes sequentially to only one extent in an undo segment, known as the <span class="bold">current extent</span> for the transaction. Multiple active transactions can write simultaneously to the same current extent or to different current extents. <a href="#BABGAFCA">Figure 12-20</a> shows transactions T1 and T2 writing simultaneously to extent E3. Within an undo extent, a data block contains data for only one transaction.</p>
<p>As the current undo extent fills, the first transaction needing space checks the availability of the next allocated extent in the ring. If the next extent does <span class="italic">not</span> contain data from an active transaction, then this extent becomes the current extent. Now all transactions that need space can write to the new current extent. In <a href="#BABEHGDD">Figure 12-21</a>, when E4 is full, T1 and T2 continue writing to E1, overwriting the nonactive undo data in E1.</p>
<div id="CNCPT89186" class="figure">
<p class="titleinfigure"><a id="BABEHGDD"></a>Figure 12-21 Cyclical Use of Allocated Extents in an Undo Segment</p>
<img width="344" height="500" src="img/cncpt327.gif" alt="Description of Figure 12-21 follows" /><br />
<a id="sthref1564" href="img_text/cncpt327.htm">Description of "Figure 12-21 Cyclical Use of Allocated Extents in an Undo Segment"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If the next extent <span class="italic">does</span> contain data from an active transaction, then the database must allocate a new extent. <a href="#BABFECCE">Figure 12-22</a> shows a scenario in which T1 and T2 are writing to E4. When E4 fills up, the transactions cannot continue writing to E1 because E1 contains active undo entries. Therefore, the database allocates a new extent (E5) for this undo segment. The transactions continue writing to E5.</p>
<div id="CNCPT89187" class="figure">
<p class="titleinfigure"><a id="BABFECCE"></a>Figure 12-22 Allocation of a New Extent for an Undo Segment</p>
<img width="431" height="450" src="img/cncpt326.gif" alt="Description of Figure 12-22 follows" /><br />
<a id="sthref1565" href="img_text/cncpt326.htm">Description of "Figure 12-22 Allocation of a New Extent for an Undo Segment"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMQS063" href="../../server.112/e10897/storage.htm#ADMQS063"><span class="italic">Oracle Database 2 Day DBA</span></a> and <a class="olink ADMIN013" href="../../server.112/e25494/undo.htm#ADMIN013"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manage undo segments</div>
</div>
<!-- class="sect3" -->
<div id="CNCPT89188" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1566"></a>
<h4 class="sect3">Transaction Rollback</h4>
<p>When a <code dir="ltr">ROLLBACK</code> statement is issued, the database uses undo records to roll back changes made to the database by the uncommitted transaction. During recovery, the database rolls back any uncommitted changes applied from the online redo log to the data files. Undo records provide <a href="glossary.htm#CHDIECGD"><span class="xrefglossterm">read consistency</span></a> by maintaining the before image of the data for users accessing data at the same time that another user is changing it.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABEEGEJ"></a>
<div id="CNCPT89022" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Segment Space and the High Water Mark</h3>
<p>To manage space, Oracle Database tracks the state of blocks in the segment. The <span class="bold">high water mark</span> <span class="bold">(HWM)</span> is the point in a segment beyond which data blocks are unformatted and have never been used.</p>
<p>MSSM uses free lists to manage segment space. At table creation, no blocks in the segment are formatted. When a session first inserts rows into the table, the database searches the free list for usable blocks. If the database finds no usable blocks, then it preformats a group of blocks, places them on the free list, and begins inserting data into the blocks. In MSSM, a full table scan reads <span class="italic">all</span> blocks below the HWM.</p>
<p>ASSM does not use free lists and so must manage space differently. When a session first inserts data into a table, the database formats a single bitmap block instead of preformatting a group of blocks as in MSSM. The bitmap tracks the state of blocks in the segment, taking the place of the free list. The database uses the bitmap to find free blocks and then formats each block before filling it with data. ASSM spread out inserts among blocks to avoid concurrency issues.</p>
<p>Every data block in an ASSM segment is in one of the following states:</p>
<ul>
<li>
<p>Above the HWM</p>
<p>These blocks are unformatted and have never been used.</p>
</li>
<li>
<p>Below the HWM</p>
<p>These blocks are in one of the following states:</p>
<ul>
<li>
<p>Allocated, but currently unformatted and unused</p>
</li>
<li>
<p>Formatted and contain data</p>
</li>
<li>
<p>Formatted and empty because the data was deleted</p>
</li>
</ul>
</li>
</ul>
<p><a href="#BABJIIAI">Figure 12-23</a> depicts an ASSM segment as a horizontal series of blocks. At table creation, the HWM is at the beginning of the segment on the left. Because no data has been inserted yet, all blocks in the segment are unformatted and never used.</p>
<div id="CNCPT89023" class="figure">
<p class="titleinfigure"><a id="BABJIIAI"></a>Figure 12-23 HWM at Table Creation</p>
<img width="420" height="276" src="img/cncpt275.gif" alt="Description of Figure 12-23 follows" /><br />
<a id="sthref1567" href="img_text/cncpt275.htm">Description of "Figure 12-23 HWM at Table Creation"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Suppose that a transaction inserts rows into the segment. The database must allocate a group of blocks to hold the rows. The allocated blocks fall below the HWM. The database formats a bitmap block in this group to hold the metadata, but does not preformat the remaining blocks in the group.</p>
<p>In <a href="#BABJGIBJ">Figure 12-24</a>, the blocks below the HWM are allocated, whereas blocks above the HWM are neither allocated or formatted. As inserts occur, the database can write to any block with available space. The <span class="bold">low high water mark (low HWM)</span> marks the point below which all blocks are known to be formatted because they either contain data or formerly contained data.</p>
<div id="CNCPT89024" class="figure">
<p class="titleinfigure"><a id="BABJGIBJ"></a>Figure 12-24 HWM and Low HWM</p>
<img width="417" height="278" src="img/cncpt276.gif" alt="Description of Figure 12-24 follows" /><br />
<a id="sthref1568" href="img_text/cncpt276.htm">Description of "Figure 12-24 HWM and Low HWM"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In <a href="#CHDBFGBB">Figure 12-25</a>, the database chooses a block between the HWM and low HWM and writes to it. The database could have just as easily chosen any other block between the HWM and low HWM, or any block below the low HWM that had available space. In <a href="#CHDBFGBB">Figure 12-25</a>, the blocks to either side of the newly filled block are unformatted.</p>
<div id="CNCPT89194" class="figure">
<p class="titleinfigure"><a id="CHDBFGBB"></a>Figure 12-25 HWM and Low HWM</p>
<img width="416" height="281" src="img/cncpt333.gif" alt="Description of Figure 12-25 follows" /><br />
<a id="sthref1569" href="img_text/cncpt333.htm">Description of "Figure 12-25 HWM and Low HWM"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The low HWM is important in a <a href="glossary.htm#CHDCGIFF"><span class="xrefglossterm">full table scan</span></a>. Because blocks below the HWM are formatted only when used, some blocks could be unformatted, as in <a href="#CHDBFGBB">Figure 12-25</a>. For this reason, the database reads the bitmap block to obtain the location of the low HWM. The database reads all blocks up to the low HWM because they are known to be formatted, and then carefully reads only the formatted blocks between the low HWM and the HWM.</p>
<p>Assume that a new transaction inserts rows into the table, but the bitmap indicates that insufficient free space exists under the HWM. In <a href="#BABFHJIC">Figure 12-26</a>, the database advances the HWM to the right, allocating a new group of unformatted blocks.</p>
<div id="CNCPT89025" class="figure">
<p class="titleinfigure"><a id="BABFHJIC"></a>Figure 12-26 Advancing HWM and Low HWM</p>
<img width="420" height="281" src="img/cncpt277.gif" alt="Description of Figure 12-26 follows" /><br />
<a id="sthref1570" href="img_text/cncpt277.htm">Description of "Figure 12-26 Advancing HWM and Low HWM"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When the blocks between the HWM and low HWM are full, the HWM advances to the right and the low HWM advances to the location of the old HWM. As the database inserts data over time, the HWM continues to advance to the right, with the low HWM always trailing behind it. Unless you manually rebuild, truncate, or shrink the object, the HWM never retreats.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN10161" href="../../server.112/e25494/schema.htm#ADMIN10161"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to shrink segments online</p>
</li>
<li>
<p><a class="olink SQLRF01707" href="../../server.112/e41084/statements_10007.htm#SQLRF01707"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">TRUNCATE TABLE</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2006"></a>
<div id="CNCPT402" class="sect1">
<h2 class="sect1">Overview of Tablespaces</h2>
<p><a id="sthref1571"></a><a id="sthref1572"></a><a id="sthref1573"></a><a id="sthref1574"></a><a id="sthref1575"></a>A <span class="bold">tablespace</span> is a logical storage container for segments. Segments are database objects, such as tables and indexes, that consume storage space. At the physical level, a tablespace stores data in one or more data files or temp files.</p>
<p>A database must have the <code dir="ltr">SYSTEM</code> and <code dir="ltr">SYSAUX</code> tablespaces<a id="sthref1576"></a><a id="sthref1577"></a><a id="sthref1578"></a>. <a href="#BABBBFDJ">Figure 12-27</a> shows the tablespaces in a typical database. The following sections describe the tablespace types.</p>
<div id="CNCPT89168" class="figure">
<p class="titleinfigure"><a id="BABBBFDJ"></a>Figure 12-27 Tablespaces</p>
<img width="600" height="338" src="img/cncpt319.gif" alt="Description of Figure 12-27 follows" /><br />
<a id="sthref1579" href="img_text/cncpt319.htm">Description of "Figure 12-27 Tablespaces"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="BABBDJEB"></a>
<div id="CNCPT89026" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Permanent Tablespaces</h3>
<p>A <span class="bold">permanent tablespace</span> groups persistent schema objects. The segments for objects in the tablespace are stored physically in data files.</p>
<p>Each database user is assigned a default permanent tablespace. A very small database may need only the default <code dir="ltr">SYSTEM</code> and <code dir="ltr">SYSAUX</code> tablespaces. However, Oracle recommends that you create at least one tablespace to store user and application data. You can use tablespaces to achieve the following goals:</p>
<ul>
<li>
<p>Control disk space allocation for database data</p>
</li>
<li>
<p>Assign a <span class="bold">quota</span> (space allowance or limit) to a database user</p>
</li>
<li>
<p>Take individual tablespaces online or offline without affecting the availability of the whole database</p>
</li>
<li>
<p>Perform backup and recovery of individual tablespaces</p>
</li>
<li>
<p>Import or export application data by using the Oracle Data Pump utility (see <a href="cncptdba.htm#CHDDDDBJ">"Oracle Data Pump Export and Import"</a>)</p>
</li>
<li>
<p>Create a <span class="bold">transportable tablespace</span> that you can copy or move from one database to another, even across platforms</p>
<p>Moving data by transporting tablespaces can be orders of magnitude faster than either export/import or unload/load of the same data, because transporting a tablespace involves only copying data files and integrating the tablespace metadata. When you transport tablespaces you can also move index data.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN01101" href="../../server.112/e25494/tspaces.htm#ADMIN01101"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to transport tablespaces</p>
</li>
<li>
<p><a class="olink SUTIL100" href="../../server.112/e22490/dp_overview.htm#SUTIL100"><span class="italic">Oracle Database Utilities</span></a> to learn about Oracle Data Pump</p>
</li>
<li>
<p><a class="olink STRMS159" href="../../server.112/e17069/strms_ipro.htm#STRMS159"><span class="italic">Oracle Streams Concepts and Administration</span></a> for more information on ways to copy or transport files</p>
</li>
</ul>
</div>
<a id="i15436"></a>
<div id="CNCPT1086" class="sect3">
<h4 class="sect3">The SYSTEM Tablespace</h4>
<p><a id="CNCPT89028"></a>The <code dir="ltr">SYSTEM</code> tablespace is a necessary administrative tablespace included with the database when it is created. <a id="sthref1580"></a><a id="sthref1581"></a><a id="sthref1582"></a>Oracle Database uses <code dir="ltr">SYSTEM</code> to manage the database.</p>
<p>The <code dir="ltr">SYSTEM</code> tablespace includes the following information, all owned by the <code dir="ltr">SYS</code> user:</p>
<ul>
<li>
<p>The data dictionary</p>
</li>
<li>
<p>Tables and views that contain administrative information about the database</p>
</li>
<li>
<p>Compiled stored objects such as triggers, procedures, and packages</p>
</li>
</ul>
<p>The <code dir="ltr">SYSTEM</code> tablespace is managed as any other tablespace, but requires a higher level of privilege and is restricted in some ways. For example, you cannot rename or drop the <code dir="ltr">SYSTEM</code> tablespace.</p>
<p>By default, Oracle Database sets all newly created user tablespaces to be locally managed. In a database with a locally managed <code dir="ltr">SYSTEM</code> tablespace, you cannot create dictionary-managed tablespaces (which are deprecated). However, if you execute the <code dir="ltr">CREATE DATABASE</code> statement manually and accept the defaults, then the <code dir="ltr">SYSTEM</code> tablespace is dictionary managed. You can migrate an existing dictionary-managed <code dir="ltr">SYSTEM</code> tablespace to a locally managed format.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle strongly recommends that you use Database Configuration Assistant (DBCA) to create new databases so that all tablespaces, including <code dir="ltr">SYSTEM</code>, are locally managed by default.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i2481">"Online and Offline Tablespaces"</a> for information about the permanent online condition of the <code dir="ltr">SYSTEM</code> tablespace</p>
</li>
<li>
<p><a href="cncptdba.htm#CHDIJHGG">"Tools for Database Installation and Configuration"</a> to learn about DBCA</p>
</li>
<li>
<p><a class="olink ADMIN11393" href="../../server.112/e25494/tspaces.htm#ADMIN11393"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to create or migrate to a locally managed <code dir="ltr">SYSTEM</code> tablespace</p>
</li>
<li>
<p><a class="olink SQLRF01204" href="../../server.112/e41084/statements_5004.htm#SQLRF01204"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">CREATE DATABASE</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABEBBDI"></a>
<div id="CNCPT1089" class="sect3">
<h4 class="sect3">The SYSAUX Tablespace</h4>
<p>The <code dir="ltr">SYSAUX</code> tablespace is an auxiliary tablespace to the <code dir="ltr">SYSTEM</code> tablespace. The <code dir="ltr">SYSAUX</code> tablespace provides a centralized location for database metadata that does not reside in the <code dir="ltr">SYSTEM</code> tablespace. It reduces the number of tablespaces created by default, both in the seed database and in user-defined databases.</p>
<p>Several database components, including Oracle Enterprise Manager and Oracle Streams, use the <code dir="ltr">SYSAUX</code> tablespace as their default storage location. Therefore, the <code dir="ltr">SYSAUX</code> tablespace is created automatically during database creation or upgrade.</p>
<p>During normal database operation, the database does not allow the <code dir="ltr">SYSAUX</code> tablespace to be dropped or renamed. If the <code dir="ltr">SYSAUX</code> tablespace becomes unavailable, then core database functionality remains operational. The database features that use the <code dir="ltr">SYSAUX</code> tablespace could fail, or function with limited capability.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN00203" href="../../server.112/e25494/create.htm#ADMIN00203"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn about the <code dir="ltr">SYSAUX</code> tablespace</div>
</div>
<!-- class="sect3" -->
<a id="i10698"></a>
<div id="CNCPT1090" class="sect3">
<h4 class="sect3">Undo Tablespaces<a id="sthref1583"></a></h4>
<p>An <span class="bold">undo tablespace</span> is a locally managed tablespace reserved for system-managed undo data (see <a href="#CHDGJJEJ">"Undo Segments"</a>). Like other permanent tablespaces, undo tablespaces contain data files. Undo blocks in these files are grouped in extents.</p>
<a id="CIHDHFBA"></a>
<div id="CNCPT1079" class="sect4">
<h5 class="sect4">Automatic Undo Management Mode</h5>
<p>Undo tablespaces require the database to be in the default <a href="glossary.htm#i997760"><span class="xrefglossterm">automatic undo management mode</span></a>. This mode eliminates the complexities of manually administering undo segments. The database automatically tunes itself to provide the best possible retention of undo data to satisfy long-running queries that may require this data.</p>
<p>An undo tablespace is automatically created with a new installation of Oracle Database. Earlier versions of Oracle Database may not include an undo tablespace and use legacy rollback segments instead, known as <span class="bold">manual undo management mode</span>. When upgrading to Oracle Database 11<span class="italic">g</span>, you can enable automatic undo management mode and create an undo tablespace. Oracle Database contains an Undo Advisor that provides advice on and helps automate your undo environment.</p>
<p>A database can contain multiple undo tablespaces, but only one can be in use at a time. When an instance attempts to open a database, Oracle Database automatically selects the first available undo tablespace. If no undo tablespace is available, then the instance starts without an undo tablespace and stores undo data in the <code dir="ltr">SYSTEM</code> tablespace. Storing undo data in <code dir="ltr">SYSTEM</code> is not recommended.</p>
<div class="infobox-note">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11461" href="../../server.112/e25494/undo.htm#ADMIN11461"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn about automatic undo management</p>
</li>
<li>
<p><a class="olink UPGRD12439" href="../../server.112/e23633/afterup.htm#UPGRD12439"><span class="italic">Oracle Database Upgrade Guide</span></a> to learn how to migrate to automatic undo management mode</p>
</li>
<li>
<p><a class="olink ADMQS0635" href="../../server.112/e10897/storage.htm#ADMQS0635"><span class="italic">Oracle Database 2 Day DBA</span></a> for information on the Undo Advisor and on how to use advisors</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="CIHCHAIF"></a>
<div id="CNCPT1080" class="sect4">
<h5 class="sect4">Automatic Undo Retention</h5>
<p>The <span class="bold">undo retention period</span> is the minimum amount of time that Oracle Database attempts to retain old undo data before overwriting it. Undo retention is important because long-running queries may require older block images to supply <a href="glossary.htm#CHDIECGD"><span class="xrefglossterm">read consistency</span></a>. Also, some Oracle Flashback features can depend on undo availability.</p>
<p>In general, it is desirable to retain old undo data as long as possible. After a transaction commits, undo data is no longer needed for rollback or transaction recovery. The database can retain old undo data if the undo tablespace has space for new transactions. When available space is low, the database begins to overwrite old undo data for committed transactions.</p>
<p>Oracle Database automatically provides the best possible undo retention for the current undo tablespace. The database collects usage <a id="sthref1584"></a>statistics and tunes the retention period based on these statistics and the undo tablespace size. If the undo tablespace is configured with the <code dir="ltr">AUTOEXTEND</code> option, and if the maximum size is not specified, then undo retention tuning is different. In this case, the database tunes the undo retention period to be slightly longer than the longest-running query, if space allows.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11464" href="../../server.112/e25494/undo.htm#ADMIN11464"><span class="italic">Oracle Database Administrator's Guide</span></a> for more details on automatic tuning of undo retention</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABIJBFF"></a>
<div id="CNCPT89029" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Temporary Tablespaces</h3>
<p>A <span class="bold">temporary tablespace</span> contains transient data that persists only for the duration of a session. No permanent schema objects can reside in a temporary tablespace. The database stores temporary tablespace data in <span class="bold">temp files</span>.</p>
<p>Temporary tablespaces can improve the concurrency of multiple sort operations that do not fit in memory. These tablespaces also improve the efficiency of space management operations during sorts.</p>
<p><a id="CNCPT1092"></a>When the <code dir="ltr">SYSTEM</code> tablespace is locally managed, a default temporary tablespace is included in the database by default during database creation. A locally managed <code dir="ltr">SYSTEM</code> tablespace cannot serve as default temporary storage.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot make a default temporary tablespace permanent.</div>
<p>You can specify a user-named default temporary tablespace when you create a database by using the <code dir="ltr">DEFAULT TEMPORARY TABLESPACE</code> extension to the <code dir="ltr">CREATE DATABASE</code> statement. If <code dir="ltr">SYSTEM</code> is dictionary managed, and if a default temporary tablespace is not defined at database creation, then <code dir="ltr">SYSTEM</code> is the default temporary storage. However, the database writes a warning in the <a href="glossary.htm#CHDJEHBI"><span class="xrefglossterm">alert log</span></a> saying that a default temporary tablespace is recommended.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="physical.htm#i10560">"Permanent and Temporary Data Files"</a></p>
</li>
<li>
<p><a class="olink ADMIN11090" href="../../server.112/e25494/create.htm#ADMIN11090"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to create a default temporary tablespace</p>
</li>
<li>
<p><a class="olink SQLRF53870" href="../../server.112/e41084/statements_5004.htm#SQLRF53870"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of the <code dir="ltr">DEFAULT TEMPORARY TABLESPACE</code> clause of <code dir="ltr">CREATE DATABASE</code> and <code dir="ltr">ALTER DATABASE</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABFFCBD"></a>
<div id="CNCPT89027" class="sect2">
<h3 class="sect2">Tablespace Modes</h3>
<p>The <span class="bold">tablespace mode</span> determines the accessibility of the tablespace.</p>
<a id="i1792"></a>
<div id="CNCPT1102" class="sect3">
<h4 class="sect3">Read/Write and Read-Only Tablespaces</h4>
<p>Every tablespace is in a <span class="bold">write mode</span> that specifies whether it can be written to. The mutually exclusive modes are as follows:</p>
<ul>
<li>
<p>Read/write mode</p>
<p>Users can read and write to the tablespace. All tablespaces are initially created as read/write. The <code dir="ltr">SYSTEM</code> and <code dir="ltr">SYSAUX</code> tablespaces and temporary tablespaces are permanently read/write, which means that they cannot be made read-only.</p>
</li>
<li>
<p>Read-only mode</p>
<p>Write operations to the data files in the tablespace are prevented. A read-only tablespace can reside on read-only media such as DVDs or WORM drives.</p>
<p>Read-only tablespaces eliminate the need to perform backup and recovery of large, static portions of a database. Read-only tablespaces do not change and thus do not require repeated backup. If you recover a database after a media failure, then you do not need to recover read-only tablespaces.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11379" href="../../server.112/e25494/tspaces.htm#ADMIN11379"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to change a tablespace to read only or read/write mode</p>
</li>
<li>
<p><a class="olink SQLRF53606" href="../../server.112/e41084/statements_3002.htm#SQLRF53606"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">ALTER TABLESPACE</code> syntax and semantics</p>
</li>
<li>
<p><a class="olink BRADV89370" href="../../backup.112/e10642/rcmquick.htm#BRADV89370"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information about recovery</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i2481"></a>
<div id="CNCPT1099" class="sect3">
<h4 class="sect3">Online and Offline Tablespaces</h4>
<p><a id="sthref1585"></a><a id="sthref1586"></a><a id="sthref1587"></a>A tablespace can be <span class="bold">online</span> (accessible) or <span class="bold">offline</span> (not accessible) whenever the database is open. A tablespace is usually online so that its data is available to users. The <code dir="ltr">SYSTEM</code> tablespace and temporary tablespaces cannot be taken offline.</p>
<p>A tablespace can go offline automatically or manually. For example, you can take a tablespace offline for maintenance or backup and recovery. The database automatically takes a tablespace offline when certain errors are encountered, as when the <a href="glossary.htm#i996724"><span class="xrefglossterm">database writer (DBW)</span></a> process fails in several attempts to write to a data file. Users trying to access tables in an offline tablespace receive an error.</p>
<p>When a tablespace goes offline, the database does the following:</p>
<ul>
<li>
<p>The database does not permit subsequent DML statements to reference objects in the offline tablespace. An offline tablespace cannot be read or edited by any utility other than Oracle Database.</p>
</li>
<li>
<p>Active transactions with completed statements that refer to data in that tablespace are not affected at the transaction level.</p>
</li>
<li>
<p>The database saves undo data corresponding to those completed statements in a deferred undo segment in the <code dir="ltr">SYSTEM</code> tablespace. When the tablespace is brought online, the database applies the undo data to the tablespace, if needed.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="physical.htm#CHDEGHEI">"Online and Offline Data Files"</a></p>
</li>
<li>
<p><a href="process.htm#BABHDJGD">"Database Writer Process (DBW<span class="bolditalic">n</span>)"</a></p>
</li>
<li>
<p><a class="olink ADMIN12490" href="../../server.112/e25494/tspaces.htm#ADMIN12490"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to alter tablespace availability</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i14068"></a>
<div id="CNCPT1083" class="sect2">
<h3 class="sect2">Tablespace File Size</h3>
<p>A tablespace is either a <span class="bold">bigfile tablespace</span> or a <span class="bold">smallfile tablespace</span>. These tablespaces are indistinguishable in terms of execution of SQL statements that do not explicitly refer to data files or temp files. The difference is as follows:</p>
<ul>
<li>
<p>A smallfile tablespace can contain multiple data files or temp files, but the files cannot be as large as in a bigfile tablespace. This is the default tablespace type.</p>
</li>
<li>
<p>A bigfile tablespace contains one very large data file or temp file. This type of tablespaces can do the following:</p>
<ul>
<li>
<p>Increase the storage capacity of a database</p>
<p>The maximum number of data files in a database is limited (usually to 64 KB files), so increasing the size of each data file increases the overall storage.</p>
</li>
<li>
<p>Reduce the burden of managing many data files and temp files</p>
<p>Bigfile tablespaces simplify file management with Oracle Managed Files and Automatic Storage Management (Oracle ASM) by eliminating the need for adding new files and dealing with multiple files.</p>
</li>
<li>
<p>Perform operations on tablespaces rather than individual files</p>
<p>Bigfile tablespaces make the tablespace the main unit of the disk space administration, backup and recovery, and so on.</p>
</li>
</ul>
<p>Bigfile tablespaces are supported only for locally managed tablespaces with ASSM. However, locally managed undo and temporary tablespaces can be bigfile tablespaces even when segments are manually managed.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="cncptdba.htm#CHDFHDCG">"Backup and Recovery"</a></p>
</li>
<li>
<p><a class="olink ADMIN01102" href="../../server.112/e25494/tspaces.htm#ADMIN01102"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manage bigfile tablespaces</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1448">
<tr>
<td class="cellalignment1455">
<table class="cellalignment1453">
<tr>
<td class="cellalignment1452"><a href="physical.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1452"><a href="part_inarch.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1457">
<table class="cellalignment1451">
<tr>
<td class="cellalignment1452"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1452"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1452"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1452"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1452"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1452"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
