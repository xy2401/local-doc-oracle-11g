<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Partitions, Views, and Other Schema Objects</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1056" />
<meta name="dcterms.created" content="2015-05-25T13:34:1Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Concepts" />
<meta name="dcterms.identifier" content="E40540-04" />
<meta name="dcterms.isVersionOf" content="CNCPT" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="indexiot.htm" title="Previous" type="text/html" />
<link rel="Next" href="datainte.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e40540.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/30</span> <!-- End Header -->
<div id="CNCPT88858" class="chapter"><a id="CFAGCHCD"></a>
<h1 class="chapter"><span class="secnum">4</span> Partitions, Views, and Other Schema Objects</h1>
<p>Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#CFAGCECI">Overview of Partitions</a></p>
</li>
<li>
<p><a href="#i20690">Overview of Views</a></p>
</li>
<li>
<p><a href="#CFAIGHFC">Overview of Materialized Views</a></p>
</li>
<li>
<p><a href="#i5667">Overview of Sequences</a></p>
</li>
<li>
<p><a href="#i18190">Overview of Dimensions</a></p>
</li>
<li>
<p><a href="#i5669">Overview of Synonyms</a></p>
</li>
</ul>
<a id="CFAGCECI"></a>
<div id="CNCPT112" class="sect1">
<h2 class="sect1">Overview of Partitions</h2>
<p><span class="bold"><a id="sthref427"></a>Partitioning</span> enables you to decompose very large tables and indexes into smaller and more manageable pieces called <span class="bold">partitions</span>. Each partition is an independent object with its own name and optionally its own storage characteristics.</p>
<p>For an analogy that illustrates partitioning, suppose an HR manager has one big box that contains employee folders. Each folder lists the employee hire date. Queries are often made for employees hired in a particular month. One approach to satisfying such requests is to create an index on employee hire date that specifies the locations of the folders scattered throughout the box. In contrast, a partitioning strategy uses many smaller boxes, with each box containing folders for employees hired in a given month.</p>
<p>Using smaller boxes has several advantages. When asked to retrieve the folders for employees hired in June, the HR manager can retrieve the June box. Furthermore, if any small box is temporarily damaged, the other small boxes remain available. Moving offices also becomes easier because instead of moving a single heavy box, the manager can move several small boxes.</p>
<p>From the perspective of an application, only one schema object exists. <a href="glossary.htm#i432381"><span class="xrefglossterm">DML</span></a> statements require no modification to access partitioned tables. Partitioning is useful for many different types of database applications, particularly those that manage large volumes of data. Benefits include:</p>
<ul>
<li>
<p>Increased availability</p>
<p>The unavailability of a partition does not entail the unavailability of the object. The query <a id="sthref428"></a><a href="glossary.htm#CHDGHIIF"><span class="xrefglossterm">optimizer</span></a> automatically removes unreferenced partitions from the <a id="sthref429"></a><a href="glossary.htm#CHDFAHBD"><span class="xrefglossterm">query plan</span></a> so queries are not affected when the partitions are unavailable.</p>
</li>
<li>
<p>Easier administration of schema objects</p>
<p>A partitioned object has pieces that can be managed either collectively or individually. <a href="glossary.htm#CHDJJGGF"><span class="xrefglossterm">DDL</span></a> statements can manipulate partitions rather than entire tables or indexes. Thus, you can break up resource-intensive tasks such as rebuilding an index or table. For example, you can move one table partition at a time. If a problem occurs, then only the partition move must be redone, not the table move. Also, dropping a partition avoids executing numerous <code dir="ltr">DELETE</code> statements.</p>
</li>
<li>
<p>Reduced contention for shared resources in <a href="glossary.htm#CHDBBEFA"><span class="xrefglossterm">OLTP</span></a> systems</p>
<p>In some OLTP systems, partitions can decrease contention for a shared resource. For example, DML is distributed over many segments rather than one segment.</p>
</li>
<li>
<p>Enhanced query performance in data warehouses</p>
<p>In a <a id="sthref430"></a><a href="glossary.htm#CHDCBJAD"><span class="xrefglossterm">data warehouse</span></a>, partitioning can speed processing of ad hoc queries. For example, a sales table containing a million rows can be partitioned by quarter.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink VLDBG00101" href="../../server.112/e25523/intro.htm#VLDBG00101"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for an introduction to partitioning</div>
<a id="CFAJEFFI"></a>
<div id="CNCPT88859" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Partition Characteristics</h3>
<p>Each partition of a table or index must have the same logical attributes, such as <a href="glossary.htm#i432240"><span class="xrefglossterm">column</span></a> names, <a href="glossary.htm#CHDBIHHE"><span class="xrefglossterm">data types</span></a>, and constraints. For example, all partitions in a table share the same column and constraint definitions, and all partitions in an index share the same indexed columns. However, each partition can have separate physical attributes, such as the tablespace to which it belongs.</p>
<div id="CNCPT1512" class="sect3"><a id="sthref431"></a>
<h4 class="sect3">Partition Key</h4>
<p><a id="sthref432"></a><a id="sthref433"></a>The <span class="bold">partition key</span> is a set of one or more columns that determines the partition in which each <a href="glossary.htm#i432693"><span class="xrefglossterm">row</span></a> in a partitioned table should go. Each row is unambiguously assigned to a single partition.</p>
<p>In the <code dir="ltr">sales</code> table, you could specify the <code dir="ltr">time_id</code> column as the key of a range partition. The database assigns rows to partitions based on whether the date in this column falls in a specified range. Oracle Database automatically directs insert, update, and delete operations to the appropriate partition by using the partition key.</p>
</div>
<!-- class="sect3" -->
<div id="CNCPT1911" class="sect3"><a id="sthref434"></a>
<h4 class="sect3">Partitioning Strategies</h4>
<p><a id="sthref435"></a><a id="sthref436"></a><a id="sthref437"></a>Oracle Partitioning offers several partitioning strategies that control how the database places data into partitions. The basic strategies are range, list, and hash partitioning.</p>
<p><a id="sthref438"></a><a id="sthref439"></a>A <span class="bold">single-level</span> partitioning strategy uses only one method of data distribution, for example, only list partitioning or only range partitioning. <a id="sthref440"></a><a id="sthref441"></a>In <span class="bold">composite partitioning</span>, a table is partitioned by one data distribution method and then each partition is further divided into subpartitions using a second data distribution method. For example, you could use a list partition for <code dir="ltr">channel_id</code> and a range subpartition for <code dir="ltr">time_id</code>.</p>
<div id="CNCPT88862" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref442"></a>
<h5 class="sect4">Range Partitioning</h5>
<p>In <span class="bold">range partitioning</span>, the database maps rows to partitions based on ranges of values of the partitioning key. Range partitioning is the most common type of partitioning and is often used with dates.</p>
<p>Suppose that you want to populate a partitioned table with the <code dir="ltr">sales</code> rows shown in <a href="#BABCHIID">Example 4-1</a>.</p>
<div id="CNCPT89158" class="example">
<p class="titleinexample"><a id="BABCHIID"></a>Example 4-1 Sample Row Set for Partitioned Table</p>
<pre dir="ltr">
  PROD_ID    CUST_ID TIME_ID   CHANNEL_ID   PROMO_ID QUANTITY_SOLD AMOUNT_SOLD
---------- ---------- --------- ---------- ---------- ------------- -----------
      116      11393 05-JUN-99          2        999             1       12.18
       40     100530 30-NOV-98          9         33             1       44.99
      118        133 06-JUN-01          2        999             1       17.12
      133       9450 01-DEC-00          2        999             1       31.28
       36       4523 27-JAN-99          3        999             1       53.89
      125       9417 04-FEB-98          3        999             1       16.86
       30        170 23-FEB-01          2        999             1         8.8
       24      11899 26-JUN-99          4        999             1       43.04
       35       2606 17-FEB-00          3        999             1       54.94
       45       9491 28-AUG-98          4        350             1       47.45 
</pre></div>
<!-- class="example" -->
<p>You create <code dir="ltr">time_range_sales</code> as a partitioned table using the statement in <a href="#CFAHGJEJ">Example 4-2</a>. The <code dir="ltr">time_id</code> column is the partition key.</p>
<div id="CNCPT88860" class="example">
<p class="titleinexample"><a id="CFAHGJEJ"></a>Example 4-2 Range-Partitioned Table</p>
<pre dir="ltr">
CREATE TABLE time_range_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , <span class="bold">time_id</span>        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY RANGE (<span class="bold">time_id</span>)
 (PARTITION SALES_1998 VALUES LESS THAN (TO_DATE('01-JAN-1999','DD-MON-YYYY')),
  PARTITION SALES_1999 VALUES LESS THAN (TO_DATE('01-JAN-2000','DD-MON-YYYY')),
  PARTITION SALES_2000 VALUES LESS THAN (TO_DATE('01-JAN-2001','DD-MON-YYYY')),
  PARTITION SALES_2001 VALUES LESS THAN (MAXVALUE)
 ); 
</pre></div>
<!-- class="example" -->
<p>Afterward, you load <code dir="ltr">time_range_sales</code> with the rows from <a href="#BABCHIID">Example 4-1</a>. <a href="#BABHEGFF">Figure 4-1</a> shows the row distributions in the four partitions. The database chooses the partition for each row based on the <code dir="ltr">time_id</code> value according to the rules specified in the <code dir="ltr">PARTITION BY RANGE</code> clause.</p>
<div id="CNCPT89159" class="figure">
<p class="titleinfigure"><a id="BABHEGFF"></a>Figure 4-1 Range Partitions</p>
<img width="650" height="660" src="img/cncpt297.gif" alt="Description of Figure 4-1 follows" /><br />
<a id="sthref443" href="img_text/cncpt297.htm">Description of "Figure 4-1 Range Partitions"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The range partition key value determines the high value of the range partitions, which is called the <span class="bold">transition point</span>. In <a href="#BABHEGFF">Figure 4-1</a>, the <code dir="ltr">SALES_1998</code> partition contains rows with partitioning key <code dir="ltr">time_id</code> values less than the transition point <code dir="ltr">01-JAN-1999</code>.</p>
<p>The database creates <span class="bold">interval partitions</span> for data beyond that transition point. Interval partitions extend range partitioning by instructing the database to create partitions of the specified range or interval automatically when data inserted into the table exceeds all of the range partitions. In <a href="#BABHEGFF">Figure 4-1</a>, the <code dir="ltr">SALES_2001</code> partition contains rows with partitioning key <code dir="ltr">time_id</code> values greater than or equal to <code dir="ltr">01-JAN-2001</code>.</p>
</div>
<!-- class="sect4" -->
<div id="CNCPT88863" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref444"></a>
<h5 class="sect4">List Partitioning</h5>
<p><a id="sthref445"></a>In <span class="bold">list partitioning</span>, the database uses a list of discrete values as the partition key for each partition. You can use list partitioning to control how individual rows map to specific partitions. By using lists, you can group and organize related sets of data when the key used to identify them is not conveniently ordered.</p>
<p>Assume that you create <code dir="ltr">list_sales</code> as a list-partitioned table using the statement in <a href="#BABIDDJA">Example 4-3</a>. The <code dir="ltr">channel_id</code> column is the partition key.</p>
<div id="CNCPT89160" class="example">
<p class="titleinexample"><a id="BABIDDJA"></a>Example 4-3 List-Partitioned Table</p>
<pre dir="ltr">
CREATE TABLE list_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , <span class="bold">channel_id</span>     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY LIST (<span class="bold">channel_id</span>)
 (PARTITION even_channels VALUES (2,4),
  PARTITION odd_channels VALUES (3,9)
 ); 
</pre></div>
<!-- class="example" -->
<p>Afterward, you load the table with the rows from <a href="#BABCHIID">Example 4-1</a>. <a href="#BABFAIJE">Figure 4-2</a> shows the row distribution in the two partitions. The database chooses the partition for each row based on the <code dir="ltr">channel_id</code> value according to the rules specified in the <code dir="ltr">PARTITION BY LIST</code> clause. Rows with a <code dir="ltr">channel_id</code> value of 2 or 4 are stored in the <code dir="ltr">EVEN_CHANNELS</code> partitions, while rows with a <code dir="ltr">channel_id</code> value of 3 or 9 are stored in the <code dir="ltr">ODD_CHANNELS</code> partition.</p>
<div id="CNCPT89161" class="figure">
<p class="titleinfigure"><a id="BABFAIJE"></a>Figure 4-2 List Partitions</p>
<img width="650" height="369" src="img/cncpt298.gif" alt="Description of Figure 4-2 follows" /><br />
<a id="sthref446" href="img_text/cncpt298.htm">Description of "Figure 4-2 List Partitions"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect4" -->
<div id="CNCPT88864" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref447"></a>
<h5 class="sect4">Hash Partitioning</h5>
<p><a id="sthref448"></a>In <span class="bold">hash <a id="sthref449"></a><a id="sthref450"></a>partitioning</span>, the database maps rows to partitions based on a <a href="glossary.htm#CHDJAJHF"><span class="xrefglossterm">hashing</span></a> algorithm that the database applies to the user-specified partitioning key. The destination of a row is determined by the internal <a id="sthref451"></a><a id="sthref452"></a><a href="glossary.htm#CHDGDJJH"><span class="xrefglossterm">hash function</span></a> applied to the row by the database. The hashing algorithm is designed to evenly distributes rows across devices so that each partition contains about the same number of rows.</p>
<p>Hash partitioning is useful for dividing large tables to increase manageability. Instead of one large table to manage, you have several smaller pieces. The loss of a single hash partition does not affect the remaining partitions and can be recovered independently. Hash partitioning is also useful in <a href="glossary.htm#CHDBBEFA"><span class="xrefglossterm">OLTP</span></a> systems with high update contention. For example, a segment is divided into several pieces, each of which is updated, instead of a single segment that experiences contention.</p>
<p>Assume that you create the partitioned <code dir="ltr">hash_sales</code> table using the statement in <a href="#BABFDBIG">Example 4-4</a>. The <code dir="ltr">prod_id</code> column is the partition key.</p>
<div id="CNCPT89162" class="example">
<p class="titleinexample"><a id="BABFDBIG"></a>Example 4-4 Hash-Partitioned Table</p>
<pre dir="ltr">
CREATE TABLE hash_sales
   ( <span class="bold">prod_id</span>        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY HASH (<span class="bold">prod_id</span>)
PARTITIONS 2; 
</pre></div>
<!-- class="example" -->
<p>Afterward, you load the table with the rows from <a href="#BABCHIID">Example 4-1</a>. <a href="#BABBFIAG">Figure 4-3</a> shows a possible row distribution in the two partitions. Note that the names of these partitions are system-generated.</p>
<p>As you insert rows, the database attempts to randomly and evenly distribute them across partitions. You cannot specify the partition into which a row is placed. The database applies the hash function, whose outcome determines which partition contains the row. If you change the number of partitions, then the database redistributes the data over all of the partitions.</p>
<div id="CNCPT89163" class="figure">
<p class="titleinfigure"><a id="BABBFIAG"></a>Figure 4-3 Hash Partitions</p>
<img width="651" height="360" src="img/cncpt299.gif" alt="Description of Figure 4-3 follows" /><br />
<a id="sthref453" href="img_text/cncpt299.htm">Description of "Figure 4-3 Hash Partitions"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink VLDBG003" href="../../server.112/e25523/part_admin.htm#VLDBG003"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> to learn how to create partitions</p>
</li>
<li>
<p><a class="olink SQLRF54655" href="../../server.112/e41084/statements_7002.htm#SQLRF54655"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">CREATE TABLE ... PARTITION BY</code> examples</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CNCPT1136" class="sect2"><a id="sthref454"></a>
<h3 class="sect2">Partitioned Tables</h3>
<p><a id="sthref455"></a><a id="sthref456"></a>A <span class="bold">partitioned table</span> consists of one or more partitions, which are managed individually and can operate independently of the other partitions. A table is either partitioned or nonpartitioned. Even if a partitioned table consists of only one partition, this table is different from a nonpartitioned table, which cannot have partitions added to it. <a href="#CFAJEFFI">"Partition Characteristics"</a> gives examples of partitioned tables.</p>
<p>A partitioned table is made up of one or more table partition segments. If you create a partitioned table named <code dir="ltr">hash_products</code>, then no table <a href="glossary.htm#i432714"><span class="xrefglossterm">segment</span></a> is allocated for this table. Instead, the database stores data for each table partition in its own partition segment. Each table partition segment contains a portion of the table data.</p>
<p>Some or all partitions of a heap-organized table can be stored in a compressed format. Compression saves space and can speed query execution. Thus, compression can be useful in environments such as data warehouses, where the amount of insert and update operations is small, and in <a href="glossary.htm#CHDBBEFA"><span class="xrefglossterm">OLTP</span></a> environments.</p>
<p>The attributes <a id="sthref457"></a><a id="sthref458"></a>for <a href="glossary.htm#CHDJCICJ"><span class="xrefglossterm">table compression</span></a> can be declared for a tablespace, table, or table partition. If declared at the tablespace level, then tables created in the tablespace are compressed by default. You can alter the compression attribute for a table, in which case the change only applies to new data going into that table. Consequently, a single table or partition may contain compressed and uncompressed blocks, which guarantees that data size will not increase because of compression. If compression could increase the size of a block, then the database does not apply it to the block.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="tablecls.htm#CBBFAAII">"Table Compression"</a> and <a href="logical.htm#i10405">"Overview of Segments"</a></p>
</li>
<li>
<p><a class="olink DWHSG8117" href="../../server.112/e25554/physical.htm#DWHSG8117"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn about table compression in a data warehouse</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="CNCPT312" class="sect2"><a id="sthref459"></a>
<h3 class="sect2">Partitioned Indexes</h3>
<p><a id="sthref460"></a><a id="sthref461"></a>A <span class="bold">partitioned index</span> is an index that, like a partitioned table, has been decomposed into smaller and more manageable pieces. <span class="bold">Global indexes</span> <a id="sthref462"></a><a id="sthref463"></a>are partitioned independently of the table on which they are created, whereas <span class="bold">local indexes</span> <a id="sthref464"></a><a id="sthref465"></a>are automatically linked to the partitioning method for a table. Like partitioned tables, partitioned indexes improve manageability, availability, performance, and scalability.</p>
<p>The following graphic shows index partitioning options.</p>
<img width="476" height="195" src="img/cncpt301.gif" alt="Description of cncpt301.gif follows" /><br />
<a id="sthref466" href="img_text/cncpt301.htm">Description of the illustration cncpt301.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="indexiot.htm#i5671">"Overview of Indexes"</a></p>
</li>
<li>
<p><a class="olink VLDBG00203" href="../../server.112/e25523/partition.htm#VLDBG00203"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> and <a class="olink PFGRF94786" href="../../server.112/e41573/data_acc.htm#PFGRF94786"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about partitioned indexes and how to decide which type to use</p>
</li>
</ul>
</div>
<div id="CNCPT1520" class="sect3"><a id="sthref467"></a>
<h4 class="sect3">Local Partitioned Indexes</h4>
<p>In a <span class="bold">local partitioned index</span>, the index is partitioned on the same columns, with the same number of partitions and the same partition bounds as its table. Each index partition is associated with exactly one partition of the underlying table, so that all keys in an index partition refer only to rows stored in a single table partition. In this way, the database automatically synchronizes index partitions with their associated table partitions, making each table-index pair independent.</p>
<p>Local partitioned indexes are common in data warehousing environments. Local indexes offer the following advantages:</p>
<ul>
<li>
<p>Availability is increased because actions that make data invalid or unavailable in a partition affect this partition only.</p>
</li>
<li>
<p>Partition maintenance is simplified. When moving a table partition, or when data ages out of a partition, only the associated local index partition must be rebuilt or maintained. In a global index, all index partitions must be rebuilt or maintained.</p>
</li>
<li>
<p>If <span class="bold"><a id="sthref468"></a>point-in-time recovery</span> of a partition occurs, then the indexes can be recovered to the recovery time (see <a href="cncptdba.htm#CHDCHHIJ">"Data File Recovery"</a>). The entire index does not need to be rebuilt.</p>
</li>
</ul>
<p><a href="#BABFDBIG">Example 4-4</a> shows the creation statement for the partitioned <code dir="ltr">hash_sales</code> table, using the <code dir="ltr">prod_id</code> column as partition key. <a href="#CFACGEIH">Example 4-5</a> creates a local partitioned index on the <code dir="ltr">time_id</code> column of the <code dir="ltr">hash_sales</code> table.</p>
<div id="CNCPT88866" class="example">
<p class="titleinexample"><a id="CFACGEIH"></a>Example 4-5 Local Partitioned Index</p>
<pre dir="ltr">
CREATE INDEX hash_sales_idx ON hash_sales(time_id) LOCAL;
</pre></div>
<!-- class="example" -->
<p>In <a href="#CFAIJFJI">Figure 4-4</a>, the <code dir="ltr">hash_products</code> table has two partitions, so <code dir="ltr">hash_sales_idx</code> has two partitions. Each index partition is associated with a different table partition. Index partition <code dir="ltr">SYS_P38</code> indexes rows in table partition <code dir="ltr">SYS_P33</code>, whereas index partition <code dir="ltr">SYS_P39</code> indexes rows in table partition <code dir="ltr">SYS_P34</code>.</p>
<div id="CNCPT88867" class="figure">
<p class="titleinfigure"><a id="CFAIJFJI"></a>Figure 4-4 Local Index Partitions</p>
<img width="626" height="573" src="img/cncpt302.gif" alt="Description of Figure 4-4 follows" /><br />
<a id="sthref469" href="img_text/cncpt302.htm">Description of "Figure 4-4 Local Index Partitions"</a><br />
<br /></div>
<!-- class="figure" -->
<p>You cannot explicitly add a partition to a local index. Instead, new partitions are added to local indexes only when you add a partition to the underlying table. Likewise, you cannot explicitly drop a partition from a local index. Instead, local index partitions are dropped only when you drop a partition from the underlying table.</p>
<p>Like other indexes, you can create a <a id="sthref470"></a><a id="sthref471"></a><a href="glossary.htm#CHDDEACG"><span class="xrefglossterm">bitmap index</span></a> on partitioned tables. The only restriction is that bitmap indexes must be local to the partitioned table&mdash;they cannot be global indexes. Global bitmap indexes are supported only on nonpartitioned tables.</p>
<div id="CNCPT88868" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref472"></a>
<h5 class="sect4">Local Prefixed and Nonprefixed Indexes</h5>
<p>Local partitioned indexes are divided into the following subcategories:</p>
<ul>
<li>
<p><a id="sthref473"></a><a id="sthref474"></a>Local prefixed indexes</p>
<p>In this case, the partition keys are on the leading edge of the index definition. In <a href="#CFAHGJEJ">Example 4-2</a>, the table is partitioned by range on <code dir="ltr">time_id</code>. A local prefixed index on this table would have <code dir="ltr">time_id</code> as the first column in its list.</p>
</li>
<li>
<p>Local nonprefixed indexes</p>
<p>In this case, the partition keys are not on the leading edge of the indexed column list and need not be in the list at all. In <a href="#CFACGEIH">Example 4-5</a>, the index is local nonprefixed because the partition key <code dir="ltr">product_id</code> is not on the leading edge.</p>
</li>
</ul>
<p>Both types of indexes can take advantage <a id="sthref475"></a>of <span class="bold">partition elimination</span> (also called <span class="bold">partition pruning</span>), which occurs when the optimizer speeds data access by excluding partitions from consideration. Whether a <a href="glossary.htm#CHDCAGGJ"><span class="xrefglossterm">query</span></a> can eliminate partitions depends on the query <a href="glossary.htm#CHDGAHDF"><span class="xrefglossterm">predicate</span></a>. A query that uses a local prefixed index always allows for index partition elimination, whereas a query that uses a local nonprefixed index might not.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink VLDBG1251" href="../../server.112/e25523/part_avail.htm#VLDBG1251"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> to learn how to use prefixed and nonprefixed indexes</div>
</div>
<!-- class="sect4" -->
<div id="CNCPT88869" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref476"></a>
<h5 class="sect4">Local Partitioned Index Storage</h5>
<p>Like a table partition, a local index partition is stored in its own segment. Each segment contains a portion of the total index data. Thus, a local index made up of four partitions is not stored in a single index segment, but in four separate segments.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF54053" href="../../server.112/e41084/statements_5012.htm#SQLRF54053"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">CREATE INDEX ... LOCAL</code> examples</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="CNCPT1521" class="sect3"><a id="sthref477"></a>
<h4 class="sect3">Global Partitioned Indexes</h4>
<p><a id="sthref478"></a><a id="sthref479"></a>A <span class="bold">global partitioned index</span> is a B-tree index that is partitioned independently of the underlying table on which it is created. A single index partition can point to any or all table partitions, whereas in a locally partitioned index, a one-to-one parity exists between index partitions and table partitions.</p>
<p>In general, global indexes are useful for OLTP applications, where rapid access, data integrity, and availability are important. In an OLTP system, a table may be partitioned by one key, for example, the <code dir="ltr">employees.department_id</code> column, but an application may need to access the data with many different keys, for example, by <code dir="ltr">employee_id</code> or <code dir="ltr">job_id</code>. Global indexes can be useful in this scenario.</p>
<p>You can partition a global index by range or by hash. If partitioned by range, then the database partitions the global index on the ranges of values from the table columns you specify in the column list. If partitioned by hash, then the database assigns rows to the partitions using a hash function on values in the partitioning key columns.</p>
<p>As an illustration, suppose that you create a global partitioned index on the <code dir="ltr">time_range_sales</code> table from <a href="#CFAHGJEJ">Example 4-2</a>. In this table, rows for sales from 1998 are stored in one partition, rows for sales from 1999 are in another, and so on. <a href="#BABBEIJB">Example 4-6</a> creates a global index partitioned by range on the <code dir="ltr">channel_id</code> column.</p>
<div id="CNCPT89164" class="example">
<p class="titleinexample"><a id="BABBEIJB"></a>Example 4-6 Global Partitioned Index</p>
<pre dir="ltr">
CREATE INDEX time_channel_sales_idx ON time_range_sales (<span class="bold">channel_id</span>)
   GLOBAL PARTITION BY RANGE (<span class="bold">channel_id</span>)
      (PARTITION p1 VALUES LESS THAN (3),
       PARTITION p2 VALUES LESS THAN (4),
       PARTITION p3 VALUES LESS THAN (MAXVALUE));
</pre></div>
<!-- class="example" -->
<p>As shown in <a href="#CFAEBFFA">Figure 4-5</a>, a global index partition can contain entries that point to multiple table partitions. Index partition <code dir="ltr">p1</code> points to the rows with a <code dir="ltr">channel_id</code> of 2, index partition <code dir="ltr">p2</code> points to the rows with a <code dir="ltr">channel_id</code> of 3, and index partition <code dir="ltr">p3</code> points to the rows with a <code dir="ltr">channel_id</code> of 4 or 9.</p>
<div id="CNCPT88870" class="figure">
<p class="titleinfigure"><a id="CFAEBFFA"></a>Figure 4-5 Global Partitioned Index</p>
<img width="654" height="770" src="img/cncpt300.gif" alt="Description of Figure 4-5 follows" /><br />
<a id="sthref480" href="img_text/cncpt300.htm">Description of "Figure 4-5 Global Partitioned Index"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink VLDBG1256" href="../../server.112/e25523/part_avail.htm#VLDBG1256"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> to learn how to use global partitioned indexes</p>
</li>
<li>
<p><a class="olink SQLRF54051" href="../../server.112/e41084/statements_5012.htm#SQLRF54051"><span class="italic">Oracle Database SQL Language Reference</span></a> for<a id="sthref481"></a> <code dir="ltr">CREATE INDEX ... GLOBAL</code> examples</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CNCPT1514" class="sect2"><a id="sthref482"></a>
<h3 class="sect2">Partitioned Index-Organized Tables</h3>
<p>You can partition an <a id="sthref483"></a><a id="sthref484"></a><a id="sthref485"></a><a id="sthref486"></a><a href="glossary.htm#CHDJJFII"><span class="xrefglossterm">index-organized table</span></a> (IOT) by range, list, or hash. Partitioning is useful for providing improved manageability, availability, and performance for IOTs. In addition, data cartridges that use IOTs can take advantage of the ability to partition their stored data.</p>
<p>Note the following characteristics of partitioned IOTs:</p>
<ul>
<li>
<p>Partition columns must be a subset of primary key columns.</p>
</li>
<li>
<p>Secondary indexes can be partitioned locally and globally.</p>
</li>
<li>
<p><code dir="ltr">OVERFLOW</code> data segments are always equipartitioned with the table partitions.</p>
</li>
</ul>
<p>Oracle Database supports bitmap indexes on partitioned and nonpartitioned index-organized tables. A mapping table is required for creating bitmap indexes on an index-organized table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="indexiot.htm#CBBJEBIH">"Overview of Index-Organized Tables"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i20690"></a>
<div id="CNCPT311" class="sect1">
<h2 class="sect1">Overview of Views</h2>
<p><a id="sthref487"></a><a id="sthref488"></a><a id="sthref489"></a>A <a href="glossary.htm#i432872"><span class="xrefglossterm">view</span></a> is a logical representation of one or more tables. In essence, a view is a stored query. A view derives its data from the tables on which it is based, <a id="sthref490"></a><a id="sthref491"></a>called <span class="bold">base tables</span>. Base tables can be tables or other views. All operations performed on a view actually affect the base tables. You can use views in most places where tables are used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Materialized views use a different data structure from standard views. See <a href="#CFAIGHFC">"Overview of Materialized Views"</a>.</div>
<p><a id="sthref492"></a>Views enable you to tailor the presentation of data to different types of users. Views are often used to:</p>
<ul>
<li>
<p><a id="sthref493"></a>Provide an additional level of table security by restricting access to a predetermined set of rows or columns of a table</p>
<p>For example, <a href="#i5739">Figure 4-6</a> shows how the <code dir="ltr">staff</code> view does not show the <code dir="ltr">salary</code> or <code dir="ltr">commission_pct</code> columns of the base table <code dir="ltr">employees</code>.</p>
</li>
<li>
<p><a id="sthref494"></a>Hide data complexity</p>
<p>For example, a single view can be defined with a <a href="glossary.htm#CHDDCCEI"><span class="xrefglossterm">join</span></a>, which is a collection of related columns or rows in multiple tables. However, the view hides the fact that this information actually originates from several tables. A query might also perform extensive calculations with table information. Thus, users can query a view without knowing how to perform a join or calculations.</p>
</li>
<li>
<p>Present the data in a different perspective from that of the base table</p>
<p>For example, the columns of a view can be renamed without affecting the tables on which the view is based.</p>
</li>
<li>
<p>Isolate applications from changes in definitions of base tables</p>
<p>For example, if the defining query of a view references three columns of a four column table, and a fifth column is added to the table, then the definition of the view is not affected, and all applications using the view are not affected.</p>
</li>
</ul>
<p>For an example of the use of views, consider the <code dir="ltr">hr.employees</code> table, which has several columns and numerous rows. To allow users to see only five of these columns or only specific rows, you could create a view as follows:</p>
<pre dir="ltr">
CREATE VIEW staff AS
  SELECT employee_id, last_name, job_id, manager_id, department_id
  FROM   employees;
</pre>
<p>As with all <a id="sthref495"></a><a id="sthref496"></a><a id="sthref497"></a><a href="glossary.htm#CHDJDAFA"><span class="xrefglossterm">subqueries</span></a>, the query that defines a view cannot contain the <code dir="ltr">FOR UPDATE</code> clause. <a href="#i5739">Figure 4-6</a> graphically illustrates the view named <code dir="ltr">staff</code>. Notice that the view shows only five of the columns in the base table.</p>
<div id="CNCPT88871" class="figure">
<p class="titleinfigure"><a id="i5739"></a>Figure 4-6 View</p>
<img width="648" height="327" src="img/cncpt045.gif" alt="Description of Figure 4-6 follows" /><br />
<a id="sthref498" href="img_text/cncpt045.htm">Description of "Figure 4-6 View"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11774" href="../../server.112/e25494/views.htm#ADMIN11774"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manage views</p>
</li>
<li>
<p><a class="olink SQLRF01504" href="../../server.112/e41084/statements_8004.htm#SQLRF01504"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">CREATE VIEW</code> syntax and semantics</p>
</li>
</ul>
</div>
<div id="CNCPT1145" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref499"></a>
<h3 class="sect2">Characteristics of Views</h3>
<p>Unlike a table, a view is not allocated storage space, nor does a view contain data. Rather, a view is defined by a query that extracts or derives data from the base tables referenced by the view. Because a view is based on other objects, it requires no storage other than storage for the query that defines the view in the <a href="glossary.htm#CHDJJJGD"><span class="xrefglossterm">data dictionary</span></a>.<a id="sthref500"></a><a id="sthref501"></a></p>
<p><a id="sthref502"></a><a id="sthref503"></a>A view has dependencies on its referenced objects, which are automatically handled by the database. For example, if you drop and re-create a base table of a view, then the database determines whether the new base table is acceptable to the view definition.</p>
<div id="CNCPT88872" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref504"></a>
<h4 class="sect3">Data Manipulation in Views</h4>
<p>Because views are derived from tables, they have many similarities. For example, a view can contain up to 1000 columns, just like a table. Users can query views, and with some restrictions they can perform DML on views. Operations performed on a view affect data in some base table of the view and are subject to the <a id="sthref505"></a><a id="sthref506"></a>integrity constraints and triggers of the base tables.</p>
<p>The following example creates a view of the <code dir="ltr">hr.employees</code> table:</p>
<pre dir="ltr">
CREATE VIEW staff_dept_10 AS
SELECT employee_id, last_name, job_id, 
       manager_id, department_id
FROM   employees
WHERE  department_id = 10
WITH CHECK OPTION CONSTRAINT staff_dept_10_cnst;
</pre>
<p>The defining query references only rows for department 10. The <code dir="ltr">CHECK OPTION</code> creates the view with a constraint so that <code dir="ltr">INSERT</code> and <code dir="ltr">UPDATE</code> statements issued against the view cannot result in rows that the view cannot select. Thus, rows for employees in department 10 can be inserted, but not rows for department 30.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF55299" href="../../server.112/e41084/statements_10002.htm#SQLRF55299"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about subquery restrictions in <code dir="ltr">CREATE VIEW</code> statements</div>
</div>
<!-- class="sect3" -->
<div id="CNCPT1147" class="sect3"><a id="sthref507"></a>
<h4 class="sect3">How Data Is Accessed in Views</h4>
<p><a id="sthref508"></a>Oracle Database stores a view definition in the data dictionary as the text of the query that defines the view. When you reference a view in a SQL statement, Oracle Database performs the following tasks:</p>
<ol>
<li>
<p>Merges a query (whenever possible) against a view with the queries that define the view and any underlying views</p>
<p>Oracle Database optimizes the merged query as if you issued the query without referencing the views. Therefore, Oracle Database can use indexes on any referenced base table columns, whether the columns are referenced in the view definition or in the user query against the view.</p>
<p>Sometimes Oracle Database cannot merge the view definition with the user query. In such cases, Oracle Database may not use all indexes on referenced columns.</p>
</li>
<li>
<p>Parses the merged statement in a <a id="sthref509"></a><a href="glossary.htm#CHDFIJAF"><span class="xrefglossterm">shared SQL area</span></a></p>
<p>Oracle Database parses a statement that references a view in a new shared SQL area <span class="italic">only</span> if no existing shared SQL area contains a similar statement. Thus, views provide the benefit of reduced memory use associated with shared SQL.</p>
</li>
<li>
<p>Executes the SQL statement</p>
</li>
</ol>
<p><a id="sthref510"></a>The following example illustrates data access when a view is queried. Assume that you create <code dir="ltr">employees_view</code> based on the <code dir="ltr">employees</code> and <code dir="ltr">departments</code> tables:</p>
<pre dir="ltr">
CREATE VIEW employees_view AS 
  SELECT employee_id, last_name, salary, location_id
  FROM   employees JOIN departments USING (department_id)
  WHERE  department_id = 10; 
</pre>
<p>A user executes the following query of <code dir="ltr">employees_view</code>:</p>
<pre dir="ltr">
SELECT last_name 
FROM   employees_view 
WHERE  employee_id = 200;
</pre>
<p>Oracle Database merges the view and the user query to construct the following query, which it then executes to retrieve the data:</p>
<pre dir="ltr">
SELECT last_name
FROM   employees, departments
WHERE  employees.department_id = departments.department_id 
AND    departments.department_id = 10 
AND    employees.employee_id = 200;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="sqllangu.htm#i8709">"Overview of the Optimizer"</a> and <a class="olink PFGRF001" href="../../server.112/e41573/optimops.htm#PFGRF001"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn about query optimization</p>
</li>
<li>
<p><a href="memory.htm#i9081">"Shared SQL Areas"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i19228"></a>
<div id="CNCPT1151" class="sect2">
<h3 class="sect2">Updatable Join Views</h3>
<p><a id="sthref511"></a><a id="sthref512"></a><a id="sthref513"></a><a id="sthref514"></a>A <span class="bold">join view</span> is defined as a view that has multiple tables or views in its <code dir="ltr">FROM</code> clause. In <a href="#CFACJAIA">Example 4-7</a>, the <code dir="ltr">staff_dept_10_30</code> view joins the <code dir="ltr">employees</code> and <code dir="ltr">departments</code> tables, including only employees in departments 10 or 30.</p>
<div id="CNCPT88873" class="example">
<p class="titleinexample"><a id="CFACJAIA"></a>Example 4-7 Join View</p>
<pre dir="ltr">
CREATE VIEW staff_dept_10_30 AS
SELECT employee_id, last_name, job_id, e.department_id
FROM   employees e, departments d
WHERE  e.department_id IN (10, 30)
AND    e.department_id = d.department_id;
</pre></div>
<!-- class="example" -->
<p>An <a id="sthref515"></a><span class="bold">updatable join view</span>, also called a <span class="bold">modifiable join view</span>, involves two or more base tables or views and permits DML operations. <a id="sthref516"></a>An updatable view contains multiple tables in the top-level <code dir="ltr">FROM</code> clause of the <code dir="ltr">SELECT</code> statement and is not restricted by the <code dir="ltr">WITH READ ONLY</code> clause.</p>
<p>To be inherently updatable, a view must meet several criteria. For example, a general rule is that an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> operation on a join view can modify only one base table at a time. The following query of the <code dir="ltr">USER_UPDATABLE_COLUMNS</code> data dictionary view shows that the view created in <a href="#CFACJAIA">Example 4-7</a> is updatable:</p>
<pre dir="ltr">
SQL&gt; SELECT TABLE_NAME, COLUMN_NAME, UPDATABLE 
  2  FROM   USER_UPDATABLE_COLUMNS 
  3  WHERE  TABLE_NAME = 'STAFF_DEPT_10_30';
 
TABLE_NAME                     COLUMN_NAME                    UPD
------------------------------ ------------------------------ ---
STAFF_DEPT_10_30               EMPLOYEE_ID                    YES
STAFF_DEPT_10_30               LAST_NAME                      YES
STAFF_DEPT_10_30               JOB_ID                         YES
STAFF_DEPT_10_30               DEPARTMENT_ID                  YES
</pre>
<p>All updatable columns of a join view must map to columns of a key-preserved table. A <span class="bold">key-preserved table</span> <a id="sthref517"></a><a id="sthref518"></a>in a join query is a table in which each row of the underlying table appears at most one time in the output of the query. In <a href="#CFACJAIA">Example 4-7</a>, <code dir="ltr">department_id</code> is the primary key of the <code dir="ltr">departments</code> table, so each row from the <code dir="ltr">employees</code> table appears at most once in the <a id="sthref519"></a><a id="sthref520"></a>result set, making the <code dir="ltr">employees</code> table key-preserved. The <code dir="ltr">departments</code> table is not key-preserved because each of its rows may appear many times in the result set.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11782" href="../../server.112/e25494/views.htm#ADMIN11782"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to update join views</div>
</div>
<!-- class="sect2" -->
<a id="CHDEIIGI"></a>
<div id="CNCPT1152" class="sect2">
<h3 class="sect2">Object Views</h3>
<p><a id="sthref521"></a><a id="sthref522"></a>Just as a view is a virtual table, an <span class="bold">object view</span> is a virtual object table. Each row in the view is an <span class="bold">object</span>, which is an instance of an <a id="sthref523"></a><a id="sthref524"></a><a href="glossary.htm#i996725"><span class="xrefglossterm">object type</span></a>. An object type is a user-defined data type.</p>
<p>You can retrieve, update, insert, and delete relational data as if it was stored as an object type. You can also define views with columns that are object data types, such as objects, <code dir="ltr">REF</code>s, and collections (nested tables and <code dir="ltr">VARRAY</code>s).</p>
<p>Like relational views, object views can present only the data that you want users to see. For example, an object view could present data about IT programmers but omit sensitive data about salaries. The following example creates an <code dir="ltr">employee_type</code> object and then the view <code dir="ltr">it_prog_view</code> based on this object:</p>
<pre dir="ltr">
CREATE TYPE employee_type AS OBJECT
(
  employee_id  NUMBER (6),
  last_name    VARCHAR2 (25),
  job_id       VARCHAR2 (10)
);
/

CREATE VIEW it_prog_view OF employee_type
  WITH OBJECT IDENTIFIER (employee_id) AS 
SELECT  e.employee_id, e.last_name, e.job_id
FROM    employees e
WHERE   job_id = 'IT_PROG';
</pre>
<p>Object views are useful in prototyping or transitioning to object-oriented applications because the data in the view can be taken from relational tables and accessed as if the table were defined as an object table. You can run object-oriented applications without converting existing tables to a different physical structure.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADOBJ7026" href="../../appdev.112/e11822/adobjint.htm#ADOBJ7026"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> to learn about object types and object views</p>
</li>
<li>
<p><a class="olink SQLRF01506" href="../../server.112/e41084/statements_8001.htm#SQLRF01506"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code dir="ltr">CREATE TYPE</code> command</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CFAIGHFC"></a>
<div id="CNCPT411" class="sect1">
<h2 class="sect1">Overview of Materialized Views</h2>
<p><span class="bold"><a id="sthref525"></a><a id="sthref526"></a><a id="sthref527"></a><a id="sthref528"></a>Materialized views</span> are query results that have been stored or "materialized" in advance as schema objects. The <code dir="ltr">FROM</code> clause of the query can name tables, views, and materialized views. Collectively these objects are called<a id="sthref529"></a><a id="sthref530"></a><a id="sthref531"></a><a id="sthref532"></a> <span class="bold">master tables</span> (a replication term) or <span class="bold">detail tables</span> (a data warehousing term).</p>
<p>Materialized views are used to summarize, compute, replicate, and distribute data. They are suitable in various computing environments, such as the following:</p>
<ul>
<li>
<p><a id="sthref533"></a><a id="sthref534"></a><a id="sthref535"></a><a id="sthref536"></a>In data warehouses, you can use materialized views to compute and store data generated from aggregate functions such as sums and averages.</p>
<p>A <span class="bold">summary</span> is an aggregate view that reduces query time by precalculating joins and aggregation operations and storing the results in a table. Materialized views are equivalent to summaries (see <a href="cmntopc.htm#i32111">"Data Warehouse Architecture (Basic)"</a>). You can also use materialized views to compute joins with or without aggregations. If compatibility is set to Oracle9<span class="italic">i</span> or higher, then materialized views are usable for queries that include filter selections.</p>
</li>
<li>
<p>In materialized view<a id="sthref537"></a> <a href="glossary.htm#CHDJDBAG"><span class="xrefglossterm">replication</span></a>, the view contains a complete or partial copy of a table from a single point in time. Materialized views replicate data at distributed sites and synchronize updates performed at several sites. This form of replication is suitable for environments such as field sales when databases are not always connected to the network.</p>
</li>
<li>
<p>In mobile computing environments, you can use materialized views to download a data subset from central servers to mobile clients, with periodic refreshes from the central servers and propagation of updates by clients to the central servers.</p>
</li>
</ul>
<p>In a <a id="sthref538"></a><a id="sthref539"></a><a id="sthref540"></a>replication environment, a materialized view shares data with a table in a different database, called a <span class="bold">master database</span>. The table associated with the materialized view at the master site is the <span class="bold">master table</span>. <a href="#CFACFDIG">Figure 4-7</a> illustrates a materialized view in one database based on a master table in another database. Updates to the master table replicate to the materialized view database.</p>
<div id="CNCPT88874" class="figure">
<p class="titleinfigure"><a id="CFACFDIG"></a>Figure 4-7 Materialized View</p>
<img width="371" height="362" src="img/cncpt260.gif" alt="Description of Figure 4-7 follows" /><br />
<a id="sthref541" href="img_text/cncpt260.htm">Description of "Figure 4-7 Materialized View"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="cmntopc.htm#BABJBGBE">"Information Sharing"</a> to learn about replication with Oracle Streams</p>
</li>
<li>
<p><a class="olink TDPII048" href="../../server.112/e17516/tdpii_reppit.htm#TDPII048"><span class="italic">Oracle Database 2 Day + Data Replication and Integration Guide</span></a> and <a class="olink REPLN003" href="../../server.112/e10706/repmview.htm#REPLN003"><span class="italic">Oracle Database Advanced Replication</span></a> to learn how to use materialized views</p>
</li>
<li>
<p><a class="olink SQLRF01302" href="../../server.112/e41084/statements_6002.htm#SQLRF01302"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the<a id="sthref542"></a> <code dir="ltr">CREATE MATERIALIZED VIEW</code> statement</p>
</li>
</ul>
</div>
<div id="CNCPT88875" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref543"></a>
<h3 class="sect2">Characteristics of Materialized Views</h3>
<p>Materialized views share some characteristics of nonmaterialized views and indexes. Materialized views are similar to indexes in the following ways:</p>
<ul>
<li>
<p>They contain actual data and consume storage space.</p>
</li>
<li>
<p>They can be refreshed when the data in their master tables changes.</p>
</li>
<li>
<p>They can improve performance of SQL execution when used for query rewrite operations.</p>
</li>
<li>
<p>Their existence is transparent to SQL applications and users.</p>
</li>
</ul>
<p>A materialized view is similar to a nonmaterialized view because it represents data in other tables and views. Unlike indexes, users can query materialized views directly using <code dir="ltr">SELECT</code> statements. Depending on the types of refresh that are required, the views can also be updated with DML statements.</p>
<p>The following example creates and populates a materialized aggregate view based on three master tables in the <code dir="ltr">sh</code> sample schema:</p>
<pre dir="ltr">
CREATE MATERIALIZED VIEW sales_mv AS 
  SELECT t.calendar_year, p.prod_id, SUM(s.amount_sold) AS sum_sales
  FROM   times t, products p, sales s
  WHERE  t.time_id = s.time_id 
  AND    p.prod_id = s.prod_id
  GROUP BY t.calendar_year, p.prod_id;
</pre>
<p>The following example drops table <code dir="ltr">sales</code>, which is a master table for <code dir="ltr">sales_mv</code>, and then queries <code dir="ltr">sales_mv</code>. The query selects data because the rows are stored (materialized) separately from the data in the master tables.</p>
<pre dir="ltr">
SQL&gt; DROP TABLE sales;

Table dropped.

SQL&gt; SELECT * FROM sales_mv WHERE ROWNUM &lt; 4;
 
CALENDAR_YEAR    PROD_ID  SUM_SALES
------------- ---------- ----------
         1998         13  936197.53
         1998         26  567533.83
         1998         27  107968.24
</pre>
<p><a id="sthref544"></a><a id="sthref545"></a>A materialized view can be partitioned. You can define a materialized view on a partitioned table and one or more indexes on the materialized view.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG008" href="../../server.112/e25554/basicmv.htm#DWHSG008"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn how to use materialized views in a data warehouse</div>
</div>
<!-- class="sect2" -->
<div id="CNCPT1155" class="sect2"><a id="sthref546"></a>
<h3 class="sect2">Refresh Methods for Materialized Views</h3>
<p><a id="sthref547"></a><a id="sthref548"></a><a id="sthref549"></a><a id="sthref550"></a><a id="sthref551"></a>The database maintains data in materialized views by refreshing them after changes to their master tables. The refresh method can be incremental, known as <span class="bold">fast refresh</span>, or a <span class="bold">complete refresh</span>.</p>
<p>A complete refresh occurs when the materialized view is initially defined as <code dir="ltr">BUILD IMMEDIATE</code>, unless the materialized view references a prebuilt table. The refresh involves executing the query that defines the materialized view. This process can be slow, especially if the database must read and process huge amounts of data.</p>
<p>A fast refresh eliminates the need to rebuild materialized views from scratch. Thus, processing only the changes can result in a very fast refresh time. Materialized views can be refreshed either on demand or at regular time intervals. Alternatively, materialized views in the same database as their master tables can be refreshed whenever a transaction commits its changes to the master tables.</p>
<p>For materialized views that use the fast refresh method, <a id="sthref552"></a>a <span class="bold">materialized view log</span> or <span class="bold">direct loader log</span> keeps a record of changes to the master tables. A materialized view log is a schema object that records changes to master table data so that a materialized view defined on the master table can be refreshed incrementally. Each materialized view log is associated with a single master table. The materialized view log resides in the same database and schema as its master table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG03003" href="../../server.112/e25554/refresh.htm#DWHSG03003"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn how to refresh materialized views</p>
</li>
<li>
<p><a class="olink REPLN107" href="../../server.112/e10706/repmview.htm#REPLN107"><span class="italic">Oracle Database Advanced Replication</span></a> to learn about materialized view logs</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CFAHEBBA"></a>
<div id="CNCPT88876" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Query Rewrite</h3>
<p><span class="bold">Query rewrite</span> <a id="sthref553"></a><a id="sthref554"></a>is an optimization technique that transforms a user request written in terms of master tables into a semantically equivalent request that includes materialized views. When base tables contain large amounts of data, computing an aggregate or <a href="glossary.htm#CHDGBDJE"><span class="xrefglossterm">join</span></a> is expensive and time-consuming. Because materialized views contain precomputed aggregates and joins, query rewrite can quickly answer queries using materialized views.</p>
<p>The <a href="glossary.htm#CHDGHIIF"><span class="xrefglossterm">optimizer</span></a><a id="sthref555"></a><a id="sthref556"></a> <span class="bold">query transformer</span> transparently rewrites the request to use the materialized view, requiring no user intervention and no reference to the materialized view in the SQL statement. Because query rewrite is transparent, materialized views can be added or dropped without invalidating the SQL in the application code.</p>
<p>In general, rewriting queries to use materialized views rather than detail tables improves response time. <a href="#CFABICCA">Figure 4-8</a> shows the database generating an <a id="sthref557"></a><a id="sthref558"></a><a href="glossary.htm#CHDJEJHC"><span class="xrefglossterm">execution plan</span></a> for the original and rewritten query and choosing the lowest-cost plan.</p>
<div id="CNCPT88877" class="figure">
<p class="titleinfigure"><a id="CFABICCA"></a>Figure 4-8 Query Rewrite</p>
<img width="593" height="300" src="img/cncpt334.gif" alt="Description of Figure 4-8 follows" /><br />
<a id="sthref559" href="img_text/cncpt334.htm">Description of "Figure 4-8 Query Rewrite"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="sqllangu.htm#i8709">"Overview of the Optimizer"</a></p>
</li>
<li>
<p><a class="olink DWHSG018" href="../../server.112/e25554/qrbasic.htm#DWHSG018"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn how to use query rewrite</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5667"></a>
<div id="CNCPT611" class="sect1">
<h2 class="sect1">Overview of Sequences</h2>
<p><a id="sthref560"></a><a id="sthref561"></a>A <span class="bold">sequence</span> is a schema object from which multiple users can generate unique integers. A sequence generator provides a highly scalable and well-performing method to generate surrogate keys for a number data type.</p>
<div id="CNCPT88878" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref562"></a>
<h3 class="sect2">Sequence Characteristics</h3>
<p>A sequence definition indicates general information, such as the following:</p>
<ul>
<li>
<p>The name of the sequence</p>
</li>
<li>
<p>Whether the sequence ascends or descends</p>
</li>
<li>
<p>The interval between numbers</p>
</li>
<li>
<p>Whether the database should cache sets of generated sequence numbers in memory</p>
</li>
<li>
<p>Whether the sequence should cycle when a limit is reached</p>
</li>
</ul>
<p>The following example creates the sequence <code dir="ltr">customers_seq</code> in the sample schema <code dir="ltr">oe</code>. An application could use this sequence to provide customer ID numbers when rows are added to the <code dir="ltr">customers</code> table.</p>
<pre dir="ltr">
CREATE SEQUENCE customers_seq
START WITH      1000
INCREMENT BY    1
NOCACHE
NOCYCLE;
</pre>
<p>The first reference to <code dir="ltr">customers_seq.nextval</code> returns <code dir="ltr">1000</code>. The second returns <code dir="ltr">1001</code>. Each subsequent reference returns a value 1 greater than the previous reference.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink TDDDG34000" href="../../appdev.112/e10766/tdddg_objects.htm#TDDDG34000"><span class="italic">Oracle Database 2 Day Developer's Guide</span></a> and <a class="olink ADMIN11796" href="../../server.112/e25494/views.htm#ADMIN11796"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manage sequences</p>
</li>
<li>
<p><a class="olink SQLRF01314" href="../../server.112/e41084/statements_6015.htm#SQLRF01314"><span class="italic">Oracle Database SQL Language Reference</span></a> <a id="sthref563"></a>for <code dir="ltr">CREATE SEQUENCE</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="CNCPT88879" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref564"></a>
<h3 class="sect2">Concurrent Access to Sequences</h3>
<p><a id="sthref565"></a>The same sequence generator can generate numbers for multiple tables. In this way, the database can generate primary keys automatically and coordinate keys across multiple rows or tables. For example, a sequence can generate primary keys for an <code dir="ltr">orders</code> table and a <code dir="ltr">customers</code> table.</p>
<p>The sequence generator is useful in multiuser environments for generating unique numbers without the overhead of disk I/O or transaction locking. For example, two users simultaneously insert new rows into the <code dir="ltr">orders</code> table. By using a sequence to generate unique numbers for the <code dir="ltr">order_id</code> column, neither user has to wait for the other to enter the next available order number. The sequence automatically generates the correct values for each user.</p>
<p>Each user that references a sequence has access to his or her current sequence number, which is the last sequence generated in the <a id="sthref566"></a><a href="glossary.htm#i432744"><span class="xrefglossterm">session</span></a>. A user can issue a statement to generate a new sequence number or use the current number last generated by the session. After a statement in a session generates a sequence number, it is available only to this session. Individual sequence numbers can be skipped if they were generated and used in a transaction that was ultimately rolled back.</p>
<div class="infoboxnotewarn">
<p class="notep1">Caution:</p>
<p class="warnsp">If your application requires a gap-free set of numbers, then you cannot use Oracle sequences. You must serialize activities in the database using your own developed code.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="consist.htm#g43931">Chapter 9, "Data Concurrency and Consistency"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i18190"></a>
<div id="CNCPT511" class="sect1">
<h2 class="sect1">Overview of Dimensions</h2>
<p><a id="sthref567"></a><a id="sthref568"></a><a id="sthref569"></a>A typical <a href="glossary.htm#CHDCBJAD"><span class="xrefglossterm">data warehouse</span></a> has two important components: dimensions and facts. A <a href="glossary.htm#CHDGCBFA"><span class="xrefglossterm">dimension</span></a> is any category used in specifying business questions, for example, time, geography, product, department, and distribution channel. A <span class="bold">fact</span> is an event or entity associated with a particular set of dimension values, for example, units sold or profits.</p>
<p>Examples of multidimensional requests include the following:</p>
<ul>
<li>
<p>Show total sales across all products at increasing aggregation levels for a geography dimension, from state to country to region, for 2010 and 2011.</p>
</li>
<li>
<p>Create a cross-tabular analysis of our operations showing expenses by territory in South America for 2010 and 2011. Include all possible subtotals.</p>
</li>
<li>
<p>List the top 10 sales representatives in Asia according to 2011 sales revenue for automotive products, and rank their commissions.</p>
</li>
</ul>
<p>Many multidimensional questions require aggregated data and comparisons of data sets, often across time, geography or budgets.</p>
<p>Creating a dimension permits the broader use of the <a id="sthref570"></a>query rewrite feature. By transparently rewriting queries to use <a href="glossary.htm#CHDHHDAI"><span class="xrefglossterm">materialized views</span></a>, the database can improve query performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cmntopc.htm#i30644">"Overview of Data Warehousing and Business Intelligence"</a></div>
<div id="CNCPT88880" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref571"></a>
<h3 class="sect2">Hierarchical Structure of a Dimension</h3>
<p><a id="sthref572"></a><a id="sthref573"></a>A <span class="bold">dimension table</span> is a logical structure that defines hierarchical relationships between pairs of columns or column sets. A dimension has no data storage assigned to it. Dimensional information is stored in dimension tables, whereas fact information is stored in a<a id="sthref574"></a><a id="sthref575"></a> <span class="bold">fact table</span>.</p>
<p>Within a customer dimension, customers could roll up to city, state, country, subregion, and region. Data analysis typically starts at higher levels in the dimensional hierarchy and gradually drills down if the situation warrants such analysis.</p>
<p>Each value at the child level is associated with one and only one value at the parent level. A hierarchical relationship is a <span class="bold">functional dependency</span> from one level of a hierarchy to the next level in the hierarchy.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG010" href="../../server.112/e25554/dimen.htm#DWHSG010"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn about dimensions</p>
</li>
<li>
<p><a class="olink OLAUG300" href="../../olap.112/e17123/cubes.htm#OLAUG300"><span class="italic">Oracle OLAP User's Guide</span></a> to learn how to create dimensions</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="CNCPT88881" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref576"></a>
<h3 class="sect2">Creation of Dimensions</h3>
<p>Dimensions are created with SQL statements. <a id="sthref577"></a>The <code dir="ltr">CREATE</code> <code dir="ltr">DIMENSION</code> statement specifies:</p>
<ul>
<li>
<p><a id="sthref578"></a>Multiple <code dir="ltr">LEVEL</code> clauses, each of which identifies a column or column set in the dimension</p>
</li>
<li>
<p><a id="sthref579"></a>One or more <code dir="ltr">HIERARCHY</code> clauses that specify the parent/child relationships between adjacent levels</p>
</li>
<li>
<p><a id="sthref580"></a>Optional <code dir="ltr">ATTRIBUTE</code> clauses, each of which identifies an additional column or column set associated with an individual level</p>
</li>
</ul>
<p>The following statement was used to create the <code dir="ltr">customers_dim</code> dimension in the sample schema <code dir="ltr">sh</code>:</p>
<pre dir="ltr">
CREATE DIMENSION customers_dim 
   LEVEL customer   IS (customers.cust_id)
   LEVEL city       IS (customers.cust_city) 
   LEVEL state      IS (customers.cust_state_province) 
   LEVEL country    IS (countries.country_id) 
   LEVEL subregion  IS (countries.country_subregion) 
   LEVEL region     IS (countries.country_region) 
   HIERARCHY geog_rollup (
      customer      CHILD OF
      city          CHILD OF 
      state         CHILD OF 
      country       CHILD OF 
      subregion     CHILD OF 
      region 
   JOIN KEY (customers.country_id) REFERENCES country )
   ATTRIBUTE customer DETERMINES
   (cust_first_name, cust_last_name, cust_gender, 
    cust_marital_status, cust_year_of_birth, 
    cust_income_level, cust_credit_limit) 
   ATTRIBUTE country DETERMINES (countries.country_name);
</pre>
<p><a id="sthref581"></a><a id="sthref582"></a><a id="sthref583"></a><a id="sthref584"></a><a id="sthref585"></a><a id="sthref586"></a>The columns in a dimension can come either from the same table (<span class="bold">denormalized</span>) or from multiple tables (<span class="bold">fully</span> or <span class="bold">partially normalized</span>). For example, a normalized time dimension can include a date table, a month table, and a year table, with join conditions that connect each date row to a month row, and each month row to a year row. In a fully denormalized time dimension, the date, month, and year columns are in the same table. Whether normalized or denormalized, the hierarchical relationships among the columns must be specified in the<a id="sthref587"></a> <code dir="ltr">CREATE</code> <code dir="ltr">DIMENSION</code> statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink WBETL03001" href="../../owb.112/e10935/dim_objects.htm#WBETL03001"><span class="italic">Oracle Warehouse Builder Data Modeling, ETL, and Data Quality Guide</span></a> for information about how dimensions are used in a warehousing environment</p>
</li>
<li>
<p><a class="olink SQLRF01206" href="../../server.112/e41084/statements_5006.htm#SQLRF01206"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">CREATE DIMENSION</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5669"></a>
<div id="CNCPT711" class="sect1">
<h2 class="sect1">Overview of Synonyms</h2>
<p><a id="sthref588"></a>A <span class="bold">synonym</span> is an alias for a schema object. For example, you can create a synonym for a table or view, sequence, PL/SQL program unit, user-defined object type, or another synonym. Because a synonym is simply an alias, it requires no storage other than its definition in the data dictionary.</p>
<p>Synonyms can simplify SQL statements for database users. Synonyms are also useful for hiding the identity and location of an underlying schema object. If the underlying object must be renamed or moved, then only the synonym must be redefined. Applications based on the synonym continue to work without modification.</p>
<p><a id="sthref589"></a><a id="sthref590"></a>You can create both private and public synonyms. <a id="sthref591"></a><a id="sthref592"></a>A <span class="bold">private</span> synonym is in the schema of a specific user who has control over its availability to others. A <span class="bold">public</span> synonym is owned by the user group named <code dir="ltr">PUBLIC</code> and is accessible by every database user.</p>
<p>In <a href="#CFAHDJFB">Example 4-9</a>, a database administrator creates a public synonym named <code dir="ltr">people</code> for the <code dir="ltr">hr.employees</code> table. The user then connects to the <code dir="ltr">oe</code> schema and counts the number of rows in the table referenced by the synonym.</p>
<div id="CNCPT88882" class="example">
<p class="titleinexample"><a id="sthref593"></a>Example 4-8 Public Synonym</p>
<pre dir="ltr">
SQL&gt; CREATE PUBLIC SYNONYM people FOR hr.employees;
 
Synonym created.
 
SQL&gt; CONNECT oe
Enter password: <span class="italic">password</span>
Connected.

SQL&gt; SELECT COUNT(*) FROM people;

  COUNT(*)
----------
       107
</pre></div>
<!-- class="example" -->
<p>Use public synonyms sparingly because they make database consolidation more difficult. As shown in <a href="#CFAHDJFB">Example 4-9</a>, if another administrator attempts to create the public synonym <code dir="ltr">people</code>, then the creation fails because only one public synonym <code dir="ltr">people</code> can exist in the database. Overuse of public synonyms causes namespace conflicts between applications.</p>
<div id="CNCPT88883" class="example">
<p class="titleinexample"><a id="CFAHDJFB"></a>Example 4-9 Public Synonym</p>
<pre dir="ltr">
SQL&gt; CREATE PUBLIC SYNONYM people FOR oe.customers;
CREATE PUBLIC SYNONYM people FOR oe.customers
                      *
ERROR at line 1:
ORA-00955: name is already used by an existing object

SQL&gt; SELECT OWNER, SYNONYM_NAME, TABLE_OWNER, TABLE_NAME 
  2  FROM DBA_SYNONYMS 
  3  WHERE SYNONYM_NAME = 'PEOPLE';
 
OWNER      SYNONYM_NAME TABLE_OWNER TABLE_NAME
---------- ------------ ----------- ----------
PUBLIC     PEOPLE       HR          EMPLOYEES
</pre></div>
<!-- class="example" -->
<p><a id="sthref594"></a>Synonyms themselves are not securable. When you grant object privileges on a synonym, you are really granting privileges on the underlying object. The synonym is acting only as an alias for the object in <a id="sthref595"></a>the <code dir="ltr">GRANT</code> statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11805" href="../../server.112/e25494/views.htm#ADMIN11805"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manage synonyms</p>
</li>
<li>
<p><a class="olink SQLRF01401" href="../../server.112/e41084/statements_7001.htm#SQLRF01401"><span class="italic">Oracle Database SQL Language Reference</span></a> <a id="sthref596"></a>for <code dir="ltr">CREATE SYNONYM</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1448">
<tr>
<td class="cellalignment1455">
<table class="cellalignment1453">
<tr>
<td class="cellalignment1452"><a href="indexiot.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1452"><a href="datainte.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1457">
<table class="cellalignment1451">
<tr>
<td class="cellalignment1452"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1452"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1452"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1452"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1452"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1452"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
