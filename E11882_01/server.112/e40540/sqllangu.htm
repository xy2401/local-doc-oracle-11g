<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1056" />
<meta name="dcterms.created" content="2015-05-25T13:34:2Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Concepts" />
<meta name="dcterms.identifier" content="E40540-04" />
<meta name="dcterms.isVersionOf" content="CNCPT" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="part_datac.htm" title="Previous" type="text/html" />
<link rel="Next" href="srvrside.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e40540.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/30</span> <!-- End Header -->
<div id="CNCPT015" class="chapter"><a id="g35564"></a> <a id="i15198"></a>
<h1 class="chapter"><span class="secnum">7</span> SQL</h1>
<p>This chapter provides an overview of the Structured Query Language (<a href="glossary.htm#CHDGGEDJ"><span class="xrefglossterm">SQL</span></a>) and how Oracle Database processes SQL statements.</p>
<p>This chapter includes the following topics:</p>
<ul>
<li>
<p><a href="#i1411">Introduction to SQL</a></p>
</li>
<li>
<p><a href="#i1225">Overview of SQL Statements</a></p>
</li>
<li>
<p><a href="#i8709">Overview of the Optimizer</a></p>
</li>
<li>
<p><a href="#CHDFCAGA">Overview of SQL Processing</a></p>
</li>
</ul>
<a id="i1411"></a>
<div id="CNCPT116" class="sect1">
<h2 class="sect1">Introduction to SQL</h2>
<p>SQL (pronounced <span class="italic">sequel</span>) is the set-based, high-level declarative computer language with which all programs and users access data in an Oracle database.<a id="sthref764"></a><a id="sthref765"></a><a id="sthref766"></a> Although some Oracle tools and applications mask SQL use, all database operations are performed using SQL. Any other data access method circumvents the security built into Oracle Database and potentially compromises data security and integrity.</p>
<p>SQL provides an interface to a relational <a id="sthref767"></a>database such as Oracle Database. SQL unifies tasks such as the following in one consistent language:</p>
<ul>
<li>
<p>Creating, replacing, altering, and dropping objects</p>
</li>
<li>
<p>Inserting, updating, and deleting table rows</p>
</li>
<li>
<p><a id="sthref768"></a>Querying data</p>
</li>
<li>
<p>Controlling access to the database and its objects</p>
</li>
<li>
<p>Guaranteeing database consistency and <a id="sthref769"></a>integrity</p>
</li>
</ul>
<p>SQL can be used <span class="bold">interactively</span>, which means that statements are entered manually into a program. SQL statements can also <a id="sthref770"></a><a id="sthref771"></a><a id="sthref772"></a>be <span class="bold">embedded</span> within a program written in a different language such as C or Java.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF001" href="../../server.112/e41084/intro.htm#SQLRF001"><span class="italic">Oracle Database SQL Language Reference</span></a> for an introduction to SQL</p>
</li>
<li>
<p><a href="srvrside.htm#i19998">"Introduction to Server-Side Programming"</a> and <a href="cncptdev.htm#CHDIAAIB">"Client-Side Database Programming"</a></p>
</li>
</ul>
</div>
<div id="CNCPT88899" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref773"></a>
<h3 class="sect2">SQL Data Access</h3>
<p>There are two broad families of computer languages: <span class="bold">declarative languages</span> that are nonprocedural and describe <span class="italic">what</span> should be done, and <span class="bold">procedural languages</span> such as C++ and Java that describe <span class="italic">how</span> things should be done. SQL is declarative in the sense that users specify the result that they want, not how to derive it. The SQL language compiler performs the work of generating a procedure to navigate the database and perform the desired task.</p>
<p>SQL enables you to work with data at the logical level. You need be concerned with implementation details only when you want to manipulate the data. For example, the following statement queries records for employees whose last name begins with <code dir="ltr">K</code>:</p>
<pre dir="ltr">
SELECT   last_name, first_name
FROM     hr.employees
WHERE    last_name LIKE 'K%'
ORDER BY last_name, first_name;
</pre>
<p>The database retrieves all rows satisfying the <code dir="ltr">WHERE</code> <a id="sthref774"></a><a id="sthref775"></a><a href="glossary.htm#CHDCBGCI"><span class="xrefglossterm">condition</span></a>, also called the <a id="sthref776"></a><a href="glossary.htm#CHDEJGFG"><span class="xrefglossterm">predicate</span></a>, in a single step. These rows can be passed as a unit to the user, to another SQL statement, or to an application. You do not need to process the rows one by one, nor are you required to know how the rows are physically stored or retrieved.</p>
<p>All SQL statements use the <a id="sthref777"></a><a href="glossary.htm#CHDCAIFG"><span class="xrefglossterm">optimizer</span></a>, a part of Oracle Database that determines the most efficient means of accessing the specified data. Oracle Database also supports techniques that you can use to make the optimizer perform its job better.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for detailed information about SQL statements and other parts of SQL (such as <a id="sthref778"></a><a href="glossary.htm#CHDJCEGF"><span class="xrefglossterm">operators</span></a>, functions, and format models)</div>
</div>
<!-- class="sect2" -->
<div id="CNCPT88900" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref779"></a>
<h3 class="sect2">SQL Standards</h3>
<p>Oracle strives to follow industry-accepted standards and participates actively in SQL standards committees. Industry-accepted committees are the American National Standards Institute (ANSI) and the International Organization for Standardization (ISO). Both ANSI and the ISO/IEC have accepted SQL as the standard language for relational databases.</p>
<p>The latest <a id="sthref780"></a><a id="sthref781"></a>SQL standard was adopted in July 2003 and is often called SQL:2003. One part of the SQL standard, Part 14, SQL/XML (ISO/IEC 9075-14) was revised in 2006 and is often referred to as SQL/XML:2006.<a id="sthref782"></a></p>
<p><span class="bold"><a id="sthref783"></a><a id="sthref784"></a><a id="sthref785"></a>Oracle SQL</span> includes many extensions to the <a id="sthref786"></a>ANSI/ISO standard SQL language, and Oracle Database tools and applications provide additional statements. The tools SQL*Plus, SQL Developer, and Oracle Enterprise Manager enable you to run any ANSI/ISO standard SQL statement against an Oracle database and any additional statements or functions available for those tools.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF019" href="../../server.112/e41084/ap_standard_sql.htm#SQLRF019"><span class="italic">Oracle Database SQL Language Reference</span></a> for an explanation of the differences between Oracle SQL and standard SQL</p>
</li>
<li>
<p><a class="olink SQPUG" href="../../server.112/e16604/toc.htm"><span class="italic">SQL*Plus User's Guide and Reference</span></a> for SQL*Plus commands, including their distinction from SQL statements</p>
</li>
<li>
<p><a href="cncptdba.htm#CHDFEAEB">"Tools for Database Administrators"</a> and <a href="cncptdev.htm#CHDCDEBH">"Tools for Database Developers"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1225"></a>
<div id="CNCPT1730" class="sect1">
<h2 class="sect1">Overview of SQL Statements</h2>
<p><a id="sthref787"></a><a id="sthref788"></a><a id="sthref789"></a><a id="sthref790"></a><a id="sthref791"></a>All operations performed on the information in an Oracle database are run using SQL <span class="bold">statements</span>. A SQL statement is a computer program or instruction that consists of identifiers, parameters, variables, names, data types, and SQL <span class="bold">reserved words</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL reserved words have special meaning in SQL and should not be used for any other purpose. For example, <code dir="ltr">SELECT</code> and <code dir="ltr">UPDATE</code> are reserved words and should not be used as table names.</div>
<p>A SQL statement must be the equivalent of a complete SQL sentence, such as:</p>
<pre dir="ltr">
SELECT last_name, department_id FROM employees
</pre>
<p>Oracle Database only runs complete SQL statements. A fragment such as the following generates an error indicating that more text is required:</p>
<pre dir="ltr">
SELECT last_name;
</pre>
<p><a id="sthref792"></a>Oracle SQL statements are divided into the following categories:</p>
<ul>
<li>
<p><a href="#i18507">Data Definition Language (DDL) Statements</a></p>
</li>
<li>
<p><a href="#i18503">Data Manipulation Language (DML) Statements</a></p>
</li>
<li>
<p><a href="#i18511">Transaction Control Statements</a></p>
</li>
<li>
<p><a href="#i18515">Session Control Statements</a></p>
</li>
<li>
<p><a href="#i18519">System Control Statement</a></p>
</li>
<li>
<p><a href="#i18523">Embedded SQL Statements</a></p>
</li>
</ul>
<a id="i18507"></a>
<div id="CNCPT1732" class="sect2">
<h3 class="sect2">Data Definition Language (DDL) Statements</h3>
<p><a id="sthref793"></a><a id="sthref794"></a>Data definition language (<a href="glossary.htm#CHDFBCII"><span class="xrefglossterm">DDL</span></a>) statements define, structurally change, and drop <a id="sthref795"></a><a href="glossary.htm#CHDBHJCF"><span class="xrefglossterm">schema objects</span></a>. For example, DDL statements enable you to:</p>
<ul>
<li>
<p>Create, alter, and drop schema objects and other database structures, including the database itself and database users. Most DDL statements start with the keywords <code dir="ltr">CREATE</code>, <code dir="ltr">ALTER</code>, or <code dir="ltr">DROP</code>.</p>
</li>
<li>
<p><a id="sthref796"></a><a id="sthref797"></a>Delete all the data in schema objects without removing the structure of these objects (<code dir="ltr">TRUNCATE</code>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Unlike <code dir="ltr">DELETE</code>, <code dir="ltr">TRUNCATE</code> generates no <a href="glossary.htm#CHDDFBFI"><span class="xrefglossterm">undo data</span></a>, which makes it faster than <code dir="ltr">DELETE</code>. Also, <code dir="ltr">TRUNCATE</code> does not invoke delete <a href="glossary.htm#CHDBBAJJ"><span class="xrefglossterm">triggers</span></a>.</div>
</li>
<li>
<p><a id="sthref798"></a><a id="sthref799"></a><a id="sthref800"></a><a id="sthref801"></a>Grant and revoke privileges and roles (<code dir="ltr">GRANT</code>, <code dir="ltr">REVOKE</code>).</p>
</li>
<li>
<p>Turn <a id="sthref802"></a><a id="sthref803"></a><a id="sthref804"></a>auditing options on and off (<code dir="ltr">AUDIT</code>, <code dir="ltr">NOAUDIT</code>).</p>
</li>
<li>
<p><a id="sthref805"></a><a id="sthref806"></a>Add a comment to the <a href="glossary.htm#CHDJCHJA"><span class="xrefglossterm">data dictionary</span></a> (<code dir="ltr">COMMENT</code>).</p>
</li>
</ul>
<p>DDL enables you to alter attributes of an object without altering the applications that access the object. For example, you can add a column to a table accessed by a human resources application without rewriting the application. You can also use DDL to alter the structure of objects while database users are performing work in the database.</p>
<p><a href="#CHDHBIGA">Example 7-1</a> uses DDL statements to create the <code dir="ltr">plants</code> table and then uses DML to insert two rows in the table. The example then uses DDL to alter the table structure, grant and revoke privileges on this table to a user, and then drop the table.</p>
<div id="CNCPT88901" class="example">
<p class="titleinexample"><a id="CHDHBIGA"></a>Example 7-1 DDL Statements</p>
<pre dir="ltr">
CREATE TABLE plants
    ( plant_id    NUMBER PRIMARY KEY, 
      common_name VARCHAR2(15) );

INSERT INTO plants VALUES (1, 'African Violet'); # DML statement

INSERT INTO plants VALUES (2, 'Amaryllis'); # DML statement

ALTER TABLE plants ADD 
    ( latin_name VARCHAR2(40) );

GRANT SELECT ON plants TO scott;

REVOKE SELECT ON plants FROM scott;

DROP TABLE plants;
</pre></div>
<!-- class="example" -->
<p><a id="sthref807"></a><a id="sthref808"></a>An implicit <code dir="ltr">COMMIT</code> occurs immediately before the database executes a DDL statement and a <code dir="ltr">COMMIT</code> or <code dir="ltr">ROLLBACK</code> occurs immediately afterward. In <a href="#CHDHBIGA">Example 7-1</a>, two <code dir="ltr">INSERT</code> statements are followed by an <code dir="ltr">ALTER TABLE</code> statement, so the database commits the two <code dir="ltr">INSERT</code> statements. If the <code dir="ltr">ALTER TABLE</code> statement succeeds, then the database commits this statement; otherwise, the database rolls back this statement. In either case the two <code dir="ltr">INSERT</code> statements have already been committed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="cmntopc.htm#i2332">"Overview of Database Security"</a> to learn about privileges and roles</p>
</li>
<li>
<p><a class="olink TDDDG30000" href="../../appdev.112/e10766/tdddg_objects.htm#TDDDG30000"><span class="italic">Oracle Database 2 Day Developer's Guide</span></a> and <a class="olink ADMIN01503" href="../../server.112/e25494/tables.htm#ADMIN01503"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to create schema objects</p>
</li>
<li>
<p><a class="olink SQLRF30041" href="../../server.112/e41084/statements_1001.htm#SQLRF30041"><span class="italic">Oracle Database SQL Language Reference</span></a> for a list of DDL statements</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i18503"></a>
<div id="CNCPT516" class="sect2">
<h3 class="sect2">Data Manipulation Language (DML) Statements</h3>
<p><a id="sthref809"></a><a id="sthref810"></a><a id="sthref811"></a>Data manipulation language (<a href="glossary.htm#CBADGAJE"><span class="xrefglossterm">DML</span></a>) statements query or manipulate data in existing schema objects. Whereas DDL statements enable you to change the structure of the database, DML statements enable you to query or change the contents. For example, <code dir="ltr">ALTER TABLE</code> changes the structure of a table, whereas <code dir="ltr">INSERT</code> adds one or more rows to the table.</p>
<p>DML statements are the most frequently used SQL statements and enable you to:</p>
<ul>
<li>
<p><a id="sthref812"></a>Retrieve or fetch data from one or more tables or views (<code dir="ltr">SELECT</code>).</p>
</li>
<li>
<p><a id="sthref813"></a>Add new rows of data into a table or view (<code dir="ltr">INSERT</code>) by specifying a list of column values or using a <a id="sthref814"></a><a id="sthref815"></a><a href="glossary.htm#CHDBHDJE"><span class="xrefglossterm">subquery</span></a> to select and manipulate existing data.</p>
</li>
<li>
<p><a id="sthref816"></a>Change column values in existing rows of a table or view (<code dir="ltr">UPDATE</code>).</p>
</li>
<li>
<p><a id="sthref817"></a>Update or insert rows conditionally into a table or <a href="glossary.htm#CBAJDAFJ"><span class="xrefglossterm">view</span></a> (<code dir="ltr">MERGE</code>).</p>
</li>
<li>
<p><a id="sthref818"></a>Remove rows from tables or views (<code dir="ltr">DELETE</code>).</p>
</li>
<li>
<p><a id="sthref819"></a><a id="sthref820"></a><a id="sthref821"></a>View the <a href="glossary.htm#CHDFFBGF"><span class="xrefglossterm">execution plan</span></a> for a SQL statement (<code dir="ltr">EXPLAIN</code> <code dir="ltr">PLAN</code>). See <a href="#CHDBDCHA">"How Oracle Database Processes DML"</a>.</p>
</li>
<li>
<p><a id="sthref822"></a><a id="sthref823"></a>Lock a table or view, temporarily limiting access by other users (<code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code>).</p>
</li>
</ul>
<p>The following example uses DML to query the <code dir="ltr">employees</code> table. The example uses DML to insert a row into <code dir="ltr">employees</code>, update this row, and then delete it:</p>
<pre dir="ltr">
SELECT * FROM employees;

INSERT INTO employees (employee_id, last_name, email, job_id, hire_date, salary)
  VALUES (1234, 'Mascis', 'JMASCIS', 'IT_PROG', '14-FEB-2011', 9000);

UPDATE employees SET salary=9100 WHERE employee_id=1234;

DELETE FROM employees WHERE employee_id=1234;
</pre>
<p>A collection of DML statements that forms a logical unit of work is called a <a id="sthref824"></a><a href="glossary.htm#CHDBEFGD"><span class="xrefglossterm">transaction</span></a>. For example, a transaction to transfer money could involve three discrete operations: decreasing the savings account balance, increasing the checking account balance, and recording the transfer in an account history table. Unlike DDL statements, DML statements do not implicitly commit the current transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="transact.htm#i1666">"Introduction to Transactions "</a></p>
</li>
<li>
<p><a class="olink TDDDG20000" href="../../appdev.112/e10766/tdddg_connecting.htm#TDDDG20000"><span class="italic">Oracle Database 2 Day Developer's Guide</span></a> to learn how to query and manipulate data</p>
</li>
<li>
<p><a class="olink SQLRF30042" href="../../server.112/e41084/statements_1001.htm#SQLRF30042"><span class="italic">Oracle Database SQL Language Reference</span></a> for a list of DML statements</p>
</li>
</ul>
</div>
<div id="CNCPT88902" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref825"></a>
<h4 class="sect3">SELECT Statements</h4>
<p><a id="sthref826"></a>A <a href="glossary.htm#CHDGABIG"><span class="xrefglossterm">query</span></a> is an operation that retrieves data from a table or view. <code dir="ltr">SELECT</code> is the only SQL statement that you can use to query data. The set of data retrieved from execution of a <code dir="ltr">SELECT</code> statement is known as <a id="sthref827"></a><a id="sthref828"></a>a <span class="bold">result set</span>.</p>
<p><a href="#CHDEHIDI">Table 7-1</a> shows two required keywords and two keywords that are commonly found in a <code dir="ltr">SELECT</code> statement. The table also associates capabilities of a <code dir="ltr">SELECT</code> statement with the keywords.</p>
<div id="CNCPT88903" class="tblformal">
<p class="titleintable"><a id="sthref829"></a><a id="CHDEHIDI"></a>Table 7-1 Keywords in a SQL Statement</p>
<table class="cellalignment1458" title="Keywords in a SQL Statement" summary="Description of SQL keywords" dir="ltr">
<thead>
<tr class="cellalignment1449">
<th class="cellalignment1459" id="r1c1-t9">Keyword</th>
<th class="cellalignment1459" id="r1c2-t9">Required?</th>
<th class="cellalignment1459" id="r1c3-t9">Description</th>
<th class="cellalignment1459" id="r1c4-t9">Capability</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r2c1-t9" headers="r1c1-t9">
<p><code dir="ltr">SELECT</code></p>
</td>
<td class="cellalignment1455" headers="r2c1-t9 r1c2-t9">
<p>Yes</p>
</td>
<td class="cellalignment1455" headers="r2c1-t9 r1c3-t9">
<p>Specifies which columns should be shown in the result. Projection produces a subset of the columns in the table.</p>
<p>An <a id="sthref830"></a><a id="sthref831"></a><a href="glossary.htm#CHDHEIII"><span class="xrefglossterm">expression</span></a> is a combination of one or more values, <a id="sthref832"></a><a id="sthref833"></a><a href="glossary.htm#CHDJCEGF"><span class="xrefglossterm">operators</span></a>, and SQL <a id="sthref834"></a>functions that resolves to a value. The list of expressions that appears after the <code dir="ltr">SELECT</code> keyword and before the <code dir="ltr">FROM</code> clause is called <a id="sthref835"></a><a id="sthref836"></a>the <span class="bold">select list</span>.</p>
</td>
<td class="cellalignment1455" headers="r2c1-t9 r1c4-t9">
<p>Projection</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r3c1-t9" headers="r1c1-t9">
<p><code dir="ltr">FROM</code></p>
</td>
<td class="cellalignment1455" headers="r3c1-t9 r1c2-t9">
<p>Yes</p>
</td>
<td class="cellalignment1455" headers="r3c1-t9 r1c3-t9">
<p>Specifies the tables or views from which the data should be retrieved.</p>
</td>
<td class="cellalignment1455" headers="r3c1-t9 r1c4-t9">
<p>Joining</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r4c1-t9" headers="r1c1-t9">
<p><code dir="ltr">WHERE</code></p>
</td>
<td class="cellalignment1455" headers="r4c1-t9 r1c2-t9">
<p>No</p>
</td>
<td class="cellalignment1455" headers="r4c1-t9 r1c3-t9">
<p><a id="sthref837"></a><a id="sthref838"></a>Specifies a <span class="bold">condition</span> to filter rows, producing a subset of the rows in the table. A condition specifies a combination of one or more expressions and <a id="sthref839"></a><a id="sthref840"></a>logical (Boolean) operators and returns a value of <code dir="ltr">TRUE</code>, <code dir="ltr">FALSE</code>, or <code dir="ltr">UNKNOWN</code>.</p>
</td>
<td class="cellalignment1455" headers="r4c1-t9 r1c4-t9">
<p>Selection</p>
</td>
</tr>
<tr class="cellalignment1449">
<td class="cellalignment1455" id="r5c1-t9" headers="r1c1-t9">
<p><code dir="ltr">ORDER BY</code></p>
</td>
<td class="cellalignment1455" headers="r5c1-t9 r1c2-t9">
<p>No</p>
</td>
<td class="cellalignment1455" headers="r5c1-t9 r1c3-t9">
<p>Specifies the order in which the rows should be shown.</p>
</td>
<td class="cellalignment1455" headers="r5c1-t9 r1c4-t9">&nbsp;</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01702" href="../../server.112/e41084/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">SELECT</code> syntax and semantics</div>
</div>
<!-- class="sect3" -->
<div id="CNCPT88904" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref841"></a>
<h4 class="sect3">Joins</h4>
<p>A <a id="sthref842"></a><a id="sthref843"></a><a href="glossary.htm#CHDDCCEI"><span class="xrefglossterm">join</span></a> is a query that combines rows from two or more tables, views, or materialized views. <a href="#CHDGHAED">Example 7-2</a> joins the <code dir="ltr">employees</code> and <code dir="ltr">departments</code> tables (<code dir="ltr">FROM</code> clause), selects only rows that meet specified criteria (<code dir="ltr">WHERE</code> clause), and uses projection to retrieve data from two columns (<code dir="ltr">SELECT</code>). Sample output follows the SQL statement.</p>
<div id="CNCPT88905" class="example">
<p class="titleinexample"><a id="CHDGHAED"></a>Example 7-2 Sample Join</p>
<pre dir="ltr">
SELECT email, department_name
FROM   employees JOIN departments
ON     employees.department_id = departments.department_id
WHERE  employee_id IN (100,103)
ORDER BY email;

EMAIL                     DEPARTMENT_NAME
------------------------- ------------------------------
AHUNOLD                   IT
SKING                     Executive
</pre></div>
<!-- class="example" -->
<p><a href="#CHDJBIDH">Figure 7-1</a> graphically represents the operations of projection and selection in the join shown in <a href="#CHDGHAED">Example 7-2</a>.</p>
<div id="CNCPT88906" class="figure">
<p class="titleinfigure"><a id="CHDJBIDH"></a>Figure 7-1 Projection and Selection</p>
<img width="650" height="327" src="img/cncpt290.gif" alt="Description of Figure 7-1 follows" /><br />
<a id="sthref844" href="img_text/cncpt290.htm">Description of "Figure 7-1 Projection and Selection"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Most joins have at least one <a href="glossary.htm#CHDIBGAC"><span class="xrefglossterm">join condition</span></a>, either in the <code dir="ltr">FROM</code> clause or in the <code dir="ltr">WHERE</code> clause, that compares two columns, each from a different table. The database combines pairs of rows, each containing one row from each table, for which the join condition evaluates to <code dir="ltr">TRUE</code>. The optimizer determines the order in which the database joins tables based on the join conditions, indexes, and any available <a id="sthref845"></a>statistics for the tables.</p>
<p>Join types include the following:</p>
<ul>
<li>
<p><a id="sthref846"></a><a id="sthref847"></a>Inner joins</p>
<p>An <span class="bold">inner join</span> is a join of two or more tables that returns only rows that satisfy the join condition. For example, if the join condition is <code dir="ltr">employees.department_id=departments.department_id</code>, then rows that do not satisfy this condition are not returned.</p>
</li>
<li>
<p>Outer joins</p>
<p><a id="sthref848"></a><a id="sthref849"></a>An <span class="bold">outer join</span> returns all rows that satisfy the join condition and also returns rows from one table for which no rows from the other table satisfy the condition. For example, a <span class="bold">left outer join</span> of <code dir="ltr">employees</code> and <code dir="ltr">departments</code> retrieves all rows in the <code dir="ltr">employees</code> table even if there is no match in <code dir="ltr">departments</code>. A <span class="bold">right outer join</span> retrieves all rows in <code dir="ltr">departments</code> even if there is no match in <code dir="ltr">employees</code>.</p>
</li>
<li>
<p>Cartesian products</p>
<p><a id="sthref850"></a><a id="sthref851"></a>If two tables in a join query have no join condition, then the database returns their <span class="bold">Cartesian product</span>. Each row of one table combines with each row of the other. For example, if <code dir="ltr">employees</code> has 107 rows and <code dir="ltr">departments</code> has 27, then the Cartesian product contains 107*27 rows. A Cartesian product is rarely useful.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF30046" href="../../server.112/e41084/queries006.htm#SQLRF30046"><span class="italic">Oracle Database SQL Language Reference</span></a> for detailed descriptions and examples of joins</div>
</div>
<!-- class="sect3" -->
<a id="CHDFDJCH"></a>
<div id="CNCPT88907" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Subqueries and Implicit Queries</h4>
<p><a id="sthref852"></a><a id="sthref853"></a><a id="sthref854"></a>A <span class="bold">subquery</span> is a <code dir="ltr">SELECT</code> statement nested within another SQL statement. Subqueries are useful when you must execute multiple queries to solve a single problem.</p>
<p>Each query portion of a statement is called <a id="sthref855"></a>a <span class="bold">query block</span>. In <a href="#CHDFFJJJ">Example 7-3</a>, the subquery in parentheses is the <span class="bold">inner query block</span>. The inner <code dir="ltr">SELECT</code> statement retrieves the IDs of departments with location ID 1800. These department IDs are needed by the <span class="bold">outer query block</span>, which retrieves names of employees in the departments whose IDs were supplied by the subquery.</p>
<div id="CNCPT88908" class="example">
<p class="titleinexample"><a id="CHDFFJJJ"></a>Example 7-3 Subquery</p>
<pre dir="ltr">
SELECT first_name, last_name 
FROM   employees
WHERE  department_id 
IN     (SELECT department_id FROM departments WHERE location_id = 1800);
</pre></div>
<!-- class="example" -->
<p>The structure of the SQL statement does not force the database to execute the inner query first. For example, the database could rewrite the entire query as a join of <code dir="ltr">employees</code> and <code dir="ltr">departments</code>, so that the subquery never executes by itself. As another example, the Virtual Private Database (VPD) feature could restrict the query of employees using a <code dir="ltr">WHERE</code> clause, so that the database decides to query the employees first and then obtain the department IDs. The optimizer determines the best sequence of steps to retrieve the requested rows.</p>
<p><a id="sthref856"></a><a id="sthref857"></a><a id="sthref858"></a>An <span class="bold">implicit query</span> is a component of a DML statement that retrieves data without using a subquery. An <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, or <code dir="ltr">MERGE</code> statement that does not explicitly include a <code dir="ltr">SELECT</code> statement uses an implicit query to retrieve rows to be modified. For example, the following statement includes an implicit query for the <code dir="ltr">Baer</code> record:</p>
<pre dir="ltr">
UPDATE employees 
  SET salary = salary*1.1 
  WHERE last_name = 'Baer';
</pre>
<p>The only DML statement that does <span class="italic">not</span> necessarily include a query component is an <code dir="ltr">INSERT</code> statement with a <code dir="ltr">VALUES</code> clause. For example, an <code dir="ltr">INSERT INTO TABLE mytable VALUES (1)</code> statement does not retrieve rows before inserting a row.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cmntopc.htm#BABJBIDG">"Virtual Private Database (VPD)"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i18511"></a>
<div id="CNCPT1733" class="sect2">
<h3 class="sect2">Transaction Control Statements</h3>
<p><a id="sthref859"></a><a id="sthref860"></a><a id="sthref861"></a>Transaction control statements manage the changes made by DML statements and group DML statements into transactions. These statements enable you to:</p>
<ul>
<li>
<p><a id="sthref862"></a>Make changes to a transaction permanent (<code dir="ltr">COMMIT</code>).</p>
</li>
<li>
<p><a id="sthref863"></a><a id="sthref864"></a>Undo the changes in a transaction, since the transaction started (<code dir="ltr">ROLLBACK</code>) or since a savepoint (<code dir="ltr">ROLLBACK TO SAVEPOINT</code>). A <span class="bold">savepoint</span> is a user-declared intermediate marker within the context of a transaction.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">ROLLBACK</code> command ends a transaction, but <code dir="ltr">ROLLBACK TO SAVEPOINT</code> does not.</div>
</li>
<li>
<p><a id="sthref865"></a>Set a point to which you can roll back (<code dir="ltr">SAVEPOINT</code>).</p>
</li>
<li>
<p><a id="sthref866"></a><a id="sthref867"></a>Establish properties for a transaction (<code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code>).</p>
</li>
<li>
<p><a id="sthref868"></a><a id="sthref869"></a>Specify whether a deferrable <a href="glossary.htm#CBABGDBI"><span class="xrefglossterm">integrity constraint</span></a> is checked following each DML statement or when the transaction is committed (<code dir="ltr">SET CONSTRAINT</code>).</p>
</li>
</ul>
<p>The following example starts a transaction named <code dir="ltr">Update salaries</code>. The example creates a savepoint, updates an employee salary, and then rolls back the transaction to the savepoint. The example updates the salary to a different value and commits.</p>
<pre dir="ltr">
SET TRANSACTION NAME 'Update salaries';

SAVEPOINT before_salary_update;

UPDATE employees SET salary=9100 WHERE employee_id=1234 # DML

ROLLBACK TO SAVEPOINT before_salary_update;

UPDATE employees SET salary=9200 WHERE employee_id=1234 # DML

COMMIT COMMENT 'Updated salaries';
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="transact.htm#i1666">"Introduction to Transactions "</a></p>
</li>
<li>
<p><a href="datainte.htm#CHDIECJG">"Deferrable Constraints"</a></p>
</li>
<li>
<p><a class="olink SQLRF30043" href="../../server.112/e41084/statements_1001.htm#SQLRF30043"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i18515"></a>
<div id="CNCPT1734" class="sect2">
<h3 class="sect2">Session Control Statements</h3>
<p><a id="sthref870"></a><a id="sthref871"></a>Session control statements dynamically manage the properties of a user <a id="sthref872"></a><a href="glossary.htm#CBAHEBIG"><span class="xrefglossterm">session</span></a>. As explained in <a href="process.htm#i18532">"Connections and Sessions"</a>, a session is a logical entity in the database instance memory that represents the state of a current user login to a database. A session lasts from the time the user is <a id="sthref873"></a><a id="sthref874"></a>authenticated by the database until the user disconnects or exits the database application.</p>
<p>Session control statements enable you to:</p>
<ul>
<li>
<p><a id="sthref875"></a>Alter the current session by performing a specialized function, such as enabling and disabling SQL tracing (<code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code>).</p>
</li>
<li>
<p><a id="sthref876"></a><a id="sthref877"></a>Enable and disable roles, which are groups of privileges, for the current session (<code dir="ltr">SET</code> <code dir="ltr">ROLE</code>).</p>
</li>
</ul>
<p>The following example turns on SQL tracing for the session and then enables all roles granted in the current session except <code dir="ltr">dw_manager</code>:</p>
<pre dir="ltr">
ALTER SESSION SET SQL_TRACE = TRUE;

SET ROLE ALL EXCEPT dw_manager;
</pre>
<p>Session control statements do not implicitly commit the current transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF30044" href="../../server.112/e41084/statements_1001.htm#SQLRF30044"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">ALTER SESSION</code> syntax and semantics</div>
</div>
<!-- class="sect2" -->
<a id="i18519"></a>
<div id="CNCPT1735" class="sect2">
<h3 class="sect2">System Control Statement</h3>
<p><a id="sthref878"></a><a id="sthref879"></a>System control statements change the properties of the database <a id="sthref880"></a><a href="glossary.htm#CBAFGFCJ"><span class="xrefglossterm">instance</span></a>. The only system control statement is <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code>. It enables you to change settings such as the minimum number of shared servers, terminate a session, and perform other system-level tasks.</p>
<p>Following are examples of system control statements:</p>
<pre dir="ltr">
ALTER SYSTEM SWITCH LOGFILE; 

ALTER SYSTEM KILL SESSION '39, 23';
</pre>
<p>The <code dir="ltr">ALTER SYSTEM</code> statement does not implicitly commit the current transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00902" href="../../server.112/e41084/statements_2014.htm#SQLRF00902"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">ALTER SYSTEM</code> syntax and semantics</div>
</div>
<!-- class="sect2" -->
<a id="i18523"></a>
<div id="CNCPT1736" class="sect2">
<h3 class="sect2">Embedded SQL Statements</h3>
<p><a id="sthref881"></a><a id="sthref882"></a><a id="sthref883"></a><a id="sthref884"></a><a id="sthref885"></a>Embedded SQL statements incorporate DDL, DML, and transaction control statements within a procedural language program. They are used with the Oracle precompilers. Embedded SQL is one approach to incorporating SQL in your procedural language applications. Another approach is to use a procedural <a id="sthref886"></a>API such as Open Database Connectivity (<a id="sthref887"></a>ODBC) or Java Database Connectivity (<a id="sthref888"></a><a id="sthref889"></a>JDBC).</p>
<p>Embedded SQL statements enable you to:</p>
<ul>
<li>
<p><a id="sthref890"></a>Define, allocate, and release <a href="glossary.htm#CHDGJIIC"><span class="xrefglossterm">cursors</span></a> (<code dir="ltr">DECLARE CURSOR</code>, <code dir="ltr">OPEN</code>, <code dir="ltr">CLOSE</code>).</p>
</li>
<li>
<p><a id="sthref891"></a>Specify a database and connect to it (<code dir="ltr">DECLARE DATABASE</code>, <code dir="ltr">CONNECT</code>).</p>
</li>
<li>
<p><a id="sthref892"></a>Assign variable names (<code dir="ltr">DECLARE STATEMENT</code>).</p>
</li>
<li>
<p>Initialize descriptors (<code dir="ltr">DESCRIBE</code>).</p>
</li>
<li>
<p>Specify how error and warning conditions are handled (<code dir="ltr">WHENEVER</code>).</p>
</li>
<li>
<p><a id="sthref893"></a>Parse and run SQL statements (<code dir="ltr">PREPARE</code>, <code dir="ltr">EXECUTE</code>, <code dir="ltr">EXECUTE IMMEDIATE</code>).</p>
</li>
<li>
<p><a id="sthref894"></a>Retrieve data from the database (<code dir="ltr">FETCH</code>).</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="srvrside.htm#i19998">"Introduction to Server-Side Programming"</a> and <a href="cncptdev.htm#CHDHJGCD">"Client-Side APIs"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i8709"></a>
<div id="CNCPT316" class="sect1">
<h2 class="sect1"><a id="sthref895"></a>Overview of the Optimizer</h2>
<p>To understand how Oracle Database processes SQL statements, it is necessary to understand the part of the database called <a id="sthref896"></a>the <span class="bold">optimizer</span> (also known as the <span class="bold">query</span> <span class="bold">optimizer</span> or <span class="bold">cost-based optimizer</span>). All SQL statements use the optimizer to determine the most efficient means of accessing the specified data.</p>
<div id="CNCPT88909" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref897"></a>
<h3 class="sect2">Use of the Optimizer</h3>
<p>To execute a DML statement, Oracle Database may have to perform many steps. Each step either retrieves rows of data physically from the database or prepares them for the user issuing the statement.</p>
<p>Many different ways of processing a DML statement are often possible. For example, the order in which tables or indexes are accessed can vary. The steps that the database uses to execute a statement greatly affect how quickly the statement runs. The optimizer generates <a id="sthref898"></a><a id="sthref899"></a><a href="glossary.htm#CHDGBADJ"><span class="xrefglossterm">execution plans</span></a> describing possible methods of execution.</p>
<p>The optimizer determines which execution plan is most efficient by considering several sources of information, including query conditions, available <a href="glossary.htm#CHDCCEHH"><span class="xrefglossterm">access paths</span></a>, <a id="sthref900"></a>statistics gathered for the system, and hints. For any SQL statement processed by Oracle, the optimizer performs the following operations:</p>
<ul>
<li>
<p>Evaluation of expressions and conditions</p>
</li>
<li>
<p>Inspection of integrity constraints to learn more about the data and optimize based on this metadata</p>
</li>
<li>
<p>Statement transformation</p>
</li>
<li>
<p>Choice of optimizer goals</p>
</li>
<li>
<p>Choice of access paths<a id="sthref901"></a></p>
</li>
<li>
<p>Choice of join orders</p>
</li>
</ul>
<p>The optimizer generates most of the possible ways of processing a query and assigns a cost to each step in the generated execution plan. The plan with the lowest cost is chosen as the <a href="glossary.htm#CHDICHFA"><span class="xrefglossterm">query plan</span></a> to be executed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can obtain an execution plan for a SQL statement without executing the plan. Only an execution plan that the database actually uses to execute a query is correctly termed a query plan.</div>
<p>You can influence optimizer choices by setting the optimizer goal and by gathering representative statistics for the optimizer. For example, you may set the optimizer goal to either of the following:</p>
<ul>
<li>
<p>Total throughput</p>
<p>The <code dir="ltr">ALL_ROWS</code> <a id="sthref902"></a><a id="sthref903"></a>hint instructs the optimizer to get the last row of the result to the client application as fast as possible.</p>
</li>
<li>
<p>Initial response time</p>
<p>The <code dir="ltr">FIRST_ROWS</code> hint instructs the optimizer to get the first row to the client as fast as possible.</p>
</li>
</ul>
<p>A typical end-user, interactive application would benefit from initial response time optimization, whereas a batch-mode, non-interactive application would benefit from total throughput optimization.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about using <code dir="ltr">DBMS_STATS</code></p>
</li>
<li>
<p><a class="olink PFGRF94582" href="../../server.112/e41573/optimops.htm#PFGRF94582"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about the optimizer and using hints</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="CNCPT88910" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref904"></a>
<h3 class="sect2">Optimizer Components</h3>
<p><a id="sthref905"></a>The optimizer contains three main components, which are shown in <a href="#CHDCCIDA">Figure 7-2</a>.</p>
<div id="CNCPT88911" class="figure">
<p class="titleinfigure"><a id="CHDCCIDA"></a>Figure 7-2 Optimizer Components</p>
<img width="452" height="354" src="img/cncpt287.gif" alt="Description of Figure 7-2 follows" /><br />
<a id="sthref906" href="img_text/cncpt287.htm">Description of "Figure 7-2 Optimizer Components"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The input to the optimizer is a parsed query (see <a href="#CHDHFFHA">"SQL Parsing"</a>). The optimizer performs the following operations:</p>
<ol>
<li>
<p>The optimizer receives the parsed query and generates a set of potential plans for the SQL statement based on available access paths and hints.</p>
</li>
<li>
<p>The optimizer estimates the cost of each plan based on statistics in the data dictionary. The cost is an estimated value proportional to the expected resource use needed to execute the statement with a particular plan.</p>
</li>
<li>
<p>The optimizer compares the costs of plans and chooses the lowest-cost plan, known as the query plan, to pass to the row source generator (see <a href="#CHDHJJBG">"SQL Row Source Generation"</a>).</p>
</li>
</ol>
<div id="CNCPT88912" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref907"></a>
<h4 class="sect3">Query Transformer</h4>
<p><a id="sthref908"></a><a id="sthref909"></a>The <span class="bold">query transformer</span> determines whether it is helpful to change the form of the query so that the optimizer can generate a better execution plan. The input to the query transformer is a parsed query, which is represented by a set of query blocks.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="schemaob.htm#CFAHEBBA">"Query Rewrite"</a></div>
</div>
<!-- class="sect3" -->
<div id="CNCPT88913" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref910"></a>
<h4 class="sect3">Estimator</h4>
<p><a id="sthref911"></a>The <span class="bold">estimator</span> determines the overall cost of a given execution plan. The estimator generates three different types of measures to achieve this goal:</p>
<ul>
<li>
<p>Selectivity</p>
<p>This measure represents a fraction of rows from a row set. The selectivity is tied to a query predicate, such as <code dir="ltr">last_name='Smith'</code>, or a combination of predicates.</p>
</li>
<li>
<p>Cardinality</p>
<p><a id="sthref912"></a><a id="sthref913"></a>This measure represents the number of rows in a row set.</p>
</li>
<li>
<p>Cost</p>
<p>This measure represents units of work or resource used. The query optimizer uses disk I/O, CPU usage, and memory usage as units of work.</p>
</li>
</ul>
<p>If statistics are available, then the estimator uses them to compute the measures. The statistics improve the degree of accuracy of the measures.</p>
</div>
<!-- class="sect3" -->
<div id="CNCPT1755" class="sect3"><a id="sthref914"></a>
<h4 class="sect3"><a id="sthref915"></a>Plan Generator</h4>
<p><a id="sthref916"></a>The <span class="bold">plan generator</span> tries out different plans for a submitted query and picks the plan with the lowest cost. The optimizer generates subplans for each of the nested subqueries and unmerged views, which is represented by a <a id="sthref917"></a><a id="sthref918"></a>separate <span class="bold">query block</span>. The plan generator explores various plans for a query block by trying out different access paths, join methods, and join orders.</p>
<p>The optimizer automatically manages plans and ensures that only verified plans are used. <a id="sthref919"></a>SQL Plan Management (SPM) allows controlled plan evolution by only using a new plan after it has been verified to be perform better than the current plan.</p>
<p>Diagnostic tools such as <a id="sthref920"></a>the <code dir="ltr">EXPLAIN PLAN</code> statement enable you to view execution plans chosen by the optimizer. <code dir="ltr">EXPLAIN PLAN</code> shows the query plan for the specified SQL query if it were executed now in the current session. Other diagnostic tools are Oracle Enterprise Manager and the SQL*Plus <code dir="ltr">AUTOTRACE</code> command. <a href="#CHDHGDCG">Example 7-6</a> shows the execution plan of a query when <code dir="ltr">AUTOTRACE</code> is enabled.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="cncptdba.htm#CHDFEAEB">"Tools for Database Administrators"</a></p>
</li>
<li>
<p><a class="olink SQLRF01601" href="../../server.112/e41084/statements_9010.htm#SQLRF01601"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about <code dir="ltr">EXPLAIN PLAN</code></p>
</li>
<li>
<p><a class="olink PFGRF94582" href="../../server.112/e41573/optimops.htm#PFGRF94582"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn about the optimizer components</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEBHEG"></a>
<div id="CNCPT88914" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Access Paths</h3>
<p><a id="sthref921"></a>An <span class="bold">access path</span> is the way in which data is retrieved from the database. For example, a query that uses an index has a different access path from a query that does not. In general, index access paths are best for statements that retrieve a small subset of table rows. Full scans are more efficient for accessing a large portion of a table.</p>
<p>The database can use several different access paths to retrieve data from a table. The following is a representative list:</p>
<ul>
<li>
<p><a id="sthref922"></a><a id="sthref923"></a>Full table scans</p>
<p>This type of scan reads all rows from a table and filters out those that do not meet the selection criteria. The database sequentially scans all data blocks in the segment, including those under the <a href="glossary.htm#CHDHDJAE"><span class="xrefglossterm">high water mark</span></a> that separates used from unused space (see <a href="logical.htm#BABEEGEJ">"Segment Space and the High Water Mark"</a>).</p>
</li>
<li>
<p>Rowid scans</p>
<p><a id="sthref924"></a>The <a href="glossary.htm#CHDIHIFE"><span class="xrefglossterm">rowid</span></a> of <a id="sthref925"></a>a row specifies the data file and data block containing the row and the location of the row in that block. The database first obtains the rowids of the selected rows, either from the statement <code dir="ltr">WHERE</code> clause or through an index scan, and then locates each selected row based on its rowid.</p>
</li>
<li>
<p>Index scans</p>
<p><a id="sthref926"></a><a id="sthref927"></a>This scan searches an index for the indexed column values accessed by the SQL statement (see <a href="indexiot.htm#CHDEGIHF">"Index Scans"</a>). If the statement accesses only columns of the index, then Oracle Database reads the indexed column values directly from the index.</p>
</li>
<li>
<p>Cluster scans</p>
<p><a id="sthref928"></a><a id="sthref929"></a>A cluster scan is used to retrieve data from a table stored in an indexed <a href="glossary.htm#CHDEIIGC"><span class="xrefglossterm">table cluster</span></a>, where all rows with the same cluster key value are stored in the same data block (see <a href="tablecls.htm#CFABHBAG">"Overview of Indexed Clusters"</a>). The database first obtains the rowid of a selected row by scanning the cluster index. Oracle Database locates the rows based on this rowid.</p>
</li>
<li>
<p>Hash scans</p>
<p>A hash scan is used to locate rows in a hash cluster, where all rows with the same hash value are stored in the same data block (see <a href="tablecls.htm#BABJJGHI">"Overview of Hash Clusters"</a>. The database first obtains the hash value by applying a <a href="glossary.htm#CHDJGEAI"><span class="xrefglossterm">hash function</span></a> to a cluster key value specified by the statement. Oracle Database then scans the data blocks containing rows with this hash value.</p>
</li>
</ul>
<p>The optimizer chooses an access path based on the available access paths for the statement and the estimated cost of using each access path or combination of paths.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink TDPPT170" href="../../server.112/e10822/tdppt_sqlopt.htm#TDPPT170"><span class="italic">Oracle Database 2 Day + Performance Tuning Guide</span></a> and <a class="olink PFGRF94599" href="../../server.112/e41573/optimops.htm#PFGRF94599"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn about access paths</div>
</div>
<!-- class="sect2" -->
<div id="CNCPT88915" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref930"></a>
<h3 class="sect2">Optimizer Statistics</h3>
<p><a id="sthref931"></a><a id="sthref932"></a>Optimizer <span class="bold">statistics</span> are a collection of data that describe details about the database and the objects in the database. The statistics provide a statistically correct picture of data storage and distribution usable by the optimizer when evaluating access paths.</p>
<p>Optimizer statistics include the following:</p>
<ul>
<li>
<p>Table statistics</p>
<p>These include the number of rows, number of blocks, and average row length.</p>
</li>
<li>
<p>Column statistics</p>
<p>These include the number of distinct values and nulls in a column and the distribution of data.</p>
</li>
<li>
<p>Index statistics</p>
<p>These include the number of leaf blocks and index levels.</p>
</li>
<li>
<p>System statistics</p>
<p>These include CPU and I/O performance and utilization.</p>
</li>
</ul>
<p>Oracle Database gathers optimizer statistics on all database objects automatically and maintains these statistics as an automated maintenance task. You can also gather statistics manually using <a id="sthref933"></a>the <code dir="ltr">DBMS_STATS</code> package. This PL/SQL package can modify, view, export, import, and delete statistics.</p>
<p>Optimizer statistics are created for the purposes of query optimization and are stored in the data dictionary. These statistics should not be confused with performance statistics visible through dynamic performance views.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink TDPPT007" href="../../server.112/e10822/tdppt_method.htm#TDPPT007"><span class="italic">Oracle Database 2 Day + Performance Tuning Guide</span></a> and <a class="olink PFGRF003" href="../../server.112/e41573/stats.htm#PFGRF003"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn how to gather and manage statistics</p>
</li>
<li>
<p><a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn about <code dir="ltr">DBMS_STATS</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="CNCPT88916" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref934"></a>
<h3 class="sect2">Optimizer Hints</h3>
<p><a id="sthref935"></a><a id="sthref936"></a>A <span class="bold">hint</span> is a comment in a SQL statement that acts as an instruction to the optimizer. Sometimes the application designer, who has more information about a particular application's data than is available to the optimizer, can choose a more effective way to run a SQL statement. The application designer can use hints in SQL statements to specify how the statement should be run.</p>
<p>For example, suppose that your interactive application runs a query that returns 50 rows. This application initially fetches only the first 25 rows of the query to present to the end user. You want the optimizer to generate a plan that gets the first 25 records as quickly as possible so that the user is not forced to wait. You can use a hint to pass this instruction to the optimizer as shown in the <code dir="ltr">SELECT</code> statement and <code dir="ltr">AUTOTRACE</code> output in <a href="#CHDBEDFI">Example 7-4</a>.</p>
<div id="CNCPT88917" class="example">
<p class="titleinexample"><a id="CHDBEDFI"></a>Example 7-4 Execution Plan for SELECT with FIRST_ROWS Hint</p>
<pre dir="ltr">
SELECT /*+ FIRST_ROWS(25) */ employee_id, department_id
FROM   hr.employees
WHERE  department_id &gt; 50;

------------------------------------------------------------------------
| Id | Operation                    | Name              | Rows | Bytes
------------------------------------------------------------------------
|  0 | SELECT STATEMENT             |                   | 26   | 182
|  1 |  TABLE ACCESS BY INDEX ROWID | EMPLOYEES         | 26   | 182
|* 2 |   INDEX RANGE SCAN           | EMP_DEPARTMENT_IX |      |
------------------------------------------------------------------------
</pre></div>
<!-- class="example" -->
<pre dir="ltr">
</pre>
<p>The execution plan in <a href="#CHDBEDFI">Example 7-4</a> shows that the optimizer chooses an index on the <code dir="ltr">employees.department_id</code> column to find the first 25 rows of <code dir="ltr">employees</code> whose department ID is over 50. The optimizer uses the rowid retrieved from the index to retrieve the record from the <code dir="ltr">employees</code> table and return it to the client. Retrieval of the first record is typically almost instantaneous.</p>
<p><a href="#CHDEJCCJ">Example 7-5</a> shows the same statement, but without the optimizer hint.</p>
<div id="CNCPT88918" class="example">
<p class="titleinexample"><a id="CHDEJCCJ"></a>Example 7-5 Execution Plan for SELECT with No Hint</p>
<pre dir="ltr">
SELECT employee_id, department_id
FROM   hr.employees
WHERE  department_id &gt; 50;
 
------------------------------------------------------------------------
| Id | Operation              | Name              | Rows | Bytes | Cos
------------------------------------------------------------------------
|  0 | SELECT STATEMENT       |                   | 50   | 350   |
|* 1 |  VIEW                  | index$_join$_001  | 50   | 350   |
|* 2 |   HASH JOIN            |                   |      |       |
|* 3 |    INDEX RANGE SCAN    | EMP_DEPARTMENT_IX | 50   | 350   |
|  4 |    INDEX FAST FULL SCAN| EMP_EMP_ID_PK     | 50   | 350   |
</pre></div>
<!-- class="example" -->
<p>The execution plan in <a href="#CHDEJCCJ">Example 7-5</a> joins two indexes to return the requested records as fast as possible. Rather than repeatedly going from index to table as in <a href="#CHDBEDFI">Example 7-4</a>, the optimizer chooses a range scan of <code dir="ltr">EMP_DEPARTMENT_IX</code> to find all rows where the department ID is over 50 and place these rows in a <a href="glossary.htm#CHDEJFJE"><span class="xrefglossterm">hash table</span></a>. The optimizer then chooses to read the <code dir="ltr">EMP_EMP_ID_PK</code> index. For each row in this index, it probes the hash table to find the department ID.</p>
<p>In this case, the database cannot return the first row to the client until the index range scan of <code dir="ltr">EMP_DEPARTMENT_IX</code> completes. Thus, this generated plan would take longer to return the first record. Unlike the plan in <a href="#CHDBEDFI">Example 7-4</a>, which accesses the table by index rowid, the plan in <a href="#CHDEJCCJ">Example 7-5</a> uses multiblock I/O, resulting in large reads. The reads enable the last row of the entire result set to be returned more rapidly.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF501" href="../../server.112/e41573/hintsref.htm#PFGRF501"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn how to use optimizer hints</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDFCAGA"></a>
<div id="CNCPT216" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of SQL Processing</h2>
<p>This section explains how Oracle Database processes SQL statements. Specifically, the section explains the way in which the database processes DDL statements to create objects, DML to modify data, and queries to retrieve data.</p>
<a id="CHDDAGAA"></a>
<div id="CNCPT1741" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Stages of SQL Processing</h3>
<p><a id="sthref937"></a><a href="#CHDBEDJC">Figure 7-3</a> depicts the general stages of SQL processing: parsing, optimization, row source generation, and execution. Depending on the statement, the database may omit some of these steps.</p>
<div id="CNCPT88919" class="figure">
<p class="titleinfigure"><a id="CHDBEDJC"></a>Figure 7-3 Stages of SQL Processing</p>
<img width="338" height="558" src="img/cncpt250.gif" alt="Description of Figure 7-3 follows" /><br />
<a id="sthref938" href="img_text/cncpt250.htm">Description of "Figure 7-3 Stages of SQL Processing"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="CHDHFFHA"></a>
<div id="CNCPT1740" class="sect3">
<h4 class="sect3">SQL Parsing</h4>
<p><a id="sthref939"></a><a id="sthref940"></a>As shown in <a href="#CHDBEDJC">Figure 7-3</a>, the first stage of SQL processing is <span class="bold">parsing</span>. This stage involves separating the pieces of a SQL statement into a data structure that can be processed by other routines. The database parses a statement when instructed by the application, which means that only the application&shy;, and not the database itself, can reduce the number of parses.</p>
<p>When an application issues a SQL statement, the application makes a <span class="bold">parse call</span> to the database to prepare the statement for execution. The parse call opens or creates a <a href="glossary.htm#CHDCDGBB"><span class="xrefglossterm">cursor</span></a>, which is a handle for the session-specific <a id="sthref941"></a><a href="glossary.htm#CHDHEJGI"><span class="xrefglossterm">private SQL area</span></a> that holds a parsed SQL statement and other processing information. The cursor and private SQL area are in the <a href="glossary.htm#CHDECHFD"><span class="xrefglossterm">PGA</span></a>.</p>
<p>During the parse call, the database performs the following checks:</p>
<ul>
<li>
<p><a href="#CHDBIADC">Syntax Check</a></p>
</li>
<li>
<p><a href="#CHDBAHAE">Semantic Check</a></p>
</li>
<li>
<p><a href="#CHDFFCGI">Shared Pool Check</a></p>
</li>
</ul>
<p>The preceding checks identify the errors that can be found <span class="italic">before statement execution</span>. Some errors cannot be caught by parsing. For example, the database can encounter <a id="sthref942"></a><a id="sthref943"></a><a href="glossary.htm#CHDGIJBA"><span class="xrefglossterm">deadlocks</span></a> or errors in data conversion only during statement execution (see <a href="consist.htm#BABDDBCG">"Locks and Deadlocks"</a>).</p>
<a id="CHDBIADC"></a>
<div id="CNCPT88920" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Syntax Check</h5>
<p>Oracle Database must check each SQL statement for syntactic validity. A statement that breaks a rule for well-formed SQL syntax fails the check. For example, the following statement fails because the keyword <code dir="ltr">FROM</code> is misspelled as <code dir="ltr">FORM</code>:</p>
<pre dir="ltr">
SQL&gt; SELECT * FORM employees;
SELECT * FORM employees
         *
ERROR at line 1:
ORA-00923: FROM keyword not found where expected
</pre></div>
<!-- class="sect4" -->
<a id="CHDBAHAE"></a>
<div id="CNCPT88921" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Semantic Check</h5>
<p>The semantics of a statement are its meaning. Thus, a semantic check determines whether a statement is meaningful, for example, whether the objects and columns in the statement exist. A syntactically correct statement can fail a semantic check, as shown in the following example of a query of a nonexistent table:</p>
<pre dir="ltr">
SQL&gt; SELECT * FROM nonexistent_table;
SELECT * FROM nonexistent_table
              *
ERROR at line 1:
ORA-00942: table or view does not exist
</pre></div>
<!-- class="sect4" -->
<a id="CHDFFCGI"></a>
<div id="CNCPT88922" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Shared Pool Check</h5>
<p>During the parse, the database performs <a id="sthref944"></a>a <span class="bold">shared pool check</span> to determine whether it can skip resource-intensive steps of statement processing. To this end, the database uses a <a href="glossary.htm#CHDEAEJB"><span class="xrefglossterm">hashing</span></a> algorithm to generate a hash value for every SQL statement. The statement hash value is the<a id="sthref945"></a> <span class="bold">SQL ID</span> shown in <code dir="ltr">V$SQL.SQL_ID</code>.</p>
<p>When a user submits a SQL statement, the database searches the <a id="sthref946"></a><a href="glossary.htm#CHDEEJGC"><span class="xrefglossterm">shared SQL area</span></a> to see if an existing parsed statement has the same hash value. The hash value of a SQL statement is distinct from the following values:</p>
<ul>
<li>
<p>Memory address for the statement</p>
<p>Oracle Database uses the SQL ID to perform a keyed read in a lookup table. In this way, the database obtains possible memory addresses of the statement.</p>
</li>
<li>
<p>Hash value of an execution plan for the statement</p>
<p>A SQL statement can have multiple plans in the shared pool. Each plan has a different hash value. If the same SQL ID has multiple plan hash values, then the database knows that multiple plans exist for this SQL ID.</p>
</li>
</ul>
<p>Parse operations fall into the following categories, depending on the type of statement submitted and the result of the hash check:</p>
<ul>
<li>
<p><a id="sthref947"></a><a id="sthref948"></a>Hard parse</p>
<p>If Oracle Database cannot reuse existing code, then it must build a new executable version of the application code. This operation is known as a <span class="bold">hard parse</span>, or a <span class="bold">library cache miss</span>. The database always perform a hard parse of DDL.</p>
<p>During the hard parse, the database accesses the <a id="sthref949"></a><a href="glossary.htm#CHDCFADC"><span class="xrefglossterm">library cache</span></a> and <a id="sthref950"></a><a href="glossary.htm#CHDIAHJE"><span class="xrefglossterm">data dictionary cache</span></a> numerous times to check the data dictionary. When the database accesses these areas, it uses a serialization device called a <a id="sthref951"></a><a href="glossary.htm#CHDGJAGG"><span class="xrefglossterm">latch</span></a> on required objects so that their definition does not change (see <a href="consist.htm#CIHGBBAF">"Latches"</a>). Latch contention increases statement execution time and decreases concurrency.</p>
</li>
<li>
<p><a id="sthref952"></a><a id="sthref953"></a>Soft parse</p>
<p>A <span class="bold">soft parse</span> is any parse that is not a hard parse. If the submitted statement is the same as a reusable SQL statement in the shared pool, then Oracle Database reuses the existing code. This reuse of code is also called a <span class="bold">library cache hit</span>.</p>
<p>Soft parses can vary in the amount of work they perform. For example, configuring the session shared SQL area can sometimes reduce the amount of latching in the soft parses, making them "softer."</p>
<p>In general, a soft parse is preferable to a hard parse because the database skips the optimization and row source generation steps, proceeding straight to execution.</p>
</li>
</ul>
<p><a href="#CHDJCBED">Figure 7-4</a> is a simplified representation of a shared pool check of an <code dir="ltr">UPDATE</code> statement in a <a id="sthref954"></a><a id="sthref955"></a><a href="glossary.htm#CBAIBCHE"><span class="xrefglossterm">dedicated server</span></a> architecture.</p>
<div id="CNCPT88923" class="figure">
<p class="titleinfigure"><a id="CHDJCBED"></a>Figure 7-4 Shared Pool Check</p>
<img width="623" height="387" src="img/cncpt251.gif" alt="Description of Figure 7-4 follows" /><br />
<a id="sthref956" href="img_text/cncpt251.htm">Description of "Figure 7-4 Shared Pool Check"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If a check determines that a statement in the shared pool has the same hash value, then the database performs semantic and environment checks to determine whether the statements have the same meaning. Identical syntax is not sufficient. For example, suppose two different users log in to the database and issue the following SQL statements:</p>
<pre dir="ltr">
CREATE TABLE my_table ( some_col INTEGER );
SELECT * FROM my_table;
</pre>
<p>The <code dir="ltr">SELECT</code> statements for the two users are syntactically identical, but two separate schema objects are named <code dir="ltr">my_table</code>. This semantic difference means that the second statement cannot reuse the code for the first statement.</p>
<p>Even if two statements are semantically identical, an environmental difference can force a hard parse. In this case, the environment is the totality of session settings that can affect execution plan generation, such as the work area size or optimizer settings. Consider the following series of SQL statements executed by a single user:</p>
<pre dir="ltr">
ALTER SYSTEM FLUSH SHARED_POOL;
SELECT * FROM my_table;

ALTER SESSION SET OPTIMIZER_MODE=FIRST_ROWS;
SELECT * FROM my_table;

ALTER SESSION SET SQL_TRACE=TRUE;
SELECT * FROM my_table;
</pre>
<p>In the preceding example, the same <code dir="ltr">SELECT</code> statement is executed in three different optimizer environments. Consequently, the database creates three separate shared SQL areas for these statements and forces a hard parse of each statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="memory.htm#i17716">"Private SQL Area"</a> and <a href="memory.htm#i9081">"Shared SQL Areas"</a></p>
</li>
<li>
<p><a class="olink PFGRF94287" href="../../server.112/e41573/memory.htm#PFGRF94287"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn how to configure the shared pool</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="CNCPT88924" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref957"></a>
<h4 class="sect3">SQL Optimization</h4>
<p><a id="sthref958"></a><a id="sthref959"></a>As explained in <a href="#i8709">"Overview of the Optimizer"</a>, query <span class="bold">optimization</span> is the process of choosing the most efficient means of executing a SQL statement. The database optimizes queries based on <a id="sthref960"></a>statistics collected about the actual data being accessed. The optimizer uses the number of rows, the size of the data set, and other factors to generate possible execution plans, assigning a numeric cost to each plan. The database uses the plan with the lowest cost.</p>
<p>The database must perform a hard parse at least once for every unique DML statement and performs optimization during this parse. DDL is never optimized unless it includes a DML component such as a subquery that requires optimization.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF001" href="../../server.112/e41573/optimops.htm#PFGRF001"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for detailed information about the query optimizer</div>
</div>
<!-- class="sect3" -->
<a id="CHDHJJBG"></a>
<div id="CNCPT88925" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SQL Row Source Generation</h4>
<p><a id="sthref961"></a><a id="sthref962"></a>The <span class="bold">row source generator</span> is software that receives the optimal execution plan from the optimizer and produces an iterative plan, called <a id="sthref963"></a><a id="sthref964"></a><a id="sthref965"></a>the <span class="bold">query plan</span>, that is usable by the rest of the database. The iterative plan is a binary program that, when executed by the SQL virtual machine, produces the <a id="sthref966"></a><a id="sthref967"></a>result set.</p>
<p>The query plan takes the form of a combination of steps. Each step returns <a id="sthref968"></a><a id="sthref969"></a>a <span class="bold">row set</span>. The rows in this set are either used by the next step or, in the last step, are returned to the application issuing the SQL statement.</p>
<p><a id="sthref970"></a>A <span class="bold">row source</span> is a row set returned by a step in the execution plan along with a control structure that can iteratively process the rows. The row source can be a table, view, or result of a join or grouping operation.</p>
<p>The row source generator produces a <span class="bold">row source tree</span>, which is a collection of row sources. The row source tree shows the following information:</p>
<ul>
<li>
<p>An ordering of the tables referenced by the statement</p>
</li>
<li>
<p>An access method for each table mentioned in the statement</p>
</li>
<li>
<p>A join method for tables affected by join operations in the statement</p>
</li>
<li>
<p>Data operations such as filter, sort, or aggregation</p>
</li>
</ul>
<p><a href="#CHDHGDCG">Example 7-6</a> shows the execution plan of a <code dir="ltr">SELECT</code> statement when <code dir="ltr">AUTOTRACE</code> is enabled. The statement selects the last name, job title, and department name for all employees whose last names begin with the letter <code dir="ltr">A</code>. The execution plan for this statement is the output of the row source generator.</p>
<div id="CNCPT88926" class="example">
<p class="titleinexample"><a id="CHDHGDCG"></a>Example 7-6 Execution Plan</p>
<pre dir="ltr">
SELECT e.last_name, j.job_title, d.department_name 
FROM   hr.employees e, hr.departments d, hr.jobs j
WHERE  e.department_id = d.department_id
AND    e.job_id = j.job_id
AND    e.last_name LIKE 'A%' ;
 
Execution Plan
----------------------------------------------------------
Plan hash value: 975837011
 
---------------------------------------------------------------------------------------------
| Id  | Operation                     | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |             |     3 |   189 |     7  (15)| 00:00:01 |
|*  1 |  HASH JOIN                    |             |     3 |   189 |     7  (15)| 00:00:01 |
|*  2 |   HASH JOIN                   |             |     3 |   141 |     5  (20)| 00:00:01 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMPLOYEES   |     3 |    60 |     2   (0)| 00:00:01 |
|*  4 |     INDEX RANGE SCAN          | EMP_NAME_IX |     3 |       |     1   (0)| 00:00:01 |
|   5 |    TABLE ACCESS FULL          | JOBS        |    19 |   513 |     2   (0)| 00:00:01 |
|   6 |   TABLE ACCESS FULL           | DEPARTMENTS |    27 |   432 |     2   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   2 - access("E"."JOB_ID"="J"."JOB_ID")
   4 - access("E"."LAST_NAME" LIKE 'A%')
       filter("E"."LAST_NAME" LIKE 'A%')
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDBDGBB"></a>
<div id="CNCPT1750" class="sect3">
<h4 class="sect3">SQL Execution</h4>
<p><a id="sthref971"></a><a id="sthref972"></a>During execution, the SQL engine executes each row source in the tree produced by the row source generator. This step is the only mandatory step in DML processing.</p>
<p><a href="#CHDGBAEJ">Figure 7-5</a> is an <span class="bold">execution tree</span>, also called a <span class="bold">parse tree</span>, that shows the flow of row sources from one step to another. In general, the order of the steps in execution is the <span class="italic">reverse</span> of the order in the plan, so you read the plan from the bottom up. Initial spaces in the <code dir="ltr">Operation</code> column indicate hierarchical relationships. For example, if the name of an operation is preceded by two spaces, then this operation is a child of an operation preceded by one space. Operations preceded by one space are children of the <code dir="ltr">SELECT</code> statement itself.</p>
<div id="CNCPT88927" class="figure">
<p class="titleinfigure"><a id="CHDGBAEJ"></a>Figure 7-5 Row Source Tree</p>
<img width="357" height="540" src="img/cncpt001.gif" alt="Description of Figure 7-5 follows" /><br />
<a id="sthref973" href="img_text/cncpt001.htm">Description of "Figure 7-5 Row Source Tree"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In <a href="#CHDGBAEJ">Figure 7-5</a>, each node of the tree acts as a row source, which means that each step of the execution plan either retrieves rows from the database or accepts rows from one or more row sources as input. The SQL engine executes each row source as follows:</p>
<ul>
<li>
<p>Steps indicated by the black boxes physically retrieve data from an object in the database. These steps are <a id="sthref974"></a>the <span class="bold">access paths</span>, or techniques for retrieving data from the database.</p>
<ul>
<li>
<p>Step 6 uses a <a href="glossary.htm#CHDCGIFF"><span class="xrefglossterm">full table scan</span></a> to retrieve all rows from the <code dir="ltr">departments</code> table.</p>
</li>
<li>
<p>Step 5 uses a full table scan to retrieve all rows from the <code dir="ltr">jobs</code> table.</p>
</li>
<li>
<p>Step 4 scans the <code dir="ltr">emp_name_ix</code> index in order, looking for each key that begins with the letter <code dir="ltr">A</code> and retrieving the corresponding rowid (see <a href="indexiot.htm#BABHDGHB">"Index Range Scan"</a>). For example, the rowid corresponding to <code dir="ltr">Atkinson</code> is <code dir="ltr">AAAPzRAAFAAAABSAAe</code>.</p>
</li>
<li>
<p>Step 3 retrieves from the <code dir="ltr">employees</code> table the rows whose rowids were returned by Step 4. For example, the database uses rowid <code dir="ltr">AAAPzRAAFAAAABSAAe</code> to retrieve the row for <code dir="ltr">Atkinson</code>.</p>
</li>
</ul>
</li>
<li>
<p>Steps indicated by the clear boxes operate on row sources.</p>
<ul>
<li>
<p>Step 2 performs <a id="sthref975"></a>a <span class="bold">hash join</span>, accepting row sources from Steps 3 and 5, joining each row from the Step 5 row source to its corresponding row in Step 3, and returning the resulting rows to Step 1.</p>
<p>For example, the row for employee <code dir="ltr">Atkinson</code> is associated with the job name <code dir="ltr">Stock Clerk</code>.</p>
</li>
<li>
<p>Step 1 performs another hash join, accepting row sources from Steps 2 and 6, joining each row from the Step 6 source to its corresponding row in Step 2, and returning the result to the client.</p>
<p>For example, the row for employee <code dir="ltr">Atkinson</code> is associated with the department named <code dir="ltr">Shipping</code>.</p>
</li>
</ul>
</li>
</ul>
<p>In some execution plans the steps are iterative and in others sequential. The plan shown in <a href="#CHDHGDCG">Example 7-6</a> is iterative because the SQL engine moves from index to table to client and then repeats the steps.</p>
<p>During execution, the database reads the data from disk into memory if the data is not in memory. The database also takes out any locks and latches necessary to ensure data integrity and logs any changes made during the SQL execution. The final stage of processing a SQL statement is closing the cursor.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF009" href="../../server.112/e41573/ex_plan.htm#PFGRF009"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for detailed information about execution plans and the <code dir="ltr">EXPLAIN PLAN</code> statement</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBDCHA"></a>
<div id="CNCPT88928" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">How Oracle Database Processes DML</h3>
<p>Most DML statements have a query component. In a query, execution of a cursor places the results of the query into a set of rows called <a id="sthref976"></a><a id="sthref977"></a>the <span class="bold">result set</span>.</p>
<p>Result set rows can be fetched either a row at a time or in groups. In the fetch stage, the database selects rows and, if requested by the query, orders the rows. Each successive fetch retrieves another row of the result until the last row has been fetched.</p>
<p>In general, the database cannot determine for certain the number of rows to be retrieved by a query until the last row is fetched. Oracle Database retrieves the data in response to fetch calls, so that the more rows the database reads, the more work it performs. For some queries the database returns the first row as quickly as possible, whereas for others it creates the entire result set before returning the first row.</p>
<div id="CNCPT88929" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref978"></a>
<h4 class="sect3">Read Consistency</h4>
<p><a id="sthref979"></a>In general, a query retrieves data by using the Oracle Database <a href="glossary.htm#CHDIECGD"><span class="xrefglossterm">read consistency</span></a> mechanism. This mechanism, which uses <a href="glossary.htm#CHDGJGEC"><span class="xrefglossterm">undo data</span></a> to show past versions of data, guarantees that all <a id="sthref980"></a><a href="glossary.htm#CHDBACIH"><span class="xrefglossterm">data blocks</span></a> read by a query are consistent to a single point in time.</p>
<p>For an example of read consistency, suppose a query must read 100 data blocks in a <a href="glossary.htm#CHDCGIFF"><span class="xrefglossterm">full table scan</span></a>. The query processes the first 10 blocks while DML in a different session modifies block 75. When the first session reaches block 75, it realizes the change and uses undo data to retrieve the old, unmodified version of the data and construct a noncurrent version of block 75 in memory.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="consist.htm#BABEAGIA">"Multiversion Read Consistency"</a></div>
</div>
<!-- class="sect3" -->
<div id="CNCPT88930" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref981"></a>
<h4 class="sect3">Data Changes</h4>
<p>DML statements that must change data use the read consistency mechanism to retrieve only the data that matched the search criteria when the modification began. Afterward, these statements retrieve the data blocks as they exist in their current state and make the required modifications. The database must perform other actions related to the modification of the data such as generating redo and undo data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="physical.htm#i1006163">"Overview of the Online Redo Log"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CNCPT1753" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref982"></a>
<h3 class="sect2">How Oracle Database Processes DDL</h3>
<p><a id="sthref983"></a>Oracle Database processes DDL differently from DML. For example, when you create a table, the database does not optimize the <code dir="ltr">CREATE TABLE</code> statement. Instead, Oracle Database parses the DDL statement and carries out the command.</p>
<p>The database process DDL differently because it is a means of defining an object in the data dictionary. Typically, Oracle Database must parse and execute many<a id="sthref984"></a><a id="sthref985"></a> <span class="bold">recursive SQL</span> statements to execute a DDL command. Suppose you create a table as follows:</p>
<pre dir="ltr">
CREATE TABLE mytable (mycolumn INTEGER);
</pre>
<p>Typically, the database would run dozens of recursive statements to execute the preceding statement. The recursive SQL would perform actions such as the following:</p>
<ul>
<li>
<p>Issue a <code dir="ltr">COMMIT</code> before executing the <code dir="ltr">CREATE TABLE</code> statement</p>
</li>
<li>
<p>Verify that user privileges are sufficient to create the table</p>
</li>
<li>
<p>Determine which tablespace the table should reside in</p>
</li>
<li>
<p>Ensure that the tablespace quota has not been exceeded</p>
</li>
<li>
<p>Ensure that no object in the schema has the same name</p>
</li>
<li>
<p>Insert rows that define the table into the data dictionary</p>
</li>
<li>
<p>Issue a <code dir="ltr">COMMIT</code> if the DDL statement succeeded or a <code dir="ltr">ROLLBACK</code> if it did not</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADFNS007" href="../../appdev.112/e41502/adfns_sqlproc.htm#ADFNS007"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> to learn about SQL processing for application developers</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1448">
<tr>
<td class="cellalignment1455">
<table class="cellalignment1453">
<tr>
<td class="cellalignment1452"><a href="part_datac.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1452"><a href="srvrside.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1457">
<table class="cellalignment1451">
<tr>
<td class="cellalignment1452"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1452"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1452"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1452"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1452"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1452"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
