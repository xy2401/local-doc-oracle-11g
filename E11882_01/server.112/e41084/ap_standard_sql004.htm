<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Oracle Support for Optional Features of SQL/Foundation:2008</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1075" />
<meta name="dcterms.created" content="2016-01-05T5:46:28Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database SQL Language Reference" />
<meta name="dcterms.identifier" content="E41084-04" />
<meta name="dcterms.isVersionOf" content="SQLRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ap_standard_sql003.htm" title="Previous" type="text/html" />
<link rel="Next" href="ap_standard_sql005.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41084.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">501/522</span> <!-- End Header --><a id="i7738"></a>
<div id="SQLRF55521" class="sect1"><!-- infolevel="all" infotype="General" -->
<h1 class="sect1">Oracle Support for Optional Features of SQL/Foundation:2008</h1>
<p>Oracle's support for optional features of SQL/Foundation:2008 is listed in <a href="#BJECCJHB">Table C-2</a>:</p>
<div id="SQLRF55577" class="tblhruleformal">
<p class="titleintable"><a id="sthref6966"></a><a id="BJECCJHB"></a>Table C-2 Oracle Support for Optional Features of SQL/Foundation:2008</p>
<table class="cellalignment1868" title="Oracle Support for Optional Features of SQL/Foundation:2008" summary="Column 1 contains the SQL:2008 optional feature identifier and its descrption and column 2 describes the Oracle Database support of the feature." dir="ltr">
<thead>
<tr class="cellalignment1859">
<th class="cellalignment1869" id="r1c1-t3">Feature ID, Feature</th>
<th class="cellalignment1869" id="r1c2-t3">Support</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r2c1-t3" headers="r1c1-t3">
<p>B012, Embedded C</p>
</td>
<td class="cellalignment1865" headers="r2c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r3c1-t3" headers="r1c1-t3">
<p>B013, Embedded COBOL</p>
</td>
<td class="cellalignment1865" headers="r3c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r4c1-t3" headers="r1c1-t3">
<p>B014, Embedded Fortran</p>
</td>
<td class="cellalignment1865" headers="r4c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r5c1-t3" headers="r1c1-t3">
<p>B021, Direct SQL</p>
</td>
<td class="cellalignment1865" headers="r5c1-t3 r1c2-t3">
<p>Oracle fully supports this feature, as SQL*Plus.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r6c1-t3" headers="r1c1-t3">
<p>B031, Basic dynamic SQL</p>
</td>
<td class="cellalignment1865" headers="r6c1-t3 r1c2-t3">
<p>Oracle supports dynamic SQL in two styles, documented in the embedded language manuals as "Oracle dynamic SQL" and "ANSI dynamic SQL."</p>
<p>ANSI dynamic SQL is an implementation of the standard, with the following restrictions:</p>
<ul>
<li>
<p>Oracle supports a subset of the descriptor items.</p>
</li>
<li>
<p>For &lt;input using clause&gt;, Oracle only supports &lt;using input descriptor&gt;.</p>
</li>
<li>
<p>For &lt;output using clause&gt;, Oracle only supports &lt;into descriptor&gt;.</p>
</li>
<li>
<p>Dynamic parameters are indicated by a colon followed by an identifier rather than a question mark.</p>
</li>
</ul>
<p>Oracle dynamic SQL is similar to standard dynamic SQL, with the following modifications:</p>
<ul>
<li>
<p>Parameters are indicated by a colon followed by an identifier, instead of a question mark.</p>
</li>
<li>
<p>Oracle's <code dir="ltr">DESCRIBE</code> <code dir="ltr">SELECT</code> <code dir="ltr">LIST</code> <code dir="ltr">FOR</code> statement replaces the standard's <code dir="ltr">DESCRIBE</code> <code dir="ltr">OUTPUT</code>.</p>
</li>
<li>
<p>Oracle provides <code dir="ltr">DECLARE</code> <code dir="ltr">STATEMENT</code> if you want to declare a cursor using a dynamic SQL statement physically prior to the <code dir="ltr">PREPARE</code> statement that prepares the dynamic SQL statement.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r7c1-t3" headers="r1c1-t3">
<p>B032, Extended dynamic SQL</p>
</td>
<td class="cellalignment1865" headers="r7c1-t3 r1c2-t3">
<p>In ANSI dynamic SQL, Oracle only implements the ability to declare global statements and global cursors from this feature; the rest of the feature is not supported.</p>
<p>In Oracle dynamic SQL, Oracle's <code dir="ltr">DESCRIBE</code> <code dir="ltr">BIND</code> <code dir="ltr">VARIABLES</code> is equivalent to the standard's <code dir="ltr">DESCRIBE</code> <code dir="ltr">INPUT</code>; the rest of this feature is not supported.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r8c1-t3" headers="r1c1-t3">
<p>B111, Module language Ada</p>
</td>
<td class="cellalignment1865" headers="r8c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r9c1-t3" headers="r1c1-t3">
<p>B122, Routine language C</p>
</td>
<td class="cellalignment1865" headers="r9c1-t3 r1c2-t3">
<p>Oracle supports external routines written in C, though Oracle does not support the standard syntax for creating such routines.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r10c1-t3" headers="r1c1-t3">
<p>B128, Routine language SQL</p>
</td>
<td class="cellalignment1865" headers="r10c1-t3 r1c2-t3">
<p>Oracle supports routines written in PL/SQL, which is Oracle's equivalent to the standard procedural language SQL/PSM.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r11c1-t3" headers="r1c1-t3">
<p>F032, <code dir="ltr">CASCADE</code> drop behavior</p>
</td>
<td class="cellalignment1865" headers="r11c1-t3 r1c2-t3">
<p>In Oracle, a <code dir="ltr">DROP</code> command invalidates all of the dropped object's dependent objects. Invalidated objects are effectively unusable until the dropped object is redefined in such a way to allow successful recompilation of the invalidated object.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r12c1-t3" headers="r1c1-t3">
<p>F033, <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement: <code dir="ltr">DROP</code> <code dir="ltr">COLUMN</code> clause</p>
</td>
<td class="cellalignment1865" headers="r12c1-t3 r1c2-t3">
<p>Oracle provides a <code dir="ltr">DROP</code> <code dir="ltr">COLUMN</code> clause, but without the <code dir="ltr">RESTRICT</code> or <code dir="ltr">CASCADE</code> options found in the standard.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r13c1-t3" headers="r1c1-t3">
<p>F034, Extended <code dir="ltr">REVOKE</code> statement</p>
</td>
<td class="cellalignment1865" headers="r13c1-t3 r1c2-t3">
<p>Oracle supports the following parts of this feature:</p>
<ul>
<li>
<p>F034-01, <code dir="ltr">REVOKE</code> statement performed by other than the owner of a schema object</p>
</li>
<li>
<p>F034-03, <code dir="ltr">REVOKE</code> statement to revoke a privilege that the grantee has <code dir="ltr">WITH</code> <code dir="ltr">GRANT</code> <code dir="ltr">OPTION</code></p>
</li>
</ul>
<p>Oracle provides equivalent functionality for the following parts of this feature:</p>
<ul>
<li>
<p><code dir="ltr">CASCADE</code>: In Oracle, a <code dir="ltr">REVOKE</code> invalidates all dependent objects, which become effectively unusable until the metadata is changed through subsequent <code dir="ltr">CREATE</code> and <code dir="ltr">GRANT</code> commands enabling the invalidated object to be successfully recompiled.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r14c1-t3" headers="r1c1-t3">
<p>F052, Intervals and datetime arithmetic</p>
</td>
<td class="cellalignment1865" headers="r14c1-t3 r1c2-t3">
<p>Oracle only supports the <code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code> and <code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code> data types.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r15c1-t3" headers="r1c1-t3">
<p>F111, Isolations levels other than <code dir="ltr">SERIALIZABLE</code></p>
</td>
<td class="cellalignment1865" headers="r15c1-t3 r1c2-t3">
<p>In addition to <code dir="ltr">SERIALIZABLE</code>, Oracle supports the <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation level.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r16c1-t3" headers="r1c1-t3">
<p>F121, Basic diagnostics management</p>
</td>
<td class="cellalignment1865" headers="r16c1-t3 r1c2-t3">
<p>Much of the functionality of this feature is provided through the SQLCA in embedded languages.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r17c1-t3" headers="r1c1-t3">
<p>F191, Referential delete actions</p>
</td>
<td class="cellalignment1865" headers="r17c1-t3 r1c2-t3">
<p>Oracle supports <code dir="ltr">ON</code> <code dir="ltr">DELETE</code> <code dir="ltr">CASCADE</code> and <code dir="ltr">ON</code> <code dir="ltr">DELETE</code> <code dir="ltr">SET</code> <code dir="ltr">NULL</code>.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r18c1-t3" headers="r1c1-t3">
<p>F200, <code dir="ltr">TRUNCATE</code> <code dir="ltr">TABLE</code></p>
</td>
<td class="cellalignment1865" headers="r18c1-t3 r1c2-t3">
<p>Oracle fully supports this feature, and extends it by permitting truncation of a table that references itself in a referential integrity constraint.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r19c1-t3" headers="r1c1-t3">
<p>F231, Privilege tables</p>
</td>
<td class="cellalignment1865" headers="r19c1-t3 r1c2-t3">
<p>Oracle makes this information available in the following metadata views:</p>
<ul>
<li>
<p>Instead of <code dir="ltr">TABLE_PRIVILEGES</code>, use <code dir="ltr">ALL_TAB_PRIVS</code>.</p>
</li>
<li>
<p>Instead of <code dir="ltr">COLUMN_PRIVILEGES</code>, use <code dir="ltr">ALL_COL_PRIVS</code>.</p>
</li>
<li>
<p>Oracle does not support <code dir="ltr">USAGE</code> privileges so there is no equivalent to <code dir="ltr">USAGE_PRIVILEGES</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r20c1-t3" headers="r1c1-t3">
<p>F281, <code dir="ltr">LIKE</code> enhancements</p>
</td>
<td class="cellalignment1865" headers="r20c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r21c1-t3" headers="r1c1-t3">
<p>F291, <code dir="ltr">UNIQUE</code> predicate</p>
</td>
<td class="cellalignment1865" headers="r21c1-t3 r1c2-t3">
<p>The <code dir="ltr">IS</code> <code dir="ltr">A</code> <code dir="ltr">SET</code> condition may be used to test whether a multiset is a set; that is, each row is unique. Thus, the equivalent of</p>
<pre dir="ltr">
UNIQUE &lt;table subquery&gt;
</pre>
<p>is</p>
<pre dir="ltr">
CAST (&lt;table subquery&gt; AS MULTISET) IS A SET
</pre></td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r22c1-t3" headers="r1c1-t3">
<p>F302, <code dir="ltr">INTERSECT</code> table operator</p>
</td>
<td class="cellalignment1865" headers="r22c1-t3 r1c2-t3">
<p>Oracle supports <code dir="ltr">INTERSECT</code> but not <code dir="ltr">INTERSECT</code> <code dir="ltr">ALL</code>. Syntactically, Oracle differs from the standard in that <code dir="ltr">UNION</code>, <code dir="ltr">INTERSECT</code>, and <code dir="ltr">MINUS</code> have the same precedence.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r23c1-t3" headers="r1c1-t3">
<p>F312, <code dir="ltr">MERGE</code> statement</p>
</td>
<td class="cellalignment1865" headers="r23c1-t3 r1c2-t3">
<p>The Oracle <code dir="ltr">MERGE</code> statement is almost the same as the standard, with these exceptions:</p>
<ul>
<li>
<p>Oracle does not support the optional <code dir="ltr">AS</code> keyword before a table alias.</p>
</li>
<li>
<p>Oracle does not support the ability to rename columns of the table specified in the <code dir="ltr">USING</code> clause with a parenthesized list of column names following the table alias.</p>
</li>
<li>
<p>Oracle does not support the &lt;override clause&gt;.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r24c1-t3" headers="r1c1-t3">
<p>F341, Usage tables</p>
</td>
<td class="cellalignment1865" headers="r24c1-t3 r1c2-t3">
<p>Oracle makes this information available in the views <code dir="ltr">ALL_DEPENDENCIES</code>, <code dir="ltr">DBA_DEPENDENCIES</code>, and <code dir="ltr">USER_DEPENDENCIES</code>.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r25c1-t3" headers="r1c1-t3">
<p>F381, Extended schema manipulation</p>
</td>
<td class="cellalignment1865" headers="r25c1-t3 r1c2-t3">
<p>Oracle fully supports the following element of this feature:</p>
<ul>
<li>
<p>Oracle supports the standard syntax to add a table constraint using <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>.</p>
</li>
</ul>
<p>Oracle partially supports the following element of this feature:</p>
<ul>
<li>
<p>Oracle supports the standard syntax to drop a table constraint, except that Oracle does not support <code dir="ltr">RESTRICT</code>.</p>
</li>
</ul>
<p>Oracle provides equivalent functionality for the following element of this feature:</p>
<ul>
<li>
<p>To alter the default value of a column, use the <code dir="ltr">MODIFY</code> option of <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>.</p>
</li>
</ul>
<p>Oracle does not support the following parts of this feature:</p>
<ul>
<li>
<p><code dir="ltr">DROP</code> <code dir="ltr">SCHEMA</code> statement</p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">ROUTINE</code> statement</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r26c1-t3" headers="r1c1-t3">
<p>F382, Alter column data type</p>
</td>
<td class="cellalignment1865" headers="r26c1-t3 r1c2-t3">
<p>Oracle supports this functionality, though with non-standard syntax.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r27c1-t3" headers="r1c1-t3">
<p>F391, Long identifiers</p>
</td>
<td class="cellalignment1865" headers="r27c1-t3 r1c2-t3">
<p>Oracle supports identifiers up to 30 characters in length.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r28c1-t3" headers="r1c1-t3">
<p>F393, Unicode escapes in literals</p>
</td>
<td class="cellalignment1865" headers="r28c1-t3 r1c2-t3">
<p>The Oracle <code dir="ltr">UNISTR</code> function supports numeric escape sequences for all Unicode characters.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r29c1-t3" headers="r1c1-t3">
<p>F394, Optional normal form specification</p>
</td>
<td class="cellalignment1865" headers="r29c1-t3 r1c2-t3">
<p>This feature adds the keywords <code dir="ltr">NFC</code>, <code dir="ltr">NFD</code>, <code dir="ltr">NFKC</code>, and <code dir="ltr">NKD</code> to the <code dir="ltr">NORMALIZE</code> function and the <code dir="ltr">IS</code> <code dir="ltr">NORMAL</code> predicate. Without these keywords, <code dir="ltr">NFC</code> is the default (see Feature T061, UCS support). Oracle supports all four normalization forms, with nonstandard syntax, as follows:</p>
<ul>
<li>
<p>For <code dir="ltr">NFC</code>, use <code dir="ltr">COMPOSE</code></p>
</li>
<li>
<p>For <code dir="ltr">NFD</code>, use <code dir="ltr">DECOMPOSE</code> with the <code dir="ltr">CANONICAL</code> option</p>
</li>
<li>
<p>For <code dir="ltr">NFKD</code>, use <code dir="ltr">DECOMPOSE</code> with the <code dir="ltr">COMPATIBILITY</code> option</p>
</li>
<li>
<p>For <code dir="ltr">NFKC</code>, use <code dir="ltr">DECOMPOSE</code> with the <code dir="ltr">CANONICAL</code> option followed by <code dir="ltr">COMPOSE</code></p>
</li>
</ul>
<p>Oracle does not support the <code dir="ltr">IS</code> <code dir="ltr">NORMAL</code> predicate.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r30c1-t3" headers="r1c1-t3">
<p>F401, Extended joined table</p>
</td>
<td class="cellalignment1865" headers="r30c1-t3 r1c2-t3">
<p>Oracle supports <code dir="ltr">FULL</code> outer joins, <code dir="ltr">CROSS</code> joins, and <code dir="ltr">NATURAL</code> joins.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r31c1-t3" headers="r1c1-t3">
<p>F402, Named column joins for LOBs, arrays and multisets</p>
</td>
<td class="cellalignment1865" headers="r31c1-t3 r1c2-t3">
<p>Oracle supports named column joins for columns whose declared type is nested table. Oracle does not support named column joins for LOBs or arrays.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r32c1-t3" headers="r1c1-t3">
<p>F403, Partitioned join tables</p>
</td>
<td class="cellalignment1865" headers="r32c1-t3 r1c2-t3">
<p>Oracle supports this feature, except with <code dir="ltr">FULL</code> outer joins.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r33c1-t3" headers="r1c1-t3">
<p>F411, Time zone specification</p>
</td>
<td class="cellalignment1865" headers="r33c1-t3 r1c2-t3">
<p>Oracle fully supports <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>, but does not support <code dir="ltr">TIME</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r34c1-t3" headers="r1c1-t3">
<p>F421, National character</p>
</td>
<td class="cellalignment1865" headers="r34c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r35c1-t3" headers="r1c1-t3">
<p>F441, Extended set function support</p>
</td>
<td class="cellalignment1865" headers="r35c1-t3 r1c2-t3">
<p>Oracle supports the following parts of this feature:</p>
<ul>
<li>
<p>The ability in the <code dir="ltr">WHERE</code> clause to reference a column that is defined using an aggregate, either in a view or an inline view</p>
</li>
<li>
<p><code dir="ltr">COUNT</code> without <code dir="ltr">DISTINCT</code> of an expression</p>
</li>
<li>
<p>Aggregates that reference columns that are outer references with respect to the aggregating query</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r36c1-t3" headers="r1c1-t3">
<p>F442, Mixed column references in set functions</p>
</td>
<td class="cellalignment1865" headers="r36c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r37c1-t3" headers="r1c1-t3">
<p>F461, Named character sets</p>
</td>
<td class="cellalignment1865" headers="r37c1-t3 r1c2-t3">
<p>Oracle supports many character sets with Oracle-defined names. Oracle does not support any other aspect of this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r38c1-t3" headers="r1c1-t3">
<p>F491, Constraint management</p>
</td>
<td class="cellalignment1865" headers="r38c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r39c1-t3" headers="r1c1-t3">
<p>F531, Temporary tables</p>
</td>
<td class="cellalignment1865" headers="r39c1-t3 r1c2-t3">
<p>Oracle supports <code dir="ltr">GLOBAL</code> <code dir="ltr">TEMPORARY</code> tables.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r40c1-t3" headers="r1c1-t3">
<p>F555, Enhanced seconds precision</p>
</td>
<td class="cellalignment1865" headers="r40c1-t3 r1c2-t3">
<p>Oracle provides enhanced support for this feature, supporting up to 9 places after the decimal point.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r41c1-t3" headers="r1c1-t3">
<p>F561, Full value expressions</p>
</td>
<td class="cellalignment1865" headers="r41c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r42c1-t3" headers="r1c1-t3">
<p>F571, Truth value tests</p>
</td>
<td class="cellalignment1865" headers="r42c1-t3 r1c2-t3">
<p>Oracle's <code dir="ltr">LNNVL</code> function is equivalent to the standard's <code dir="ltr">IS</code> <code dir="ltr">NOT</code> <code dir="ltr">TRUE</code> predicate.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r43c1-t3" headers="r1c1-t3">
<p>F591, Derived tables</p>
</td>
<td class="cellalignment1865" headers="r43c1-t3 r1c2-t3">
<p>Oracle supports &lt;derived table&gt;, with the exception of:</p>
<ul>
<li>
<p>Oracle does not support the optional <code dir="ltr">AS</code> keyword before a table alias.</p>
</li>
<li>
<p>Oracle does not support &lt;derived column list&gt;.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r44c1-t3" headers="r1c1-t3">
<p>F641, Row and table constructors</p>
</td>
<td class="cellalignment1865" headers="r44c1-t3 r1c2-t3">
<p>In Oracle, a row constructor may be used in an equality or inequality comparison with another row constructor or with a subquery. Oracle does not support anything else in this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r45c1-t3" headers="r1c1-t3">
<p>F690, Collation support</p>
</td>
<td class="cellalignment1865" headers="r45c1-t3 r1c2-t3">
<p>Oracle's <code dir="ltr">NLSSORT</code> function may be used to change the collation of character expressions.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r46c1-t3" headers="r1c1-t3">
<p>F693, SQL-sessions and client module collations</p>
</td>
<td class="cellalignment1865" headers="r46c1-t3 r1c2-t3">
<p>To set a session collation, use <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">NLS_COMP</code> <code dir="ltr">=</code> <code dir="ltr">'LINGUISTIC'</code> and also set NLS_SORT to your desired collation. Oracle does not support client module collations.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r47c1-t3" headers="r1c1-t3">
<p>F695, Translation support</p>
</td>
<td class="cellalignment1865" headers="r47c1-t3 r1c2-t3">
<p>The Oracle <code dir="ltr">CONVERT</code> function can convert between the database character set and the national character set. For other character sets, store the data in the <code dir="ltr">RAW</code> data type and use the PL/SQL package function <code dir="ltr">UTL_RAW</code>.<code dir="ltr">CONVERT</code>. Oracle does not provide the ability to add or drop character set conversions.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r48c1-t3" headers="r1c1-t3">
<p>F721, Deferrable constraints</p>
</td>
<td class="cellalignment1865" headers="r48c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r49c1-t3" headers="r1c1-t3">
<p>F731, <code dir="ltr">INSERT</code> column privileges</p>
</td>
<td class="cellalignment1865" headers="r49c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r50c1-t3" headers="r1c1-t3">
<p>F761, Session management</p>
</td>
<td class="cellalignment1865" headers="r50c1-t3 r1c2-t3">
<p>Oracle provides the following equivalents for elements of this feature:</p>
<ul>
<li>
<p>The equivalent to the standard's <code dir="ltr">SET</code> <code dir="ltr">SESSION</code> <code dir="ltr">CHARACTERISTICS</code> <code dir="ltr">AS</code> <code dir="ltr">TRANSACTION</code> <code dir="ltr">SERIALIZABLE</code> is <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">ISOLATION_LEVEL</code> <code dir="ltr">=</code> <code dir="ltr">SERIALIZABLE</code>.</p>
</li>
<li>
<p>The equivalent to the standard's <code dir="ltr">SET</code> <code dir="ltr">SCHEMA</code> is <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">CURRENT_SCHEMA</code>.</p>
</li>
<li>
<p>The equivalent to the standard's <code dir="ltr">SET</code> <code dir="ltr">COLLATION</code> is <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">NLS_SORT</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r51c1-t3" headers="r1c1-t3">
<p>F771, Connection management</p>
</td>
<td class="cellalignment1865" headers="r51c1-t3 r1c2-t3">
<p>Oracle's <code dir="ltr">CONNECT</code> statement provides the same functionality as the standard's <code dir="ltr">CONNECT</code> statement, though with different syntax. Instead of using the standard's <code dir="ltr">SET</code> <code dir="ltr">CONNECTION</code>, Oracle provides the <code dir="ltr">AT</code> clause to indicate which connection a SQL statement should be performed on. Oracle embedded languages let you disconnect from a connection by using the <code dir="ltr">RELEASE</code> option of either <code dir="ltr">COMMIT</code> or <code dir="ltr">ROLLBACK</code>.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r52c1-t3" headers="r1c1-t3">
<p>F781, Self-referencing operations</p>
</td>
<td class="cellalignment1865" headers="r52c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r53c1-t3" headers="r1c1-t3">
<p>F801, Full set function</p>
</td>
<td class="cellalignment1865" headers="r53c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r54c1-t3" headers="r1c1-t3">
<p>F831, Full cursor update</p>
</td>
<td class="cellalignment1865" headers="r54c1-t3 r1c2-t3">
<p>Oracle supports the combination of <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> and <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clauses in a query.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r55c1-t3" headers="r1c1-t3">
<p>F841, <code dir="ltr">LIKE_REGEX</code> predicate</p>
</td>
<td class="cellalignment1865" headers="r55c1-t3 r1c2-t3">
<p>Oracle's equivalent is <code dir="ltr">REGEXP_LIKE</code>. Oracle's pattern syntax lacks some of the features of the standard's. Oracle's match parameter has the same capabilities as the standard's, though with a few spelling differences.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r56c1-t3" headers="r1c1-t3">
<p>F842, <code dir="ltr">OCCURRENCES_REGEX</code> function</p>
</td>
<td class="cellalignment1865" headers="r56c1-t3 r1c2-t3">
<p>Oracle's equivalent is <code dir="ltr">REGEXP_COUNT</code>. Oracle's pattern syntax lacks some of the features of the standard's. Oracle's match parameter has the same capabilities as the standard's, though with a few spelling differences.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r57c1-t3" headers="r1c1-t3">
<p>F843, <code dir="ltr">POSITION_REGEX</code> function</p>
</td>
<td class="cellalignment1865" headers="r57c1-t3 r1c2-t3">
<p>Oracle's equivalent is <code dir="ltr">REGEXP_INSTR</code>. Oracle's pattern syntax lacks some of the features of the standard's. Oracle's match parameter has the same capabilities as the standard's, though with a few spelling differences.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r58c1-t3" headers="r1c1-t3">
<p>F844, <code dir="ltr">SUBSTRING_REGEX</code> function</p>
</td>
<td class="cellalignment1865" headers="r58c1-t3 r1c2-t3">
<p>Oracle's equivalent is <code dir="ltr">REGEXP_SUBSTR</code>. Oracle's pattern syntax lacks some of the features of the standard's. Oracle's match parameter has the same capabilities as the standard's, though with a few spelling differences.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r59c1-t3" headers="r1c1-t3">
<p>F845, <code dir="ltr">TRANSLATE_REGEX</code> function</p>
</td>
<td class="cellalignment1865" headers="r59c1-t3 r1c2-t3">
<p>Oracle's equivalent is <code dir="ltr">REGEXP_REPLACE</code>. Oracle's pattern syntax lacks some of the features of the standard's. Oracle's match parameter has the same capabilities as the standard's, though with a few spelling differences.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r60c1-t3" headers="r1c1-t3">
<p>S023, Basic structured types</p>
</td>
<td class="cellalignment1865" headers="r60c1-t3 r1c2-t3">
<p>Oracle's object types are equivalent to structured types in the standard.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r61c1-t3" headers="r1c1-t3">
<p>S024, Enhanced structured types</p>
</td>
<td class="cellalignment1865" headers="r61c1-t3 r1c2-t3">
<p>Oracle's syntax is non-standard, but provides equivalents for the following:</p>
<ul>
<li>
<p><code dir="ltr">NOT</code> <code dir="ltr">INSTANTIABLE</code></p>
</li>
<li>
<p><code dir="ltr">STATIC</code> methods</p>
</li>
<li>
<p><code dir="ltr">RELATIVE</code>, <code dir="ltr">MAP</code>, and <code dir="ltr">STATE</code> orderings. The keyword in Oracle for <code dir="ltr">RELATIVE</code> orderings is <code dir="ltr">ORDER</code>. There is no keyword for <code dir="ltr">STATE</code> orderings (this is the default, if no other ordering is defined). Unlike the standard, Oracle does not support <code dir="ltr">EQUALS</code> <code dir="ltr">ONLY</code> on non-<code dir="ltr">STATE</code> orderings. (See also Feature S251, User-defined orderings.)</p>
</li>
<li>
<p><code dir="ltr">SELF</code> <code dir="ltr">AS</code> <code dir="ltr">RESULT</code> in the signature of constructor methods</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r62c1-t3" headers="r1c1-t3">
<p>S025, Final structured types</p>
</td>
<td class="cellalignment1865" headers="r62c1-t3 r1c2-t3">
<p>Oracle's final object types are equivalent to final structured types in the standard.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r63c1-t3" headers="r1c1-t3">
<p>S026, Self-referencing structured types</p>
</td>
<td class="cellalignment1865" headers="r63c1-t3 r1c2-t3">
<p>In Oracle, an object type OT may have a reference that references OT.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r64c1-t3" headers="r1c1-t3">
<p>S041, Basic reference types</p>
</td>
<td class="cellalignment1865" headers="r64c1-t3 r1c2-t3">
<p>Oracle's reference types are equivalent to reference types in the standard. To dereference a reference, dot notation is used, instead of -&gt; as in the standard.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r65c1-t3" headers="r1c1-t3">
<p>S043, Enhanced reference types</p>
</td>
<td class="cellalignment1865" headers="r65c1-t3 r1c2-t3">
<p>Oracle supports the following elements of this feature:</p>
<ul>
<li>
<p><code dir="ltr">DEREF</code> operator to return the object referenced by a reference</p>
</li>
<li>
<p><code dir="ltr">SCOPE</code> clause as a constraint on columns of tables or materialized views</p>
</li>
<li>
<p>Adding and dropping the scope of a column</p>
</li>
<li>
<p>References that are either system-generated or derived from the primary key (but not from any other list of columns, nor from a list of attributes of the type)</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r66c1-t3" headers="r1c1-t3">
<p>S051, Create table of type</p>
</td>
<td class="cellalignment1865" headers="r66c1-t3 r1c2-t3">
<p>Oracle's object tables are equivalent to tables of structured type in the standard.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r67c1-t3" headers="r1c1-t3">
<p>S081, Subtables</p>
</td>
<td class="cellalignment1865" headers="r67c1-t3 r1c2-t3">
<p>Oracle supports hierarchies of object views, but not of object base tables. To emulate a hierarchy of base tables, create a hierarchy of views on those base tables.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r68c1-t3" headers="r1c1-t3">
<p>S091, Array types</p>
</td>
<td class="cellalignment1865" headers="r68c1-t3 r1c2-t3">
<p>Oracle <code dir="ltr">VARRAY</code> types are equivalent to array types in the standard. However, Oracle does not support storage of arrays of LOBs. To access a single element of an array using a subscript, you must use PL/SQL. Oracle supports the following aspects of this feature with nonstandard syntax:</p>
<ul>
<li>
<p>To construct an instance of varray type, including an empty array, use the varray type constructor.</p>
</li>
<li>
<p>To unnest a varray in the <code dir="ltr">FROM</code> clause, use the <code dir="ltr">TABLE</code> operator.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r69c1-t3" headers="r1c1-t3">
<p>S092, Arrays of user-defined types</p>
</td>
<td class="cellalignment1865" headers="r69c1-t3 r1c2-t3">
<p>Oracle supports <code dir="ltr">VARRAY</code>s of object types.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r70c1-t3" headers="r1c1-t3">
<p>S094, Arrays of reference types</p>
</td>
<td class="cellalignment1865" headers="r70c1-t3 r1c2-t3">
<p>Oracle supports <code dir="ltr">VARRAY</code>s of references.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r71c1-t3" headers="r1c1-t3">
<p>S095, Array constructors by query</p>
</td>
<td class="cellalignment1865" headers="r71c1-t3 r1c2-t3">
<p>Oracle supports this using <code dir="ltr">CAST</code> (<code dir="ltr">MULTISET</code> (<code dir="ltr">SELECT</code> ...) <code dir="ltr">AS</code> <code dir="ltr"><span class="codeinlineitalic">varray_type</span></code><code dir="ltr">)</code>. The ability to order the elements of the array using <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> is not supported.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r72c1-t3" headers="r1c1-t3">
<p>S097, Array element assignment</p>
</td>
<td class="cellalignment1865" headers="r72c1-t3 r1c2-t3">
<p>In PL/SQL, you can assign to array elements, using syntax that is similar to the standard (SQL/PSM).</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r73c1-t3" headers="r1c1-t3">
<p>S111, <code dir="ltr">ONLY</code> in query expressions</p>
</td>
<td class="cellalignment1865" headers="r73c1-t3 r1c2-t3">
<p>Oracle supports the <code dir="ltr">ONLY</code> clause for view hierarchies; Oracle does not support hierarchies of base tables.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r74c1-t3" headers="r1c1-t3">
<p>S151, Type predicate</p>
</td>
<td class="cellalignment1865" headers="r74c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r75c1-t3" headers="r1c1-t3">
<p>S161, Subtype treatment</p>
</td>
<td class="cellalignment1865" headers="r75c1-t3 r1c2-t3">
<p>Supported, with a minor syntactic difference: The standard requires parentheses around the referenced type's name; Oracle does not support parentheses in this position.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r76c1-t3" headers="r1c1-t3">
<p>S162, Subtype treatment for references</p>
</td>
<td class="cellalignment1865" headers="r76c1-t3 r1c2-t3">
<p>The standard requires parentheses around the referenced type's name; Oracle does not support parentheses in this position.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r77c1-t3" headers="r1c1-t3">
<p>S201, SQL-invoked routines on arrays</p>
</td>
<td class="cellalignment1865" headers="r77c1-t3 r1c2-t3">
<p>PL/SQL provides the ability to pass arrays as parameters and return arrays as the result of functions. Procedures and functions written in C may pass arrays and return arrays as the result of functions using the Oracle Type Translator (OTT).</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r78c1-t3" headers="r1c1-t3">
<p>S202, SQL-invoked routines on multisets</p>
</td>
<td class="cellalignment1865" headers="r78c1-t3 r1c2-t3">
<p>A PL/SQL routine may have nested tables as parameters, and may return a nested table. Routines written in C may pass arrays and return arrays as the result of functions using the Oracle Type Translator.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r79c1-t3" headers="r1c1-t3">
<p>S232, Array locators</p>
</td>
<td class="cellalignment1865" headers="r79c1-t3 r1c2-t3">
<p>Oracle Type Translator supports descriptors for arrays, which achieve the same purpose as locators.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r80c1-t3" headers="r1c1-t3">
<p>S233, Multiset locators</p>
</td>
<td class="cellalignment1865" headers="r80c1-t3 r1c2-t3">
<p>Oracle supports locators for nested tables.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r81c1-t3" headers="r1c1-t3">
<p>S241, Transform functions</p>
</td>
<td class="cellalignment1865" headers="r81c1-t3 r1c2-t3">
<p>The Oracle Type Translator provides the same capability as transforms.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r82c1-t3" headers="r1c1-t3">
<p>S251, User-defined orderings</p>
</td>
<td class="cellalignment1865" headers="r82c1-t3 r1c2-t3">
<p>Oracle's object type ordering capabilities correspond to the standard's capabilities as follows:</p>
<ul>
<li>
<p>Oracle's <code dir="ltr">MAP</code> ordering corresponds to the standard's <code dir="ltr">ORDER</code> <code dir="ltr">FULL</code> <code dir="ltr">BY</code> <code dir="ltr">MAP</code> ordering.</p>
</li>
<li>
<p>Oracle's <code dir="ltr">ORDER</code> ordering corresponds to the standard's <code dir="ltr">ORDER</code> <code dir="ltr">FULL</code> <code dir="ltr">BY</code> <code dir="ltr">RELATIVE</code> ordering.</p>
</li>
<li>
<p>If an Oracle object type has neither <code dir="ltr">MAP</code> nor <code dir="ltr">ORDER</code> declared, then this corresponds to <code dir="ltr">EQUALS</code> <code dir="ltr">ONLY</code> <code dir="ltr">BY</code> <code dir="ltr">STATE</code> in the standard.</p>
</li>
<li>
<p>Oracle does not have unordered object types; you can alter the ordering but you cannot drop it.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r83c1-t3" headers="r1c1-t3">
<p>S271, Basic multiset support</p>
</td>
<td class="cellalignment1865" headers="r83c1-t3 r1c2-t3">
<p>Multisets in the standard are supported as nested table types in Oracle. The Oracle nested table data type based on a scalar type ST is equivalent, in standard terminology, to a multiset of rows having a single field of type ST and named <code dir="ltr"><span class="codeinlineitalic">column_value</span></code>. The Oracle nested table type based on an object type is equivalent to a multiset of structured type in the standard.</p>
<p>Oracle supports the following elements of this feature on nested tables using the same syntax as the standard has for multisets:</p>
<ul>
<li>
<p>The <code dir="ltr">CARDINALITY</code> function</p>
</li>
<li>
<p>The <code dir="ltr">SET</code> function</p>
</li>
<li>
<p>The <code dir="ltr">MEMBER</code> predicate</p>
</li>
<li>
<p>The <code dir="ltr">IS</code> <code dir="ltr">A</code> <code dir="ltr">SET</code> predicate</p>
</li>
<li>
<p>The <code dir="ltr">COLLECT</code> aggregate</p>
</li>
</ul>
<p>All other aspects of this feature are supported with non-standard syntax, as follows:</p>
<ul>
<li>
<p>To create an empty multiset, denoted <code dir="ltr">MULTISET[]</code> in the standard, use an empty constructor of the nested table type.</p>
</li>
<li>
<p>To obtain the sole element of a multiset with one element, denoted <code dir="ltr">ELEMENT</code> (&lt;multiset value expression&gt;) in the standard, use a scalar subquery to select the single element from the nested table.</p>
</li>
<li>
<p>To construct a multiset by enumeration, use the constructor of the nested table type.</p>
</li>
<li>
<p>To construct a multiset by query, use <code dir="ltr">CAST</code> with a multiset argument, casting to the nested table type.</p>
</li>
<li>
<p>To unnest a multiset, use the <code dir="ltr">TABLE</code> operator in the <code dir="ltr">FROM</code> clause.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r84c1-t3" headers="r1c1-t3">
<p>S272, Multisets of user-defined types</p>
</td>
<td class="cellalignment1865" headers="r84c1-t3 r1c2-t3">
<p>Oracle's nested table type permits a multiset of structured types. Oracle does not have distinct types, so a multiset of distinct types is not supported</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r85c1-t3" headers="r1c1-t3">
<p>S274, Multisets of reference types</p>
</td>
<td class="cellalignment1865" headers="r85c1-t3 r1c2-t3">
<p>A nested table type can have one or more columns of reference type.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r86c1-t3" headers="r1c1-t3">
<p>S275, Advanced multiset support</p>
</td>
<td class="cellalignment1865" headers="r86c1-t3 r1c2-t3">
<p>Oracle supports the following elements of this feature on nested tables using the same syntax as the standard has for multisets:</p>
<ul>
<li>
<p>The <code dir="ltr">MULTISET</code> <code dir="ltr">UNION</code>, <code dir="ltr">MULTISET</code> <code dir="ltr">INTERSECTION</code>, and <code dir="ltr">MULTISET</code> <code dir="ltr">EXCEPT</code> operators</p>
</li>
<li>
<p>The <code dir="ltr">SUBMULTISET</code> predicate</p>
</li>
<li>
<p><code dir="ltr">=</code> and <code dir="ltr">&lt;&gt;</code> predicates</p>
</li>
</ul>
<p>Oracle does not support the <code dir="ltr">FUSION</code> or <code dir="ltr">INTERSECTION</code> aggregates.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r87c1-t3" headers="r1c1-t3">
<p>S281, Nested collection types</p>
</td>
<td class="cellalignment1865" headers="r87c1-t3 r1c2-t3">
<p>Oracle permits nesting of its collection types (varray and nested table).</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r88c1-t3" headers="r1c1-t3">
<p>T041, Basic LOB data type support</p>
</td>
<td class="cellalignment1865" headers="r88c1-t3 r1c2-t3">
<p>Oracle supports the following aspects of this feature:</p>
<ul>
<li>
<p>The keywords <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB</code>, and <code dir="ltr">NCLOB</code></p>
</li>
<li>
<p>Concatenation, <code dir="ltr">UPPER</code>, <code dir="ltr">LOWER</code>, and <code dir="ltr">TRIM</code> on <code dir="ltr">CLOB</code>s</p>
</li>
</ul>
<p>Oracle provides equivalent support for the following aspects of this feature:</p>
<ul>
<li>
<p>Use <code dir="ltr">INSTR</code> instead of <code dir="ltr">POSITION</code>.</p>
</li>
<li>
<p>Use <code dir="ltr">LENGTH</code> instead of <code dir="ltr">CHAR_LENGTH</code>.</p>
</li>
<li>
<p>Use <code dir="ltr">SUBSTR</code> instead of <code dir="ltr">SUBSTRING</code>.</p>
</li>
</ul>
<p>Oracle does not support the following aspects of this feature:</p>
<ul>
<li>
<p>The keywords <code dir="ltr">BINARY</code> <code dir="ltr">LARGE</code> <code dir="ltr">OBJECT</code>, <code dir="ltr">CHARACTER</code> <code dir="ltr">LARGE</code> <code dir="ltr">OBJECT</code>, and <code dir="ltr">NATIONAL</code> <code dir="ltr">CHARACTER</code> <code dir="ltr">LARGE</code> <code dir="ltr">OBJECT</code> as synonyms for <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB</code>, and <code dir="ltr">NCLOB</code>, respectively</p>
</li>
<li>
<p>&lt;binary string literal&gt;</p>
</li>
<li>
<p>The ability to specify an upper bound on the length of a LOB or <code dir="ltr">CLOB</code></p>
</li>
<li>
<p>Concatenation of <code dir="ltr">BLOB</code>s</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r89c1-t3" headers="r1c1-t3">
<p>T042, Extended LOB support</p>
</td>
<td class="cellalignment1865" headers="r89c1-t3 r1c2-t3">
<p>Oracle fully supports the following element of this feature:</p>
<ul>
<li>
<p><code dir="ltr">TRIM</code> function on a <code dir="ltr">CLOB</code> argument</p>
</li>
</ul>
<p>Oracle provides equivalent functionality for the following elements of this feature:</p>
<ul>
<li>
<p><code dir="ltr">BLOB</code> and <code dir="ltr">CLOB</code> substring, supported using <code dir="ltr">SUBSTR</code></p>
</li>
<li>
<p><code dir="ltr">SIMILAR</code> predicate, supported using <code dir="ltr">REGEXPR_LIKE</code> to perform pattern matching with a Perl-like syntax</p>
</li>
</ul>
<p>The following elements of this feature are not supported:</p>
<ul>
<li>
<p>Comparison predicates with <code dir="ltr">BLOB</code> or <code dir="ltr">CLOB</code> operands</p>
</li>
<li>
<p><code dir="ltr">CAST</code> with a <code dir="ltr">BLOB</code> or <code dir="ltr">CLOB</code> operand</p>
</li>
<li>
<p><code dir="ltr">OVERLAY</code> (This may be emulated using <code dir="ltr">SUBSTR</code> and string concatenation.)</p>
</li>
<li>
<p><code dir="ltr">LIKE</code> predicate with <code dir="ltr">BLOB</code> or <code dir="ltr">CLOB</code> operands</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r90c1-t3" headers="r1c1-t3">
<p>T051, Row types</p>
</td>
<td class="cellalignment1865" headers="r90c1-t3 r1c2-t3">
<p>Oracle object types can be used in place of the standard's row types.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r91c1-t3" headers="r1c1-t3">
<p>T061, UCS support</p>
</td>
<td class="cellalignment1865" headers="r91c1-t3 r1c2-t3">
<p>Oracle provides equivalent functionality for the following elements of this feature:</p>
<ul>
<li>
<p>Oracle supports the keyword <code dir="ltr">CHAR</code> instead of <code dir="ltr">CHARACTERS</code>, and <code dir="ltr">BYTE</code> instead of <code dir="ltr">OCTETS</code>, in a character data type declaration.</p>
</li>
<li>
<p>The Oracle <code dir="ltr">COMPOSE</code> function is equivalent to the standard's <code dir="ltr">NORMALIZE</code> function.</p>
</li>
</ul>
<p>Oracle does not support the <code dir="ltr">IS</code> <code dir="ltr">NORMALIZED</code> predicate.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r92c1-t3" headers="r1c1-t3">
<p>T071, <code dir="ltr">BIGINT</code> data type</p>
</td>
<td class="cellalignment1865" headers="r92c1-t3 r1c2-t3">
<p>On many implementations, <code dir="ltr">BIGINT</code> refers to a binary integer type with 64 bits, which supports almost 19 decimal digits. The Oracle <code dir="ltr">NUMBER</code> type supports 39 decimal digits.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r93c1-t3" headers="r1c1-t3">
<p>T111, Updatable joins, unions and columns</p>
</td>
<td class="cellalignment1865" headers="r93c1-t3 r1c2-t3">
<p>Oracle's updatable join views are a subset of the standard's updatable join capabilities.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r94c1-t3" headers="r1c1-t3">
<p>T121, <code dir="ltr">WITH</code> (excluding <code dir="ltr">RECURSIVE</code>) in query expression</p>
</td>
<td class="cellalignment1865" headers="r94c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r95c1-t3" headers="r1c1-t3">
<p>T122, <code dir="ltr">WITH</code> (excluding <code dir="ltr">RECURSIVE</code>) in subquery</p>
</td>
<td class="cellalignment1865" headers="r95c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r96c1-t3" headers="r1c1-t3">
<p>T131, Recursive query</p>
</td>
<td class="cellalignment1865" headers="r96c1-t3 r1c2-t3">
<p>Oracle supports the use of a <code dir="ltr">WITH</code> clause element that references itself, but without the <code dir="ltr">RECURSIVE</code> keyword. Alternatively, Oracle's <code dir="ltr">START</code> <code dir="ltr">WITH</code> and <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> clauses can be used to perform many recursive queries.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r97c1-t3" headers="r1c1-t3">
<p>T132, Recursive query in subquery</p>
</td>
<td class="cellalignment1865" headers="r97c1-t3 r1c2-t3">
<p>Oracle supports the use of a <code dir="ltr">WITH</code> clause element that references itself, but without the <code dir="ltr">RECURSIVE</code> keyword. Alternatively, Oracle's <code dir="ltr">START</code> <code dir="ltr">WITH</code> and <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> clauses can be used to perform many recursive queries.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r98c1-t3" headers="r1c1-t3">
<p>T141, <code dir="ltr">SIMILAR</code> predicate</p>
</td>
<td class="cellalignment1865" headers="r98c1-t3 r1c2-t3">
<p>Oracle provides <code dir="ltr">REGEXP_LIKE</code> for pattern matching with a Perl-like syntax.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r99c1-t3" headers="r1c1-t3">
<p>T172, <code dir="ltr">AS</code> subquery clause in table definition</p>
</td>
<td class="cellalignment1865" headers="r99c1-t3 r1c2-t3">
<p>Oracle's <code dir="ltr">AS</code> subquery feature of <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> has substantially the same functionality as the standard, though there are some syntactic differences.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r100c1-t3" headers="r1c1-t3">
<p>T175, Generated columns</p>
</td>
<td class="cellalignment1865" headers="r100c1-t3 r1c2-t3">
<p>Oracle supports this feature, with the following restrictions:</p>
<ul>
<li>
<p>Generated columns are not supported in temporary tables.</p>
</li>
<li>
<p>The data type of a generated column may not be LOB or XML.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r101c1-t3" headers="r1c1-t3">
<p>T176, Sequence generator support</p>
</td>
<td class="cellalignment1865" headers="r101c1-t3 r1c2-t3">
<p>Oracle's sequences have the same capabilities as the standard's, though with different syntax.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r102c1-t3" headers="r1c1-t3">
<p>T201, Comparable data types for referential constraints</p>
</td>
<td class="cellalignment1865" headers="r102c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r103c1-t3" headers="r1c1-t3">
<p>T211, Basic trigger capability</p>
</td>
<td class="cellalignment1865" headers="r103c1-t3 r1c2-t3">
<p>Oracle's triggers differ from the standard as follows:</p>
<ul>
<li>
<p>Oracle does not provide the optional syntax <code dir="ltr">FOR</code> <code dir="ltr">EACH</code> <code dir="ltr">STATEMENT</code> for the default case, the statement trigger.</p>
</li>
<li>
<p>Oracle does not support <code dir="ltr">OLD</code> <code dir="ltr">TABLE</code> and <code dir="ltr">NEW</code> <code dir="ltr">TABLE</code>; the transition tables specified in the standard (the multiset of before and after images of affected rows) are not available.</p>
</li>
<li>
<p>The trigger body is written in PL/SQL, which is functionally equivalent to the standard's procedural language PSM, but not the same.</p>
</li>
<li>
<p>In the trigger body, the new and old transition variables are referenced beginning with a colon.</p>
</li>
<li>
<p>Oracle's row triggers are executed as the row is processed, instead of buffering them and executing all of them after processing all rows. The standard's semantics are deterministic, but Oracle's in-flight row triggers are more performant.</p>
</li>
<li>
<p>Oracle's before-row and before-statement triggers can perform DML statements, which is forbidden in the standard. However, Oracle's after-row statements cannot perform DML, while it is permitted in the standard.</p>
</li>
<li>
<p>When multiple triggers apply, the standard says they are executed in order of definition. In Oracle the execution order is nondeterministic.</p>
</li>
<li>
<p>Oracle uses the system privileges <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> and <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">TRIGGER</code> to regulate creation of triggers, instead of the standard's <code dir="ltr">TRIGGER</code> privilege, which is a table privilege.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r104c1-t3" headers="r1c1-t3">
<p>T212, Enhanced trigger capability</p>
</td>
<td class="cellalignment1865" headers="r104c1-t3 r1c2-t3">
<p>This feature permits statements triggers, which Oracle supports, as described for feature T211, Basic trigger capability.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r105c1-t3" headers="r1c1-t3">
<p>T213, <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers</p>
</td>
<td class="cellalignment1865" headers="r105c1-t3 r1c2-t3">
<p>Oracle supports <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers on views, with syntax and semantics agreeing with the standard except as noted for feature 211, Basic trigger capability.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r106c1-t3" headers="r1c1-t3">
<p>T241, <code dir="ltr">START</code> <code dir="ltr">TRANSACTION</code> statement</p>
</td>
<td class="cellalignment1865" headers="r106c1-t3 r1c2-t3">
<p>Oracle's <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement starts a transaction making it equivalent to the standard's <code dir="ltr">START</code> <code dir="ltr">TRANSACTION</code> rather than the standard's <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code>. Oracle's <code dir="ltr">READ</code> <code dir="ltr">ONLY</code> transactions are at <code dir="ltr">SERIALIZABLE</code> isolation level.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r107c1-t3" headers="r1c1-t3">
<p>T271, Savepoints</p>
</td>
<td class="cellalignment1865" headers="r107c1-t3 r1c2-t3">
<p>Oracle supports this feature, except:</p>
<ul>
<li>
<p>Oracle does not support <code dir="ltr">RELEASE</code> <code dir="ltr">SAVEPOINT</code>.</p>
</li>
<li>
<p>Oracle does not support savepoint levels.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r108c1-t3" headers="r1c1-t3">
<p>T285, Enhanced derived column names</p>
</td>
<td class="cellalignment1865" headers="r108c1-t3 r1c2-t3">
<p>This feature pertains only to derived columns in a <code dir="ltr">SELECT</code> list with no column alias and consisting of a SQL parameter reference. In that case, the column name defaults to the parameter name, the same as in the standard.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r109c1-t3" headers="r1c1-t3">
<p>T322, Overloading of SQL-invoked functions and procedures</p>
</td>
<td class="cellalignment1865" headers="r109c1-t3 r1c2-t3">
<p>Oracle supports overloading of functions and procedures. However, the rules for handling certain data type combinations are not the same as the standard. For example, the standard permits the coexistence of two functions of the same name differing only in the numeric types of the arguments, whereas Oracle does not permit this.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r110c1-t3" headers="r1c1-t3">
<p>T323, Explicit security for external routines</p>
</td>
<td class="cellalignment1865" headers="r110c1-t3 r1c2-t3">
<p>The Oracle syntax <code dir="ltr">AUTHID</code> { <code dir="ltr">CURRENT</code> <code dir="ltr">USER</code> | <code dir="ltr">DEFINER</code> } when used when creating an external function, procedure, or package is equivalent to the standard's <code dir="ltr">EXTERNAL</code> <code dir="ltr">SECURITY</code> { <code dir="ltr">DEFINER</code> | <code dir="ltr">INVOKER</code> }.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r111c1-t3" headers="r1c1-t3">
<p>T324, Explicit security for SQL routines</p>
</td>
<td class="cellalignment1865" headers="r111c1-t3 r1c2-t3">
<p>Oracle's syntax <code dir="ltr">AUTHID</code> { <code dir="ltr">CURRENT</code> <code dir="ltr">USER</code> | <code dir="ltr">DEFINER</code> } when used when creating a PL/SQL function, procedure, or package is equivalent to the standard's <code dir="ltr">SQL</code> <code dir="ltr">SECURITY</code> { <code dir="ltr">DEFINER</code> | <code dir="ltr">INVOKER</code> }.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r112c1-t3" headers="r1c1-t3">
<p>T325, Qualified SQL parameter reference</p>
</td>
<td class="cellalignment1865" headers="r112c1-t3 r1c2-t3">
<p>PL/SQL supports the use of a routine name to qualify a parameter name.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r113c1-t3" headers="r1c1-t3">
<p>T326, Table functions</p>
</td>
<td class="cellalignment1865" headers="r113c1-t3 r1c2-t3">
<p>Oracle provides equivalents for the following elements of this feature:</p>
<ul>
<li>
<p>&lt;multiset value constructor by query&gt; is supported using <code dir="ltr">CAST</code> (<code dir="ltr">MULTISET</code> (&lt;<code dir="ltr"><span class="codeinlineitalic">query expression</span></code>&gt;) <code dir="ltr">AS</code> &lt;<code dir="ltr"><span class="codeinlineitalic">nested table type</span></code>&gt;)</p>
</li>
<li>
<p>&lt;table function derived table&gt; is supported using the <code dir="ltr">TABLE</code> operator in the <code dir="ltr">FROM</code> clause with a varray or nested table as the argument</p>
</li>
<li>
<p>&lt;collection value expression&gt; is equivalent to an Oracle expression resulting in a varray or nested table</p>
</li>
<li>
<p>&lt;returns table type&gt; is equivalent to a PL/SQL function that returns a nested table</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r114c1-t3" headers="r1c1-t3">
<p>T331, Basic roles</p>
</td>
<td class="cellalignment1865" headers="r114c1-t3 r1c2-t3">
<p>Oracle supports this feature, except for <code dir="ltr">REVOKE</code> <code dir="ltr">ADMIN</code> <code dir="ltr">OPTION</code> <code dir="ltr">FOR</code> &lt;role name&gt;.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r115c1-t3" headers="r1c1-t3">
<p>T351, Bracketed comments</p>
</td>
<td class="cellalignment1865" headers="r115c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r116c1-t3" headers="r1c1-t3">
<p>T431, Extended grouping capabilities</p>
</td>
<td class="cellalignment1865" headers="r116c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r117c1-t3" headers="r1c1-t3">
<p>T432, Nested and concatenated <code dir="ltr">GROUPING</code> <code dir="ltr">SETS</code></p>
</td>
<td class="cellalignment1865" headers="r117c1-t3 r1c2-t3">
<p>Oracle supports concatenated <code dir="ltr">GROUPING</code> <code dir="ltr">SETS</code>, but not nested <code dir="ltr">GROUPING</code> <code dir="ltr">SETS</code>.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r118c1-t3" headers="r1c1-t3">
<p>T433, Multiargument function <code dir="ltr">GROUPING</code></p>
</td>
<td class="cellalignment1865" headers="r118c1-t3 r1c2-t3">
<p>The Oracle <code dir="ltr">GROUP_ID</code> function can be used to conveniently distinguish groups in a grouped query, serving the same purpose as the standard multiargument <code dir="ltr">GROUPING</code> function.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r119c1-t3" headers="r1c1-t3">
<p>T441, <code dir="ltr">ABS</code> and <code dir="ltr">MOD</code> functions</p>
</td>
<td class="cellalignment1865" headers="r119c1-t3 r1c2-t3">
<p>Oracle supports the <code dir="ltr">ABS</code> function. Oracle's <code dir="ltr">MOD</code> function is similar to the standard, though the behavior is different if the two arguments are of opposite sign.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r120c1-t3" headers="r1c1-t3">
<p>T471, Result sets return value</p>
</td>
<td class="cellalignment1865" headers="r120c1-t3 r1c2-t3">
<p>PL/SQL ref cursors provide all the functionality of the standard's result set cursors.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r121c1-t3" headers="r1c1-t3">
<p>T491, <code dir="ltr">LATERAL</code> derived tables</p>
</td>
<td class="cellalignment1865" headers="r121c1-t3 r1c2-t3">
<p>The Oracle <code dir="ltr">TABLE</code> operator in the <code dir="ltr">FROM</code> clause is equivalent to the <code dir="ltr">LATERAL</code> operator in the standard, but only for collection expressions.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r122c1-t3" headers="r1c1-t3">
<p>T501, Enhanced <code dir="ltr">EXISTS</code> predicate</p>
</td>
<td class="cellalignment1865" headers="r122c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r123c1-t3" headers="r1c1-t3">
<p>T571, Array-returning external SQL-invoked function</p>
</td>
<td class="cellalignment1865" headers="r123c1-t3 r1c2-t3">
<p>Oracle table functions returning a varray can be defined in external programming languages. When declaring such functions in SQL, use the <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> command with the <code dir="ltr">PIPELINED</code> <code dir="ltr">USING</code> clause.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r124c1-t3" headers="r1c1-t3">
<p>T572, Multiset-returning external SQL-invoked function</p>
</td>
<td class="cellalignment1865" headers="r124c1-t3 r1c2-t3">
<p>Oracle table functions returning a nested table can be defined in external programming languages. When declaring such functions in SQL, use the <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> command with the <code dir="ltr">PIPELINED</code> <code dir="ltr">USING</code> clause. In the body of the function, use the <code dir="ltr">OCITable</code> interface. The function must be invoked within the <code dir="ltr">TABLE</code> operator in the <code dir="ltr">FROM</code> clause.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r125c1-t3" headers="r1c1-t3">
<p>T581, Regular expressions substring functions</p>
</td>
<td class="cellalignment1865" headers="r125c1-t3 r1c2-t3">
<p>Oracle provides the <code dir="ltr">REGEXP_SUBSTR</code> function to perform substring operations using regular expression matching.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r126c1-t3" headers="r1c1-t3">
<p>T591, <code dir="ltr">UNIQUE</code> constraints of possibly null columns</p>
</td>
<td class="cellalignment1865" headers="r126c1-t3 r1c2-t3">
<p>Oracle permits a <code dir="ltr">UNIQUE</code> constraint on one or more nullable columns. If the <code dir="ltr">UNIQUE</code> constraint is on a single column, then the semantics are the same as the standard (the constraint permits any number of rows that are null in the designated column). If the <code dir="ltr">UNIQUE</code> constraint is on two or more columns, then the semantics are nonstandard. Oracle permits any number of rows that are null in all the designated columns. Unlike the standard, if a row is non-null in at least one of the designated columns, then another row having the same values in the non-null columns of the constraint is a constraint violation and not permitted.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r127c1-t3" headers="r1c1-t3">
<p>T611, Elementary OLAP operations</p>
</td>
<td class="cellalignment1865" headers="r127c1-t3 r1c2-t3">
<p>Oracle fully supports this feature.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r128c1-t3" headers="r1c1-t3">
<p>T612, Advanced OLAP operations</p>
</td>
<td class="cellalignment1865" headers="r128c1-t3 r1c2-t3">
<p>Oracle supports the following elements of this feature: <code dir="ltr">PERCENT_RANK</code>, <code dir="ltr">CUME_DIST</code>, <code dir="ltr">WIDTH_BUCKET</code>, hypothetical set functions, <code dir="ltr">PERCENTILE_CONT</code>, and <code dir="ltr">PERCENTILE_DISC</code>.</p>
<p>Oracle does not support the following elements of this feature:</p>
<ul>
<li>
<p>window names</p>
</li>
<li>
<p><code dir="ltr">ROW_NUMBER</code> without an <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r129c1-t3" headers="r1c1-t3">
<p>T613, Sampling</p>
</td>
<td class="cellalignment1865" headers="r129c1-t3 r1c2-t3">
<p>Oracle uses the keyword <code dir="ltr">SAMPLE</code> instead of the standard's keyword, <code dir="ltr">TABLESAMPLE</code>. Oracle uses the keyword <code dir="ltr">BLOCK</code> instead of the standard's keyword, <code dir="ltr">SYSTEM</code>. Oracle uses the absence of the keyword <code dir="ltr">BLOCK</code> to indicate a Bernoulli sampling of rows, indicated in the standard by the keyword <code dir="ltr">BERNOULLI</code>.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r130c1-t3" headers="r1c1-t3">
<p>T621, Enhanced numeric functions</p>
</td>
<td class="cellalignment1865" headers="r130c1-t3 r1c2-t3">
<p>Oracle fully supports this feature, except for the alternate spelling <code dir="ltr">CEILING</code> of the <code dir="ltr">CEIL</code> function.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r131c1-t3" headers="r1c1-t3">
<p>T641, Multiple column assignment</p>
</td>
<td class="cellalignment1865" headers="r131c1-t3 r1c2-t3">
<p>The standard syntax to assign to multiple columns is supported if the assignment source is a subquery.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r132c1-t3" headers="r1c1-t3">
<p>T652, SQL-dynamic statements in SQL routines.</p>
</td>
<td class="cellalignment1865" headers="r132c1-t3 r1c2-t3">
<p>PL/SQL supports dynamic SQL.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r133c1-t3" headers="r1c1-t3">
<p>T654, SQL-dynamic statements in external routines</p>
</td>
<td class="cellalignment1865" headers="r133c1-t3 r1c2-t3">
<p>Oracle supports dynamic SQL in embedded C, which may be used to create an external routine.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r134c1-t3" headers="r1c1-t3">
<p>T655, Cyclically dependent routines</p>
</td>
<td class="cellalignment1865" headers="r134c1-t3 r1c2-t3">
<p>PL/SQL supports recursion.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1858">
<tr>
<td class="cellalignment1865">
<table class="cellalignment1863">
<tr>
<td class="cellalignment1862"><a href="ap_standard_sql003.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1862"><a href="ap_standard_sql005.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1867">
<table class="cellalignment1861">
<tr>
<td class="cellalignment1862"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1862"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1862"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1862"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1862"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1862"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
