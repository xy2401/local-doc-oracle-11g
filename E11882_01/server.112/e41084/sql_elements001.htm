<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Data Types</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1075" />
<meta name="dcterms.created" content="2016-01-05T5:45:27Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database SQL Language Reference" />
<meta name="dcterms.identifier" content="E41084-04" />
<meta name="dcterms.isVersionOf" content="SQLRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="sql_elements.htm" title="Previous" type="text/html" />
<link rel="Next" href="sql_elements002.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41084.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">23/522</span> <!-- End Header --><a id="i45441"></a>
<div id="SQLRF0021" class="sect1"><!-- infolevel="all" infotype="General" -->
<h1 class="sect1">Data Types <a id="sthref72"></a></h1>
<p>Each value manipulated by Oracle Database has a <span class="bold">data type</span>. The data type of a value associates a fixed set of properties with the value. These properties cause Oracle to treat values of one data type differently from values of another. For example, you can add values of <code dir="ltr">NUMBER</code> data type, but not values of <code dir="ltr">RAW</code> data type.</p>
<p>When you create a table or cluster, you must specify a data type for each of its columns. When you create a procedure or stored function, you must specify a data type for each of its arguments. These data types define the domain of values that each column can contain or each argument can have. For example, <code dir="ltr">DATE</code> columns cannot accept the value February 29 (except for a leap year) or the values 2 or 'SHOE'. Each value subsequently placed in a column assumes the data type of the column. For example, if you insert <code dir="ltr">'01-JAN-98'</code> into a <code dir="ltr">DATE</code> column, then Oracle treats the <code dir="ltr">'01-JAN-98'</code> character string as a <code dir="ltr">DATE</code> value after verifying that it translates to a valid date.</p>
<p>Oracle Database provides a number of built-in data types as well as several categories for user-defined types that can be used as data types. The syntax of Oracle data types appears in the diagrams that follow. The text of this section is divided into the following sections:</p>
<ul>
<li>
<p><a href="#i54330">Oracle Built-in Data Types</a></p>
</li>
<li>
<p><a href="#i54335">ANSI, DB2, and SQL/DS Data Types</a></p>
</li>
<li>
<p><a href="#i46376">User-Defined Types</a></p>
</li>
<li>
<p><a href="#i54873">Oracle-Supplied Types</a></p>
</li>
<li>
<p><a href="sql_elements002.htm#i55214">Data Type Comparison Rules</a></p>
</li>
<li>
<p><a href="sql_elements002.htm#i46862">Data Conversion</a></p>
</li>
</ul>
<p>A data type is either scalar or nonscalar. A scalar type contains an atomic value, whereas a nonscalar (sometimes called a "collection") contains a set of values. A large object (LOB) is a special form of scalar data type representing a large scalar value of binary or character data. LOBs are subject to some restrictions that do not affect other scalar types because of their size. Those restrictions are documented in the context of the relevant SQL syntax.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABHIJHI">"Restrictions on LOB Columns"</a></div>
<p>The Oracle precompilers recognize other data types in embedded SQL programs. These data types are called <span class="bold">external data types</span> and are associated with host variables. Do not confuse built-in data types and user-defined types with external data types. For information on external data types, including how Oracle converts between them and built-in data types or user-defined types, see <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a>, and <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a>.</p>
<p class="subhead2"><a id="SQLRF50957"></a><span class="italic">datatypes</span>::=</p>
<img width="215" height="123" src="img/datatypes.gif" alt="Description of datatypes.gif follows" /><br />
<a id="sthref73" href="img_text/datatypes.htm">Description of the illustration ''datatypes.gif''</a><br />
<br />
<p>The Oracle built-in data types appear in the figures that follows. For descriptions, refer to <a href="#i54330">"Oracle Built-in Data Types"</a>.</p>
<p class="subhead2"><a id="SQLRF50958"></a><span class="italic">Oracle_built_in_datatypes</span>::=</p>
<img width="202" height="187" src="img/oracle_built_in_datatypes.gif" alt="Description of oracle_built_in_datatypes.gif follows" /><br />
<a id="sthref74" href="img_text/oracle_built_in_datatypes.htm">Description of the illustration ''oracle_built_in_datatypes.gif''</a><br />
<br />
<p class="subhead2"><a id="BABDAGJF"></a><a id="SQLRF50959"></a><span class="italic">character_datatypes</span>::=</p>
<img width="397" height="267" src="img/character_datatypes.gif" alt="Description of character_datatypes.gif follows" /><br />
<a id="sthref75" href="img_text/character_datatypes.htm">Description of the illustration ''character_datatypes.gif''</a><br />
<br />
<p class="subhead2"><a id="SQLRF50960"></a><span class="italic">number_datatypes</span>::=</p>
<img width="432" height="183" src="img/number_datatypes.gif" alt="Description of number_datatypes.gif follows" /><br />
<a id="sthref76" href="img_text/number_datatypes.htm">Description of the illustration ''number_datatypes.gif''</a><br />
<br />
<p class="subhead2"><a id="SQLRF50961"></a><span class="italic">long_and_raw_datatypes</span>::=</p>
<img width="208" height="91" src="img/long_and_raw_datatypes.gif" alt="Description of long_and_raw_datatypes.gif follows" /><br />
<a id="sthref77" href="img_text/long_and_raw_datatypes.htm">Description of the illustration ''long_and_raw_datatypes.gif''</a><br />
<br />
<p class="subhead2"><a id="SQLRF50962"></a><span class="italic">datetime_datatypes</span>::=</p>
<img width="779" height="202" src="img/datetime_datatypes.gif" alt="Description of datetime_datatypes.gif follows" /><br />
<a id="sthref78" href="img_text/datetime_datatypes.htm">Description of the illustration ''datetime_datatypes.gif''</a><br />
<br />
<p class="subhead2"><a id="SQLRF50963"></a><span class="italic">large_object_datatypes</span>::=</p>
<img width="114" height="123" src="img/large_object_datatypes.gif" alt="Description of large_object_datatypes.gif follows" /><br />
<a id="sthref79" href="img_text/large_object_datatypes.htm">Description of the illustration ''large_object_datatypes.gif''</a><br />
<br />
<p class="subhead2"><a id="SQLRF50964"></a><span class="italic">rowid_datatypes</span>::=</p>
<img width="275" height="79" src="img/rowid_datatypes.gif" alt="Description of rowid_datatypes.gif follows" /><br />
<a id="sthref80" href="img_text/rowid_datatypes.htm">Description of the illustration ''rowid_datatypes.gif''</a><br />
<br />
<p>The ANSI-supported data types appear in the figure that follows. <a href="#i54335">"ANSI, DB2, and SQL/DS Data Types"</a> discusses the mapping of ANSI-supported data types to Oracle built-in data types.</p>
<p class="subhead2"><a id="SQLRF50965"></a><a id="sthref81"></a><a id="sthref82"></a><span class="italic">ANSI_supported_datatypes</span>::=</p>
<img width="491" height="529" src="img/ansi_supported_datatypes.gif" alt="Description of ansi_supported_datatypes.gif follows" /><br />
<a id="sthref83" href="img_text/ansi_supported_datatypes.htm">Description of the illustration ''ansi_supported_datatypes.gif''</a><br />
<br />
<p>For descriptions of user-defined types, refer to <a href="#i46376">"User-Defined Types"</a>.</p>
<p>The Oracle-supplied data types appear in the figures that follows. For descriptions, refer to <a href="#i54873">"Oracle-Supplied Types"</a>.</p>
<p class="subhead2"><a id="SQLRF50966"></a><span class="italic">Oracle_supplied_types</span>::=</p>
<img width="187" height="156" src="img/oracle_supplied_types.gif" alt="Description of oracle_supplied_types.gif follows" /><br />
<a id="sthref84" href="img_text/oracle_supplied_types.htm">Description of the illustration ''oracle_supplied_types.gif''</a><br />
<br />
<p>For a description of the <code dir="ltr"><span class="codeinlineitalic">expression_filter_type</span></code>, refer to <a href="#i159408">"Expression Filter Type"</a>. Other Oracle-supplied types follow:</p>
<p class="subhead2"><a id="SQLRF50967"></a><span class="italic">any_types</span>::=</p>
<img width="162" height="91" src="img/any_types.gif" alt="Description of any_types.gif follows" /><br />
<a id="sthref85" href="img_text/any_types.htm">Description of the illustration ''any_types.gif''</a><br />
<br />
<p>For descriptions of the <code dir="ltr">Any</code> types, refer to <a href="#i107578">"Any Types"</a>.</p>
<p class="subhead2"><a id="SQLRF50968"></a><span class="italic">XML_types</span>::=</p>
<img width="124" height="58" src="img/xml_types.gif" alt="Description of xml_types.gif follows" /><br />
<a id="sthref86" href="img_text/xml_types.htm">Description of the illustration ''xml_types.gif''</a><br />
<br />
<p>For descriptions of the XML types, refer to <a href="#i160550">"XML Types"</a>.</p>
<p class="subhead2"><a id="SQLRF50969"></a><span class="italic">spatial_types</span>::=</p>
<img width="189" height="91" src="img/spatial_types.gif" alt="Description of spatial_types.gif follows" /><br />
<a id="sthref87" href="img_text/spatial_types.htm">Description of the illustration ''spatial_types.gif''</a><br />
<br />
<p>For descriptions of the spatial types, refer to <a href="#i107588">"Spatial Types"</a>.</p>
<p class="subhead2"><a id="SQLRF50970"></a><span class="italic">media_types</span>::=</p>
<img width="199" height="187" src="img/media_types.gif" alt="Description of media_types.gif follows" /><br />
<a id="sthref88" href="img_text/media_types.htm">Description of the illustration ''media_types.gif''</a><br />
<br />
<p class="subhead2"><a id="SQLRF50971"></a><span class="italic">still_image_object_types</span>::=</p>
<img width="171" height="220" src="img/still_image_object_types.gif" alt="Description of still_image_object_types.gif follows" /><br />
<a id="sthref89" href="img_text/still_image_object_types.htm">Description of the illustration ''still_image_object_types.gif''</a><br />
<br />
<p>For descriptions of the media types, refer to <a href="#i121058">"Media Types"</a>.</p>
<a id="i54330"></a>
<div id="SQLRF30020" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Oracle Built-in Data Types</h2>
<p>The table that follows summarizes Oracle built-in data types. Refer to the syntax in the preceding sections for the syntactic elements. The codes listed for the data types are used internally by Oracle Database. The data type code of a column or object attribute is returned by the <code dir="ltr">DUMP</code> function.</p>
<div id="SQLRF50972" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref90"></a><a id="BABCGCHG"></a>Table 3-1 Built-in Data Type Summary</p>
<table class="cellalignment1868" title="Built-in Data Type Summary" summary="This table presents each Oracle built-in datatype (middle column), its description (right-hand column), and its code (left-hand column) used internally by Oracle." dir="ltr">
<thead>
<tr class="cellalignment1859">
<th class="cellalignment1869" id="r1c1-t3">Code</th>
<th class="cellalignment1869" id="r1c2-t3">Data Type</th>
<th class="cellalignment1869" id="r1c3-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r2c1-t3" headers="r1c1-t3">
<p>1</p>
</td>
<td class="cellalignment1865" headers="r2c1-t3 r1c2-t3">
<p><code dir="ltr">VARCHAR2</code>(<code dir="ltr"><span class="codeinlineitalic">size</span></code> [<code dir="ltr">BYTE</code> | <code dir="ltr">CHAR</code>])</p>
</td>
<td class="cellalignment1865" headers="r2c1-t3 r1c3-t3">
<p>Variable-length character string having maximum length <code dir="ltr"><span class="codeinlineitalic">size</span></code> bytes or characters. Maximum <code dir="ltr"><span class="codeinlineitalic">size</span></code> is 4000 bytes or characters, and minimum is 1 byte or 1 character. You must specify <code dir="ltr"><span class="codeinlineitalic">size</span></code> for <code dir="ltr">VARCHAR2</code>.</p>
<p><code dir="ltr">BYTE</code> indicates that the column will have byte length semantics. <code dir="ltr">CHAR</code> indicates that the column will have character semantics.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r3c1-t3" headers="r1c1-t3">
<p>1</p>
</td>
<td class="cellalignment1865" headers="r3c1-t3 r1c2-t3">
<p><code dir="ltr">NVARCHAR2</code>(<code dir="ltr"><span class="codeinlineitalic">size</span></code>)</p>
</td>
<td class="cellalignment1865" headers="r3c1-t3 r1c3-t3">
<p>Variable-length Unicode character string having maximum length <code dir="ltr"><span class="codeinlineitalic">size</span></code> characters. The number of bytes can be up to two times <code dir="ltr"><span class="codeinlineitalic">size</span></code> for <code dir="ltr">AL16UTF16</code> encoding and three times <code dir="ltr"><span class="codeinlineitalic">size</span></code> for <code dir="ltr">UTF8</code> encoding. Maximum <code dir="ltr"><span class="codeinlineitalic">size</span></code> is determined by the national character set definition, with an upper limit of 4000 bytes. You must specify <code dir="ltr"><span class="codeinlineitalic">size</span></code> for <code dir="ltr">NVARCHAR2</code>.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r4c1-t3" headers="r1c1-t3">
<p>2</p>
</td>
<td class="cellalignment1865" headers="r4c1-t3 r1c2-t3">
<p><code dir="ltr">NUMBER</code> [ (<code dir="ltr"><span class="codeinlineitalic">p</span></code> [, <code dir="ltr"><span class="codeinlineitalic">s</span></code>]) ]</p>
</td>
<td class="cellalignment1865" headers="r4c1-t3 r1c3-t3">
<p>Number having precision <code dir="ltr"><span class="codeinlineitalic">p</span></code> and scale <code dir="ltr"><span class="codeinlineitalic">s</span></code>. The precision <code dir="ltr"><span class="codeinlineitalic">p</span></code> can range from 1 to 38. The scale <code dir="ltr"><span class="codeinlineitalic">s</span></code> can range from -84 to 127. Both precision and scale are in decimal digits. A <code dir="ltr">NUMBER</code> value requires from 1 to 22 bytes.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r5c1-t3" headers="r1c1-t3">
<p>2</p>
</td>
<td class="cellalignment1865" headers="r5c1-t3 r1c2-t3">
<p><code dir="ltr">FLOAT</code> [(<code dir="ltr"><span class="codeinlineitalic">p</span></code>)]</p>
</td>
<td class="cellalignment1865" headers="r5c1-t3 r1c3-t3">
<p>A subtype of the <code dir="ltr">NUMBER</code> data type having precision <code dir="ltr"><span class="codeinlineitalic">p</span></code>. A <code dir="ltr">FLOAT</code> value is represented internally as <code dir="ltr">NUMBER</code>. The precision <code dir="ltr"><span class="codeinlineitalic">p</span></code> can range from 1 to 126 binary digits. A <code dir="ltr">FLOAT</code> value requires from 1 to 22 bytes.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r6c1-t3" headers="r1c1-t3">
<p>8</p>
</td>
<td class="cellalignment1865" headers="r6c1-t3 r1c2-t3">
<p><code dir="ltr">LONG</code></p>
</td>
<td class="cellalignment1865" headers="r6c1-t3 r1c3-t3">
<p>Character data of variable length up to 2 gigabytes, or 2<sup>31</sup> -1 bytes. Provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r7c1-t3" headers="r1c1-t3">
<p>12</p>
</td>
<td class="cellalignment1865" headers="r7c1-t3 r1c2-t3">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment1865" headers="r7c1-t3 r1c3-t3">
<p>Valid date range from January 1, 4712 BC, to December 31, 9999 AD. The default format is determined explicitly by the <code dir="ltr">NLS_DATE_FORMAT</code> parameter or implicitly by the <code dir="ltr">NLS_TERRITORY</code> parameter. The size is fixed at 7 bytes. This data type contains the datetime fields <code dir="ltr">YEAR</code>, <code dir="ltr">MONTH</code>, <code dir="ltr">DAY</code>, <code dir="ltr">HOUR</code>, <code dir="ltr">MINUTE</code>, and <code dir="ltr">SECOND</code>. It does not have fractional seconds or a time zone.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r8c1-t3" headers="r1c1-t3">
<p>100</p>
</td>
<td class="cellalignment1865" headers="r8c1-t3 r1c2-t3">
<p><code dir="ltr">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment1865" headers="r8c1-t3 r1c3-t3">
<p>32-bit floating point number. This data type requires 4 bytes.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r9c1-t3" headers="r1c1-t3">
<p>101</p>
</td>
<td class="cellalignment1865" headers="r9c1-t3 r1c2-t3">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment1865" headers="r9c1-t3 r1c3-t3">
<p>64-bit floating point number. This data type requires 8 bytes.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r10c1-t3" headers="r1c1-t3">
<p>180</p>
</td>
<td class="cellalignment1865" headers="r10c1-t3 r1c2-t3">
<p><code dir="ltr">TIMESTAMP</code> [(<code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code>)]</p>
</td>
<td class="cellalignment1865" headers="r10c1-t3 r1c3-t3">
<p>Year, month, and day values of date, as well as hour, minute, and second values of time, where <code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> is the number of digits in the fractional part of the <code dir="ltr">SECOND</code> datetime field. Accepted values of <code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> are 0 to 9. The default is 6. The default format is determined explicitly by the <code dir="ltr">NLS_TIMESTAMP_FORMAT</code> parameter or implicitly by the <code dir="ltr">NLS_TERRITORY</code> parameter. The size is 7 or 11 bytes, depending on the precision. This data type contains the datetime fields <code dir="ltr">YEAR</code>, <code dir="ltr">MONTH</code>, <code dir="ltr">DAY</code>, <code dir="ltr">HOUR</code>, <code dir="ltr">MINUTE</code>, and <code dir="ltr">SECOND</code>. It contains fractional seconds but does not have a time zone.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r11c1-t3" headers="r1c1-t3">
<p>181</p>
</td>
<td class="cellalignment1865" headers="r11c1-t3 r1c2-t3">
<p><code dir="ltr">TIMESTAMP</code> [(<code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code>)] <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code></p>
</td>
<td class="cellalignment1865" headers="r11c1-t3 r1c3-t3">
<p>All values of <code dir="ltr">TIMESTAMP</code> as well as time zone displacement value, where <code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> is the number of digits in the fractional part of the <code dir="ltr">SECOND</code> datetime field. Accepted values are 0 to 9. The default is 6. The default format is determined explicitly by the <code dir="ltr">NLS_TIMESTAMP_FORMAT</code> parameter or implicitly by the <code dir="ltr">NLS_TERRITORY</code> parameter. The size is fixed at 13 bytes. This data type contains the datetime fields <code dir="ltr">YEAR</code>, <code dir="ltr">MONTH</code>, <code dir="ltr">DAY</code>, <code dir="ltr">HOUR</code>, <code dir="ltr">MINUTE</code>, <code dir="ltr">SECOND</code>, <code dir="ltr">TIMEZONE_HOUR</code>, and <code dir="ltr">TIMEZONE_MINUTE</code>. It has fractional seconds and an explicit time zone.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r12c1-t3" headers="r1c1-t3">
<p>231</p>
</td>
<td class="cellalignment1865" headers="r12c1-t3 r1c2-t3">
<p><code dir="ltr">TIMESTAMP</code> [(<code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code>)] <code dir="ltr">WITH</code> <code dir="ltr">LOCAL</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code></p>
</td>
<td class="cellalignment1865" headers="r12c1-t3 r1c3-t3">
<p>All values of <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>, with the following exceptions:</p>
<ul>
<li>
<p>Data is normalized to the database time zone when it is stored in the database.</p>
</li>
<li>
<p>When the data is retrieved, users see the data in the session time zone.</p>
</li>
</ul>
<p>The default format is determined explicitly by the <code dir="ltr">NLS_TIMESTAMP_FORMAT</code> parameter or implicitly by the <code dir="ltr">NLS_TERRITORY</code> parameter. The size is 7 or 11 bytes, depending on the precision.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r13c1-t3" headers="r1c1-t3">
<p>182</p>
</td>
<td class="cellalignment1865" headers="r13c1-t3 r1c2-t3">
<p><code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> [(<code dir="ltr"><span class="codeinlineitalic">year_precision</span></code>)] <code dir="ltr">TO</code> <code dir="ltr">MONTH</code></p>
</td>
<td class="cellalignment1865" headers="r13c1-t3 r1c3-t3">
<p>Stores a period of time in years and months, where <code dir="ltr"><span class="codeinlineitalic">year_precision</span></code> is the number of digits in the <code dir="ltr">YEAR</code> datetime field. Accepted values are 0 to 9. The default is 2. The size is fixed at 5 bytes.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r14c1-t3" headers="r1c1-t3">
<p>183</p>
</td>
<td class="cellalignment1865" headers="r14c1-t3 r1c2-t3">
<p><code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> [(<code dir="ltr"><span class="codeinlineitalic">day_precision</span></code>)] <code dir="ltr">TO</code> <code dir="ltr">SECOND</code> [(<code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code>)]</p>
</td>
<td class="cellalignment1865" headers="r14c1-t3 r1c3-t3">
<p>Stores a period of time in days, hours, minutes, and seconds, where</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">day_precision</span></code> is the maximum number of digits in the <code dir="ltr">DAY</code> datetime field. Accepted values are 0 to 9. The default is 2.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> is the number of digits in the fractional part of the <code dir="ltr">SECOND</code> field. Accepted values are 0 to 9. The default is 6.</p>
</li>
</ul>
<p>The size is fixed at 11 bytes.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r15c1-t3" headers="r1c1-t3">
<p>23</p>
</td>
<td class="cellalignment1865" headers="r15c1-t3 r1c2-t3">
<p><code dir="ltr">RAW</code>(<code dir="ltr"><span class="codeinlineitalic">size</span></code>)</p>
</td>
<td class="cellalignment1865" headers="r15c1-t3 r1c3-t3">
<p>Raw binary data of length <code dir="ltr"><span class="codeinlineitalic">size</span></code> bytes. Maximum <code dir="ltr"><span class="codeinlineitalic">size</span></code> is 2000 bytes. You must specify <code dir="ltr"><span class="codeinlineitalic">size</span></code> for a <code dir="ltr">RAW</code> value.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r16c1-t3" headers="r1c1-t3">
<p>24</p>
</td>
<td class="cellalignment1865" headers="r16c1-t3 r1c2-t3">
<p><code dir="ltr">LONG RAW</code></p>
</td>
<td class="cellalignment1865" headers="r16c1-t3 r1c3-t3">
<p>Raw binary data of variable length up to 2 gigabytes.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r17c1-t3" headers="r1c1-t3">
<p>69</p>
</td>
<td class="cellalignment1865" headers="r17c1-t3 r1c2-t3">
<p><code dir="ltr">ROWID</code></p>
</td>
<td class="cellalignment1865" headers="r17c1-t3 r1c3-t3">
<p>Base 64 string representing the unique address of a row in its table. This data type is primarily for values returned by the <code dir="ltr">ROWID</code> pseudocolumn.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r18c1-t3" headers="r1c1-t3">
<p>208</p>
</td>
<td class="cellalignment1865" headers="r18c1-t3 r1c2-t3">
<p><code dir="ltr">UROWID</code> [(<code dir="ltr"><span class="codeinlineitalic">size</span></code>)]</p>
</td>
<td class="cellalignment1865" headers="r18c1-t3 r1c3-t3">
<p>Base 64 string representing the logical address of a row of an index-organized table. The optional <code dir="ltr"><span class="codeinlineitalic">size</span></code> is the size of a column of type <code dir="ltr">UROWID</code>. The maximum size and default is 4000 bytes.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r19c1-t3" headers="r1c1-t3">
<p>96</p>
</td>
<td class="cellalignment1865" headers="r19c1-t3 r1c2-t3">
<p><code dir="ltr">CHAR</code> [(<code dir="ltr"><span class="codeinlineitalic">size</span></code> [<code dir="ltr">BYTE</code> | <code dir="ltr">CHAR</code>])]</p>
</td>
<td class="cellalignment1865" headers="r19c1-t3 r1c3-t3">
<p>Fixed-length character data of length <code dir="ltr"><span class="codeinlineitalic">size</span></code> bytes or characters. Maximum <code dir="ltr"><span class="codeinlineitalic">size</span></code> is 2000 bytes or characters. Default and minimum <code dir="ltr"><span class="codeinlineitalic">size</span></code> is 1 byte.</p>
<p><code dir="ltr">BYTE</code> and <code dir="ltr">CHAR</code> have the same semantics as for <code dir="ltr">VARCHAR2</code>.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r20c1-t3" headers="r1c1-t3">
<p>96</p>
</td>
<td class="cellalignment1865" headers="r20c1-t3 r1c2-t3">
<p><code dir="ltr">NCHAR</code>[(<code dir="ltr"><span class="codeinlineitalic">size</span></code>)]</p>
</td>
<td class="cellalignment1865" headers="r20c1-t3 r1c3-t3">
<p>Fixed-length character data of length <code dir="ltr"><span class="codeinlineitalic">size</span></code> characters. The number of bytes can be up to two times <code dir="ltr"><span class="codeinlineitalic">size</span></code> for <code dir="ltr">AL16UTF16</code> encoding and three times <code dir="ltr"><span class="codeinlineitalic">size</span></code> for <code dir="ltr">UTF8</code> encoding. Maximum <code dir="ltr"><span class="codeinlineitalic">size</span></code> is determined by the national character set definition, with an upper limit of 2000 bytes. Default and minimum <code dir="ltr"><span class="codeinlineitalic">size</span></code> is 1 character.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r21c1-t3" headers="r1c1-t3">
<p>112</p>
</td>
<td class="cellalignment1865" headers="r21c1-t3 r1c2-t3">
<p><code dir="ltr">CLOB</code></p>
</td>
<td class="cellalignment1865" headers="r21c1-t3 r1c3-t3">
<p>A character large object containing single-byte or multibyte characters. Both fixed-width and variable-width character sets are supported, both using the database character set. Maximum size is (4 gigabytes - 1) * (database block size).</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r22c1-t3" headers="r1c1-t3">
<p>112</p>
</td>
<td class="cellalignment1865" headers="r22c1-t3 r1c2-t3">
<p><code dir="ltr">NCLOB</code></p>
</td>
<td class="cellalignment1865" headers="r22c1-t3 r1c3-t3">
<p>A character large object containing Unicode characters. Both fixed-width and variable-width character sets are supported, both using the database national character set. Maximum size is (4 gigabytes - 1) * (database block size). Stores national character set data.</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r23c1-t3" headers="r1c1-t3">
<p>113</p>
</td>
<td class="cellalignment1865" headers="r23c1-t3 r1c2-t3">
<p><code dir="ltr">BLOB</code></p>
</td>
<td class="cellalignment1865" headers="r23c1-t3 r1c3-t3">
<p>A binary large object. Maximum size is (4 gigabytes - 1) * (database block size).</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r24c1-t3" headers="r1c1-t3">
<p>114</p>
</td>
<td class="cellalignment1865" headers="r24c1-t3 r1c2-t3">
<p><code dir="ltr">BFILE</code></p>
</td>
<td class="cellalignment1865" headers="r24c1-t3 r1c3-t3">
<p>Contains a locator to a large binary file stored outside the database. Enables byte stream I/O access to external LOBs residing on the database server. Maximum size is 4 gigabytes.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>The sections that follow describe the Oracle data types as they are stored in Oracle Database. For information on specifying these data types as literals, refer to <a href="sql_elements003.htm#i11223">"Literals"</a>.</p>
<p class="subhead2"><a id="i45625"></a><a id="SQLRF50973"></a>Character Data Types <a id="sthref91"></a></p>
<p>Character data types store character (alphanumeric) data, which are words and free-form text, in the database character set or national character set. They are less restrictive than other data types and consequently have fewer properties. For example, character columns can store all alphanumeric values, but <code dir="ltr">NUMBER</code> columns can store only numeric values.</p>
<p>Character data is stored in strings with byte values corresponding to one of the character sets, such as 7-bit ASCII or EBCDIC, specified when the database was created. Oracle Database supports both single-byte and multibyte character sets.</p>
<p>These data types are used for character data:</p>
<ul>
<li>
<p><a href="#i45647">CHAR Data Type</a></p>
</li>
<li>
<p><a href="#i45672">NCHAR Data Type</a></p>
</li>
<li>
<p><a href="#i45685">NVARCHAR2 Data Type</a></p>
</li>
<li>
<p><a href="#i45694">VARCHAR2 Data Type</a></p>
</li>
</ul>
<p>For information on specifying character data types as literals, refer to <a href="sql_elements003.htm#i42617">"Text Literals"</a>.</p>
<a id="i45647"></a>
<div id="SQLRF50974" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">CHAR Data Type <a id="sthref92"></a><a id="sthref93"></a><a id="sthref94"></a><a id="sthref95"></a><a id="sthref96"></a><a id="sthref97"></a></h3>
<p>The <code dir="ltr">CHAR</code> data type specifies a fixed-length character string. Oracle ensures that all values stored in a <code dir="ltr">CHAR</code> column have the length specified by <code dir="ltr"><span class="codeinlineitalic">size</span></code>. If you insert a value that is shorter than the column length, then Oracle blank-pads the value to column length. If you try to insert a value that is too long for the column, then Oracle returns an error.</p>
<p><a id="sthref98"></a>The default length for a <code dir="ltr">CHAR</code> column is 1 byte and the maximum allowed is 2000 bytes. A 1-byte string can be inserted into a <code dir="ltr">CHAR(10)</code> column, but the string is blank-padded to 10 bytes before it is stored.</p>
<p><a id="sthref99"></a>When you create a table with a <code dir="ltr">CHAR</code> column, by default you supply the column length in bytes. The <code dir="ltr">BYTE</code> qualifier is the same as the default. If you use the <code dir="ltr">CHAR</code> qualifier, for example <code dir="ltr">CHAR</code>(<code dir="ltr">10</code> <code dir="ltr">CHAR</code>), then you supply the column length in characters. A character is technically a code point of the database character set. Its size can range from 1 byte to 4 bytes, depending on the database character set. The <code dir="ltr">BYTE</code> and <code dir="ltr">CHAR</code> qualifiers override the semantics specified by the <code dir="ltr">NLS_LENGTH_SEMANTICS</code> parameter, which has a default of byte semantics. For performance reasons, Oracle recommends that you use the <code dir="ltr">NLS_LENGTH_SEMANTICS</code> parameter to set length semantics and that you use the <code dir="ltr">BYTE</code> and <code dir="ltr">CHAR</code> qualifiers only when necessary to override the parameter.</p>
<p>To ensure proper data conversion between databases with different character sets, you must ensure that <code dir="ltr">CHAR</code> data consists of well-formed strings.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG002" href="../../server.112/e10729/ch2charset.htm#NLSPG002"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information on character set support and <a href="sql_elements002.htm#i55214">"Data Type Comparison Rules"</a> for information on comparison semantics</div>
</div>
<!-- class="sect3" -->
<a id="i45672"></a>
<div id="SQLRF50975" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">NCHAR Data Type <a id="sthref100"></a><a id="sthref101"></a><a id="sthref102"></a></h3>
<p>The <code dir="ltr">NCHAR</code> data type is a Unicode-only data type. When you create a table with an <code dir="ltr">NCHAR</code> column, you define the column length in characters. You define the national character set when you create your database.</p>
<p><a id="sthref103"></a>The maximum length of a column is determined by the national character set definition. Width specifications of character data type <code dir="ltr">NCHAR</code> refer to the number of characters. The maximum column size allowed is 2000 bytes.</p>
<p>If you insert a value that is shorter than the column length, then Oracle blank-pads the value to column length. You cannot insert a <code dir="ltr">CHAR</code> value into an <code dir="ltr">NCHAR</code> column, nor can you insert an <code dir="ltr">NCHAR</code> value into a <code dir="ltr">CHAR</code> column.</p>
<p>The following example compares the <code dir="ltr">translated_description</code> column of the <code dir="ltr">pm.product_descriptions</code> table with a national character set string:</p>
<pre dir="ltr">
SELECT translated_description
  FROM product_descriptions
  WHERE translated_name = N'LCD Monitor 11/PM';
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG006" href="../../server.112/e10729/ch6unicode.htm#NLSPG006"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information on Unicode data type support</div>
</div>
<!-- class="sect3" -->
<a id="i45685"></a>
<div id="SQLRF50976" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">NVARCHAR2 <a id="sthref104"></a><a id="sthref105"></a><a id="sthref106"></a>Data Type <a id="sthref107"></a><a id="sthref108"></a><a id="sthref109"></a></h3>
<p>The <code dir="ltr">NVARCHAR2</code> data type is a Unicode-only data type. When you create a table with an <code dir="ltr">NVARCHAR2</code> column, you supply the maximum number of characters it can hold. Oracle subsequently stores each value in the column exactly as you specify it, provided the value does not exceed the maximum length of the column.</p>
<p><a id="sthref110"></a><a id="sthref111"></a>The maximum length of the column is determined by the national character set definition. Width specifications of character data type <code dir="ltr">NVARCHAR2</code> refer to the number of characters. The maximum column size allowed is 4000 bytes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG006" href="../../server.112/e10729/ch6unicode.htm#NLSPG006"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information on Unicode data type support.</div>
</div>
<!-- class="sect3" -->
<a id="i45694"></a>
<div id="SQLRF50977" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">VARCHAR2 Data Type <a id="sthref112"></a><a id="sthref113"></a><a id="sthref114"></a></h3>
<p>The <code dir="ltr">VARCHAR2</code> data type specifies a variable-length character string. When you create a <code dir="ltr">VARCHAR2</code> column, you supply the maximum number of bytes or characters of data that it can hold. Oracle subsequently stores each value in the column exactly as you specify it, provided the value does not exceed the maximum length of the column. If you try to insert a value that exceeds the specified length, then Oracle returns an error.</p>
<p>You must specify a maximum length for a <code dir="ltr">VARCHAR2</code> column. This maximum must be at least 1 byte, although the actual string stored is permitted to be a zero-length string (<code dir="ltr">''</code>). You can use the <code dir="ltr">CHAR</code> qualifier, for example <code dir="ltr">VARCHAR2</code>(<code dir="ltr">10</code> <code dir="ltr">CHAR</code>), to give the maximum length in characters instead of bytes. A character is technically a code point of the database character set. You can use the <code dir="ltr">BYTE</code> qualifier, for example <code dir="ltr">VARCHAR2</code>(10 <code dir="ltr">BYTE</code>), to explicitly give the maximum length in bytes. If no explicit qualifier is included in a column or attribute definition when a database object with this column or attribute is created, then the length semantics are determined by the value of the <code dir="ltr">NLS_LENGTH_SEMANTICS</code> parameter of the session creating the object. Independently of the maximum length in characters, the length of <code dir="ltr">VARCHAR2</code> data cannot exceed 4000 bytes. Oracle compares <code dir="ltr">VARCHAR2</code> values using nonpadded comparison semantics.</p>
<p>To ensure proper data conversion between databases with different character sets, you must ensure that <code dir="ltr">VARCHAR2</code> data consists of well-formed strings. See <a class="olink NLSPG002" href="../../server.112/e10729/ch2charset.htm#NLSPG002"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information on character set support.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="sql_elements002.htm#i55214">"Data Type Comparison Rules"</a> for information on comparison semantics</div>
</div>
<!-- class="sect3" -->
<div id="SQLRF50978" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref115"></a>
<h3 class="sect3">VARCHAR Data Type <a id="sthref116"></a><a id="sthref117"></a></h3>
<p>Do not use the <code dir="ltr">VARCHAR</code> data type. Use the <code dir="ltr">VARCHAR2</code> data type instead. Although the <code dir="ltr">VARCHAR</code> data type is currently synonymous with <code dir="ltr">VARCHAR2</code>, the <code dir="ltr">VARCHAR</code> data type is scheduled to be redefined as a separate data type used for variable-length character strings compared with different comparison semantics.</p>
<p class="subhead2"><a id="i45721"></a><a id="SQLRF50979"></a>Numeric Data Types</p>
<p>The Oracle Database numeric data types store positive and negative fixed and floating-point numbers, zero, infinity, and values that are the undefined result of an operation&mdash;"not a number" or <code dir="ltr">NAN</code>. For information on specifying numeric data types as literals, refer to <a href="sql_elements003.htm#i139891">"Numeric Literals"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="SQLRF00222" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref118"></a>
<h3 class="sect3">NUMBER Data Type <a id="sthref119"></a><a id="sthref120"></a><a id="sthref121"></a><a id="sthref122"></a><a id="sthref123"></a><a id="sthref124"></a><a id="sthref125"></a></h3>
<p>The <code dir="ltr">NUMBER</code> data type stores zero as well as positive and negative fixed numbers with absolute values from 1.0 x 10<sup>-130</sup> to but not including 1.0 x 10<sup>126</sup>. If you specify an arithmetic expression whose value has an absolute value greater than or equal to 1.0 x 10<sup>126</sup>, then Oracle returns an error. Each <code dir="ltr">NUMBER</code> value requires from 1 to 22 bytes.</p>
<p>Specify a fixed-point number using the following form:</p>
<pre dir="ltr">
NUMBER(p,s)
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">p</span></code> is the <span class="bold">precision</span>, or the maximum number of significant decimal digits, where the most significant digit is the left-most nonzero digit, and the least significant digit is the right-most known digit. Oracle guarantees the portability of numbers with precision of up to 20 base-100 digits, which is equivalent to 39 or 40 decimal digits depending on the position of the decimal point.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">s</span></code> is the <span class="bold">scale</span>, or the number of digits from the decimal point to the least significant digit. The scale can range from -84 to 127.</p>
<ul>
<li>
<p>Positive scale is the number of significant digits to the right of the decimal point to and including the least significant digit.</p>
</li>
<li>
<p>Negative scale is the number of significant digits to the left of the decimal point, to but not including the least significant digit. For negative scale the least significant digit is on the left side of the decimal point, because the actual data is rounded to the specified number of places to the left of the decimal point. For example, a specification of (10,-2) means to round to hundreds.</p>
</li>
</ul>
</li>
</ul>
<p><a id="sthref126"></a>Scale can be greater than precision, most commonly when <code dir="ltr">e</code> notation is used. When scale is greater than precision, the precision specifies the maximum number of significant digits to the right of the decimal point. For example, a column defined as <code dir="ltr">NUMBER(4,5)</code> requires a zero for the first digit after the decimal point and rounds all values past the fifth digit after the decimal point.</p>
<p><a id="sthref127"></a>It is good practice to specify the scale and precision of a fixed-point number column for extra integrity checking on input. Specifying scale and precision does not force all values to a fixed length. If a value exceeds the precision, then Oracle returns an error. If a value exceeds the scale, then Oracle rounds it.</p>
<p>Specify an integer using the following form:</p>
<pre dir="ltr">
NUMBER(p)
</pre>
<p>This represents a fixed-point number with precision <code dir="ltr"><span class="codeinlineitalic">p</span></code> and scale 0 and is equivalent to <code dir="ltr">NUMBER(p,0)</code>.</p>
<p>Specify a floating-point number using the following form:</p>
<pre dir="ltr">
NUMBER 
</pre>
<p>The absence of precision and scale designators specifies the maximum range and precision for an Oracle number.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i140176">"Floating-Point Numbers"</a></div>
<p><a href="#g196646">Table 3-2</a> show how Oracle stores data using different precisions and scales.</p>
<div id="SQLRF50980" class="tblhruleformal">
<p class="titleintable"><a id="sthref128"></a><a id="g196646"></a>Table 3-2 Storage of Scale and Precision</p>
<table class="cellalignment1868" title="Storage of Scale and Precision" summary="The first column repeats the number 7456123.89 in each row. The second column lists the various ways of specifying the NUMBER datatype. The third column shows how the number is stored depending on how the NUMBER datatype is specified." dir="ltr">
<thead>
<tr class="cellalignment1859">
<th class="cellalignment1869" id="r1c1-t9">Actual Data</th>
<th class="cellalignment1869" id="r1c2-t9">Specified As</th>
<th class="cellalignment1869" id="r1c3-t9">Stored As</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r2c1-t9" headers="r1c1-t9">
<p>123.89</p>
</td>
<td class="cellalignment1865" headers="r2c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER</code></p>
</td>
<td class="cellalignment1865" headers="r2c1-t9 r1c3-t9">
<p>123.89</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r3c1-t9" headers="r1c1-t9">
<p>123.89</p>
</td>
<td class="cellalignment1865" headers="r3c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(3)</code></p>
</td>
<td class="cellalignment1865" headers="r3c1-t9 r1c3-t9">
<p>124</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r4c1-t9" headers="r1c1-t9">
<p>123.89</p>
</td>
<td class="cellalignment1865" headers="r4c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(3,2)</code></p>
</td>
<td class="cellalignment1865" headers="r4c1-t9 r1c3-t9">
<p>exceeds precision</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r5c1-t9" headers="r1c1-t9">
<p>123.89</p>
</td>
<td class="cellalignment1865" headers="r5c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(4,2)</code></p>
</td>
<td class="cellalignment1865" headers="r5c1-t9 r1c3-t9">
<p>exceeds precision</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r6c1-t9" headers="r1c1-t9">
<p>123.89</p>
</td>
<td class="cellalignment1865" headers="r6c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(5,2)</code></p>
</td>
<td class="cellalignment1865" headers="r6c1-t9 r1c3-t9">
<p>123.89</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r7c1-t9" headers="r1c1-t9">
<p>123.89</p>
</td>
<td class="cellalignment1865" headers="r7c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(6,1)</code></p>
</td>
<td class="cellalignment1865" headers="r7c1-t9 r1c3-t9">
<p>123.9</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r8c1-t9" headers="r1c1-t9">
<p>123.89</p>
</td>
<td class="cellalignment1865" headers="r8c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(6,-2)</code></p>
</td>
<td class="cellalignment1865" headers="r8c1-t9 r1c3-t9">
<p>100</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r9c1-t9" headers="r1c1-t9">
<p>.01234</p>
</td>
<td class="cellalignment1865" headers="r9c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(4,5)</code></p>
</td>
<td class="cellalignment1865" headers="r9c1-t9 r1c3-t9">
<p>.01234</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r10c1-t9" headers="r1c1-t9">
<p>.00012</p>
</td>
<td class="cellalignment1865" headers="r10c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(4,5)</code></p>
</td>
<td class="cellalignment1865" headers="r10c1-t9 r1c3-t9">
<p>.00012</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r11c1-t9" headers="r1c1-t9">
<p>.000127</p>
</td>
<td class="cellalignment1865" headers="r11c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(4,5)</code></p>
</td>
<td class="cellalignment1865" headers="r11c1-t9 r1c3-t9">
<p>.00013</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r12c1-t9" headers="r1c1-t9">
<p>.0000012</p>
</td>
<td class="cellalignment1865" headers="r12c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(2,7)</code></p>
</td>
<td class="cellalignment1865" headers="r12c1-t9 r1c3-t9">
<p>.0000012</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r13c1-t9" headers="r1c1-t9">
<p>.00000123</p>
</td>
<td class="cellalignment1865" headers="r13c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(2,7)</code></p>
</td>
<td class="cellalignment1865" headers="r13c1-t9 r1c3-t9">
<p>.0000012</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r14c1-t9" headers="r1c1-t9">
<p>1.2e-4</p>
</td>
<td class="cellalignment1865" headers="r14c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(2,5)</code></p>
</td>
<td class="cellalignment1865" headers="r14c1-t9 r1c3-t9">
<p>0.00012</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r15c1-t9" headers="r1c1-t9">
<p>1.2e-5</p>
</td>
<td class="cellalignment1865" headers="r15c1-t9 r1c2-t9">
<p><code dir="ltr">NUMBER(2,5)</code></p>
</td>
<td class="cellalignment1865" headers="r15c1-t9 r1c3-t9">
<p>0.00001</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect3" -->
<div id="SQLRF50981" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref129"></a>
<h3 class="sect3">FLOAT Data Type</h3>
<p>The <code dir="ltr">FLOAT</code> data type is a subtype of <code dir="ltr">NUMBER</code>. It can be specified with or without precision, which has the same definition it has for <code dir="ltr">NUMBER</code> and can range from 1 to 126. Scale cannot be specified, but is interpreted from the data. Each <code dir="ltr">FLOAT</code> value requires from 1 to 22 bytes.</p>
<p>To convert from binary to decimal precision, multiply <code dir="ltr"><span class="codeinlineitalic">n</span></code> by 0.30103. To convert from decimal to binary precision, multiply the decimal precision by 3.32193. The maximum of 126 digits of binary precision is roughly equivalent to 38 digits of decimal precision.</p>
<p>The difference between <code dir="ltr">NUMBER</code> and <code dir="ltr">FLOAT</code> is best illustrated by example. In the following example the same values are inserted into <code dir="ltr">NUMBER</code> and <code dir="ltr">FLOAT</code> columns:</p>
<pre dir="ltr">
CREATE TABLE test (col1 NUMBER(5,2), col2 FLOAT(5));

INSERT INTO test VALUES (1.23, 1.23);
INSERT INTO test VALUES (7.89, 7.89);
INSERT INTO test VALUES (12.79, 12.79);
INSERT INTO test VALUES (123.45, 123.45);

SELECT * FROM test;

      COL1       COL2
---------- ----------
      1.23        1.2
      7.89        7.9
     12.79         13
    123.45        120
</pre>
<p>In this example, the <code dir="ltr">FLOAT</code> value returned cannot exceed 5 binary digits. The largest decimal number that can be represented by 5 binary digits is 31. The last row contains decimal values that exceed 31. Therefore, the <code dir="ltr">FLOAT</code> value must be truncated so that its significant digits do not require more than 5 binary digits. Thus 123.45 is rounded to 120, which has only two significant decimal digits, requiring only 4 binary digits.</p>
<p>Oracle Database uses the Oracle <code dir="ltr">FLOAT</code> data type internally when converting ANSI <code dir="ltr">FLOAT</code> data. Oracle <code dir="ltr">FLOAT</code> is available for you to use, but Oracle recommends that you use the <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> data types instead, as they are more robust. Refer to <a href="#i140176">"Floating-Point Numbers"</a> for more information.</p>
</div>
<!-- class="sect3" -->
<a id="i140176"></a>
<div id="SQLRF00209" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Floating-Point Numbers <a id="sthref130"></a><a id="sthref131"></a></h3>
<p>Floating-point numbers can have a decimal point anywhere from the first to the last digit or can have no decimal point at all. An exponent may optionally be used following the number to increase the range, for example, 1.777 e<sup>-20</sup>. A scale value is not applicable to floating-point numbers, because the number of digits that can appear after the decimal point is not restricted.</p>
<p>Binary floating-point numbers differ from <code dir="ltr">NUMBER</code> in the way the values are stored internally by Oracle Database. Values are stored using decimal precision for <code dir="ltr">NUMBER</code>. All literals that are within the range and precision supported by <code dir="ltr">NUMBER</code> are stored exactly as <code dir="ltr">NUMBER</code>. Literals are stored exactly because literals are expressed using decimal precision (the digits 0 through 9). Binary floating-point numbers are stored using binary precision (the digits 0 and 1). Such a storage scheme cannot represent all values using decimal precision exactly. Frequently, the error that occurs when converting a value from decimal to binary precision is undone when the value is converted back from binary to decimal precision. The literal 0.1 is such an example.</p>
<p>Oracle Database provides two numeric data types exclusively for floating-point numbers:</p>
<a id="i140620"></a>
<div id="SQLRF50982" class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4">BINARY_FLOAT</h4>
<p><code dir="ltr">BINARY_FLOAT</code> is a 32-bit, single-precision floating-point number data type. Each <code dir="ltr">BINARY_FLOAT</code> value requires 4 bytes.</p>
</div>
<!-- class="sect4" -->
<a id="i140621"></a>
<div id="SQLRF50983" class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4">BINARY_DOUBLE</h4>
<p><code dir="ltr">BINARY_DOUBLE</code> is a 64-bit, double-precision floating-point number data type. Each <code dir="ltr">BINARY_DOUBLE</code> value requires 8 bytes.</p>
<p>In a <code dir="ltr">NUMBER</code> column, floating point numbers have decimal precision. In a <code dir="ltr">BINARY_FLOAT</code> or <code dir="ltr">BINARY_DOUBLE</code> column, floating-point numbers have binary precision. The binary floating-point numbers support the special values infinity and <code dir="ltr">NaN</code> (not a number).</p>
<p>You can specify floating-point numbers within the limits listed in <a href="#g195556">Table 3-3</a>. The format for specifying floating-point numbers is defined in <a href="sql_elements003.htm#i139891">"Numeric Literals"</a>.</p>
<div id="SQLRF50984" class="tblformal">
<p class="titleintable"><a id="sthref132"></a><a id="g195556"></a>Table 3-3 Floating Point Number Limits</p>
<table class="cellalignment1870" title="Floating Point Number Limits" summary="The first column lists the value categories and the second and third columns show the values of that category for binary-float and binary-double numbers, respectively." dir="ltr">
<thead>
<tr class="cellalignment1859">
<th class="cellalignment1869" id="r1c1-t10">Value</th>
<th class="cellalignment1869" id="r1c2-t10">BINARY_FLOAT</th>
<th class="cellalignment1869" id="r1c3-t10">BINARY_DOUBLE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r2c1-t10" headers="r1c1-t10">
<p>Maximum positive finite value</p>
</td>
<td class="cellalignment1865" headers="r2c1-t10 r1c2-t10">
<p>3.40282E+38F</p>
</td>
<td class="cellalignment1865" headers="r2c1-t10 r1c3-t10">
<p>1.79769313486231E+308</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r3c1-t10" headers="r1c1-t10">
<p>Minimum positive finite value</p>
</td>
<td class="cellalignment1865" headers="r3c1-t10 r1c2-t10">
<p>1.17549E-38F</p>
</td>
<td class="cellalignment1865" headers="r3c1-t10 r1c3-t10">
<p>2.22507485850720E-308</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a id="SQLRF50985"></a><span class="subhead3">IEEE754 Conformance <a id="sthref133"></a><a id="sthref134"></a>&nbsp;</span>The Oracle implementation of floating-point data types conforms substantially with the Institute of Electrical and Electronics Engineers (IEEE) Standard for Binary Floating-Point Arithmetic, IEEE Standard 754-1985 (IEEE754). The floating-point data types conform to IEEE754 in the following areas:</p>
<ul>
<li>
<p>The SQL function <code dir="ltr">SQRT</code> implements square root. See <a href="functions168.htm#i1009289">SQRT</a>.</p>
</li>
<li>
<p>The SQL function <code dir="ltr">REMAINDER</code> implements remainder. See <a href="functions152.htm#i1300767">REMAINDER</a>.</p>
</li>
<li>
<p>Arithmetic operators conform. See <a href="operators002.htm#i1028549">"Arithmetic Operators"</a>.</p>
</li>
<li>
<p>Comparison operators conform, except for comparisons with <code dir="ltr">NaN</code>. Oracle orders <code dir="ltr">NaN</code> greatest with respect to all other values, and evaluates <code dir="ltr">NaN</code> equal to <code dir="ltr">NaN</code>. See <a href="conditions003.htm#i1052323">"Floating-Point Conditions"</a>.</p>
</li>
<li>
<p>Conversion operators conform. See <a href="functions002.htm#i88892">"Conversion Functions"</a>.</p>
</li>
<li>
<p>The default rounding mode is supported.</p>
</li>
<li>
<p>The default exception handling mode is supported.</p>
</li>
<li>
<p>The special values <code dir="ltr">INF</code>, -<code dir="ltr">INF</code>, and <code dir="ltr">NaN</code> are supported. See <a href="conditions003.htm#i1052323">"Floating-Point Conditions"</a>.</p>
</li>
<li>
<p>Rounding of <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> values to integer-valued <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> values is provided by the SQL functions <code dir="ltr">ROUND</code>, <code dir="ltr">TRUNC</code>, <code dir="ltr">CEIL</code>, and <code dir="ltr">FLOOR</code>.</p>
</li>
<li>
<p>Rounding of <code dir="ltr">BINARY_FLOAT</code>/<code dir="ltr">BINARY_DOUBLE</code> to decimal and decimal to <code dir="ltr">BINARY_FLOAT</code>/<code dir="ltr">BINARY_DOUBLE</code> is provided by the SQL functions <code dir="ltr">TO_CHAR</code>, <code dir="ltr">TO_NUMBER</code>, <code dir="ltr">TO_NCHAR</code>, <code dir="ltr">TO_BINARY_FLOAT</code>, <code dir="ltr">TO_BINARY_DOUBLE</code>, and <code dir="ltr">CAST</code>.</p>
</li>
</ul>
<p>The floating-point data types do not conform to IEEE754 in the following areas:</p>
<ul>
<li>
<p>-0 is coerced to +0.</p>
</li>
<li>
<p>Comparison with <code dir="ltr">NaN</code> is not supported.</p>
</li>
<li>
<p>All <code dir="ltr">NaN</code> values are coerced to either <code dir="ltr">BINARY_FLOAT_NAN</code> or <code dir="ltr">BINARY_DOUBLE_NAN</code>.</p>
</li>
<li>
<p>Non-default rounding modes are not supported.</p>
</li>
<li>
<p>Non-default exception handling mode are not supported.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i156865"></a>
<div id="SQLRF50986" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Numeric Precedence <a id="sthref135"></a><a id="sthref136"></a></h3>
<p><span class="bold">Numeric precedence</span> determines, for operations that support numeric data types, the data type Oracle uses if the arguments to the operation have different data types. <code dir="ltr">BINARY_DOUBLE</code> has the highest numeric precedence, followed by <code dir="ltr">BINARY_FLOAT</code>, and finally by <code dir="ltr">NUMBER</code>. Therefore, in any operation on multiple numeric values:</p>
<ul>
<li>
<p>If any of the operands is <code dir="ltr">BINARY_DOUBLE</code>, then Oracle attempts to convert all the operands implicitly to <code dir="ltr">BINARY_DOUBLE</code> before performing the operation.</p>
</li>
<li>
<p>If none of the operands is <code dir="ltr">BINARY_DOUBLE</code> but any of the operands is <code dir="ltr">BINARY_FLOAT</code>, then Oracle attempts to convert all the operands implicitly to <code dir="ltr">BINARY_FLOAT</code> before performing the operation.</p>
</li>
<li>
<p>Otherwise, Oracle attempts to convert all the operands to <code dir="ltr">NUMBER</code> before performing the operation.</p>
</li>
</ul>
<p>If any implicit conversion is needed and fails, then the operation fails. Refer to <a href="sql_elements002.htm#g195937">Table 3-10, "Implicit Type Conversion Matrix"</a> for more information on implicit conversion.</p>
<p>In the context of other data types, numeric data types have lower precedence than the datetime/interval data types and higher precedence than character and all other data types.</p>
<p class="subhead2"><a id="i45885"></a><a id="SQLRF00201"></a>LONG Data Type <a id="sthref137"></a><a id="sthref138"></a><a id="sthref139"></a><a id="sthref140"></a><a id="sthref141"></a></p>
<p><a id="sthref142"></a><a id="sthref143"></a>Do not create tables with <code dir="ltr">LONG</code> columns. Use LOB columns (<code dir="ltr">CLOB</code>, <code dir="ltr">NCLOB</code>, <code dir="ltr">BLOB</code>) instead. <code dir="ltr">LONG</code> columns are supported only for backward compatibility.</p>
<p><code dir="ltr">LONG</code> columns store variable-length character strings containing up to 2 gigabytes -1, or 2<sup>31</sup>-1 bytes. <code dir="ltr">LONG</code> columns have many of the characteristics of <code dir="ltr">VARCHAR2</code> columns. You can use <code dir="ltr">LONG</code> columns to store long text strings. The length of <code dir="ltr">LONG</code> values may be limited by the memory available on your computer. <code dir="ltr">LONG</code> literals are formed as described for <a href="sql_elements003.htm#i42617">"Text Literals"</a>.</p>
<p>Oracle also recommends that you convert existing <code dir="ltr">LONG</code> columns to LOB columns. LOB columns are subject to far fewer restrictions than <code dir="ltr">LONG</code> columns. Further, LOB functionality is enhanced in every release, whereas <code dir="ltr">LONG</code> functionality has been static for several releases. See the <code dir="ltr"><span class="codeinlineitalic">modify_col_properties</span></code> clause of <a href="statements_3001.htm#CJAHHIBI">ALTER TABLE</a> and <a href="functions205.htm#i79464">TO_LOB</a> for more information on converting <code dir="ltr">LONG</code> columns to LOB.</p>
<p><a id="sthref144"></a>You can reference <code dir="ltr">LONG</code> columns in SQL statements in these places:</p>
<ul>
<li>
<p><code dir="ltr">SELECT</code> lists</p>
</li>
<li>
<p><code dir="ltr">SET</code> clauses of <code dir="ltr">UPDATE</code> statements</p>
</li>
<li>
<p><code dir="ltr">VALUES</code> clauses of <code dir="ltr">INSERT</code> statements</p>
</li>
</ul>
<p><a id="sthref145"></a>The use of <code dir="ltr">LONG</code> values is subject to these restrictions:</p>
<ul>
<li>
<p>A table can contain only one <code dir="ltr">LONG</code> column.</p>
</li>
<li>
<p>You cannot create an object type with a <code dir="ltr">LONG</code> attribute.</p>
</li>
<li>
<p><code dir="ltr">LONG</code> columns cannot appear in <code dir="ltr">WHERE</code> clauses or in integrity constraints (except that they can appear in <code dir="ltr">NULL</code> and <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraints).</p>
</li>
<li>
<p><code dir="ltr">LONG</code> columns cannot be indexed.</p>
</li>
<li>
<p><code dir="ltr">LONG</code> data cannot be specified in regular expressions.</p>
</li>
<li>
<p>A stored function cannot return a <code dir="ltr">LONG</code> value.</p>
</li>
<li>
<p>You can declare a variable or argument of a PL/SQL program unit using the <code dir="ltr">LONG</code> data type. However, you cannot then call the program unit from SQL.</p>
</li>
<li>
<p>Within a single SQL statement, all <code dir="ltr">LONG</code> columns, updated tables, and locked tables must be located on the same database.</p>
</li>
<li>
<p><code dir="ltr">LONG</code> and <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> columns cannot be used in distributed SQL statements and cannot be replicated.</p>
</li>
<li>
<p>If a table has both <code dir="ltr">LONG</code> and LOB columns, then you cannot bind more than 4000 bytes of data to both the <code dir="ltr">LONG</code> and LOB columns in the same SQL statement. However, you can bind more than 4000 bytes of data to either the <code dir="ltr">LONG</code> or the LOB column.</p>
</li>
</ul>
<p>In addition, <code dir="ltr">LONG</code> columns cannot appear in these parts of SQL statements:</p>
<ul>
<li>
<p><code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clauses, <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clauses, or <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> clauses or with the <code dir="ltr">DISTINCT</code> operator in <code dir="ltr">SELECT</code> statements</p>
</li>
<li>
<p>The <code dir="ltr">UNIQUE</code> operator of a <code dir="ltr">SELECT</code> statement</p>
</li>
<li>
<p>The column list of a <code dir="ltr">CREATE</code> <code dir="ltr">CLUSTER</code> statement</p>
</li>
<li>
<p>The <code dir="ltr">CLUSTER</code> clause of a <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement</p>
</li>
<li>
<p>SQL built-in functions, expressions, or conditions</p>
</li>
<li>
<p><code dir="ltr">SELECT</code> lists of queries containing <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clauses</p>
</li>
<li>
<p><code dir="ltr">SELECT</code> lists of subqueries or queries combined by the <code dir="ltr">UNION</code>, <code dir="ltr">INTERSECT</code>, or <code dir="ltr">MINUS</code> set operators</p>
</li>
<li>
<p><code dir="ltr">SELECT</code> lists of <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">AS</code> <code dir="ltr">SELECT</code> statements</p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">MOVE</code> statements</p>
</li>
<li>
<p><code dir="ltr">SELECT</code> lists in subqueries in <code dir="ltr">INSERT</code> statements</p>
</li>
</ul>
<p><a id="sthref146"></a>Triggers can use the <code dir="ltr">LONG</code> data type in the following manner:</p>
<ul>
<li>
<p>A SQL statement within a trigger can insert data into a <code dir="ltr">LONG</code> column.</p>
</li>
<li>
<p>If data from a <code dir="ltr">LONG</code> column can be converted to a constrained data type (such as <code dir="ltr">CHAR</code> and <code dir="ltr">VARCHAR2</code>), then a <code dir="ltr">LONG</code> column can be referenced in a SQL statement within a trigger.</p>
</li>
<li>
<p>Variables in triggers cannot be declared using the <code dir="ltr">LONG</code> data type.</p>
</li>
<li>
<p>:<code dir="ltr">NEW</code> and :<code dir="ltr">OLD</code> cannot be used with <code dir="ltr">LONG</code> columns.</p>
</li>
</ul>
<p>You can use Oracle Call Interface functions to retrieve a portion of a <code dir="ltr">LONG</code> value from the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI16272" href="../../appdev.112/e10646/oci03typ.htm#LNOCI16272"><span class="italic">Oracle Call Interface Programmer's Guide</span></a></div>
<p class="subhead2"><a id="BABIHEID"></a><a id="SQLRF00200"></a>Datetime and Interval Data Types <a id="sthref147"></a><a id="sthref148"></a><a id="sthref149"></a><a id="sthref150"></a></p>
<p>The datetime data types are <code dir="ltr">DATE</code>, <code dir="ltr">TIMESTAMP</code>, <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>, and <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">LOCAL</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>. Values of datetime data types are sometimes called <span class="bold">datetimes</span>. The interval data types are <code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code> and <code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code>. Values of interval data types are sometimes called <span class="bold">intervals</span>. For information on expressing datetime and interval values as literals, refer to <a href="sql_elements003.htm#BABGIGCJ">"Datetime Literals"</a> and <a href="sql_elements003.htm#i38598">"Interval Literals"</a>.</p>
<p>Both datetimes and intervals are made up of fields. The values of these fields determine the value of the data type. <a href="#BABFDAEI">Table 3-4</a> lists the datetime fields and their possible values for datetimes and intervals.</p>
<p>To avoid unexpected results in your DML operations on datetime data, you can verify the database and session time zones by querying the built-in SQL functions <code dir="ltr">DBTIMEZONE</code> and <code dir="ltr">SESSIONTIMEZONE</code>. If the time zones have not been set manually, then Oracle Database uses the operating system time zone by default. If the operating system time zone is not a valid Oracle time zone, then Oracle uses UTC as the default value.</p>
<div id="SQLRF50987" class="tblhruleformalwidekey">
<p class="titleintable"><a id="sthref151"></a><a id="BABFDAEI"></a>Table 3-4 Datetime Fields and Values</p>
<table class="cellalignment1868" title="Datetime Fields and Values" summary="The first column holds the datetime fields. The second and third columns show the valid values for those fields in datetimes and intervals, respectively." dir="ltr">
<thead>
<tr class="cellalignment1859">
<th class="cellalignment1869" id="r1c1-t12">Datetime Field</th>
<th class="cellalignment1869" id="r1c2-t12">Valid Values for Datetime</th>
<th class="cellalignment1869" id="r1c3-t12">Valid Values for INTERVAL</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r2c1-t12" headers="r1c1-t12">
<p><code dir="ltr">YEAR</code></p>
</td>
<td class="cellalignment1865" headers="r2c1-t12 r1c2-t12">
<p>-4712 to 9999 (excluding year 0)</p>
</td>
<td class="cellalignment1865" headers="r2c1-t12 r1c3-t12">
<p>Any positive or negative integer</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r3c1-t12" headers="r1c1-t12">
<p><code dir="ltr">MONTH</code></p>
</td>
<td class="cellalignment1865" headers="r3c1-t12 r1c2-t12">
<p>01 to 12</p>
</td>
<td class="cellalignment1865" headers="r3c1-t12 r1c3-t12">
<p>0 to 11</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r4c1-t12" headers="r1c1-t12">
<p><code dir="ltr">DAY</code></p>
</td>
<td class="cellalignment1865" headers="r4c1-t12 r1c2-t12">
<p>01 to 31 (limited by the values of <code dir="ltr">MONTH</code> and <code dir="ltr">YEAR</code>, according to the rules of the current NLS calendar parameter)</p>
</td>
<td class="cellalignment1865" headers="r4c1-t12 r1c3-t12">
<p>Any positive or negative integer</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r5c1-t12" headers="r1c1-t12">
<p><code dir="ltr">HOUR</code></p>
</td>
<td class="cellalignment1865" headers="r5c1-t12 r1c2-t12">
<p>00 to 23</p>
</td>
<td class="cellalignment1865" headers="r5c1-t12 r1c3-t12">
<p>0 to 23</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r6c1-t12" headers="r1c1-t12">
<p><code dir="ltr">MINUTE</code></p>
</td>
<td class="cellalignment1865" headers="r6c1-t12 r1c2-t12">
<p>00 to 59</p>
</td>
<td class="cellalignment1865" headers="r6c1-t12 r1c3-t12">
<p>0 to 59</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r7c1-t12" headers="r1c1-t12">
<p><code dir="ltr">SECOND</code></p>
</td>
<td class="cellalignment1865" headers="r7c1-t12 r1c2-t12">
<p>00 to 59.9(n), where 9(n) is the precision of time fractional seconds. The 9(n) portion is not applicable for <code dir="ltr">DATE</code>.</p>
</td>
<td class="cellalignment1865" headers="r7c1-t12 r1c3-t12">
<p>0 to 59.9(n), where 9(n) is the precision of interval fractional seconds</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r8c1-t12" headers="r1c1-t12">
<p><code dir="ltr">TIMEZONE_HOUR</code></p>
</td>
<td class="cellalignment1865" headers="r8c1-t12 r1c2-t12">
<p>-12 to 14 (This range accommodates daylight saving time changes.) Not applicable for <code dir="ltr">DATE</code> or <code dir="ltr">TIMESTAMP</code>.</p>
</td>
<td class="cellalignment1865" headers="r8c1-t12 r1c3-t12">
<p>Not applicable</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r9c1-t12" headers="r1c1-t12">
<p><code dir="ltr">TIMEZONE_MINUTE</code></p>
<p>(See note at end of table)</p>
</td>
<td class="cellalignment1865" headers="r9c1-t12 r1c2-t12">
<p>00 to 59. Not applicable for <code dir="ltr">DATE</code> or <code dir="ltr">TIMESTAMP</code>.</p>
</td>
<td class="cellalignment1865" headers="r9c1-t12 r1c3-t12">
<p>Not applicable</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r10c1-t12" headers="r1c1-t12">
<p><code dir="ltr">TIMEZONE_REGION</code></p>
</td>
<td class="cellalignment1865" headers="r10c1-t12 r1c2-t12">
<p>Query the <code dir="ltr">TZNAME</code> column of the <code dir="ltr">V$TIMEZONE_NAMES</code> data dictionary view. Not applicable for <code dir="ltr">DATE</code> or <code dir="ltr">TIMESTAMP</code>. For a complete listing of all time zone region names, refer to <a class="olink NLSPG004" href="../../server.112/e10729/ch4datetime.htm#NLSPG004"><span class="italic">Oracle Database Globalization Support Guide</span></a>.</p>
</td>
<td class="cellalignment1865" headers="r10c1-t12 r1c3-t12">
<p>Not applicable</p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r11c1-t12" headers="r1c1-t12">
<p><code dir="ltr">TIMEZONE_ABBR</code></p>
</td>
<td class="cellalignment1865" headers="r11c1-t12 r1c2-t12">
<p>Query the <code dir="ltr">TZABBREV</code> column of the <code dir="ltr">V$TIMEZONE_NAMES</code> data dictionary view. Not applicable for <code dir="ltr">DATE</code> or <code dir="ltr">TIMESTAMP</code>.</p>
</td>
<td class="cellalignment1865" headers="r11c1-t12 r1c3-t12">
<p>Not applicable</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwidekey" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">TIMEZONE_HOUR</code> and <code dir="ltr">TIMEZONE_MINUTE</code> are specified together and interpreted as an entity in the format <code dir="ltr">+</code>|<code dir="ltr">-</code> <code dir="ltr"><span class="codeinlineitalic">hh</span></code><code dir="ltr">:</code><code dir="ltr"><span class="codeinlineitalic">mi</span></code>, with values ranging from -12:59 to +14:00. Refer to <a class="olink ODPNT0002" href="../../win.112/e23174/OracleTimeStampStructure.htm#ODPNT0002"><span class="italic">Oracle Data Provider for .NET Developer's Guide</span></a> for information on specifying time zone values for that API.</div>
</div>
<!-- class="sect3" -->
<div id="SQLRF00202" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref152"></a>
<h3 class="sect3">DATE Data Type <a id="sthref153"></a><a id="sthref154"></a></h3>
<p>The <code dir="ltr">DATE</code> data type stores date and time information. Although date and time information can be represented in both character and number data types, the <code dir="ltr">DATE</code> data type has special associated properties. For each <code dir="ltr">DATE</code> value, Oracle stores the following information: year, month, day, hour, minute, and second.</p>
<p>You can specify a <code dir="ltr">DATE</code> value as a literal, or you can convert a character or numeric value to a date value with the <code dir="ltr">TO_DATE</code> function. For examples of expressing <code dir="ltr">DATE</code> values in both these ways, refer to <a href="sql_elements003.htm#BABGIGCJ">"Datetime Literals"</a>.</p>
<div id="SQLRF50988" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref155"></a>
<h4 class="sect4">Using Julian Days</h4>
<p><a id="sthref156"></a><a id="sthref157"></a>A Julian day number is the number of days since January 1, 4712 BC. Julian days allow continuous dating from a common reference. You can use the date format model "J" with date functions <code dir="ltr">TO_DATE</code> and <code dir="ltr">TO_CHAR</code> to convert between Oracle <code dir="ltr">DATE</code> values and their Julian equivalents.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Database uses the astronomical system of calculating Julian days, in which the year 4713 BC is specified as -4712. The historical system of calculating Julian days, in contrast, specifies 4713 BC as -4713. If you are comparing Oracle Julian days with values calculated using the historical system, then take care to allow for the 365-day difference in BC dates. For more information, see <code dir="ltr"><a href="http://aa.usno.navy.mil/faq/docs/millennium.php">http://aa.usno.navy.mil/faq/docs/millennium.php</a></code>.</div>
<p>The default date values are determined as follows:</p>
<ul>
<li>
<p>The year is the current year, as returned by <code dir="ltr">SYSDATE</code>.</p>
</li>
<li>
<p>The month is the current month, as returned by <code dir="ltr">SYSDATE</code>.</p>
</li>
<li>
<p>The day is 01 (the first day of the month).</p>
</li>
<li>
<p>The hour, minute, and second are all 0.</p>
</li>
</ul>
<p>These default values are used in a query that requests date values where the date itself is not specified, as in the following example, which is issued in the month of May:</p>
<pre dir="ltr">
SELECT TO_DATE('2009', 'YYYY')
  FROM DUAL;

TO_DATE('
---------
01-MAY-09
</pre>
<p><a id="SQLRF50989"></a><span class="subhead3">Example&nbsp;</span>This statement returns the Julian equivalent of January 1, 2009:</p>
<pre dir="ltr">
SELECT TO_CHAR(TO_DATE('01-01-2009', 'MM-DD-YYYY'),'J')
    FROM DUAL;

TO_CHAR
-------
2454833
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="queries009.htm#i2054159">"Selecting from the DUAL Table"</a> for a description of the <code dir="ltr">DUAL</code> table</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i53219"></a>
<div id="SQLRF00203" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">TIMESTAMP Data Type <a id="sthref158"></a><a id="sthref159"></a></h3>
<p>The <code dir="ltr">TIMESTAMP</code> data type is an extension of the <code dir="ltr">DATE</code> data type. It stores the year, month, and day of the <code dir="ltr">DATE</code> data type, plus hour, minute, and second values. This data type is useful for storing precise time values and for collecting and evaluating date information across geographic regions. Specify the <code dir="ltr">TIMESTAMP</code> data type as follows:</p>
<pre dir="ltr">
TIMESTAMP [(<span class="italic">fractional_seconds_precision</span>)] 
</pre>
<p>where <code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> optionally specifies the number of digits Oracle stores in the fractional part of the <code dir="ltr">SECOND</code> datetime field. When you create a column of this data type, the value can be a number in the range 0 to 9. The default is 6.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="functions213.htm#i999843">TO_TIMESTAMP</a> for information on converting character data to <code dir="ltr">TIMESTAMP</code> data</div>
</div>
<!-- class="sect3" -->
<a id="CHDIIEID"></a>
<div id="SQLRF00204" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">TIMESTAMP WITH TIME ZONE Data Type <a id="sthref160"></a><a id="sthref161"></a></h3>
<p><code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code> is a variant of <code dir="ltr">TIMESTAMP</code> that includes a <span class="bold">time zone region name</span> or a <span class="bold">time zone offset</span> in its value. The time zone offset is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Time&mdash;formerly Greenwich Mean Time). This data type is useful for preserving local time zone information.</p>
<p>Specify the <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code> data type as follows:</p>
<pre dir="ltr">
TIMESTAMP [(<span class="italic">fractional_seconds_precision</span>)] WITH TIME ZONE
</pre>
<p>where <code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> optionally specifies the number of digits Oracle stores in the fractional part of the <code dir="ltr">SECOND</code> datetime field. When you create a column of this data type, the value can be a number in the range 0 to 9. The default is 6.</p>
<p>Oracle time zone data is derived from the public domain information available at <code dir="ltr"><a href="http://www.iana.org/time-zones/">http://www.iana.org/time-zones/</a></code>. Oracle time zone data may not reflect the most recent data available at this site.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink NLSPG004" href="../../server.112/e10729/ch4datetime.htm#NLSPG004"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information on Oracle time zone data</p>
</li>
<li>
<p><a href="#i51607">"Support for Daylight Saving Times"</a> and <a href="sql_elements004.htm#g195443">Table 3-17, "Matching Character Data and Format Models with the FX Format Model Modifier"</a> for information on daylight saving support</p>
</li>
<li>
<p><a href="functions214.htm#i999847">TO_TIMESTAMP_TZ</a> for information on converting character data to <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code> data</p>
</li>
<li>
<p><a href="statements_2013.htm#i2231814">ALTER SESSION</a> for information on the <code dir="ltr">ERROR_ON_OVERLAP_TIME</code> session parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="SQLRF00205" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref162"></a>
<h3 class="sect3">TIMESTAMP WITH LOCAL TIME ZONE Data Type <a id="sthref163"></a><a id="sthref164"></a></h3>
<p><code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">LOCAL</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code> is another variant of <code dir="ltr">TIMESTAMP</code> that is sensitive to time zone information. It differs from <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code> in that data stored in the database is normalized to the database time zone, and the time zone information is not stored as part of the column data. When a user retrieves the data, Oracle returns it in the user's local session time zone. This data type is useful for date information that is always to be displayed in the time zone of the client system in a two-tier application.</p>
<p>Specify the <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">LOCAL</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code> data type as follows:</p>
<pre dir="ltr">
TIMESTAMP [(<span class="italic">fractional_seconds_precision</span>)] WITH LOCAL TIME ZONE
</pre>
<p>where <code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> optionally specifies the number of digits Oracle stores in the fractional part of the <code dir="ltr">SECOND</code> datetime field. When you create a column of this data type, the value can be a number in the range 0 to 9. The default is 6.</p>
<p>Oracle time zone data is derived from the public domain information available at <code dir="ltr"><a href="http://www.iana.org/time-zones/">http://www.iana.org/time-zones/</a></code>. Oracle time zone data may not reflect the most recent data available at this site.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink NLSPG004" href="../../server.112/e10729/ch4datetime.htm#NLSPG004"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information on Oracle time zone data</p>
</li>
<li>
<p><a class="olink ADFNS00304" href="../../appdev.112/e41502/adfns_sqltypes.htm#ADFNS00304"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for examples of using this data type and <a href="functions023.htm#i1269136">CAST</a> for information on converting character data to <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">LOCAL</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i128552"></a>
<div id="SQLRF00206" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">INTERVAL YEAR TO MONTH Data Type <a id="sthref165"></a><a id="sthref166"></a></h3>
<p><code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code> stores a period of time using the <code dir="ltr">YEAR</code> and <code dir="ltr">MONTH</code> datetime fields. This data type is useful for representing the difference between two datetime values when only the year and month values are significant.</p>
<p>Specify <code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code> as follows:</p>
<pre dir="ltr">
INTERVAL YEAR [(<span class="italic">year_precision</span>)] TO MONTH
</pre>
<p>where <code dir="ltr"><span class="codeinlineitalic">year_precision</span></code> is the number of digits in the <code dir="ltr">YEAR</code> datetime field. The default value of <code dir="ltr"><span class="codeinlineitalic">year_precision</span></code> is 2.</p>
<p>You have a great deal of flexibility when specifying interval values as literals. Refer to <a href="sql_elements003.htm#i38598">"Interval Literals"</a> for detailed information on specifying interval values as literals. Also see <a href="#BABBICGH">"Datetime and Interval Examples"</a> for an example using intervals.</p>
</div>
<!-- class="sect3" -->
<a id="i78291"></a>
<div id="SQLRF00207" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">INTERVAL DAY TO SECOND Data Type <a id="sthref167"></a><a id="sthref168"></a></h3>
<p><code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code> stores a period of time in terms of days, hours, minutes, and seconds. This data type is useful for representing the precise difference between two datetime values.</p>
<p>Specify this data type as follows:</p>
<pre dir="ltr">
INTERVAL DAY [(<span class="italic">day_precision</span>)] 
   TO SECOND [(<span class="italic">fractional_seconds_precision</span>)]
</pre>
<p>where</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">day_precision</span></code> is the number of digits in the <code dir="ltr">DAY</code> datetime field. Accepted values are 0 to 9. The default is 2.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> is the number of digits in the fractional part of the <code dir="ltr">SECOND</code> datetime field. Accepted values are 0 to 9. The default is 6.</p>
</li>
</ul>
<p>You have a great deal of flexibility when specifying interval values as literals. Refer to <a href="sql_elements003.htm#i38598">"Interval Literals"</a> for detailed information on specify interval values as literals. Also see <a href="#BABBICGH">"Datetime and Interval Examples"</a> for an example using intervals.</p>
</div>
<!-- class="sect3" -->
<a id="i48042"></a>
<div id="SQLRF00208" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Datetime/Interval Arithmetic <a id="sthref169"></a><a id="sthref170"></a></h3>
<p><a id="sthref171"></a><a id="sthref172"></a>You can perform a number of arithmetic operations on date (<code dir="ltr">DATE</code>), timestamp (<code dir="ltr">TIMESTAMP</code>, <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>, and <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">LOCAL</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>) and interval (<code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code> and <code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code>) data. Oracle calculates the results based on the following rules:</p>
<ul>
<li>
<p>You can use <code dir="ltr">NUMBER</code> constants in arithmetic operations on date and timestamp values, but not interval values. Oracle internally converts timestamp values to date values and interprets <code dir="ltr">NUMBER</code> constants in arithmetic datetime and interval expressions as numbers of days. For example, <code dir="ltr">SYSDATE</code> + 1 is tomorrow. <code dir="ltr">SYSDATE</code> - 7 is one week ago. <code dir="ltr">SYSDATE</code> + (10/1440) is ten minutes from now. Subtracting the <code dir="ltr">hire_date</code> column of the sample table <code dir="ltr">employees</code> from <code dir="ltr">SYSDATE</code> returns the number of days since each employee was hired. You cannot multiply or divide date or timestamp values.</p>
</li>
<li>
<p>Oracle implicitly converts <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> operands to <code dir="ltr">NUMBER</code>.</p>
</li>
<li>
<p>Each <code dir="ltr">DATE</code> value contains a time component, and the result of many date operations include a fraction. This fraction means a portion of one day. For example, 1.5 days is 36 hours. These fractions are also returned by Oracle built-in functions for common operations on <code dir="ltr">DATE</code> data. For example, the <code dir="ltr">MONTHS_BETWEEN</code> function returns the number of months between two dates. The fractional portion of the result represents that portion of a 31-day month.</p>
</li>
<li>
<p>If one operand is a <code dir="ltr">DATE</code> value or a numeric value, neither of which contains time zone or fractional seconds components, then:</p>
<ul>
<li>
<p>Oracle implicitly converts the other operand to <code dir="ltr">DATE</code> data. The exception is multiplication of a numeric value times an interval, which returns an interval.</p>
</li>
<li>
<p>If the other operand has a time zone value, then Oracle uses the session time zone in the returned value.</p>
</li>
<li>
<p>If the other operand has a fractional seconds value, then the fractional seconds value is lost.</p>
</li>
</ul>
</li>
<li>
<p>When you pass a timestamp, interval, or numeric value to a built-in function that was designed only for the <code dir="ltr">DATE</code> data type, Oracle implicitly converts the non-<code dir="ltr">DATE</code> value to a <code dir="ltr">DATE</code> value. Refer to <a href="functions002.htm#i88891">"Datetime Functions"</a> for information on which functions cause implicit conversion to <code dir="ltr">DATE</code>.</p>
</li>
<li>
<p>When interval calculations return a datetime value, the result must be an actual datetime value or the database returns an error. For example, the next two statements return errors:</p>
<pre dir="ltr">
SELECT TO_DATE('31-AUG-2004','DD-MON-YYYY') + TO_YMINTERVAL('0-1')
  FROM DUAL;

SELECT TO_DATE('29-FEB-2004','DD-MON-YYYY') + TO_YMINTERVAL('1-0')
  FROM DUAL;
</pre>
<p>The first fails because adding one month to a 31-day month would result in September 31, which is not a valid date. The second fails because adding one year to a date that exists only every four years is not valid. However, the next statement succeeds, because adding four years to a February 29 date is valid:</p>
<pre dir="ltr">
SELECT TO_DATE('29-FEB-2004', 'DD-MON-YYYY') + TO_YMINTERVAL('4-0')
  FROM DUAL;
 
TO_DATE('
---------
29-FEB-08
</pre></li>
<li>
<p>Oracle performs all timestamp arithmetic in UTC time. For <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">LOCAL</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>, Oracle converts the datetime value from the database time zone to UTC and converts back to the database time zone after performing the arithmetic. For <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>, the datetime value is always in UTC, so no conversion is necessary.</p>
</li>
</ul>
<p><a href="#g196492">Table 3-5</a> is a matrix of datetime arithmetic operations. Dashes represent operations that are not supported.</p>
<div id="SQLRF50990" class="tblhruleformal">
<p class="titleintable"><a id="sthref173"></a><a id="g196492"></a>Table 3-5 Matrix of Datetime Arithmetic</p>
<table class="cellalignment1868" title="Matrix of Datetime Arithmetic" summary="This table is a matrix that shows the result of combining each two datetime values (DATE, TIMESTAMP, INTERVAL, or other numeric value) using addition, subtraction, multiplication, and division." dir="ltr">
<thead>
<tr class="cellalignment1859">
<th class="cellalignment1869" id="r1c1-t19">Operand &amp; Operator</th>
<th class="cellalignment1869" id="r1c2-t19">DATE</th>
<th class="cellalignment1869" id="r1c3-t19">TIMESTAMP</th>
<th class="cellalignment1869" id="r1c4-t19">INTERVAL</th>
<th class="cellalignment1869" id="r1c5-t19">Numeric</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r2c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">DATE</span></p>
</td>
<td class="cellalignment1865" headers="r2c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r2c1-t19 r1c3-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r2c1-t19 r1c4-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r2c1-t19 r1c5-t19">&nbsp;</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r3c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">+</span></p>
</td>
<td class="cellalignment1865" headers="r3c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r3c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r3c1-t19 r1c4-t19">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment1865" headers="r3c1-t19 r1c5-t19">
<p><code dir="ltr">DATE</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r4c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">-</span></p>
</td>
<td class="cellalignment1865" headers="r4c1-t19 r1c2-t19">
<p><code dir="ltr">NUMBER</code></p>
</td>
<td class="cellalignment1865" headers="r4c1-t19 r1c3-t19">
<p><code dir="ltr">INTERVAL</code></p>
</td>
<td class="cellalignment1865" headers="r4c1-t19 r1c4-t19">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment1865" headers="r4c1-t19 r1c5-t19">
<p><code dir="ltr">DATE</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r5c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">*</span></p>
</td>
<td class="cellalignment1865" headers="r5c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r5c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r5c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r5c1-t19 r1c5-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r6c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">/</span></p>
</td>
<td class="cellalignment1865" headers="r6c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r6c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r6c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r6c1-t19 r1c5-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r7c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">TIMESTAMP</span></p>
</td>
<td class="cellalignment1865" headers="r7c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r7c1-t19 r1c3-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r7c1-t19 r1c4-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r7c1-t19 r1c5-t19">&nbsp;</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r8c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">+</span></p>
</td>
<td class="cellalignment1865" headers="r8c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r8c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r8c1-t19 r1c4-t19">
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment1865" headers="r8c1-t19 r1c5-t19">
<p><code dir="ltr">DATE</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r9c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">-</span></p>
</td>
<td class="cellalignment1865" headers="r9c1-t19 r1c2-t19">
<p><code dir="ltr">INTERVAL</code></p>
</td>
<td class="cellalignment1865" headers="r9c1-t19 r1c3-t19">
<p><code dir="ltr">INTERVAL</code></p>
</td>
<td class="cellalignment1865" headers="r9c1-t19 r1c4-t19">
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment1865" headers="r9c1-t19 r1c5-t19">
<p><code dir="ltr">DATE</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r10c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">*</span></p>
</td>
<td class="cellalignment1865" headers="r10c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r10c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r10c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r10c1-t19 r1c5-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r11c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">/</span></p>
</td>
<td class="cellalignment1865" headers="r11c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r11c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r11c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r11c1-t19 r1c5-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r12c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">INTERVAL</span></p>
</td>
<td class="cellalignment1865" headers="r12c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r12c1-t19 r1c3-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r12c1-t19 r1c4-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r12c1-t19 r1c5-t19">&nbsp;</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r13c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">+</span></p>
</td>
<td class="cellalignment1865" headers="r13c1-t19 r1c2-t19">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment1865" headers="r13c1-t19 r1c3-t19">
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment1865" headers="r13c1-t19 r1c4-t19">
<p><code dir="ltr">INTERVAL</code></p>
</td>
<td class="cellalignment1865" headers="r13c1-t19 r1c5-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r14c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">-</span></p>
</td>
<td class="cellalignment1865" headers="r14c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r14c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r14c1-t19 r1c4-t19">
<p><code dir="ltr">INTERVAL</code></p>
</td>
<td class="cellalignment1865" headers="r14c1-t19 r1c5-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r15c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">*</span></p>
</td>
<td class="cellalignment1865" headers="r15c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r15c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r15c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r15c1-t19 r1c5-t19">
<p><code dir="ltr">INTERVAL</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r16c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">/</span></p>
</td>
<td class="cellalignment1865" headers="r16c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r16c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r16c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r16c1-t19 r1c5-t19">
<p><code dir="ltr">INTERVAL</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r17c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">Numeric</span></p>
</td>
<td class="cellalignment1865" headers="r17c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r17c1-t19 r1c3-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r17c1-t19 r1c4-t19">&nbsp;</td>
<td class="cellalignment1865" headers="r17c1-t19 r1c5-t19">&nbsp;</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r18c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">+</span></p>
</td>
<td class="cellalignment1865" headers="r18c1-t19 r1c2-t19">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment1865" headers="r18c1-t19 r1c3-t19">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment1865" headers="r18c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r18c1-t19 r1c5-t19">
<p><code dir="ltr">NA</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r19c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">-</span></p>
</td>
<td class="cellalignment1865" headers="r19c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r19c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r19c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r19c1-t19 r1c5-t19">
<p><code dir="ltr">NA</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r20c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">*</span></p>
</td>
<td class="cellalignment1865" headers="r20c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r20c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r20c1-t19 r1c4-t19">
<p><code dir="ltr">INTERVAL</code></p>
</td>
<td class="cellalignment1865" headers="r20c1-t19 r1c5-t19">
<p><code dir="ltr">NA</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r21c1-t19" headers="r1c1-t19">
<p><span class="syntaxinlinebold">/</span></p>
</td>
<td class="cellalignment1865" headers="r21c1-t19 r1c2-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r21c1-t19 r1c3-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r21c1-t19 r1c4-t19">
<p><code dir="ltr">&mdash;</code></p>
</td>
<td class="cellalignment1865" headers="r21c1-t19 r1c5-t19">
<p><code dir="ltr">NA</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p><a id="SQLRF50991"></a><span class="subhead3">Examples&nbsp;</span>You can add an interval value expression to a start time. Consider the sample table <code dir="ltr">oe.orders</code> with a column <code dir="ltr">order_date</code>. The following statement adds 30 days to the value of the <code dir="ltr">order_date</code> column:</p>
<pre dir="ltr">
SELECT order_id, order_date + INTERVAL '30' DAY AS "Due Date"
  FROM orders
  ORDER BY order_id, "Due Date";
</pre></div>
<!-- class="sect3" -->
<a id="i51607"></a>
<div id="SQLRF30039" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Support for Daylight Saving Times <a id="sthref174"></a><a id="sthref175"></a><a id="sthref176"></a><a id="sthref177"></a><a id="sthref178"></a></h3>
<p>Oracle Database automatically determines, for any given time zone region, whether daylight saving is in effect and returns local time values accordingly. The datetime value is sufficient for Oracle to determine whether daylight saving time is in effect for a given region in all cases except <span class="bold">boundary cases</span>. A boundary case occurs during the period when daylight saving goes into or comes out of effect. For example, in the US-Pacific region, when daylight saving goes into effect, the time changes from 2:00 a.m. to 3:00 a.m. The one hour interval between 2 and 3 a.m. does not exist. When daylight saving goes out of effect, the time changes from 2:00 a.m. back to 1:00 a.m., and the one-hour interval between 1 and 2 a.m. is repeated.</p>
<p>To resolve these boundary cases, Oracle uses the <code dir="ltr">TZR</code> and <code dir="ltr">TZD</code> format elements, as described in <a href="sql_elements004.htm#g195443">Table 3-17</a>. <code dir="ltr">TZR</code> represents the time zone region name in datetime input strings. Examples are '<code dir="ltr">Australia/North</code>', '<code dir="ltr">UTC</code>', and '<code dir="ltr">Singapore</code>'. <code dir="ltr">TZD</code> represents an abbreviated form of the time zone region name with daylight saving information. Examples are '<code dir="ltr">PST</code>' for US/Pacific standard time and '<code dir="ltr">PDT</code>' for US/Pacific daylight time. To see a listing of valid values for the <code dir="ltr">TZR</code> and <code dir="ltr">TZD</code> format elements, query the <code dir="ltr">TZNAME</code> and <code dir="ltr">TZABBREV</code> columns of the <code dir="ltr">V$TIMEZONE_NAMES</code> dynamic performance view.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Time zone region names are needed by the daylight saving feature. These names are stored in two types of time zone files: one large and one small. One of these files is the default file, depending on your environment and the release of Oracle Database you are using. For more information regarding time zone files and names, see <a class="olink NLSPG014" href="../../server.112/e10729/applocaledata.htm#NLSPG014"><span class="italic">Oracle Database Globalization Support Guide</span></a>.</div>
<p>For a complete listing of the time zone region names in both files, refer to <a class="olink NLSPG0141" href="../../server.112/e10729/applocaledata.htm#NLSPG0141"><span class="italic">Oracle Database Globalization Support Guide</span></a>.</p>
<p>Oracle time zone data is derived from the public domain information available at <code dir="ltr"><a href="http://www.iana.org/time-zones/">http://www.iana.org/time-zones/</a></code>. Oracle time zone data may not reflect the most recent data available at this site.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="sql_elements004.htm#i34924">"Datetime Format Models"</a> for information on the format elements and the session parameter <a href="statements_2013.htm#i2252050">ERROR_ON_OVERLAP_TIME</a>.</p>
</li>
<li>
<p><a class="olink NLSPG004" href="../../server.112/e10729/ch4datetime.htm#NLSPG004"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information on Oracle time zone data</p>
</li>
<li>
<p><a class="olink REFRN30290" href="../../server.112/e40402/dynviews_3112.htm#REFRN30290"><span class="italic">Oracle Database Reference</span></a> for information on the dynamic performance views</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABBICGH"></a>
<div id="SQLRF50992" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Datetime and Interval Examples</h3>
<p>The following example shows how to specify some datetime and interval data types.</p>
<pre dir="ltr">
CREATE TABLE time_table
  (start_time    TIMESTAMP,
   duration_1    INTERVAL DAY (6) TO SECOND (5),
   duration_2    INTERVAL YEAR TO MONTH);
</pre>
<p>The <code dir="ltr">start_time</code> column is of type <code dir="ltr">TIMESTAMP</code>. The implicit fractional seconds precision of <code dir="ltr">TIMESTAMP</code> is 6.</p>
<p>The <code dir="ltr">duration_1</code> column is of type <code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code>. The maximum number of digits in field <code dir="ltr">DAY</code> is 6 and the maximum number of digits in the fractional second is 5. The maximum number of digits in all other datetime fields is 2.</p>
<p>The <code dir="ltr">duration_2</code> column is of type <code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code>. The maximum number of digits of the value in each field (<code dir="ltr">YEAR</code> and <code dir="ltr">MONTH</code>) is 2.</p>
<p>Interval data types do not have format models. Therefore, to adjust their presentation, you must combine character functions such as <code dir="ltr">EXTRACT</code> and concatenate the components. For example, the following examples query the <code dir="ltr">hr.employees</code> and <code dir="ltr">oe.orders</code> tables, respectively, and change interval output from the form "<span class="italic">yy</span>-<span class="italic">mm</span>" to "<span class="italic">yy</span> years <span class="italic">mm</span> months" and from "<span class="italic">dd</span>-<span class="italic">hh</span>" to "<span class="italic">dddd</span> days <span class="italic">hh</span> hours":</p>
<pre dir="ltr">
SELECT last_name, EXTRACT(YEAR FROM (SYSDATE - hire_date) YEAR TO MONTH)
       || ' years '
       || EXTRACT(MONTH FROM (SYSDATE - hire_date) YEAR TO MONTH)
       || ' months'  "Interval"
  FROM employees;

LAST_NAME                 Interval
------------------------- --------------------
OConnell                  2 years 3 months
Grant                     1 years 9 months
Whalen                    6 years 1 months
Hartstein                 5 years 8 months
Fay                       4 years 2 months
Mavris                    7 years 4 months
Baer                      7 years 4 months
Higgins                   7 years 4 months
Gietz                     7 years 4 months
. . .

SELECT order_id, EXTRACT(DAY FROM (SYSDATE - order_date) DAY TO SECOND)
       || ' days '
       || EXTRACT(HOUR FROM (SYSDATE - order_date) DAY TO SECOND)
       || ' hours' "Interval"
  FROM orders;

  ORDER_ID Interval
---------- --------------------
      2458 780 days 23 hours
      2397 685 days 22 hours
      2454 733 days 21 hours
      2354 447 days 20 hours
      2358 635 days 20 hours
      2381 508 days 18 hours
      2440 765 days 17 hours
      2357 1365 days 16 hours
      2394 602 days 15 hours
      2435 763 days 15 hours
. . .
</pre></div>
<!-- class="sect3" -->
<a id="i46018"></a>
<div id="SQLRF50993" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">RAW and LONG RAW Data Types <a id="sthref179"></a><a id="sthref180"></a><a id="sthref181"></a><a id="sthref182"></a></h3>
<p>The <code dir="ltr">RAW</code> and <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> data types store data that is not to be explicitly converted by Oracle Database when moving data between different systems. These data types are intended for binary data or byte strings. For example, you can use <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> to store graphics, sound, documents, or arrays of binary data, for which the interpretation is dependent on the use.</p>
<p>Oracle strongly recommends that you convert <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> columns to binary LOB (<code dir="ltr">BLOB</code>) columns. LOB columns are subject to far fewer restrictions than <code dir="ltr">LONG</code> columns. See <a href="functions205.htm#i79464">TO_LOB</a> for more information.</p>
<p><code dir="ltr">RAW</code> is a variable-length data type like <code dir="ltr">VARCHAR2</code>, except that Oracle Net (which connects client software to a database or one database to another) and the Oracle import and export utilities do not perform character conversion when transmitting <code dir="ltr">RAW</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> data. In contrast, Oracle Net and the Oracle import and export utilities automatically convert <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR2</code>, and <code dir="ltr">LONG</code> data between different database character sets, if data is transported between databases, or between the database character set and the client character set, if data is transported between a database and a client. The client character set is determined by the type of the client interface, such as OCI or JDBC, and the client configuration (for example, the <code dir="ltr">NLS_LANG</code> environment variable).</p>
<p><a id="sthref183"></a><a id="sthref184"></a>When Oracle implicitly converts <code dir="ltr">RAW</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> data to character data, the resulting character value contains a hexadecimal representation of the binary input, where each character is a hexadecimal digit (<code dir="ltr">0</code>-<code dir="ltr">9</code>, <code dir="ltr">A</code>-<code dir="ltr">F</code>) representing four consecutive bits of <code dir="ltr">RAW</code> data. For example, one byte of <code dir="ltr">RAW</code> data with bits 11001011 becomes the value <code dir="ltr">CB</code>.</p>
<p>When Oracle implicitly converts character data to <code dir="ltr">RAW</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, it interprets each consecutive input character as a hexadecimal representation of four consecutive bits of binary data and builds the resulting <code dir="ltr">RAW</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> value by concatenating those bits. If any of the input characters is not a hexadecimal digit (<code dir="ltr">0</code>-<code dir="ltr">9</code>, <code dir="ltr">A</code>-<code dir="ltr">F</code>, <code dir="ltr">a</code>-<code dir="ltr">f</code>), then an error is reported. If the number of characters is odd, then the result is undefined.</p>
<p>The SQL functions <code dir="ltr">RAWTOHEX</code> and <code dir="ltr">HEXTORAW</code> perform explicit conversions that are equivalent to the above implicit conversions. Other types of conversions between <code dir="ltr">RAW</code> and character data are possible with functions in the Oracle-supplied PL/SQL packages <code dir="ltr">UTL_RAW</code> and <code dir="ltr">UTL_I18N</code>.</p>
<p class="subhead2"><a id="i46035"></a><a id="SQLRF50994"></a>Large Object (LOB) Data Types <a id="sthref185"></a><a id="sthref186"></a><a id="sthref187"></a><a id="sthref188"></a><a id="sthref189"></a></p>
<p>The built-in LOB data types <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB</code>, and <code dir="ltr">NCLOB</code> (stored internally) and <code dir="ltr">BFILE</code> (stored externally) can store large and unstructured data such as text, image, video, and spatial data. The size of <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB</code>, and <code dir="ltr">NCLOB</code> data can be up to (2<sup>32</sup>-1 bytes) * (the value of the <code dir="ltr">CHUNK</code> parameter of LOB storage). If the tablespaces in your database are of standard block size, and if you have used the default value of the <code dir="ltr">CHUNK</code> parameter of LOB storage when creating a LOB column, then this is equivalent to (2<sup>32</sup>-1 bytes) * (database block size). <code dir="ltr">BFILE</code> data can be up to 2<sup>64</sup>-1 bytes, although your operating system may impose restrictions on this maximum.</p>
<p>When creating a table, you can optionally specify different tablespace and storage characteristics for LOB columns or LOB object attributes from those specified for the table.</p>
<p><code dir="ltr">CLOB</code>, <code dir="ltr">NCLOB</code>, and <code dir="ltr">BLOB</code> values up to approximately 4000 bytes are stored inline if you enable storage in row at the time the LOB column is created. LOBs greater than 4000 bytes are always stored externally. Refer to <a href="statements_7002.htm#BABHDBGB">ENABLE STORAGE IN ROW</a> for more information.</p>
<p><a id="sthref190"></a>LOB columns contain LOB locators that can refer to internal (in the database) or external (outside the database) LOB values. Selecting a LOB from a table actually returns the LOB locator and not the entire LOB value. The <code dir="ltr">DBMS_LOB</code> package and Oracle Call Interface (OCI) operations on LOBs are performed through these locators.</p>
<p><a id="sthref191"></a>LOBs are similar to <code dir="ltr">LONG</code> and <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> types, but differ in the following ways:</p>
<ul>
<li>
<p>LOBs can be attributes of an object type (user-defined data type).</p>
</li>
<li>
<p>The LOB locator is stored in the table column, either with or without the actual LOB value. <code dir="ltr">BLOB</code>, <code dir="ltr">NCLOB</code>, and <code dir="ltr">CLOB</code> values can be stored in separate tablespaces. <code dir="ltr">BFILE</code> data is stored in an external file on the server.</p>
</li>
<li>
<p>When you access a LOB column, the locator is returned.</p>
</li>
<li>
<p>A LOB can be up to (2<sup>32</sup>-1 bytes)*(database block size) in size. <code dir="ltr">BFILE</code> data can be up to 2<sup>64</sup>-1 bytes, although your operating system may impose restrictions on this maximum.</p>
</li>
<li>
<p>LOBs permit efficient, random, piece-wise access to and manipulation of data.</p>
</li>
<li>
<p>You can define more than one LOB column in a table.</p>
</li>
<li>
<p>With the exception of <code dir="ltr">NCLOB</code>, you can define one or more LOB attributes in an object.</p>
</li>
<li>
<p>You can declare LOB bind variables.</p>
</li>
<li>
<p>You can select LOB columns and LOB attributes.</p>
</li>
<li>
<p>You can insert a new row or update an existing row that contains one or more LOB columns or an object with one or more LOB attributes. In update operations, you can set the internal LOB value to <code dir="ltr">NULL</code>, empty, or replace the entire LOB with data. You can set the <code dir="ltr">BFILE</code> to <code dir="ltr">NULL</code> or make it point to a different file.</p>
</li>
<li>
<p>You can update a LOB row-column intersection or a LOB attribute with another LOB row-column intersection or LOB attribute.</p>
</li>
<li>
<p>You can delete a row containing a LOB column or LOB attribute and thereby also delete the LOB value. For BFILEs, the actual operating system file is not deleted.</p>
</li>
</ul>
<p><a id="sthref192"></a><a id="sthref193"></a>You can access and populate rows of an inline LOB column (a LOB column stored in the database) or a LOB attribute (an attribute of an object type column stored in the database) simply by issuing an <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement.</p>
<p><a id="BABHIJHI"></a><a id="SQLRF50995"></a><span class="subhead3">Restrictions on LOB Columns <a id="sthref194"></a>&nbsp;</span>LOB columns are subject to a number of rules and restrictions. See <a class="olink ADLOB2010" href="../../appdev.112/e18294/adlob_working.htm#ADLOB2010"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for a complete listing.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> and <a class="olink LNOCI070" href="../../appdev.112/e10646/oci07lob.htm#LNOCI070"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for more information about these interfaces and LOBs</p>
</li>
<li>
<p>the <code dir="ltr"><span class="codeinlineitalic">modify_col_properties</span></code> clause of <a href="statements_3001.htm#CJAHHIBI">ALTER TABLE</a> and <a href="functions205.htm#i79464">TO_LOB</a> for more information on converting <code dir="ltr">LONG</code> columns to LOB columns</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="SQLRF50996" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref195"></a>
<h3 class="sect3">BFILE Data Type <a id="sthref196"></a><a id="sthref197"></a><a id="sthref198"></a></h3>
<p>The <code dir="ltr">BFILE</code> data type enables access to binary file LOBs that are stored in file systems outside Oracle Database. A <code dir="ltr">BFILE</code> column or attribute stores a <code dir="ltr">BFILE</code> locator, which serves as a pointer to a binary file on the server file system. The locator maintains the directory name and the filename.</p>
<p>You can change the filename and path of a <code dir="ltr">BFILE</code> without affecting the base table by using the <code dir="ltr">BFILENAME</code> function. Refer to <a href="functions019.htm#i76871">BFILENAME</a> for more information on this built-in SQL function.</p>
<p>Binary file LOBs do not participate in transactions and are not recoverable. Rather, the underlying operating system provides file integrity and durability. <code dir="ltr">BFILE</code> data can be up to 2<sup>64</sup>-1 bytes, although your operating system may impose restrictions on this maximum.</p>
<p>The database administrator must ensure that the external file exists and that Oracle processes have operating system read permissions on the file.</p>
<p>The <code dir="ltr">BFILE</code> data type enables read-only support of large binary files. You cannot modify or replicate such a file. Oracle provides APIs to access file data. The primary interfaces that you use to access file data are the <code dir="ltr">DBMS_LOB</code> package and Oracle Call Interface (OCI).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB012" href="../../appdev.112/e18294/adlob_bfile_ops.htm#ADLOB012"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> and <a class="olink LNOCI070" href="../../appdev.112/e10646/oci07lob.htm#LNOCI070"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for more information about LOBs and <a href="statements_5007.htm#i2061958">CREATE DIRECTORY</a></div>
</div>
<!-- class="sect3" -->
<div id="SQLRF50997" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref199"></a>
<h3 class="sect3">BLOB Data Type <a id="sthref200"></a><a id="sthref201"></a></h3>
<p>The <code dir="ltr">BLOB</code> data type stores unstructured binary large objects. <code dir="ltr">BLOB</code> objects can be thought of as bitstreams with no character set semantics. <code dir="ltr">BLOB</code> objects can store binary data up to (4 gigabytes -1) * (the value of the <code dir="ltr">CHUNK</code> parameter of LOB storage). If the tablespaces in your database are of standard block size, and if you have used the default value of the <code dir="ltr">CHUNK</code> parameter of LOB storage when creating a LOB column, then this is equivalent to (4 gigabytes - 1) * (database block size).</p>
<p><code dir="ltr"><a id="sthref202"></a>BLOB</code> objects have full transactional support. Changes made through SQL, the <code dir="ltr">DBMS_LOB</code> package, or Oracle Call Interface (OCI) participate fully in the transaction. <code dir="ltr">BLOB</code> value manipulations can be committed and rolled back. However, you cannot save a <code dir="ltr">BLOB</code> locator in a PL/SQL or OCI variable in one transaction and then use it in another transaction or session.</p>
</div>
<!-- class="sect3" -->
<div id="SQLRF20041" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref203"></a>
<h3 class="sect3">CLOB Data Type <a id="sthref204"></a><a id="sthref205"></a></h3>
<p>The <code dir="ltr">CLOB</code> data type stores single-byte and multibyte character data. Both fixed-width and variable-width character sets are supported, and both use the database character set. <code dir="ltr">CLOB</code> objects can store up to (4 gigabytes -1) * (the value of the <code dir="ltr">CHUNK</code> parameter of LOB storage) of character data. If the tablespaces in your database are of standard block size, and if you have used the default value of the <code dir="ltr">CHUNK</code> parameter of LOB storage when creating a LOB column, then this is equivalent to (4 gigabytes - 1) * (database block size).</p>
<p><code dir="ltr"><a id="sthref206"></a>CLOB</code> objects have full transactional support. Changes made through SQL, the <code dir="ltr">DBMS_LOB</code> package, or Oracle Call Interface (OCI) participate fully in the transaction. <code dir="ltr">CLOB</code> value manipulations can be committed and rolled back. However, you cannot save a <code dir="ltr">CLOB</code> locator in a PL/SQL or OCI variable in one transaction and then use it in another transaction or session.</p>
</div>
<!-- class="sect3" -->
<a id="g232603"></a>
<div id="SQLRF20042" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">NCLOB Data Type <a id="sthref207"></a><a id="sthref208"></a><a id="sthref209"></a></h3>
<p>The <code dir="ltr">NCLOB</code> data type stores Unicode data. Both fixed-width and variable-width character sets are supported, and both use the national character set. <code dir="ltr">NCLOB</code> objects can store up to (4 gigabytes -1) * (the value of the <code dir="ltr">CHUNK</code> parameter of LOB storage) of character text data. If the tablespaces in your database are of standard block size, and if you have used the default value of the <code dir="ltr">CHUNK</code> parameter of LOB storage when creating a LOB column, then this is equivalent to (4 gigabytes - 1) * (database block size).</p>
<p><code dir="ltr"><a id="sthref210"></a>NCLOB</code> objects have full transactional support. Changes made through SQL, the <code dir="ltr">DBMS_LOB</code> package, or OCI participate fully in the transaction. <code dir="ltr">NCLOB</code> value manipulations can be committed and rolled back. However, you cannot save an <code dir="ltr">NCLOB</code> locator in a PL/SQL or OCI variable in one transaction and then use it in another transaction or session.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG006" href="../../server.112/e10729/ch6unicode.htm#NLSPG006"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information on Unicode data type support</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDGIAJ"></a>
<div id="SQLRF50998" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Rowid Data Types <a id="sthref211"></a><a id="sthref212"></a><a id="sthref213"></a></h2>
<p><a id="sthref214"></a><a id="sthref215"></a>Each row in the database has an address. The sections that follow describe the two forms of row address in an Oracle Database.</p>
<div id="SQLRF50999" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref216"></a>
<h3 class="sect3">ROWID Data Type <a id="sthref217"></a></h3>
<p>The rows in heap-organized tables that are native to Oracle Database have row addresses called <span class="bold">rowids</span>. You can examine a rowid row address by querying the pseudocolumn <code dir="ltr">ROWID</code>. Values of this pseudocolumn are strings representing the address of each row. These strings have the data type <code dir="ltr">ROWID</code>. You can also create tables and clusters that contain actual columns having the <code dir="ltr">ROWID</code> data type. Oracle Database does not guarantee that the values of such columns are valid rowids. Refer to <a href="pseudocolumns.htm#g1020307">Chapter 2, "Pseudocolumns"</a> for more information on the <code dir="ltr">ROWID</code> pseudocolumn.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Beginning with Oracle8, Oracle SQL incorporated an extended format for rowids to efficiently support partitioned tables and indexes and tablespace-relative data block addresses without ambiguity. If you are running Version 7 of the database and you intend to upgrade, use the <code dir="ltr">DBMS_ROWID</code> package to migrate rowids in your data to the extended format. Refer to <span class="italic">Oracle Database PL/SQL Packages and Types Reference</span> for information on <a class="olink ARPLS053" href="../../appdev.112/e40758/d_rowid.htm#ARPLS053"><code dir="ltr">DBMS_ROWID</code></a> and to <a class="olink UPGRD12358" href="../../server.112/e23633/preup.htm#UPGRD12358"><span class="italic">Oracle Database Upgrade Guide</span></a> for information on upgrading from Oracle7.</div>
<p>Rowids contain the following information:</p>
<ul>
<li>
<p>The <span class="bold">data block</span> of the data file containing the row. The length of this string depends on your operating system.</p>
</li>
<li>
<p>The <span class="bold">row</span> in the data block.</p>
</li>
<li>
<p>The <span class="bold">database file</span> containing the row. The first data file has the number 1. The length of this string depends on your operating system.</p>
</li>
<li>
<p>The <span class="bold">data object number</span>, which is an identification number assigned to every database segment. You can retrieve the data object number from the data dictionary views <code dir="ltr">USER_OBJECTS</code>, <code dir="ltr">DBA_OBJECTS</code>, and <code dir="ltr">ALL_OBJECTS</code>. Objects that share the same segment (clustered tables in the same cluster, for example) have the same object number.</p>
</li>
</ul>
<p><a id="sthref218"></a><a id="sthref219"></a><a id="sthref220"></a><a id="sthref221"></a><a id="sthref222"></a>Rowids are stored as base 64 values that can contain the characters A-Z, a-z, 0-9, and the plus sign (+) and forward slash (/). Rowids are not available directly. You can use the supplied package <code dir="ltr">DBMS_ROWID</code> to interpret rowid contents. The package functions extract and provide information on the four rowid elements listed above.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS053" href="../../appdev.112/e40758/d_rowid.htm#ARPLS053"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information on the functions available with the <code dir="ltr">DBMS_ROWID</code> package and how to use them</div>
</div>
<!-- class="sect3" -->
<a id="i46212"></a>
<div id="SQLRF51000" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">UROWID <a id="sthref223"></a><a id="sthref224"></a><a id="sthref225"></a><a id="sthref226"></a><a id="sthref227"></a><a id="sthref228"></a><a id="sthref229"></a>Data Type <a id="sthref230"></a></h3>
<p>The rows of some tables have addresses that are not physical or permanent or were not generated by Oracle Database. For example, the row addresses of index-organized tables are stored in index leaves, which can move. Rowids of foreign tables (such as DB2 tables accessed through a gateway) are not standard Oracle rowids.</p>
<p><a id="sthref231"></a><a id="sthref232"></a><a id="sthref233"></a>Oracle uses universal rowids (<span class="bold">urowids</span>) to store the addresses of index-organized and foreign tables. Index-organized tables have logical urowids and foreign tables have foreign urowids. Both types of urowid are stored in the <code dir="ltr">ROWID</code> pseudocolumn (as are the physical rowids of heap-organized tables).</p>
<p>Oracle creates logical rowids based on the primary key of the table. The logical rowids do not change as long as the primary key does not change. The <code dir="ltr">ROWID</code> pseudocolumn of an index-organized table has a data type of <code dir="ltr">UROWID</code>. You can access this pseudocolumn as you would the <code dir="ltr">ROWID</code> pseudocolumn of a heap-organized table (using a <code dir="ltr">SELECT</code> ... <code dir="ltr">ROWID</code> statement). If you want <code dir="ltr">to</code> store the rowids of an index-organized table, then you can define a column of type <code dir="ltr">UROWID</code> for the table and retrieve the value of the <code dir="ltr">ROWID</code> pseudocolumn into that column.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i54335"></a>
<div id="SQLRF00213" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">ANSI, DB2, and SQL/DS Data Types <a id="sthref234"></a><a id="sthref235"></a><a id="sthref236"></a></h2>
<p>SQL statements that create tables and clusters can also use ANSI data types and data types from the IBM products SQL/DS and DB2. Oracle recognizes the ANSI or IBM data type name that differs from the Oracle Database data type name. It converts the data type to the equivalent Oracle data type, records the Oracle data type as the name of the column data type, and stores the column data in the Oracle data type based on the conversions shown in the tables that follow.<a id="sthref237"></a></p>
<div id="SQLRF55584" class="tblhruleformal">
<p class="titleintable"><a id="sthref238"></a><a id="sthref239"></a>Table 3-6 ANSI Data Types Converted to Oracle Data Types</p>
<table class="cellalignment1868" title="ANSI Data Types Converted to Oracle Data Types" summary="The column on the left lists the ANSI SQL datatypes and the column on the right lists the corresponding Oracle datatype." dir="ltr">
<thead>
<tr class="cellalignment1859">
<th class="cellalignment1869" id="r1c1-t27">ANSI SQL Data Type</th>
<th class="cellalignment1869" id="r1c2-t27">Oracle Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r2c1-t27" headers="r1c1-t27">
<p><code dir="ltr">CHARACTER(n)</code></p>
<p><code dir="ltr">CHAR(n)</code></p>
</td>
<td class="cellalignment1865" headers="r2c1-t27 r1c2-t27">
<p><code dir="ltr">CHAR(n)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r3c1-t27" headers="r1c1-t27">
<p><code dir="ltr">CHARACTER VARYING(n)</code></p>
<p><code dir="ltr">CHAR VARYING(n)</code></p>
</td>
<td class="cellalignment1865" headers="r3c1-t27 r1c2-t27">
<p><code dir="ltr">VARCHAR2(n)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r4c1-t27" headers="r1c1-t27">
<p><code dir="ltr">NATIONAL CHARACTER(n)</code></p>
<p><code dir="ltr">NATIONAL CHAR(n)</code></p>
<p><code dir="ltr">NCHAR(n)</code></p>
</td>
<td class="cellalignment1865" headers="r4c1-t27 r1c2-t27">
<p><code dir="ltr">NCHAR(n)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r5c1-t27" headers="r1c1-t27">
<p><code dir="ltr">NATIONAL CHARACTER VARYING(n)</code></p>
<p><code dir="ltr">NATIONAL CHAR VARYING(n)</code></p>
<p><code dir="ltr">NCHAR VARYING(n)</code></p>
</td>
<td class="cellalignment1865" headers="r5c1-t27 r1c2-t27">
<p><code dir="ltr">NVARCHAR2(n)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r6c1-t27" headers="r1c1-t27">
<p><code dir="ltr">NUMERIC[(p,s)]</code></p>
<p><code dir="ltr">DECIMAL[(p,s)]</code> (<span class="bold">Note 1</span>)</p>
</td>
<td class="cellalignment1865" headers="r6c1-t27 r1c2-t27">
<p><code dir="ltr">NUMBER(p,s)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r7c1-t27" headers="r1c1-t27">
<p><code dir="ltr">INTEGER</code></p>
<p><code dir="ltr">INT</code></p>
<p><code dir="ltr">SMALLINT</code></p>
</td>
<td class="cellalignment1865" headers="r7c1-t27 r1c2-t27">
<p><code dir="ltr">NUMBER(p,0)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r8c1-t27" headers="r1c1-t27">
<p><code dir="ltr">FLOAT</code> (<span class="bold">Note 2</span>)</p>
<p><code dir="ltr">DOUBLE PRECISION</code> (<span class="bold">Note 3</span>)</p>
<p><code dir="ltr">REAL</code> (<span class="bold">Note 4</span>)</p>
</td>
<td class="cellalignment1865" headers="r8c1-t27 r1c2-t27">
<p><code dir="ltr">FLOAT(126)</code></p>
<p><code dir="ltr">FLOAT(126)</code></p>
<p><code dir="ltr">FLOAT(63)</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p class="subhead2"><a id="SQLRF51002"></a>Notes:</p>
<ol>
<li>
<p>The <code dir="ltr">NUMERIC</code> and <code dir="ltr">DECIMAL</code> data types can specify only fixed-point numbers. For those data types, the scale (<code dir="ltr">s</code>) defaults to 0.</p>
</li>
<li>
<p>The <code dir="ltr">FLOAT</code> data type is a floating-point number with a binary precision b. The default precision for this data type is 126 binary, or 38 decimal.</p>
</li>
<li>
<p>The <code dir="ltr">DOUBLE PRECISION</code> data type is a floating-point number with binary precision 126.</p>
</li>
<li>
<p>The <code dir="ltr">REAL</code> data type is a floating-point number with a binary precision of 63, or 18 decimal.</p>
</li>
</ol>
<p><a id="sthref240"></a><a id="sthref241"></a><a id="sthref242"></a><a id="sthref243"></a><a id="sthref244"></a><a id="sthref245"></a><a id="sthref246"></a>Do <a id="sthref247"></a><a id="sthref248"></a><a id="sthref249"></a><a id="sthref250"></a><a id="sthref251"></a>not <a id="sthref252"></a><a id="sthref253"></a><a id="sthref254"></a><a id="sthref255"></a><a id="sthref256"></a>define <a id="sthref257"></a><a id="sthref258"></a>columns with the following SQL/DS and DB2 data types, because they have no corresponding Oracle data type:</p>
<ul>
<li>
<p><code dir="ltr">GRAPHIC</code></p>
</li>
<li>
<p><code dir="ltr">LONG</code> <code dir="ltr">VARGRAPHIC</code></p>
</li>
<li>
<p><code dir="ltr">VARGRAPHIC</code></p>
</li>
<li>
<p><code dir="ltr">TIME</code></p>
</li>
</ul>
<p>Note that data of type <code dir="ltr">TIME</code> can also be expressed as Oracle datetime data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABIHEID">"Datetime and Interval Data Types"</a></div>
<div id="SQLRF51003" class="tblhruleformal">
<p class="titleintable"><a id="sthref259"></a><a id="sthref260"></a>Table 3-7 SQL/DS and DB2 Data Types Converted to Oracle Data Types</p>
<table class="cellalignment1868" title="SQL/DS and DB2 Data Types Converted to Oracle Data Types" summary="The first column lists the SQL/DS and DB2 datatypes, the second column lists the corresponding Oracle datatype, and the third column provides notes." dir="ltr">
<thead>
<tr class="cellalignment1859">
<th class="cellalignment1869" id="r1c1-t29">SQL/DS or DB2 Data Type</th>
<th class="cellalignment1869" id="r1c2-t29">Oracle Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r2c1-t29" headers="r1c1-t29">
<p><code dir="ltr">CHARACTER(n)</code></p>
</td>
<td class="cellalignment1865" headers="r2c1-t29 r1c2-t29">
<p><code dir="ltr">CHAR(n)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r3c1-t29" headers="r1c1-t29">
<p><code dir="ltr">VARCHAR(n)</code></p>
</td>
<td class="cellalignment1865" headers="r3c1-t29 r1c2-t29">
<p><code dir="ltr">VARCHAR(n)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r4c1-t29" headers="r1c1-t29">
<p><code dir="ltr">LONG VARCHAR</code></p>
</td>
<td class="cellalignment1865" headers="r4c1-t29 r1c2-t29">
<p><code dir="ltr">LONG</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r5c1-t29" headers="r1c1-t29">
<p><code dir="ltr">DECIMAL(p,s)</code> (<span class="bold">Note 1</span>)</p>
</td>
<td class="cellalignment1865" headers="r5c1-t29 r1c2-t29">
<p><code dir="ltr">NUMBER(p,s)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r6c1-t29" headers="r1c1-t29">
<p><code dir="ltr">INTEGER</code></p>
<p><code dir="ltr">SMALLINT</code></p>
</td>
<td class="cellalignment1865" headers="r6c1-t29 r1c2-t29">
<p><code dir="ltr">NUMBER(p,0)</code></p>
</td>
</tr>
<tr class="cellalignment1859">
<td class="cellalignment1865" id="r7c1-t29" headers="r1c1-t29">
<p><code dir="ltr">FLOAT</code> (<span class="bold">Note 2</span>)</p>
</td>
<td class="cellalignment1865" headers="r7c1-t29 r1c2-t29">
<p><code dir="ltr">NUMBER</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p class="subhead2"><a id="SQLRF51004"></a>Notes:</p>
<ol>
<li>
<p>The <code dir="ltr">DECIMAL</code> data type can specify only fixed-point numbers. For this data type, <code dir="ltr"><span class="codeinlineitalic">s</span></code> defaults to 0.</p>
</li>
<li>
<p>The <code dir="ltr">FLOAT</code> data type is a floating-point number with a binary precision <code dir="ltr"><span class="codeinlineitalic">b</span></code>. The default precision for this data type is 126 binary or 38 decimal.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i46376"></a>
<div id="SQLRF30021" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">User-Defined Types <a id="sthref261"></a><a id="sthref262"></a></h2>
<p>User-defined data types use Oracle built-in data types and other user-defined data types as the building blocks of object types that model the structure and behavior of data in applications. The sections that follow describe the various categories of user-defined types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT113" href="../../server.112/e40540/tablecls.htm#CNCPT113"><span class="italic">Oracle Database Concepts</span></a> for information about Oracle built-in data types</p>
</li>
<li>
<p><a href="statements_8001.htm#BABHJHEB">CREATE TYPE</a> and the <a href="statements_8002.htm#i2064997">CREATE TYPE BODY</a> for information about creating user-defined types</p>
</li>
<li>
<p><a class="olink ADOBJ008" href="../../appdev.112/e11822/adobjdes.htm#ADOBJ008"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for information about using user-defined types</p>
</li>
</ul>
</div>
<div id="SQLRF51005" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref263"></a>
<h3 class="sect3">Object Types <a id="sthref264"></a><a id="sthref265"></a><a id="sthref266"></a></h3>
<p>Object types are abstractions of the real-world entities, such as purchase orders, that application programs deal with. An object type is a schema object with three kinds of components:</p>
<ul>
<li>
<p>A <span class="bold">name</span>, which identifies the object type uniquely within that schema.</p>
</li>
<li>
<p><span class="bold">Attributes</span>, which are built-in types or other user-defined types. Attributes model the structure of the real-world entity.</p>
</li>
<li>
<p><span class="bold">Methods</span>, which are functions or procedures written in PL/SQL and stored in the database, or written in a language like C or Java and stored externally. Methods implement operations the application can perform on the real-world entity.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i46417"></a>
<div id="SQLRF51006" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">REF Data Types <a id="sthref267"></a><a id="sthref268"></a><a id="sthref269"></a></h3>
<p>An <span class="bold">object identifier</span> (represented by the keyword <code dir="ltr">OID</code>) uniquely identifies an object and enables you to reference the object from other objects or from relational tables. A data type category called <code dir="ltr">REF</code> represents such references. A <code dir="ltr">REF</code> data type is a container for an object identifier. <code dir="ltr">REF</code> values are pointers to objects.</p>
<p>When a <code dir="ltr">REF</code> value points to a nonexistent object, the <code dir="ltr">REF</code> is said to be "dangling". A dangling <code dir="ltr">REF</code> is different from a null <code dir="ltr">REF</code>. To determine whether a <code dir="ltr">REF</code> is dangling or not, use the condition <code dir="ltr">IS</code> [<code dir="ltr">NOT</code>] <code dir="ltr">DANGLING</code>. For example, given object view <code dir="ltr">oc_orders</code> in the sample schema <code dir="ltr">oe</code>, the column <code dir="ltr">customer_ref</code> is of type <code dir="ltr">REF</code> to type <code dir="ltr">customer_typ</code>, which has an attribute <code dir="ltr">cust_email</code>:</p>
<pre dir="ltr">
SELECT o.customer_ref.cust_email
  FROM oc_orders o 
  WHERE o.customer_ref IS NOT DANGLING;
</pre></div>
<!-- class="sect3" -->
<a id="i46425"></a>
<div id="SQLRF51007" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Varrays <a id="sthref270"></a><a id="sthref271"></a></h3>
<p>An array is an ordered set of data elements. All elements of a given array are of the same data type. Each element has an <span class="bold">index</span>, which is a number corresponding to the position of the element in the array.</p>
<p>The number of elements in an array is the size of the array. Oracle arrays are of variable size, which is why they are called <span class="bold">varrays</span>. You must specify a maximum size when you declare the varray.</p>
<p>When you declare a varray, it does not allocate space. It defines a type, which you can use as:</p>
<ul>
<li>
<p>The data type of a column of a relational table</p>
</li>
<li>
<p>An object type attribute</p>
</li>
<li>
<p>A PL/SQL variable, parameter, or function return type</p>
</li>
</ul>
<p><a id="sthref272"></a>Oracle normally stores an array object either in line (as part of the row data) or out of line (in a LOB), depending on its size. However, if you specify separate storage characteristics for a varray, then Oracle stores it out of line, regardless of its size. Refer to the <a href="statements_7002.htm#i2143624"><span class="xreftitleitalic"><span class="italic">varray_col_properties</span></span></a> of <a href="statements_7002.htm#i2095331">CREATE TABLE</a> for more information about varray storage.</p>
</div>
<!-- class="sect3" -->
<a id="i46449"></a>
<div id="SQLRF51008" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Nested Tables <a id="sthref273"></a><a id="sthref274"></a></h3>
<p>A nested table type models an unordered set of elements. The elements may be built-in types or user-defined types. You can view a nested table as a single-column table or, if the nested table is an object type, as a multicolumn table, with a column for each attribute of the object type.</p>
<p>A nested table definition does not allocate space. It defines a type, which you can use to declare:</p>
<ul>
<li>
<p>The data type of a column of a relational table</p>
</li>
<li>
<p>An object type attribute</p>
</li>
<li>
<p>A PL/SQL variable, parameter, or function return type</p>
</li>
</ul>
<p>When a nested table appears as the type of a column in a relational table or as an attribute of the underlying object type of an object table, Oracle stores all of the nested table data in a single table, which it associates with the enclosing relational or object table.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i54873"></a>
<div id="SQLRF30022" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Oracle-Supplied Types <a id="sthref275"></a></h2>
<p>Oracle provides SQL-based interfaces for defining new types when the built-in or ANSI-supported types are not sufficient. The behavior for these types can be implemented in C/C++, Java, or PL/ SQL. Oracle Database automatically provides the low-level infrastructure services needed for input-output, heterogeneous client-side access for new data types, and optimizations for data transfers between the application and the database.</p>
<p>These interfaces can be used to build user-defined (or object) types and are also used by Oracle to create some commonly useful data types. Several such data types are supplied with the server, and they serve both broad horizontal application areas (for example, the <code dir="ltr">Any</code> types) and specific vertical ones (for example, the spatial types).</p>
<p>The Oracle-supplied types, along with cross-references to the documentation of their implementation and use, are described in the following sections:</p>
<ul>
<li>
<p><a href="#i107578">Any Types</a></p>
</li>
<li>
<p><a href="#i160550">XML Types</a></p>
</li>
<li>
<p><a href="#i107588">Spatial Types</a></p>
</li>
<li>
<p><a href="#i121058">Media Types</a></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i107578"></a>
<div id="SQLRF30023" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Any Types <a id="sthref276"></a></h2>
<p>The <code dir="ltr">Any</code> types provide highly flexible modeling of procedure parameters and table columns where the actual type is not known. These data types let you dynamically encapsulate and access type descriptions, data instances, and sets of data instances of any other SQL type. These types have OCI and PL/SQL interfaces for construction and access.</p>
<div id="SQLRF51009" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref277"></a>
<h3 class="sect3">ANYTYPE</h3>
<p>This type can contain a type description of any named SQL type or unnamed transient type.</p>
</div>
<!-- class="sect3" -->
<div id="SQLRF51010" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref278"></a>
<h3 class="sect3">ANYDATA</h3>
<p>This type contains an instance of a given type, with data, plus a description of the type. <code dir="ltr">ANYDATA</code> can be used as a table column data type and lets you store heterogeneous values in a single column. The values can be of SQL built-in types as well as user-defined types.</p>
</div>
<!-- class="sect3" -->
<div id="SQLRF51011" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref279"></a>
<h3 class="sect3">ANYDATASET</h3>
<p>This type contains a description of a given type plus a set of data instances of that type. <code dir="ltr">ANYDATASET</code> can be used as a procedure parameter data type where such flexibility is needed. The values of the data instances can be of SQL built-in types as well as user-defined types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic">Oracle Database PL/SQL Packages and Types Reference</span> for information on the <a class="olink ARPLS079" href="../../appdev.112/e40758/t_anytyp.htm#ARPLS079"><code dir="ltr">ANYTYPE</code></a>, <a class="olink ARPLS077" href="../../appdev.112/e40758/t_anydat.htm#ARPLS077"><code dir="ltr">ANYDATA</code></a>, and <a class="olink ARPLS078" href="../../appdev.112/e40758/t_anyset.htm#ARPLS078"><code dir="ltr">ANYDATASET</code></a> types</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i160550"></a>
<div id="SQLRF30024" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">XML Types <a id="sthref280"></a></h2>
<p>Extensible Markup Language (XML) is a standard format developed by the World Wide Web Consortium (W3C) for representing structured and unstructured data on the World Wide Web. Universal resource identifiers (URIs) identify resources such as Web pages anywhere on the Web. Oracle provides types to handle XML and URI data, as well as a class of URIs called <code dir="ltr">DBURIRef</code> types to access data stored within the database itself. It also provides a set of types to store and access both external and internal URIs from within the database.</p>
<div id="SQLRF51012" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref281"></a>
<h3 class="sect3">XMLType</h3>
<p>This Oracle-supplied type can be used to store and query XML data in the database. <code dir="ltr">XMLType</code> has member functions you can use to access, extract, and query the XML data using XPath expressions. XPath is another standard developed by the W3C committee to traverse XML documents. Oracle <code dir="ltr">XMLType</code> functions support many W3C XPath expressions. Oracle also provides a set of SQL functions and PL/SQL packages to create <code dir="ltr">XMLType</code> values from existing relational or object-relational data.</p>
<p><code dir="ltr">XMLType</code> is a system-defined type, so you can use it as an argument of a function or as the data type of a table or view column. You can also create tables and views of <code dir="ltr">XMLType</code>. When you create an <code dir="ltr">XMLType</code> column in a table, you can choose to store the XML data in a <code dir="ltr">CLOB</code> column, as binary XML (stored internally as a <code dir="ltr">CLOB</code>), or object relationally.</p>
<p>You can also register the schema (using the <code dir="ltr">DBMS_XMLSCHEMA</code> package) and create a table or column conforming to the registered schema. In this case Oracle stores the XML data in underlying object-relational columns by default, but you can specify storage in a <code dir="ltr">CLOB</code> or binary XML column even for schema-based data.</p>
<p>Queries and DML on <code dir="ltr">XMLType</code> columns operate the same regardless of the storage mechanism.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDB0400" href="../../appdev.112/e23094/xdb04cre.htm#ADXDB0400"><span class="italic">Oracle XML DB Developer's Guide</span></a> for information about using XMLType columns</div>
</div>
<!-- class="sect3" -->
<div id="SQLRF51013" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref282"></a>
<h3 class="sect3">URI Data Types</h3>
<p>Oracle supplies a family of URI types&mdash;<code dir="ltr">URIType</code>, <code dir="ltr">DBURIType</code>, <code dir="ltr">XDBURIType</code>, and <code dir="ltr">HTTPURIType</code>&mdash;which are related by an inheritance hierarchy. <code dir="ltr">URIType</code> is an object type and the others are subtypes of <code dir="ltr">URIType</code>. Since <code dir="ltr">URIType</code> is the supertype, you can create columns of this type and store <code dir="ltr">DBURIType</code> or <code dir="ltr">HTTPURIType</code> type instances in this column.</p>
<p><a id="SQLRF51014"></a><span class="subhead3">HTTPURIType&nbsp;</span>You can use <code dir="ltr">HTTPURIType</code> to store URLs to external Web pages or to files. Oracle accesses these files using HTTP (Hypertext Transfer Protocol).</p>
<p><a id="SQLRF51015"></a><span class="subhead3">XDBURIType&nbsp;</span>You can use <code dir="ltr">XDBURIType</code> to expose documents in the XML database hierarchy as URIs that can be embedded in any <code dir="ltr">URIType</code> column in a table. The <code dir="ltr">XDBURIType</code> consists of a URL, which comprises the hierarchical name of the XML document to which it refers and an optional fragment representing the XPath syntax. The fragment is separated from the URL part by a pound sign (#). The following lines are examples of <code dir="ltr">XDBURIType</code>:</p>
<pre dir="ltr">
/home/oe/doc1.xml
/home/oe/doc1.xml#/orders/order_item
</pre>
<p><a id="SQLRF51016"></a><span class="subhead3">DBURIType&nbsp;</span><code dir="ltr">DBURIType</code> can be used to store <code dir="ltr">DBURIRef</code> values, which reference data inside the database. Storing <code dir="ltr">DBURIRef</code> values lets you reference data stored inside or outside the database and access the data consistently.</p>
<p><code dir="ltr">DBURIRef</code> values use an XPath-like representation to reference data inside the database. If you imagine the database as an XML tree, then you would see the tables, rows, and columns as elements in the XML document. For example, the sample human resources user <code dir="ltr">hr</code> would see the following XML tree:</p>
<pre dir="ltr">
&lt;HR&gt; 
  &lt;EMPLOYEES&gt; 
    &lt;ROW&gt; 
      &lt;EMPLOYEE_ID&gt;205&lt;/EMPLOYEE_ID&gt; 
      &lt;LAST_NAME&gt;Higgins&lt;/LAST_NAME&gt; 
      &lt;SALARY&gt;12008&lt;/SALARY&gt; 
      .. &lt;!-- other columns --&gt; 
    &lt;/ROW&gt; 
    ... &lt;!-- other rows --&gt; 
  &lt;/EMPLOYEES&gt; 
  &lt;!-- other tables..--&gt; 
&lt;/HR&gt; 
&lt;!-- other user schemas on which you have some privilege on..--&gt; 
</pre>
<p>The <code dir="ltr">DBURIRef</code> is an XPath expression over this virtual XML document. So to reference the <code dir="ltr">SALARY</code> value in the <code dir="ltr">EMPLOYEES</code> table for the employee with employee number 205, you can write a <code dir="ltr">DBURIRef</code> as,</p>
<pre dir="ltr">
/HR/EMPLOYEES/ROW[EMPLOYEE_ID=205]/SALARY 
</pre>
<p>Using this model, you can reference data stored in <code dir="ltr">CLOB</code> columns or other columns and expose them as URLs to the external world.</p>
</div>
<!-- class="sect3" -->
<div id="SQLRF51017" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref283"></a>
<h3 class="sect3">URIFactory Package</h3>
<p>Oracle also provides the <code dir="ltr">URIFactory</code> package, which can create and return instances of the various subtypes of the <code dir="ltr">URITypes</code>. The package analyzes the URL string, identifies the type of URL (HTTP, <code dir="ltr">DBURI</code>, and so on), and creates an instance of the subtype. To create a <code dir="ltr">DBURI</code> instance, the URL must start with the prefix <code dir="ltr">/oradb</code>. For example, <code dir="ltr">URIFactory.getURI('/oradb/HR/EMPLOYEES')</code> would create a <code dir="ltr">DBURIType</code> instance and <code dir="ltr">URIFactory.getUri('/sys/schema')</code> would create an <code dir="ltr">XDBURIType</code> instance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADOBJ00205" href="../../appdev.112/e11822/adobjbas.htm#ADOBJ00205"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for general information on object types and type inheritance</p>
</li>
<li>
<p><a class="olink ADXDB1900" href="../../appdev.112/e23094/xdb15dbu.htm#ADXDB1900"><span class="italic">Oracle XML DB Developer's Guide</span></a> for more information about these supplied types and their implementation</p>
</li>
<li>
<p><a class="olink ADQUE0100" href="../../server.112/e11013/aq_intro.htm#ADQUE0100"><span class="italic">Oracle Streams Advanced Queuing User's Guide</span></a> for information about using <code dir="ltr">XMLType</code> with Oracle Advanced Queuing</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i107588"></a>
<div id="SQLRF30025" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Spatial Types <a id="sthref284"></a><a id="sthref285"></a><a id="sthref286"></a><a id="sthref287"></a></h2>
<p>Oracle Spatial is designed to make spatial data management easier and more natural to users of location-enabled applications, geographic information system (GIS) applications, and geoimaging applications. After the spatial data is stored in an Oracle Database, you can easily manipulate, retrieve, and relate it to all the other data stored in the database. The following data types are available only if you have installed Oracle Spatial.</p>
<div id="SQLRF51018" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref288"></a>
<h3 class="sect3">SDO_GEOMETRY</h3>
<p>The geometric description of a spatial object is stored in a single row, in a single column of object type <code dir="ltr">SDO_GEOMETRY</code> in a user-defined table. Any table that has a column of type <code dir="ltr">SDO_GEOMETRY</code> must have another column, or set of columns, that defines a unique primary key for that table. Tables of this sort are sometimes called geometry tables.</p>
<p>The <code dir="ltr">SDO_GEOMETRY</code> object type has the following definition:</p>
<pre dir="ltr">
CREATE TYPE SDO_GEOMETRY AS OBJECT
  (sgo_gtype        NUMBER, 
   sdo_srid         NUMBER,
   sdo_point        SDO_POINT_TYPE,
   sdo_elem_info    SDO_ELEM_INFO_ARRAY,
   sdo_ordinates    SDO_ORDINATE_ARRAY);
/
</pre></div>
<!-- class="sect3" -->
<a id="CHDFDHJI"></a>
<div id="SQLRF51019" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">SDO_TOPO_GEOMETRY <a id="sthref289"></a><a id="sthref290"></a></h3>
<p>This type describes a topology geometry, which is stored in a single row, in a single column of object type <code dir="ltr">SDO_TOPO_GEOMETRY</code> in a user-defined table.</p>
<p>The <code dir="ltr">SDO_TOPO_GEOMETRY</code> object type has the following definition:</p>
<pre dir="ltr">
CREATE TYPE SDO_TOPO_GEOMETRY AS OBJECT
  (tg_type        NUMBER, 
   tg_id          NUMBER,
   tg_layer_id    NUMBER,
   topology_id    NUMBER);
/
</pre></div>
<!-- class="sect3" -->
<a id="i129279"></a>
<div id="SQLRF51020" class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">SDO_GEORASTER</h3>
<p>In the GeoRaster object-relational model, a raster grid or image object is stored in a single row, in a single column of object type <code dir="ltr">SDO_GEORASTER</code> in a user-defined table. Tables of this sort are called GeoRaster tables.</p>
<p>The <code dir="ltr">SDO_GEORASTER</code> object type has the following definition:</p>
<pre dir="ltr">
CREATE TYPE SDO_GEORASTER AS OBJECT
  (rasterType         NUMBER,
   spatialExtent      SDO_GEOMETRY,
   rasterDataTable    VARCHAR2(32),
   rasterID           NUMBER,
   metadata           XMLType);
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SPATL020" href="../../appdev.112/e11830/sdo_objrelschema.htm#SPATL020"><span class="italic">Oracle Spatial Developer's Guide</span></a>, <a class="olink TOPOL100" href="../../appdev.112/e11831/sdo_topo_concepts.htm#TOPOL100"><span class="italic">Oracle Spatial Topology and Network Data Models Developer's Guide</span></a>, and <a class="olink GEORS200" href="../../appdev.112/e11827/geor_datatypes_metadata.htm#GEORS200"><span class="italic">Oracle Spatial GeoRaster Developer's Guide</span></a> for information on the full implementation of the spatial data types and guidelines for using them</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i121058"></a>
<div id="SQLRF30026" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Media Types <a id="sthref291"></a></h2>
<p>Oracle Multimedia uses object types, similar to Java or C++ classes, to describe multimedia data. An instance of these object types consists of attributes, including metadata and the media data, and methods. The Multimedia data types are created in the <code dir="ltr">ORDSYS</code> schema. Public synonyms exist for all the data types, so you can access them without specifying the schema name.</p>
<p>Oracle Multimedia provides the following object types:</p>
<ul>
<li>
<p><code dir="ltr">ORDAudio</code><a id="sthref292"></a></p>
<p>Supports the storage and management of audio data.</p>
</li>
<li>
<p><code dir="ltr">ORDDicom</code><a id="sthref293"></a></p>
<p>Supports the storage and management of Digital Imaging and Communications in Medicine (DICOM), the format universally recognized as the standard for medical imaging.</p>
</li>
<li>
<p><code dir="ltr">ORDDoc</code><a id="sthref294"></a></p>
<p>Supports storage and management of any type of media data, including audio, image and video data. Use this type when you want all media to be stored in a single column.</p>
</li>
<li>
<p><code dir="ltr">ORDImage</code><a id="sthref295"></a></p>
<p>Supports the storage and management of image data.</p>
</li>
<li>
<p><code dir="ltr">ORDVideo</code><a id="sthref296"></a></p>
<p>Supports the storage and management of video data.</p>
</li>
<li>
<p><code dir="ltr">ORDImageSignature</code><a id="sthref297"></a></p>
<p>The <code dir="ltr">ORDImageSignature</code> object type has been deprecated and should no longer be introduced into your code. Existing occurrences of this object type will continue to function as in the past.</p>
</li>
</ul>
<p>The following data types provide compliance with the ISO-IEC 13249-5 Still Image standard, commonly referred to as SQL/MM StillImage:</p>
<ul>
<li>
<p><code dir="ltr">SI_AverageColor</code><a id="sthref298"></a></p>
<p>Represents a feature that characterizes an image by its average color.</p>
</li>
<li>
<p><code dir="ltr">SI_Color</code><a id="sthref299"></a></p>
<p>Encapsulates color values.</p>
</li>
<li>
<p><code dir="ltr">SI_ColorHistogram</code><a id="sthref300"></a></p>
<p>Represents a feature that characterizes an image by the relative frequencies of the colors exhibited by samples of the raw image.</p>
</li>
<li>
<p><code dir="ltr">SI_FeatureList</code><a id="sthref301"></a></p>
<p>A list containing up to four of the image features represented by the preceding object types (<code dir="ltr">SI_AverageColor</code>, <code dir="ltr">SI_ColorHistogram</code>, <code dir="ltr">SI_PositionalColor</code>, and <code dir="ltr">SI_Texture</code>), where each feature is associated with a feature weight.</p>
</li>
<li>
<p><code dir="ltr">SI_PositionalColor</code><a id="sthref302"></a></p>
<p>Given an image divided into <code dir="ltr">n</code> by <code dir="ltr">m</code> rectangles, the <code dir="ltr">SI_PositionalColor</code> object type represents the feature that characterizes an image by the <code dir="ltr">n</code> by <code dir="ltr">m</code> most significant colors of the rectangles.</p>
</li>
<li>
<p><code dir="ltr">SI_StillImage</code><a id="sthref303"></a></p>
<p>Represents digital images with inherent image characteristics such as height, width, and format.</p>
</li>
<li>
<p><code dir="ltr">SI_Texture</code><a id="sthref304"></a></p>
<p>Represents a feature that characterizes an image by the size of repeating items (coarseness), brightness variations (contrast), and predominant direction (directionality).</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink IMDCM4000" href="../../appdev.112/e10778/ch_dev_ref.htm#IMDCM4000"><span class="italic">Oracle Multimedia DICOM Developer's Guide</span></a> for information on the <code dir="ltr">ORDDicom</code> object type</p>
</li>
<li>
<p><a class="olink AIVUG" href="../../appdev.112/e10776/toc.htm"><span class="italic">Oracle Multimedia Reference</span></a> for information on all other object types listed in this section</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i159408"></a>
<div id="SQLRF51034" class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Expression Filter Type</h2>
<p>The Oracle Expression Filter allows application developers to manage and evaluate conditional expressions that describe users' interests in data. The Expression Filter includes the following data type:</p>
<div id="SQLRF51035" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref305"></a>
<h3 class="sect3">Expression</h3>
<p>Expression Filter uses a virtual data type called <code dir="ltr">Expression</code> to manage and evaluate conditional expressions as data in database tables. The Expression Filter creates a column of <code dir="ltr">Expression</code> data type from a <code dir="ltr">VARCHAR2</code> column by assigning an attribute set to the column. This assignment enables a data constraint that ensures the validity of expressions stored in the column.</p>
<p>You can define conditions using the <code dir="ltr">EVALUATE</code> operator on an <code dir="ltr">Expression</code> data type to evaluate the expressions stored in a column for some data. If you are using Enterprise Edition, then you can also define an Expression Filter index on a column of <code dir="ltr">Expression</code> data type to process queries using the <code dir="ltr">EVALUATE</code> operator.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink EXPRN007" href="../../appdev.112/e14919/exprn_expconcepts.htm#EXPRN007"><span class="italic">Oracle Database Rules Manager and Expression Filter Developer's Guide</span></a> for more information on the Expression Filter</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1858">
<tr>
<td class="cellalignment1865">
<table class="cellalignment1863">
<tr>
<td class="cellalignment1862"><a href="sql_elements.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1862"><a href="sql_elements002.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1867">
<table class="cellalignment1861">
<tr>
<td class="cellalignment1862"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1862"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1862"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1862"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1862"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1862"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
