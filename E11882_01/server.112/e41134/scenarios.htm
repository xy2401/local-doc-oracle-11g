<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Data Guard Scenarios</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="dcterms.created" content="2014-02-25T8:43:2Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Data Guard Concepts and Administration" />
<meta name="dcterms.identifier" content="E41134-03" />
<meta name="dcterms.isVersionOf" content="SBYDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="rollup.htm" title="Previous" type="text/html" />
<link rel="Next" href="partpage2.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41134.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">21/34</span> <!-- End Header -->
<div id="SBYDB00900" class="chapter"><a id="i1008082"></a>
<h1 class="chapter"><span class="secnum">13</span> Data Guard Scenarios</h1>
<p>This chapter describes scenarios you might encounter while administering your Data Guard configuration. Each scenario can be adapted to your specific environment. <a href="#g1077484">Table 13-1</a> lists the scenarios presented in this chapter.</p>
<div id="SBYDB5073" class="tblruleformal">
<p class="titleintable"><a id="sthref900"></a><a id="g1077484"></a>Table 13-1 Data Guard Scenarios</p>
<table class="cellalignment1823" title="Data Guard Scenarios" summary="Lists the scenarios presented in this chapter, with each one providing a link to the scenario." dir="ltr">
<thead>
<tr class="cellalignment1814">
<th class="cellalignment1824" id="r1c1-t2">Reference</th>
<th class="cellalignment1824" id="r1c2-t2">Scenario</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r2c1-t2" headers="r1c1-t2">
<p><a href="#CIHEIIEA">Section 13.1</a></p>
</td>
<td class="cellalignment1820" headers="r2c1-t2 r1c2-t2">
<p><a href="#CIHEIIEA">Configuring Logical Standby Databases After a Failover</a></p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r3c1-t2" headers="r1c1-t2">
<p><a href="#i1049997">Section 13.2</a></p>
</td>
<td class="cellalignment1820" headers="r3c1-t2 r1c2-t2">
<p><a href="#i1049997">Converting a Failed Primary Into a Standby Database Using Flashback Database</a></p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r4c1-t2" headers="r1c1-t2">
<p><a href="#i1049616">Section 13.3</a></p>
</td>
<td class="cellalignment1820" headers="r4c1-t2 r1c2-t2">
<p><a href="#i1049616">Using Flashback Database After Issuing an Open Resetlogs Statement</a></p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r5c1-t2" headers="r1c1-t2">
<p><a href="#i1015738">Section 13.4</a></p>
</td>
<td class="cellalignment1820" headers="r5c1-t2 r1c2-t2">
<p><a href="#i1015738">Recovering After the NOLOGGING Clause Is Specified</a></p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r6c1-t2" headers="r1c1-t2">
<p><a href="#i1067236">Section 13.5</a></p>
</td>
<td class="cellalignment1820" headers="r6c1-t2 r1c2-t2">
<p><a href="#i1067236">Creating a Standby Database That Uses OMF or Oracle ASM</a></p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r7c1-t2" headers="r1c1-t2">
<p><a href="#BACJHHFF">Section 13.6</a></p>
</td>
<td class="cellalignment1820" headers="r7c1-t2 r1c2-t2">
<p><a href="#BACJHHFF">Recovering From Lost-Write Errors on a Primary Database</a></p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r8c1-t2" headers="r1c1-t2">
<p><a href="#BACJCDGH">Section 13.7</a></p>
</td>
<td class="cellalignment1820" headers="r8c1-t2 r1c2-t2">
<p><a href="#BACJCDGH">Converting a Failed Primary into a Standby Database Using RMAN Backups</a></p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r9c1-t2" headers="r1c1-t2">
<p><a href="#CIHCAIGA">Section 13.8</a></p>
</td>
<td class="cellalignment1820" headers="r9c1-t2 r1c2-t2">
<p><a href="#CIHCAIGA">Changing the Character Set of a Primary Without Re-Creating Physical Standbys</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<a id="CIHEIIEA"></a>
<div id="SBYDB4885" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">13.1</span> Configuring Logical Standby Databases After a Failover</h2>
<p>This section presents the steps required on a logical standby database after the primary database has failed over to another standby database. After a failover has occurred, a logical standby database cannot act as a standby database for the new primary database until it has applied the final redo from the original primary database. This is similar to the way the new primary database applied the final redo during the failover. The steps you must perform depend on whether the new primary database was a physical standby or a logical standby database prior to the failover:</p>
<ul>
<li>
<p><a href="#CIHCIBAB">Section 13.1.1, "When the New Primary Database Was Formerly a Physical Standby Database"</a></p>
</li>
<li>
<p><a href="#CIHGHFFF">Section 13.1.2, "When the New Primary Database Was Formerly a Logical Standby Database"</a></p>
</li>
</ul>
<a id="CIHCIBAB"></a>
<div id="SBYDB4886" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.1.1</span> When the New Primary Database Was Formerly a Physical Standby Database</h3>
<p>This scenario demonstrates how to configure a logical standby database to support a new primary database that was a physical standby database before it assumed the primary role. In this scenario, SAT is the logical standby database and NYC is the primary database.</p>
<dl>
<dd><a id="SBYDB5230"></a><a id="sthref901"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Configure the FAL_SERVER parameter to enable automatic recovery of log files.</dt>
<dd>
<p>On the SAT database, issue the following statement:</p>
<pre>
SQL&gt; ALTER SYSTEM SET FAL_SERVER='&lt;tns_name_to_new_primary&gt;';
</pre></dd>
<dd><a id="SBYDB5231"></a><a id="CIHFFDCF"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Verify the logical standby database is capable of serving as a standby database to the new primary database.</dt>
<dd>
<p>Call the <code>PREPARE_FOR_NEW_PRIMARY</code> routine to verify and make ready the local logical standby for configuration with the new primary. During this step, local copies of log files that pose a risk for data divergence are deleted from the local database. These log files are then requested for re-archival directly from the new primary database.</p>
<p>On the SAT database, issue the following statement:</p>
<pre>
SQL&gt; EXECUTE DBMS_LOGSTDBY.PREPARE_FOR_NEW_PRIMARY( -
&gt;  former_standby_type =&gt; 'PHYSICAL' -
&gt;  dblink =&gt; 'nyc_link');
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the <code>ORA-16109</code> message is returned and the 'LOGSTDBY: prepare_for_new_primary failure -- applied too far, flashback required.' warning is written in the alert.log, perform the following steps:
<ol>
<li>
<p>Flash back the database to the SCN as stated in the warning and then</p>
</li>
<li>
<p>Repeat this step before continuing.</p>
</li>
</ol>
<p>See <a href="#CIHDGEJE">Section 13.2.3</a> for an example of how to flash back a logical standby database to an Apply SCN.</p>
</div>
</dd>
<dd><a id="SBYDB5232"></a><a id="sthref902"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Start SQL Apply.</dt>
<dd>
<p>On the SAT database, issue the following statement:</p>
<pre>
SQL&gt; START LOGICAL STANDBY APPLY IMMEDIATE;
</pre></dd>
</dl>
</div>
<!-- class="sect2" -->
<a id="CIHGHFFF"></a>
<div id="SBYDB4887" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.1.2</span> When the New Primary Database Was Formerly a Logical Standby Database</h3>
<p>This scenario demonstrates how to configure a logical standby database to support a new primary database that was a logical standby database before it assumed the primary role. In this scenario, SAT is the logical standby database and NYC is the primary database.</p>
<dl>
<dd><a id="SBYDB5233"></a><a id="sthref903"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Ensure the new primary database is ready to support logical standby databases.</dt>
<dd>
<p>On the NYC database, ensure the following query returns a value of <code>READY</code>. Otherwise the new primary database has not completed the work required to enable support for logical standby databases. For example:</p>
<pre>
SQL&gt; SELECT VALUE FROM SYSTEM.LOGSTDBY$PARAMETERS - 
&gt;   WHERE NAME = 'REINSTATEMENT_STATUS';
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the <code>VALUE</code> column contains <code>NOT POSSIBLE</code> it means that no logical standby database may be configured with the new primary database, and you must reinstate the database.</div>
</dd>
<dd><a id="SBYDB5234"></a><a id="sthref904"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Configure the FAL_SERVER parameter to enable automatic recovery of log files.</dt>
<dd>
<p>On the SAT database, issue the following statement:</p>
<pre>
SQL&gt; ALTER SYSTEM SET FAL_SERVER='&lt;tns_name_to_new_primary&gt;';
</pre></dd>
<dd><a id="SBYDB5235"></a><a id="CIHDAGCF"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Verify the logical standby database is capable of being a standby to the new primary.</dt>
<dd>
<p>Call the <code>PREPARE_FOR_NEW_PRIMARY</code> routine to verify and make ready the local logical standby for configuration with the new primary. During this step, local copies of log files which pose a risk for data divergence are deleted from the local database. These log files are then requested for re-archival directly from the new primary database.</p>
<p>On the SAT database, issue the following statement:</p>
<pre>
SQL&gt; EXECUTE DBMS_LOGSTDBY.PREPARE_FOR_NEW_PRIMARY( -
&gt; former_standby_type =&gt; 'LOGICAL' -
&gt; dblink =&gt; 'nyc_link');
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the <code>ORA-16109</code> message is returned and the 'LOGSTDBY: prepare_for_new_primary failure -- applied too far, flashback required.' warning is written in the alert.log file, perform the following steps:
<ol>
<li>
<p>Flash back the database to the SCN as stated in the warning and then</p>
</li>
<li>
<p>Repeat this step before continuing.</p>
</li>
</ol>
<p>See <a href="#CIHDGEJE">Section 13.2.3</a> for an example of how to flash back a logical standby database to an Apply SCN.</p>
</div>
</dd>
<dd><a id="SBYDB5236"></a><a id="sthref905"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;Start SQL Apply.</dt>
<dd>
<p>On the SAT database, issue the following statements:</p>
<pre>
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY NEW PRIMARY nyc_link;
</pre>
<p>Note that you must always issue this statement without the real-time apply option enabled. If you want to enable real-time apply on the logical standby database, wait for the above statement to complete successfully, and then issue the following statements:</p>
<pre>
SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
</pre></dd>
</dl>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1049997"></a>
<div id="SBYDB00910" class="sect1">
<h2 class="sect1"><span class="secnum">13.2</span> Converting a Failed Primary Into a Standby Database Using Flashback Database</h2>
<p>After a failover occurs, the original primary database can no longer participate in the Data Guard configuration until it is repaired and established as a standby database in the new configuration. To do this, you can use the Flashback Database feature to recover the failed primary database to a point in time before the failover occurred, and then convert it into a physical or logical standby database in the new configuration. The following sections describe:</p>
<ul>
<li>
<p><a href="#i1050055">Flashing Back a Failed Primary Database into a Physical Standby Database</a></p>
</li>
<li>
<p><a href="#CIHEDFHH">Flashing Back a Failed Primary Database into a Logical Standby Database</a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must have already enabled Flashback Database on the original primary database before the failover. See <a class="olink BRADV" href="../../backup.112/e10642/toc.htm"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information.</div>
</li>
<li>
<p><a href="#CIHDGEJE">Flashing Back a Logical Standby Database to a Specific Applied SCN</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DGBKR" href="../e40771/toc.htm"><span class="italic">Oracle Data Guard Broker</span></a> for automatic reinstatement of the failed primary database as a new standby database (as an alternative to using Flashback Database)</div>
</li>
</ul>
<a id="i1050055"></a>
<div id="SBYDB4888" class="sect2">
<h3 class="sect2"><span class="secnum">13.2.1</span> Flashing Back <a id="sthref906"></a><a id="sthref907"></a><a id="sthref908"></a>a Failed Primary Database into a Physical Standby Database</h3>
<p>The following steps assume that a failover has been performed to a physical standby database and that Flashback Database was enabled on the old primary database at the time of the failover. This procedure brings the old primary database back into the Data Guard configuration as a physical standby database.</p>
<a id="i1048898"></a>
<dl>
<dd><a id="SBYDB5237"></a><a id="CIHHJCHD"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Determine the SCN at which the old standby database became the primary database.</dt>
<dd>
<p>On the new primary database, issue the following query to determine the SCN at which the old standby database became the new primary database:</p>
<pre>
SQL&gt; SELECT TO_CHAR(STANDBY_BECAME_PRIMARY_SCN) FROM V$DATABASE;
</pre></dd>
<dd><a id="SBYDB5238"></a><a id="sthref909"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Flash back the failed primary database.</dt>
<dd>
<p>Shut down the old primary database (if necessary), mount it, and flash it back to the value for <code>STANDBY_BECAME_PRIMARY_SCN</code> that was determined in <a href="#CIHHJCHD">Step 1</a>.</p>
<pre>
SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
SQL&gt; FLASHBACK DATABASE TO SCN <span class="variable">standby_became_primary_scn</span>;
</pre></dd>
<dd><a id="SBYDB5239"></a><a id="sthref910"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Convert the database to a physical standby database.</dt>
<dd>
<p>Perform the following steps on the old primary database:</p>
<ol>
<li>
<p>Issue the following statement on the old primary database:</p>
<pre>
SQL&gt; ALTER DATABASE CONVERT TO PHYSICAL STANDBY;
</pre>
<p>This statement will dismount the database after successfully converting the control file to a standby control file.</p>
</li>
<li>
<p>Shut down and restart the database:</p>
<pre>
SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
</pre></li>
</ol>
</dd>
<dd><a id="SBYDB5240"></a><a id="sthref911"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;Start transporting redo to the new physical standby database.</dt>
<dd>
<p>Perform the following steps on the new primary database:</p>
<ol>
<li>
<p>Issue the following query to see the current state of the archive destinations:</p>
<pre>
SQL&gt; SELECT DEST_ID, DEST_NAME, STATUS, PROTECTION_MODE, DESTINATION, -
&gt; ERROR,SRL FROM V$ARCHIVE_DEST_STATUS;
</pre>
<pre>
</pre></li>
<li>
<p>If necessary, enable the destination:</p>
<pre>
SQL&gt; ALTER SYSTEM SET LOG_ARCHIVE_DEST_STATE_<span class="variable">n</span>=ENABLE;
</pre></li>
<li>
<p>Perform a log switch to ensure the standby database begins receiving redo data from the new primary database, and verify it was sent successfully. Issue the following SQL statements on the new primary database:</p>
<pre>
SQL&gt; ALTER SYSTEM SWITCH LOGFILE;
SQL&gt; SELECT DEST_ID, DEST_NAME, STATUS, PROTECTION_MODE, DESTINATION,- 
&gt; ERROR,SRL FROM V$ARCHIVE_DEST_STATUS;
</pre>
<p>On the new standby database, you may also need to change the <code>LOG_ARCHIVE_DEST_</code><code><span class="codeinlineitalic">n</span></code> initialization parameters so that redo transport services do not transmit redo data to other databases.</p>
</li>
</ol>
</dd>
<dd><a id="SBYDB5241"></a><a id="sthref912"></a></dd>
<dt class="seghead">Step 5&nbsp;&nbsp;&nbsp;Start Redo Apply on the new physical standby database.</dt>
<dd>
<p>Issue the following SQL statement on the new physical standby database:</p>
<pre>
SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE -
&gt; USING CURRENT LOGFILE DISCONNECT;
</pre>
<p>Redo Apply automatically stops each time it encounters a redo record that is generated as the result of a role transition, so Redo Apply will need to be restarted one or more times until it has applied beyond the SCN at which the new primary database became the primary database. Once the failed primary database is restored and is running in the standby role, you can optionally perform a switchover to transition the databases to their original (pre-failure) roles. See <a href="role_management.htm#i1026464">Section 8.2.1, "Performing a Switchover to a Physical Standby Database"</a> for more information.</p>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<a id="CIHEDFHH"></a>
<div id="SBYDB4889" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.2.2</span> Flashing Back a Failed Primary Database into a Logical Standby Database</h3>
<p>These steps assume that the Data Guard configuration has already completed a failover involving a logical standby database and that Flashback Database has been enabled on the old primary database. This procedure brings the old primary database back into the Data Guard configuration as a new logical standby database without having to formally instantiate it from the new primary database.</p>
<dl>
<dd><a id="SBYDB5242"></a><a id="sthref913"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Determine the flashback SCN and the recovery SCN.</dt>
<dd>
<p>The flashback SCN is the SCN to which the failed primary database will be flashed back. The recovery SCN is the SCN to which the failed primary database will be recovered. Issue the following query on the new primary to identify these SCNs:</p>
<pre>
SQL&gt; SELECT merge_change# AS FLASHBACK_SCN, processed_change# AS RECOVERY_SCN -
&gt; FROM DBA_LOGSTDBY_HISTORY -
&gt; WHERE stream_sequence# = (SELECT MAX(stream_sequence#)-1 -
&gt; FROM DBA_LOGSTDBY_HISTORY);
</pre></dd>
<dd><a id="SBYDB5243"></a><a id="sthref914"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Flash back the failed primary database to the flashback SCN identified in Step 1.</dt>
<dd>
<pre>
SQL&gt; FLASHBACK DATABASE TO SCN <span class="italic">flashback_scn</span>;
</pre></dd>
<dd><a id="SBYDB5244"></a><a id="sthref915"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Convert the failed primary into a physical standby, and remount the standby database in preparation for recovery.</dt>
<dd>
<pre>
SQL&gt; ALTER DATABASE CONVERT TO PHYSICAL STANDBY;
SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
</pre></dd>
<dd><a id="SBYDB5245"></a><a id="sthref916"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;Configure the FAL_SERVER parameter to enable automatic recovery of log files.</dt>
<dd>
<p>On the physical standby (failed primary) issue the following statement:</p>
<pre>
SQL&gt; ALTER SYSTEM SET FAL_SERVER='&lt;tns_name_to_new_primary&gt;';
</pre></dd>
<dd><a id="SBYDB5246"></a><a id="sthref917"></a></dd>
<dt class="seghead">Step 5&nbsp;&nbsp;&nbsp;Remove divergent archive logs from the failed primary database.</dt>
<dd>
<p>Remove any archive logs created at the time of or, after the failover operation, from the failed primary database. If the failed primary database was isolated from the standby, it could have divergent archive logs that are not consistent with the current primary database. To ensure these divergent archive logs are never applied, they must be deleted from backups and the fast recovery area. You can use the following RMAN command to delete the relevant archive logs from the fast recovery area:</p>
<pre>
RMAN&gt; DELETE FORCE ARCHIVELOG FROM SCN ARCHIVE_SCN;
</pre>
<p>Once deleted, these divergent logs and subsequent transactions can never be recovered.</p>
</dd>
<dd><a id="SBYDB5247"></a><a id="sthref918"></a></dd>
<dt class="seghead">Step 6&nbsp;&nbsp;&nbsp;Recover until the recovery SCN identified in Step 1.</dt>
<dd>
<pre>
SQL&gt; RECOVER MANAGED STANDBY DATABASE UNTIL CHANGE <span class="italic">recovery_scn</span>;
</pre></dd>
<dd><a id="SBYDB5248"></a><a id="sthref919"></a></dd>
<dt class="seghead">Step 7&nbsp;&nbsp;&nbsp;Enable the database guard.</dt>
<dd>
<pre>
SQL&gt; ALTER DATABASE GUARD ALL;
</pre></dd>
<dd><a id="SBYDB5249"></a><a id="sthref920"></a></dd>
<dt class="seghead">Step 8&nbsp;&nbsp;&nbsp;Activate the physical standby to become a primary database.</dt>
<dd>
<pre>
SQL&gt; ALTER DATABASE ACTIVATE STANDBY DATABASE;
</pre></dd>
<dd><a id="SBYDB5250"></a><a id="sthref921"></a></dd>
<dt class="seghead">Step 9&nbsp;&nbsp;&nbsp;Open the database.</dt>
<dd>
<pre>
SQL&gt; ALTER DATABASE OPEN;
</pre></dd>
<dd><a id="SBYDB5251"></a><a id="sthref922"></a></dd>
<dt class="seghead">Step 10&nbsp;&nbsp;&nbsp;Create a database link to the new primary, and start SQL Apply.</dt>
<dd>
<pre>
SQL&gt; CREATE PUBLIC DATABASE LINK <span class="italic">mylink</span> -
&gt; CONNECT TO <span class="italic">system</span> IDENTIFIED BY <span class="italic">password</span> -
&gt; USING '<span class="italic">service_name_of_new_primary_database</span>';

SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY NEW PRIMARY <span class="italic">mylink</span>;
</pre>
<p>The role reversal is now complete.</p>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<a id="CIHDGEJE"></a>
<div id="SBYDB4890" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.2.3</span> Flashing Back a Logical Standby Database to a Specific Applied SCN</h3>
<p>One of the benefits of a standby database is that Flashback Database can be performed on the standby database without affecting the primary database service. Flashing back a database to a specific point in time is a straightforward task, however on a logical standby database, you may want to flash back to a time just before a known transaction was committed. Such a need can arise when configuring a logical standby database with a new primary database after a failover.</p>
<p>The following steps describe how to use Flashback Database and SQL Apply to recover to a known applied SCN.</p>
<dl>
<dd><a id="SBYDB5252"></a><a id="CIHJAEEJ"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Once you have determined the known SCN at the primary (APPLIED_SCN), issue the following query to determine the corresponding SCN at the logical standby database, to use for the flashback operation:</dt>
<dd>
<pre>
SQL&gt; SELECT DBMS_LOGSTDBY.MAP_PRIMARY_SCN (PRIMARY_SCN =&gt; APPLIED_SCN) -
&gt; AS TARGET_SCN FROM DUAL;
</pre></dd>
<dd><a id="SBYDB5253"></a><a id="sthref923"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Flash back the logical standby to the TARGET_SCN returned.</dt>
<dd>
<p>Issue the following SQL statements to flash back the logical standby database to the specified SCN, and open the logical standby database with the RESETLOGS option:</p>
<pre>
SQL&gt; SHUTDOWN;
SQL&gt; STARTUP MOUNT EXCLUSIVE;
SQL&gt; FLASHBACK DATABASE TO SCN &lt;TARGET_SCN&gt;;
SQL&gt; ALTER DATABASE OPEN RESETLOGS;
</pre></dd>
<dd><a id="SBYDB5254"></a><a id="sthref924"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Confirm SQL Apply has applied less than or up to the APPLIED_SCN.</dt>
<dd>
<p>Issue the following query:</p>
<pre>
SQL&gt; SELECT APPLIED_SCN FROM V$LOGSTDBY_PROGRESS;
</pre></dd>
</dl>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1049616"></a>
<div id="SBYDB4891" class="sect1">
<h2 class="sect1"><span class="secnum">13.3</span> Using Flashback Database After Issuing an Open Resetlogs Statement<a id="sthref925"></a><a id="sthref926"></a></h2>
<p>Suppose an error has occurred on the primary database in a Data Guard configuration in which the standby database is using real-time apply. In this situation, the same error will be applied on the standby database.</p>
<p>However, if Flashback Database is enabled, you can revert the primary and standby databases back to their pre-error condition by issuing the <code>FLASHBACK DATABASE</code> and <code>OPEN RESETLOGS</code> statements on the primary database, and then issuing a similar <code>FLASHBACK STANDBY DATABASE</code> statement on the standby database before restarting apply services. (If Flashback Database is not enabled, you need to re-create the standby database, as described in <a href="create_ps.htm#g88234">Chapter 3</a> and <a href="create_ls.htm#g105412">Chapter 4</a>, after the point-in-time recovery was performed on the primary database.)</p>
<a id="i1067797"></a>
<div id="SBYDB4892" class="sect2">
<h3 class="sect2"><span class="secnum">13.3.1</span> Flashing Back a Physical Standby Database to a Specific Point-in-Time</h3>
<p>The following steps describe how to avoid re-creating a physical standby database after you issued the <code>OPEN RESETLOGS</code> statement on the primary database.</p>
<dl>
<dd><a id="SBYDB5255"></a><a id="sthref927"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Determine the SCN before the RESETLOGS operation occurred.</dt>
<dd id="i1059312">
<p>On the primary database, use the following query to obtain the value of the system change number (SCN) that is 2 SCNs before the <code>RESETLOGS</code> operation occurred on the primary database:</p>
<pre>
SQL&gt; SELECT TO_CHAR(RESETLOGS_CHANGE# - 2) FROM V$DATABASE;
</pre></dd>
<dd><a id="SBYDB5256"></a><a id="sthref928"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Obtain the current SCN on the standby database.</dt>
<dd id="i1051532">
<p>On the standby database, obtain the current SCN with the following query:</p>
<pre>
SQL&gt; SELECT TO_CHAR(CURRENT_SCN) FROM V$DATABASE;
</pre></dd>
<dd><a id="SBYDB5257"></a><a id="sthref929"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Determine if it is necessary to flash back the database.</dt>
<dd>
<p>If the value of <code>CURRENT_SCN</code> is larger than the value of resetlogs_change# - 2, issue the following statement to flash back the standby database.</p>
<pre>
SQL&gt; FLASHBACK STANDBY DATABASE TO SCN resetlogs_change# -2;
</pre>
<ul>
<li>
<p>If the value of <code>CURRENT_SCN</code> is less than the value of the resetlogs_change# - 2, skip to Step <a href="#CIHDEEDE">4</a>.</p>
</li>
<li>
<p>If the standby database's SCN is far enough behind the primary database's SCN, and the new branch of redo from the <code>OPEN RESETLOGS</code> statement has been registered at the standby, apply services will be able to continue through the <code>OPEN RESETLOGS</code> statement without stopping. In this case, flashing back the database is unnecessary because apply services do not stop upon reaching the <code>OPEN RESETLOGS</code> statement in the redo data.</p>
</li>
</ul>
</dd>
<dd><a id="SBYDB5258"></a><a id="CIHDEEDE"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;Restart Redo Apply.</dt>
<dd>
<p>To start Redo Apply on the physical standby database, issue the following statement:</p>
<pre>
SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE -
&gt; USING CURRENT LOGFILE DISCONNECT;
</pre>
<p>The standby database is now ready to receive and apply redo from the primary database.</p>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<a id="CIHDJICD"></a>
<div id="SBYDB4893" class="sect2">
<h3 class="sect2"><span class="secnum">13.3.2</span> Flashing Back a Logical Standby Database to a Specific Point-in-Time</h3>
<p>The following steps describe how to avoid re-creating a logical standby database after you have flashed back the primary database and opened it by issuing an <code>OPEN RESETLOGS</code> statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If SQL Apply detects the occurrence of a resetlogs operation at the primary database, it automatically mines the correct branch of redo, if it is possible to do so without having to flashback the logical standby database. Otherwise, SQL Apply stops with an error <code>ORA-1346: LogMiner processed redo beyond specified reset log scn</code>. In this section, it is assumed that SQL Apply has already stopped with such an error.</div>
<dl>
<dd><a id="SBYDB5259"></a><a id="CIHCHBJH"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Determine the SCN at the primary database.</dt>
<dd>
<p>On the primary database, use the following query to obtain the value of the system change number (SCN) that is 2 SCNs before the <code>RESETLOGS</code> operation occurred on the primary database:</p>
<pre>
SQL&gt; SELECT TO_CHAR(RESETLOGS_CHANGE# - 2) AS FLASHBACK_SCN FROM V$DATABASE;
</pre></dd>
<dd><a id="SBYDB5260"></a><a id="sthref930"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Determine the target SCN for flashback operation at the logical standby.</dt>
<dd>
<p>In this step, the <code>FLASHBACK_SCN</code> value for <code>PRIMARY_SCN</code> is from Step 1.</p>
<pre>
SQL&gt; SELECT DBMS_LOGSTDBY.MAP_PRIMARY_SCN (PRIMARY_SCN =&gt; FLASHBACK_SCN) -
&gt; AS TARGET_SCN FROM DUAL;
</pre></dd>
<dd><a id="SBYDB5261"></a><a id="CIHGACIF"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Flash back the logical standby to the TARGET_SCN returned.</dt>
<dd>
<p>Issue the following SQL statements to flash back the logical standby database to the specified SCN, and open the logical standby database with the <code>RESETLOGS</code> option:</p>
<pre>
SQL&gt; SHUTDOWN;
SQL&gt; STARTUP MOUNT EXCLUSIVE;
SQL&gt; FLASHBACK DATABASE TO SCN &lt;TARGET_SCN&gt;;
SQL&gt; ALTER DATABASE OPEN RESETLOGS;
</pre></dd>
<dd><a id="SBYDB5262"></a><a id="sthref931"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;Confirm that a log file from the primary's new branch is registered before SQL apply is started.</dt>
<dd>
<p>Issue the following query on the primary database:</p>
<pre>
SQL&gt; SELECT resetlogs_id FROM V$DATABASE_INCARNATION WHERE status = 'CURRENT';
</pre>
<p>Issue the following query on the standby database:</p>
<pre>
SQL&gt; SELECT * FROM DBA_LOGSTDBY_LOG WHERE resetlogs_id = <span class="italic">resetlogs_id_at_primary</span>;
</pre>
<p>If one or more rows are returned, it confirms that there are registered logfiles from the primary's new branch.</p>
</dd>
<dd><a id="SBYDB5263"></a><a id="sthref932"></a></dd>
<dt class="seghead">Step 5&nbsp;&nbsp;&nbsp;Start SQL Apply.</dt>
<dd>
<pre>
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
</pre></dd>
</dl>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1015738"></a>
<div id="SBYDB00920" class="sect1">
<h2 class="sect1"><span class="secnum">13.4</span> Recovering After the NOLOGGING Clause Is Specified</h2>
<p>In so<a id="sthref933"></a>me SQL statements, the user has the option of specifying the <code>NOLOGGING</code> clause, which indicates that the database operation is not logged in the online redo log file. Even though the user specifies the clause, a redo record is still written to the online redo log file. However, there is no data associated with this record. This can result in log application or data access errors at the standby site and manual recovery might be required to resume applying log files.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
To avoid these problems, Oracle recommends that you always specify the <code><a id="sthref934"></a><a id="sthref935"></a>FORCE LOGGING</code> clause in the <a id="sthref936"></a><a id="sthref937"></a><code>CREATE DATABASE</code> or <code><a id="sthref938"></a><a id="sthref939"></a>ALTER DATABASE</code> statements. See the <a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide.</span></a></div>
<div id="SBYDB4894" class="sect2"><a id="sthref940"></a>
<h3 class="sect2"><span class="secnum">13.4.1</span> Recovery Steps for Logical Standby Databases</h3>
<p>For logical standby databases, when SQL Apply encounters a redo record for an operation performed on an interesting table with the <code>NOLOGGING</code> clause, it stops with the following error: <code>ORA-16211 unsupported record found in the archived redo log</code>.</p>
<p>To recover after the <code>NOLOGGING</code> clause is specified, re-create one or more tables from the primary database, as described in <a href="manage_ls.htm#i1016645">Section 10.5.5</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In general, use of the <code>NOLOGGING</code> clause is not recommended. Optionally, if you know in advance that operations using the <code>NOLOGGING</code> clause will be performed on certain tables in the primary database, you might want to prevent the application of SQL statements associated with these tables to the logical standby database by using the <code>DBMS_LOGSTDBY.SKIP</code> procedure.</div>
</div>
<!-- class="sect2" -->
<div id="SBYDB4895" class="sect2"><a id="sthref941"></a>
<h3 class="sect2"><span class="secnum">13.4.2</span> Recovery Steps for Physical Standby Databases</h3>
<p>When the archived redo log file is copied to the standby site and applied to the physical standby database, a portion of the datafile is unusable and is marked as being unrecoverable. When you either fail over to the physical standby database, or open the standby database for read-only access, and attempt to read the range of blocks that are marked as <code><a id="sthref942"></a>UNRECOVERABLE</code>, you will see error messages similar to the following:</p>
<pre>
ORA-01578: ORACLE data block corrupted (file # 1, block # 2521)
ORA-01110: data file 1: '/oracle/dbs/stdby/tbs_1.dbf'
ORA-26040: Data block was loaded using the NOLOGGING option
</pre>
<p>To recover after the <code>NOLOGGING</code> clause is specified, you need to copy the datafile that contains the missing redo data from the primary site to the physical standby site. Perform the following steps:</p>
<dl>
<dd><a id="SBYDB5264"></a><a id="sthref943"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Determine which datafiles should be copied.</dt>
<dd>
<p>Follow these steps:</p>
<ol>
<li>
<p><a id="sthref944"></a><a id="sthref945"></a><a id="sthref946"></a>Query the primary database:</p>
<pre>
SQL&gt; SELECT NAME, UNRECOVERABLE_CHANGE# FROM V$DATAFILE;

NAME                                                  UNRECOVERABLE
----------------------------------------------------- -------------
/oracle/dbs/tbs_1.dbf                                       5216
/oracle/dbs/tbs_2.dbf                                          0
/oracle/dbs/tbs_3.dbf                                          0
/oracle/dbs/tbs_4.dbf                                          0
4 rows selected.
</pre></li>
<li>
<p>Query the standby database:</p>
<pre>
SQL&gt; SELECT NAME, UNRECOVERABLE_CHANGE# FROM V$DATAFILE;

NAME                                                  UNRECOVERABLE
----------------------------------------------------- -------------
/oracle/dbs/stdby/tbs_1.dbf                                 5186
/oracle/dbs/stdby/tbs_2.dbf                                    0
/oracle/dbs/stdby/tbs_3.dbf                                    0
/oracle/dbs/stdby/tbs_4.dbf                                    0
4 rows selected.
</pre></li>
<li>
<p>Compare the query results of the primary and standby databases.</p>
<p>Compare the value of the <code>UNRECOVERABLE_CHANGE#</code> column in both query results. If the value of the <code>UNRECOVERABLE_CHANGE#</code> column in the primary database is greater than the same column in the standby database, then the datafile needs to be copied from the primary site to the standby site.</p>
<p>In this example, the value of the <code>UNRECOVERABLE_CHANGE#</code> in the primary database for the <code>tbs_1.dbf</code> datafile is greater, so you need to copy the <code>tbs_1.dbf</code> datafile to the standby site.</p>
</li>
</ol>
</dd>
<dd><a id="SBYDB5265"></a><a id="sthref947"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;On the primary site, back up the datafile you need to copy to the standby site.</dt>
<dd>
<p>Issue the following SQL statements:</p>
<pre>
SQL&gt; <a id="sthref948"></a><a id="sthref949"></a>ALTER TABLESPACE system BEGIN BACKUP;
SQL&gt; EXIT;
</pre>
<p>Copy the needed datafile to a local directory.</p>
<pre>
SQL&gt; ALTER TABLESPACE system END BACKUP;
</pre></dd>
<dd><a id="SBYDB5266"></a><a id="sthref950"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Copy the datafile to the standby database.</dt>
<dd>
<p>Copy the datafile that contains the missing redo data from the primary site to a location on the physical standby site where files related to recovery are stored.</p>
</dd>
<dd><a id="SBYDB5267"></a><a id="CIHGEICG"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;On the standby database, restart Redo Apply.</dt>
<dd>
<p>Issue the following SQL statement:</p>
<pre>
SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT FROM SESSION;
</pre>
<p>You might get the following error messages (possibly in the alert log) when you try to restart Redo Apply:</p>
<pre>
ORA-00308: cannot open archived log 'standby1'
ORA-27037: unable to obtain file status
SVR4 Error: 2: No such file or directory
Additional information: 3
ORA-01547: warning: RECOVER succeeded but OPEN RESETLOGS would get error below
ORA-01152: file 1 was not restored from a sufficiently old backup
ORA-01110: data file 1: '/oracle/dbs/stdby/tbs_1.dbf'
</pre>
<p>If you get the <code>ORA-00308</code> error and Redo Apply does not terminate automatically, you can cancel recovery by issuing the following SQL statement from another terminal window:</p>
<pre>
SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;
</pre>
<p>These error messages are returned when one or more log files in the archive gap have not been successfully applied. If you receive these errors, manually resolve the gaps, and repeat Step <a href="#CIHGEICG">4</a>. See <a href="log_transport.htm#BABIDDDC">Section 6.4.3.1</a> for information about manually resolving an archive gap.</p>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<div id="SBYDB4896" class="sect2"><a id="sthref951"></a>
<h3 class="sect2"><span class="secnum">13.4.3</span> Determining If a Back<a id="sthref952"></a>up Is Required After Unrecoverable Operations</h3>
<p><a id="sthref953"></a><a id="sthref954"></a><a id="sthref955"></a><a id="sthref956"></a>If you performed unrecoverable operations on your primary database, determine if a new backup operation is required by following these steps:</p>
<a id="CIHHGHHF"></a>
<ol>
<li>
<p>Query the <code>V$DATAFILE</code> view on the primary database to determine the <span class="bold">system change number (SCN)</span> or the time at which the Oracle database generated the most recent invalidated redo data.</p>
</li>
<li>
<p>Issue the following SQL statement on the primary database to determine if you need to perform another backup:</p>
<pre>
SQL&gt; SELECT UNRECOVERABLE_CHANGE#,-
&gt; TO_CHAR(UNRECOVERABLE_TIME, 'mm-dd-yyyy hh:mi:ss') -
&gt; FROM   V$DATAFILE;
</pre></li>
<li>
<p>If the query in the previous step reports an unrecoverable time for a datafile that is more recent than the time when the datafile was last backed up, then make another backup of the datafile in question.</p>
</li>
</ol>
<p>See <a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for more information about the <code>V$DATAFILE</code> view.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1067236"></a>
<div id="SBYDB4897" class="sect1">
<h2 class="sect1"><span class="secnum">13.5</span> Creating a Standby Database That Uses OMF or Oracle ASM</h2>
<p><a href="create_ps.htm#g88234">Chapter 3</a> and <a href="create_ls.htm#g105412">Chapter 4</a> described how to create physical and logical standby databases. This section augments the discussions in those chapters with additional steps that must be performed if the primary database uses Oracle Managed Files (OMF) or <a id="sthref957"></a><a id="sthref958"></a><a id="sthref959"></a>Oracle Automatic Storage Management (Oracle ASM).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The discussion in this section is presented at a level of detail that assumes the reader already knows how to create a physical standby database and is an experienced user of the RMAN, OMF, and Oracle ASM features. For more information, see:
<ul>
<li>
<p><a href="create_ps.htm#g88234">Chapter 3</a>, <a href="create_ls.htm#g105412">Chapter 4</a>, and <a href="rcmbackp.htm#g648533">Appendix E</a> for information about creating physical and logical standby databases</p>
</li>
<li>
<p><a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about OMF and Oracle ASM</p>
</li>
<li>
<p><a class="olink BRADV" href="../../backup.112/e10642/toc.htm"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> and <a class="olink RCMRF" href="../../backup.112/e10643/toc.htm"><span class="italic">Oracle Database Backup and Recovery Reference</span></a> for information about RMAN</p>
</li>
</ul>
</div>
<p>Perform the following tasks to prepare for standby database creation:</p>
<ol>
<li>
<p>Enable forced logging on the primary database.</p>
</li>
<li>
<p>Enable archiving on the primary database.</p>
</li>
<li>
<p>Set all necessary initialization parameters on the primary database.</p>
</li>
<li>
<p>Create an initialization parameter file for the standby database.</p>
</li>
<li>
<p>If the primary database is configured to use OMF, then Oracle recommends that the standby database be configured to use OMF, too. To do this, set the <code>DB_CREATE_FILE_DEST</code> and <code>DB_CREATE_ONLINE_LOG_DEST_</code><code><span class="codeinlineitalic">n</span></code> initialization parameters to appropriate values. Maintenance and future role transitions are simplified if the same disk group names are used for both the primary and standby databases.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If OMF parameters are set on the standby, then new files on that standby are always created as OMF, regardless of how they were created on the primary. Therefore, if both the <code>DB_FILE_NAME_CONVERT</code> and <code>DB_CREATE_FILE_DEST</code> parameters are set on the standby, the <code>DB_CREATE_FILE_DEST</code> parameter takes precedence.</div>
</li>
<li>
<p>Set the <code>STANDBY_FILE_MANAGEMENT</code> initialization parameter to <code>AUTO</code>.</p>
</li>
<li>
<p>Configure Oracle Net, as required, to allow connections to the standby database.</p>
</li>
<li>
<p>Configure redo transport authentication as described in <a href="create_ps.htm#i69583">Section 3.1.2, "Configure Redo Transport Authentication"</a>.</p>
</li>
<li>
<p>Start the standby database instance without mounting the control file.</p>
</li>
</ol>
<p>Perform the following tasks to create the standby database:</p>
<ol>
<li>
<p>If the standby database is going to use Oracle ASM, create an Oracle ASM instance if one does not already exist on the standby database system.</p>
</li>
<li>
<p>Use the RMAN <code>BACKUP</code> command to create a backup set that contains a copy of the primary database's datafiles, archived log files, and a standby control file.</p>
</li>
<li>
<p>Use the RMAN <code>DUPLICATE FOR STANDBY</code> command to copy the datafiles, archived redo log files and standby control file in the backup set to the standby database's storage area.</p>
<p>The <code>DUPLICATE FOR STANDBY</code> command performs the actual data movement at the standby instance. If the backup set is on tape, the media manager must be configured so that the standby instance can read the backup set. If the backup set is on disk, the backup pieces must be readable by the standby instance, either by making their primary path names available through NFS, or by copying them to the standby system and using RMAN <code>CATALOG BACKUPPIECE</code> command to catalog the backup pieces before restoring them.</p>
</li>
</ol>
<p>After you successfully complete these steps, continue with the steps in <a href="create_ps.htm#i77231">Section 3.2.7</a>, to verify the configuration of the physical standby database.</p>
<p>To create a logical standby database, continue with the standby database creation process described in <a href="create_ls.htm#g105412">Chapter 4</a>, but with the following modifications:</p>
<ol>
<li>
<p>For a logical standby database, setting the <code>DB_CREATE_FILE_DEST</code> parameter does not force the creation of OMF filenames. However, if this parameter was set on the primary database, it must also be set on the standby database.</p>
</li>
<li>
<p>After creating a logical standby control file on the primary system, do not use an operating system command to copy this file to the standby system. Instead, use the RMAN <code>RESTORE CONTROLFILE</code> command to restore a copy of the logical standby control file to the standby system.</p>
</li>
<li>
<p>If the primary database uses OMF files, use RMAN to update the standby database control file to use the new OMF files created on the standby database. To perform this operation, connect only to the standby database, as shown in the following example:</p>
<pre>
&gt; RMAN TARGET sys@lstdby

target database Password: <span class="italic">password</span>

RMAN&gt; CATALOG START WITH '+stby_diskgroup';
RMAN&gt; SWITCH DATABASE TO COPY;
</pre></li>
</ol>
<p>After you successfully complete these steps, continue with the steps in <a href="create_ls.htm#i75998">Section 4.2.5</a> to start, recover, and verify the logical standby database.</p>
</div>
<!-- class="sect1" -->
<a id="BACJHHFF"></a>
<div id="SBYDB00930" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">13.6</span> Recovering From Lost-Write Errors on a Primary Database</h2>
<p>During media recovery in a Data Guard configuration, a physical standby database can be used to detect lost-write data corruption errors on the primary database. This is done by comparing SCNs of blocks stored in the redo log on the primary database to SCNs of blocks on the physical standby database. If the SCN of the block on the primary database is lower than the SCN on the standby database, then there was a lost-write error on the primary database.</p>
<p>In such a situation, if lost write detection (set with the <a class="olink REFRN10268" href="../../server.112/e40402/initparams063.htm#REFRN10268"><code>DB_LOST_WRITE_PROTECT</code></a> initialization parameter) is enabled at both the primary and standby, then a recovery attempt at the standby results in an <code>ORA-752</code> error. If lost write detection is not enabled, then a recovery attempt results in an <code>ORA-600</code> <code>[3020]</code> error. However, not all <code>ORA-600</code> <code>[3020]</code> errors are due to lost writes at the primary. Therefore, before following the guidelines given in this section, you should work with your Oracle Support representative to determine whether the root cause for the <code>ORA-600</code> <code>[3020]</code> error was indeed a lost write that occurred on the primary. Also see "Resolving ORA-752 or ORA-600 [3020] During Standby Recovery" in the My Oracle Support Note 1265884.1 at <code><a href="http://support.oracle.com">http://support.oracle.com</a></code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because lost-write errors are detected only when a block is read into the cache by a primary and the corresponding redo is later compared to the block on the standby, there may be undetected stale blocks on both the primary and the standby that have not yet been read and verified. These stale blocks do not affect operation of the current database because until those blocks are read, all blocks that have been used up to the SCN of the currently applied redo on the standby to do queries or updates were verified by the standby.</div>
<p>When a primary lost-write error is detected on the standby, one or more block error messages similar to the following for each stale block are printed in the alert file of the standby database:</p>
<pre>
Tue Dec 12 19:09:48 2006
STANDBY REDO APPLICATION HAS DETECTED THAT THE PRIMARY DATABASE
LOST A DISK WRITE OF BLOCK 26, FILE 7
NO REDO AT OR AFTER SCN 389667 CAN BE USED FOR RECOVERY.
.
.
.
</pre>
<p>The alert file then shows that an <code>ORA-00752</code> error is raised on the standby database and the managed recovery is cancelled:</p>
<pre>
Slave exiting with ORA-752 exception
Errors in file /oracle/log/diag/rdbms/dgstwrite2/stwrite2/trace/stwrite2_pr00_23532.trc:
ORA-00752: recovery detected a lost write of a data block
ORA-10567: Redo is inconsistent with data block (file# 7, block# 26)
ORA-10564: tablespace TBS_2
ORA-01110: data file 7: '/oracle/dbs/btbs_21.f'
ORA-10561: block type 'TRANSACTION MANAGED DATA BLOCK', data object# 57503
.
.
.
</pre>
<p>The standby database is then recovered to a consistent state, without any corruption to its datafiles caused by this error, at the SCN printed in the alert file:</p>
<pre>
Recovery interrupted!
Recovered data files to a consistent state at change 389569
</pre>
<p>This last message may appear significantly later in the alert file and it may have a lower SCN than the block error messages. Also, the primary database may operate without visible errors even though its datafiles may already be corrupted.</p>
<p>The recommended procedure to recover from such errors is a failover to the physical standby, as described in the following steps.</p>
<p class="subhead1"><a id="SBYDB5074"></a>Steps to Failover to a Physical Standby After Lost-Writes Are Detected on the Primary</p>
<ol>
<li>
<p>Shut down the primary database. All data at or after SCN printed in the block error messages will be lost.</p>
</li>
<li>
<p>Issue the following SQL statement on the standby database to convert it to a primary:</p>
<pre>
SQL&gt; ALTER DATABASE ACTIVATE STANDBY DATABASE;
 
Database altered.
 
Tue Dec 12 19:15:23 2006
alter database activate standby database
ALTER DATABASE ACTIVATE [PHYSICAL] STANDBY DATABASE (stwrite2)
RESETLOGS after incomplete recovery UNTIL CHANGE 389569
Resetting resetlogs activation ID 612657558 (0x24846996)
Online log /oracle/dbs/bt_log1.f: Thread 1 Group 1 was previously cleared
Online log /oracle/dbs/bt_log2.f: Thread 1 Group 2 was previously cleared
Standby became primary SCN: 389567
Tue Dec 12 19:15:23 2006
Setting recovery target incarnation to 3
Converting standby mount to primary mount.
ACTIVATE STANDBY: Complete - Database mounted as primary (stwrite2)
Completed: alter database activate standby database
</pre></li>
<li>
<p>Back up the new primary. Performing a backup immediately is a necessary safety measure, because you cannot recover changes made after the failover without a complete backup copy of the database. As a result of the failover, the original primary database can no longer participate in the Data Guard configuration, and all other standby databases will now receive and apply redo data from the new primary database.</p>
</li>
<li>
<p>Open the new primary database.</p>
</li>
<li>
<p>An optional step is to recreate the failed primary as a physical standby. This can be done using the database backup taken at the new primary in step 3. (You cannot use flashback database or the Data Guard broker to reinstantiate the old primary database in this situation.)</p>
<p>Be aware that a physical standby created using the backup taken from the new primary will have the same datafiles as the old standby. Therefore, any undetected lost writes that the old standby had before it was activated will not be detected by the new standby, since the new standby will be comparing the same blocks. Any new lost writes that happen on either the primary or the standby will be detected.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink BRADV89476" href="../../backup.112/e10642/rcmconfa.htm#BRADV89476"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information about enabling lost-write detection</div>
</div>
<!-- class="sect1" -->
<a id="BACJCDGH"></a>
<div id="SBYDB4898" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">13.7</span> Converting a Failed Primary into a Standby Database Using RMAN Backups</h2>
<p>To convert a failed primary database, Oracle recommends that you enable the Flashback Database feature on the primary and follow the procedure described in either <a href="#i1050055">Section 13.2.1</a> or <a href="#CIHEDFHH">Section 13.2.2</a>. The procedures in those sections describe the fastest ways to convert a failed primary into either a physical or logical standby. However, if Flashback Database was not enabled on the failed primary, you can still convert the failed primary into either a physical or logical standby using a local backup of the failed primary, as described in the following sections:</p>
<ul>
<li>
<p><a href="#CIHGIICE">Converting a Failed Primary into a Physical Standby Using RMAN Backups</a></p>
</li>
<li>
<p><a href="#CIHBDFAC">Converting a Failed Primary into a Logical Standby Using RMAN Backups</a></p>
</li>
</ul>
<a id="CIHGIICE"></a>
<div id="SBYDB4899" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.7.1</span> Converting a Failed Primary into a Physical Standby Using RMAN Backups</h3>
<p>The steps in this section describe how to convert a failed primary into a physical standby by using RMAN backups. This procedure requires that the <code>COMPATIBLE</code> initialization parameter of the old primary be set to at least 11.0.0.</p>
<dl>
<dd><a id="SBYDB5268"></a><a id="sthref960"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Determine the SCN at which the old standby database became the primary database.</dt>
<dd>
<p>On the new primary database, issue the following query to determine the SCN at which the old standby database became the new primary database:</p>
<pre>
SQL&gt; SELECT TO_CHAR(STANDBY_BECAME_PRIMARY_SCN) FROM V$DATABASE;
</pre></dd>
<dd><a id="SBYDB5269"></a><a id="sthref961"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Restore and recover the entire database.</dt>
<dd>
<p>Restore the database with a backup taken before the old primary had reached the SCN at which the standby became the new primary (<code>standby_became_primary_scn)</code>. Then, perform a point-in-time recovery to recover the old primary to that same point.</p>
<p>Issue the following RMAN commands:</p>
<pre>
RMAN&gt; RUN
    {
      SET UNTIL SCN &lt;standby_became_primary_scn + 1&gt;;
      RESTORE DATABASE;
      RECOVER DATABASE;
     }
</pre>
<p>With user-managed recovery, you can first restore the database manually. Typically, a backup taken a couple of hours before the failover would be old enough. You can then recover the failed primary using the following command:</p>
<pre>
SQL&gt; RECOVER DATABASE USIING BACKUP CONTROLFILE UNTIL CHANGE -
&gt;  &lt;standby_became_primary_scn + 1&gt;;
</pre>
<p>Unlike a reinstantiation that uses Flashback Database, this procedure adds one to <code>standby_became_primary_scn</code>. For datafiles, flashing back to an SCN is equivalent to recovering up until that SCN plus one.</p>
</dd>
<dd><a id="SBYDB5270"></a><a id="sthref962"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Convert the database to a physical standby database.</dt>
<dd>
<p>Perform the following steps on the old primary database:</p>
<ol>
<li>
<p>Issue the following statement on the old primary database:</p>
<pre>
SQL&gt; ALTER DATABASE CONVERT TO PHYSICAL STANDBY;
</pre>
<p>This statement will dismount the database after successfully converting the control file to a standby control file.</p>
</li>
<li>
<p>Shut down and restart the database:</p>
<pre>
SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
</pre></li>
</ol>
</dd>
<dd><a id="SBYDB5271"></a><a id="sthref963"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;Open the database as read-only.</dt>
<dd>
<p>Issue the following command:</p>
<pre>
SQL&gt; ALTER DATABASE OPEN READ ONLY;
</pre>
<p>The goal of this step is to synchronize the control file with the database by using a dictionary check. After this command, check the alert log for any actions suggested by the dictionary check. Typically, no user action is needed if the old primary was not in the middle of adding or dropping datafiles during the failover.</p>
</dd>
<dd><a id="SBYDB5272"></a><a id="sthref964"></a></dd>
<dt class="seghead">Step 5&nbsp;&nbsp;&nbsp;(Optional) Mount the standby again, if desired</dt>
<dd>
<p>If you have purchased a license for the Active Data Guard option and would like to operate your physical standby database in active query mode, skip this step. Otherwise, bring your standby database to the mount state.</p>
<p>For example:</p>
<pre>
SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
</pre></dd>
<dd><a id="SBYDB5273"></a><a id="sthref965"></a></dd>
<dt class="seghead">Step 6&nbsp;&nbsp;&nbsp;Restart transporting redo to the new physical standby database.</dt>
<dd>
<p>Before the new standby database was created, the new primary database probably stopped transmitting redo to the remote destination. To restart redo transport services, perform the following steps on the new primary database:</p>
<ol>
<li>
<p>Issue the following query to see the current state of the archive destinations:</p>
<pre>
SQL&gt; SELECT DEST_ID, DEST_NAME, STATUS, PROTECTION_MODE, DESTINATION, -
&gt; ERROR,SRL FROM V$ARCHIVE_DEST_STATUS;
</pre>
<pre>
</pre></li>
<li>
<p>If necessary, enable the destination:</p>
<pre>
SQL&gt; ALTER SYSTEM SET LOG_ARCHIVE_DEST_STATE_<span class="variable">n</span>=ENABLE;
</pre></li>
<li>
<p>Perform a log switch to ensure the standby database begins receiving redo data from the new primary database, and verify it was sent successfully.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This is an important step in order for the old primary to become a new standby following the new primary. If this step is not done, the old primary may recover to an incorrect database branch. The only way to correct the problem then is to convert the old primary again.</div>
<p>At the SQL prompt, enter the following statements:</p>
<pre>
SQL&gt; ALTER SYSTEM SWITCH LOGFILE;
SQL&gt; SELECT DEST_ID, DEST_NAME, STATUS, PROTECTION_MODE, DESTINATION, -
&gt; ERROR,SRL FROM V$ARCHIVE_DEST_STATUS;
</pre>
<p>On the new standby database, you may also need to change the <code>LOG_ARCHIVE_DEST_</code><code><span class="codeinlineitalic">n</span></code> initialization parameters so that redo transport services do not transmit redo data to other databases. This step can be skipped if both the primary and standby database roles were set up with the <code>VALID_FOR</code> attribute in one server parameter file (SPFILE). By doing this, the Data Guard configuration operates properly after a role transition.</p>
</li>
</ol>
</dd>
<dd><a id="SBYDB5274"></a><a id="sthref966"></a></dd>
<dt class="seghead">Step 7&nbsp;&nbsp;&nbsp;Start Redo Apply.</dt>
<dd>
<p>Start Redo Apply on the new physical standby database, as follows:</p>
<pre>
SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE -
&gt; USING CURRENT LOGFILE DISCONNECT;
</pre>
<p>Once the failed primary database is restored and is running in the standby role, you can optionally perform a switchover to transition the databases to their original (pre-failure) roles. See <a href="role_management.htm#i1026464">Section 8.2.1, "Performing a Switchover to a Physical Standby Database"</a> for more information.</p>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<a id="CIHBDFAC"></a>
<div id="SBYDB4900" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.7.2</span> Converting a Failed Primary into a Logical Standby Using RMAN Backups</h3>
<p>The steps in this section describe how to convert a failed primary into a logical standby using RMAN backups.</p>
<dl>
<dd><a id="SBYDB5275"></a><a id="sthref967"></a></dd>
<dt class="seghead">Step 1&nbsp;&nbsp;&nbsp;Determine the SCN to which to recover the failed primary database.</dt>
<dd>
<p>On the new primary database, issue the following query to determine the SCN to which you want to recover the failed primary database:</p>
<pre>
SQL&gt; SELECT APPLIED_SCN RECOVERY_SCN FROM V$LOGSTDBY_PROGRESS;
</pre>
<p>Also on the new primary database, determine the SCN to use in dealing with archive logs, as follows:</p>
<ol>
<li>
<p>Ensure all standby redo logs have been archived. Issue the following query, looking for a value of <code>READY</code> to be returned. Depending on the size of the database and the number of logs needing to be archived, it could take some time before a status of <code>READY</code> is returned.</p>
<pre>
SQL&gt; SELECT VALUE FROM SYSTEM.LOGSTDBY$PARAMETERS - 
&gt; WHERE NAME='REINSTATEMENT_STATUS';
</pre></li>
<li>
<p>After a status of <code>READY</code> has been returned, run the following query to retrieve the SCN for dealing with archive logs as part of this recovery:</p>
<pre>
SQL&gt; SELECT VALUE ARCHIVE_SCN FROM SYSTEM.LOGSTDBY$PARAMETERS -
&gt; WHERE NAME='STANDBY_BECAME_PRIMARY_SCN';
</pre></li>
</ol>
</dd>
<dd><a id="SBYDB5276"></a><a id="sthref968"></a></dd>
<dt class="seghead">Step 2&nbsp;&nbsp;&nbsp;Remove divergent archive logs from the failed primary database.</dt>
<dd>
<p>Remove any archive logs created at the time of, or after the failover operation, from the failed primary database. If the failed primary database was isolated from the standby, it could have divergent archive logs that are not consistent with the current primary database. To ensure these divergent archive logs are never applied, they must be deleted from backups and the fast recovery area. You can use the following RMAN command to delete the relevant archive logs from the fast recovery area:</p>
<pre>
RMAN&gt; DELETE ARCHIVELOG FROM SCN ARCHIVE_SCN;
</pre>
<p>Once deleted, these divergent logs and subsequent transactions can never be recovered.</p>
</dd>
<dd><a id="SBYDB5277"></a><a id="CIHJBJDC"></a></dd>
<dt class="seghead">Step 3&nbsp;&nbsp;&nbsp;Determine the log files to be copied to the failed primary database.</dt>
<dd>
<p>On the new primary database, issue the following query to determine the minimum set of log files that must be copied to the failed primary database before recovering from a backup:</p>
<pre>
SQL&gt; SELECT file_name FROM DBA_LOGSTDBY_LOG WHERE next_change# &gt; ARCHIVE_SCN;
</pre>
<p>Retrieve the required standby logs, copy the backup set to the new standby and restore it to the new standby fast recovery area. Because these logs are coming from standby redo logs, they are not part of the standby's standard archives. The RMAN utility is able to use a partial file name to retrieve the files from the correct location.</p>
<p>The following is a sample use of the RMAN <code>BACKUP</code> command:</p>
<pre>
RMAN&gt; BACKUP AS COPY DEVICE TYPE DISK FORMAT '/tmp/test/%U'
&gt; ARCHIVELOG LIKE '&lt;partial file names from above&gt;%';
</pre>
<p>The following is a sample use of the RMAN <code>RESTORE</code> command:</p>
<pre>
RMAN&gt; CATALOG START WITH '/tmp/test';
RMAN&gt; RESTORE ARCHIVELOG FROM SEQUENCE 33 UNTIL SEQUENCE 35;
</pre></dd>
<dd><a id="SBYDB5278"></a><a id="sthref969"></a></dd>
<dt class="seghead">Step 4&nbsp;&nbsp;&nbsp;Restore a backup and recover the database.</dt>
<dd>
<p>Restore a backup of all the original primary's data files and recover to <code>RECOVERY_SCN + 1</code>. Oracle recommends that you leverage the current control file.</p>
<ol>
<li>
<p>Start up the database in restricted mode to protect it from rogue transactions until the <code>GUARD ALL</code> command can be issued after the database has been opened.</p>
</li>
<li>
<p>Use the backup to restore the data files of the failed primary database.</p>
</li>
<li>
<p>Turn off flashback database, if it is enabled (necessary for the <code>USING BACKUP CONTROLFILE</code> clause).</p>
</li>
<li>
<p>Perform point-in-time recovery to <code>RECOVERY_SCN +1</code> in SQL*Plus.</p>
</li>
</ol>
<p>Whether you are using a current control file or a backup control file, you must specify the <code>USING BACKUP CONTROLFILE</code> clause to allow you to point to the archive logs being restored. Otherwise, the recovery process could attempt to access online redo logs instead of the logs retrieved in <a href="#CIHJBJDC">Step 3</a>. When prompted for the sequences retrieved in <a href="#CIHJBJDC">Step 3</a>, ensure you specify the file names of the restored archive log copies, as follows:</p>
<pre>
SQL&gt; RECOVER DATABASE UNTIL CHANGE RECOVERY_SCN + 1 USING BACKUP CONTROLFILE;
</pre></dd>
<dd><a id="SBYDB5279"></a><a id="sthref970"></a></dd>
<dt class="seghead">Step 5&nbsp;&nbsp;&nbsp;Open the database with the RESETLOGS option.</dt>
<dd>
<pre>
SQL&gt; ALTER DATABASE OPEN RESETLOGS;
</pre></dd>
<dd><a id="SBYDB5280"></a><a id="sthref971"></a></dd>
<dt class="seghead">Step 6&nbsp;&nbsp;&nbsp; Enable Database Guard</dt>
<dd>
<pre>
SQL&gt; ALTER DATABASE GUARD ALL;
</pre></dd>
<dd><a id="SBYDB5281"></a><a id="sthref972"></a></dd>
<dt class="seghead">Step 7&nbsp;&nbsp;&nbsp; Create a database link to the new primary database and start SQL Apply.</dt>
<dd>
<pre>
SQL&gt; CREATE PUBLIC DATABASE LINK <span class="italic">myLink</span> -
&gt; CONNECT TO SYSTEM IDENTIFIED BY <span class="italic">password</span> -
&gt; USING '<span class="italic">service name of new primary database</span>';
</pre>
<pre>
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY NEW PRIMARY <span class="italic">myLink</span>;
</pre>
<p>At this point, you can disable restricted session (<code>ALTER SYSTEM DISABLE RESTRICTED SESSION</code>) or, if you need to restart the database to re-enable Flashback from Step 4.3, let this restart turn off <code>RESTRICTED SESSION</code>.</p>
</dd>
</dl>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHCAIGA"></a>
<div id="SBYDB5134" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">13.8</span> Changing the Character Set of a Primary Without Re-Creating Physical Standbys<a id="sthref973"></a></h2>
<p>Oracle Data Guard allows you to change both the database character set and the national character set of a primary database without requiring you to recreate any physical standby databases in the configuration. You can continue to use your physical standby database with minimal disruption while performing character set conversion of a primary database.</p>
<p>The process requires the running of several procedures prior to the actual conversion. The conversion itself requires that the primary database be shut down and opened in restricted mode, and that the <code>CSALTER</code> script be executed. Both the system data and user data are converted to the new character set.</p>
<p>For a detailed description of the steps involved in this process, see My Oracle Support note 1124165.1 at <code><a href="http://support.oracle.com">http://support.oracle.com</a></code>. You will also need to read note 260192.1.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Similar to the obsolete <code>ALTER DATABASE CHARACTER SET</code> SQL statement, the <code>CSALTER</code> script should be used only by a system administrator. System administrators must run the Database Character Set Scanner first to confirm that the proper conditions exist for running <code>CSALTER</code>. Also, the database must be backed up before running <code>CSALTER</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG469" href="../../server.112/e10729/ch11charsetmig.htm#NLSPG469"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more general information about using the <code>CSALTER</code> script to migrate character sets</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1813">
<tr>
<td class="cellalignment1820">
<table class="cellalignment1818">
<tr>
<td class="cellalignment1817"><a href="rollup.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1817"><a href="partpage2.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1822">
<table class="cellalignment1816">
<tr>
<td class="cellalignment1817"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1817"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1817"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1817"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1817"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1817"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
