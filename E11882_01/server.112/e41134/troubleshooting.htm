<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Troubleshooting Data Guard</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="dcterms.created" content="2014-02-25T8:43:2Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Data Guard Concepts and Administration" />
<meta name="dcterms.identifier" content="E41134-03" />
<meta name="dcterms.isVersionOf" content="SBYDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="partpage3.htm" title="Previous" type="text/html" />
<link rel="Next" href="upgrades.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41134.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">28/34</span> <!-- End Header -->
<div id="SBYDB01400" class="appendix"><a id="g643918"></a> <a id="i634208"></a>
<h1 class="appendix"><span class="secnum">A</span> Troubleshooting Data Guard</h1>
<p>This appendix provides help troubleshooting a standby database. This appendix contains the following sections:</p>
<ul>
<li>
<p><a href="#i639379">Common Problems</a></p>
</li>
<li>
<p><a href="#i636223">Log File Destination Failures</a></p>
</li>
<li>
<p><a href="#i636211">Handling Logical Standby Database Failures</a></p>
</li>
<li>
<p><a href="#i634277">Problems Switching Over to a Physical Standby Database</a></p>
</li>
<li>
<p><a href="#BABJHACH">Problems Switching Over to a Logical Standby Database</a></p>
</li>
<li>
<p><a href="#i634786">What to Do If SQL Apply Stops</a></p>
</li>
<li>
<p><a href="#i635902">Network Tuning for Redo Data Transmission</a></p>
</li>
<li>
<p><a href="#i637895">Slow Disk Performance on Standby Databases</a></p>
</li>
<li>
<p><a href="#i639505">Log Files Must Match to Avoid Primary Database Shutdown</a></p>
</li>
<li>
<p><a href="#CHDBDBHH">Troubleshooting a Logical Standby Database</a></p>
</li>
</ul>
<a id="i639379"></a>
<div id="SBYDB01405" class="sect1">
<h2 class="sect1"><span class="secnum">A.1</span> Common Problems</h2>
<p>If you encounter a problem when using a standby database, it is probably because of one of the following reasons:</p>
<ul>
<li>
<p><a href="#i639341">Renaming Datafiles with the ALTER DATABASE Statement</a></p>
</li>
<li>
<p><a href="#i634242">Standby Database Does Not Receive Redo Data from the Primary Database</a></p>
</li>
<li>
<p><a href="#i634270">You Cannot Mount the Physical Standby Database</a></p>
</li>
</ul>
<a id="i639341"></a>
<div id="SBYDB4905" class="sect2">
<h3 class="sect2"><span class="secnum">A.1.1</span> Renaming Datafiles with the ALTER DATABASE Statement</h3>
<p>You cannot rename the datafile on the standby site when the <code>STANDBY_FILE_MANAGEMENT</code> initialization parameter is set to <code>AUTO</code>. When you set the <code>STANDBY_FILE_MANAGEMENT</code> initialization parameter to <code>AUTO</code>, use of the following SQL statements is<a id="sthref1209"></a> not allowed:</p>
<ul>
<li>
<p><code><a id="sthref1210"></a><a id="sthref1211"></a>ALTER DATABASE RENAME</code></p>
</li>
<li>
<p><code><a id="sthref1212"></a><a id="sthref1213"></a><a id="sthref1214"></a>ALTER DATABASE ADD/DROP LOGFILE</code></p>
</li>
<li>
<p><code><a id="sthref1215"></a><a id="sthref1216"></a><a id="sthref1217"></a>ALTER DATABASE ADD/DROP STANDBY LOGFILE MEMBER</code></p>
</li>
<li>
<p><code><a id="sthref1218"></a><a id="sthref1219"></a>ALTER DATABASE CREATE DATAFILE AS</code></p>
</li>
</ul>
<p>If you attempt to use any of these statements on the standby database, an error is returned. For example:</p>
<pre>
SQL&gt; <a id="sthref1220"></a><a id="sthref1221"></a>ALTER DATABASE RENAME FILE '/disk1/oracle/oradata/payroll/t_db2.log' to 'dummy';

alter database rename file '/disk1/oracle/oradata/payroll/t_db2.log' to 'dummy' 
* 
ERROR at line 1: 
ORA-01511: error in renaming log/datafiles 
ORA-01270: RENAME operation is not allowed if STANDBY_FILE_MANAGEMENT is auto
</pre>
<p>See <a href="manage_ps.htm#i1010428">Section 9.3.1</a> to learn how to add datafiles to a physical standby database.</p>
</div>
<!-- class="sect2" -->
<a id="i634242"></a>
<div id="SBYDB4906" class="sect2">
<h3 class="sect2"><span class="secnum">A.1.2</span> Standby Database Does Not Receive Redo Data from the Primary Database</h3>
<p><a id="sthref1222"></a><a id="sthref1223"></a>If the standby site is not receiving redo data, query the <code>V$ARCHIVE_DEST</code> view and check for error messages. For example, enter the following query:</p>
<pre>
SQL&gt; SELECT DEST_ID "ID", -
&gt; STATUS "DB_status", -
&gt; DESTINATION "Archive_dest", -
&gt; ERROR "Error" -
&gt; FROM V$ARCHIVE_DEST WHERE DEST_ID &lt;=5;

ID DB_status Archive_dest                   Error   
-- --------- ------------------------------ ------------------------------------
 1  VALID    /vobs/oracle/work/arc_dest/arc                          
 2  ERROR    standby1                       ORA-16012: Archivelog standby database identifier mismatch  
 3  INACTIVE                            
 4  INACTIVE                    
 5  INACTIVE                                           
5 rows selected.
</pre>
<p>If the output of the query does not help you, check the following list of possible issues. If any of the following conditions exist, redo transport services will fail to transmit redo data to the standby database:</p>
<ul>
<li>
<p>The service name for the standby instance is not configured correctly in the <a id="sthref1224"></a><a id="sthref1225"></a><a id="sthref1226"></a><a id="sthref1227"></a><code>tnsnames.ora</code> file for the primary database.</p>
</li>
<li>
<p>The Oracle Net service name specified by the <code>LOG_ARCHIVE_DEST_</code><code><span class="codeinlineitalic">n</span></code> parameter for the primary database is incorrect.</p>
</li>
<li>
<p>The <code>LOG_ARCHIVE_DEST_STATE_</code><code><span class="codeinlineitalic">n</span></code> parameter for the standby database is not set to the value <code>ENABLE.</code></p>
</li>
<li>
<p>The <code>listener.ora</code> file has not been configured correctly for the standby database.</p>
</li>
<li>
<p>The listener is not started at the standby site.</p>
</li>
<li>
<p>The standby instance is not started.</p>
</li>
<li>
<p>You have added a standby archiving destination to the primary SPFILE or text initialization parameter file, but have not yet enabled the change.</p>
</li>
<li>
<p>Redo transport authentication has not been configured properly. See section 3.1.2 for redo transport authentication configuration requirements.</p>
</li>
<li>
<p>You used an invalid backup as the basis for the standby database (for example, you used a backup from the wrong database, or did not create the standby control file using the correct method).</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i634270"></a>
<div id="SBYDB4907" class="sect2">
<h3 class="sect2"><span class="secnum">A.1.3</span> You Cannot Mount the Physical Standby Database</h3>
<p>You cannot mount the standby database if the standby control file was not created with the <code>ALTER DATABASE <a id="sthref1228"></a><a id="sthref1229"></a>CREATE [LOGICAL] STANDBY CONTROLFILE ...</code> statement or RMAN command. You cannot use the following types of control file backups:</p>
<ul>
<li>
<p>An operating system-created backup</p>
</li>
<li>
<p>A backup created using an <code>ALTER DATABASE</code> statement <span class="italic">without</span> the <code>PHYSICAL STANDBY</code> or <code>LOGICAL STANDBY</code> option</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i636223"></a>
<div id="SBYDB4908" class="sect1">
<h2 class="sect1"><span class="secnum">A.2</span> Log File Destination Failures</h2>
<p>If you specify <code>REOPEN</code> for a <code>MANDATORY</code> destination, redo transport services stall the primary database when redo data cannot be successfully transmitted.</p>
<p>The <code>REOPEN</code> attribute is required when you use the <code>MAX_FAILURE</code> attribute. <a href="#i635145">Example A-1</a> shows how to set a retry time of 5 seconds and limit retries to 3 times.</p>
<div id="SBYDB5084" class="example">
<p class="titleinexample"><a id="i635145"></a>Example A-1 Setting a Retry Time and Limit</p>
<pre>
LOG_ARCHIVE_DEST_1='LOCATION=/arc_dest REOPEN=5 MAX_FAILURE=3'
</pre>
<p><a id="sthref1230"></a><a id="sthref1231"></a><a id="sthref1232"></a><a id="sthref1233"></a>Use the <code>ALTERNATE</code> attribute of the <code>LOG_ARCHIVE_DEST_</code><code><span class="codeinlineitalic">n</span></code> parameter to specify alternate archive destinations. An alternate archiving destination can be used when the transmission of redo data to a standby database fails. If transmission fails and the <code>REOPEN</code> attribute was not specified or the <code>MAX_FAILURE</code> attribute threshold was exceeded, redo transport services attempts to transmit redo data to the alternate destination on the next archival operation.</p>
<p><a id="sthref1234"></a><a id="sthref1235"></a>Use the <code>NOALTERNATE</code> attribute to prevent the original archive destination from automatically changing to an alternate archive destination when the original archive destination fails.</p>
<p><a href="#i635159">Example A-2</a> shows how to set the <a id="sthref1236"></a><a id="sthref1237"></a>initialization parameters so that a single, mandatory, local destination will automatically fail over to a different destination if any error occurs.</p>
</div>
<!-- class="example" -->
<div id="SBYDB5085" class="example">
<p class="titleinexample"><a id="i635159"></a>Example A-2 <a id="sthref1238"></a><a id="sthref1239"></a>Specifying an Alternate Destination</p>
<pre>
LOG_ARCHIVE_DEST_1='LOCATION=/disk1 MANDATORY ALTERNATE=LOG_ARCHIVE_DEST_2'
LOG_ARCHIVE_DEST_STATE_1=ENABLE
LOG_ARCHIVE_DEST_2='LOCATION=/disk2 MANDATORY'
LOG_ARCHIVE_DEST_STATE_2=ALTERNATE
</pre>
<p>If the <code>LOG_ARCHIVE_DEST_1</code> destination fails, the archiving process will automatically switch to the <code>LOG_ARCHIVE_DEST_2</code> destination at the next log file switch on the primary database.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i636211"></a>
<div id="SBYDB4909" class="sect1">
<h2 class="sect1"><span class="secnum">A.3</span> Handling <a id="sthref1240"></a><a id="sthref1241"></a><a id="sthref1242"></a><a id="sthref1243"></a>Logical Standby Database Failures</h2>
<p>An important tool for handling logical standby database failures is the <code>DBMS_LOGSTDBY.SKIP_ERROR</code> procedure. Depending on how important a table is, you might want to do one of the following:</p>
<ul>
<li>
<p>Ignore failures for a table or specific DDL</p>
</li>
<li>
<p>Associate a stored procedure with a filter so at runtime a determination can be made about skipping the statement, executing this statement, or executing a replacement statement</p>
</li>
</ul>
<p>Taking one of these actions prevents SQL Apply from stopping. Later, you can query the <code>DBA_LOGSTDBY_EVENTS</code> view to find and correct any problems that exist. See <a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about using the <code>DBMS_LOGSTDBY</code> package with PL/SQL callout procedures.</p>
</div>
<!-- class="sect1" -->
<a id="i634277"></a>
<div id="SBYDB01410" class="sect1">
<h2 class="sect1"><span class="secnum">A.4</span> Problems <a id="sthref1244"></a>Switching Over to a Physical Standby Database</h2>
<p>In most cases, following the steps described in <a href="role_management.htm#g1068999">Chapter 8</a> will result in a successful switchover. However, if the switchover is unsuccessful, the following sections may help you to resolve the problem:</p>
<ul>
<li>
<p><a href="#i637332">Switchover Fails Because Redo Data Was Not Transmitted</a></p>
</li>
<li>
<p><a href="#i637658">Switchover Fails Because SQL Sessions Are Still Active</a></p>
</li>
<li>
<p><a href="#i637861">Switchover Fails with the ORA-01102 Error</a></p>
</li>
<li>
<p><a href="#i634321">Redo Data Is Not Applied After Switchover</a></p>
</li>
<li>
<p><a href="#i637876">Roll Back After Unsuccessful Switchover and Start Over</a></p>
</li>
</ul>
<a id="i637332"></a>
<div id="SBYDB4910" class="sect2">
<h3 class="sect2"><span class="secnum">A.4.1</span> Switchover Fails <a id="sthref1245"></a><a id="sthref1246"></a><a id="sthref1247"></a>Because Redo Data Was Not Transmitted</h3>
<p>If the switchover does not complete successfully, you can query the <code>SEQUENCE#</code> column in the <code>V$ARCH<a id="sthref1248"></a>IVED_LOG</code> view to see if the last redo data transmitted from the original primary database was applied on the standby database. If the last redo data was not transmitted to the standby database, you can manually copy the archived redo log file containing the redo data from the original primary database to the old standby database and register it with the S<a id="sthref1249"></a><a id="sthref1250"></a>QL <code>ALTER DATABASE REGISTER LOGFILE</code> <span class="variable">file_specification</span> statement. If you then start apply services, the archived redo log file will be applied automatically. Query the <code>SWITCHOVER_STATUS</code> column in the <code>V$DATABASE</code> view. A switchover to the primary role is now possible if the <code>SWITCHOVER_STATUS</code> column returns <code>TO PRIMARY</code> or <code>SESSIONS ACTIVE</code>.</p>
<pre>
SQL&gt; SELECT SWITCHOVER_STATUS FROM V$DATABASE;

SWITCHOVER_STATUS 
----------------- 
TO PRIMARY 
1 row selected 
</pre>
<p>See <a href="views.htm#g1009239">Chapter 17</a> for information about other valid values for the <code>SWITCHO</code><a id="sthref1251"></a><a id="sthref1252"></a><code>VER_STATUS</code> column of the <code>V$DATABASE</code> view.</p>
<p>To continue with the switchover, follow the instructions in <a href="role_management.htm#i1026464">Section 8.2.1</a> for physical standby databases or <a href="role_management.htm#i1026468">Section 8.3.1</a> for logical standby databases, and try again to switch the target standby database to the primary role.</p>
</div>
<!-- class="sect2" -->
<a id="i637658"></a>
<div id="SBYDB4911" class="sect2">
<h3 class="sect2"><span class="secnum">A.4.2</span> Switchover Fails Because <a id="sthref1253"></a><a id="sthref1254"></a><a id="sthref1255"></a>SQL Sessions Are Still Active</h3>
<p>If you do not include the <code>WITH SESSION SHUTDOWN</code> clause as a part of the <a id="sthref1256"></a><a id="sthref1257"></a><code>ALTER DATABASE COMMIT TO SWITCHOVER TO PHYSICAL STANDBY</code> statement, active SQL sessions might prevent a switchover from being processed. Active SQL sessions can include other Oracle Database processes.</p>
<p><a id="i637433"></a>When sessions are active, an attempt to switch over fails with the following error message:</p>
<pre>
SQL&gt; <a id="sthref1258"></a><a id="sthref1259"></a>ALTER DATABASE COMMIT TO SWITCHOVER TO PHYSICAL STANDBY;
 
ALTER DATABASE COMMIT TO SWITCHOVER TO PHYSICAL STANDBY * 
ORA-01093: ALTER DATABASE CLOSE only permitted with no sessions connected
</pre>
<p>Action: Query the <code>V$SESSION</code> view<a id="sthref1260"></a><a id="sthref1261"></a> to determine which processes are causing the error. For example:</p>
<pre>
SQL&gt; SELECT SID, PROCESS, PROGRAM FROM V$SESSION -   
&gt; WHERE TYPE = 'USER' -
&gt;  AND SID &lt;&gt; (SELECT DISTINCT SID FROM V$MYSTAT);

SID        PROCESS   PROGRAM 
---------  --------  ------------------------------------------------ 
        7      3537  oracle@nhclone2 (CJQ0)
       10
       14
       16
       19
       21
 6 rows selected.
</pre>
<p>In the previous example, the <code>JOB_QUEUE_PROCESSES</code> parameter corresponds to the CJQ0 process entry. Because the job queue process is a user process, it is counted as a SQL session that prevents switchover from taking place. The entries with no process or program information are threads started by the job queue controller.</p>
<p>Verify the <code>JOB_QUEUE_PROCESSES</code> parameter is set using the following SQL statement:</p>
<pre>
SQL&gt; SHOW PARAMETER JOB_QUEUE_PROCESSES; 

NAME                           TYPE      VALUE
------------------------------ -------   -------------------- 
job_queue_processes            integer   5
</pre>
<p>Then, set the parameter to 0. For example:</p>
<pre>
SQL&gt; ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0; 
Statement processed.
</pre>
<p>Because <code>JOB_QUEUE_PROCESSES</code> is a dynamic parameter, you can change the value and have the change take effect immediately without having to restart the instance. You can now retry the switchover procedure.</p>
<p>Do not modify the parameter in your initialization parameter file. After you shut down the instance and restart it after the switchover completes, the parameter will be reset to the original value. This applies to both primary and physical standby databases.</p>
<p><a href="#BABHDFBA">Table A-1</a> summarizes the common processes that prevent switchover and what corrective action you need to take.</p>
<div id="SBYDB5086" class="tblruleformal">
<p class="titleintable"><a id="sthref1262"></a><a id="BABHDFBA"></a>Table A-1 Common <a id="sthref1263"></a><a id="sthref1264"></a><a id="sthref1265"></a>Processes That Prevent Switchover</p>
<table class="cellalignment1823" title="Common Processes That Prevent Switchover" summary="Describes the corrective actions you can take if the CJQ0, QMN0, and DBMSNMP processes are preventing switchover from occurring." dir="ltr">
<thead>
<tr class="cellalignment1814">
<th class="cellalignment1824" id="r1c1-t2">Type of Process</th>
<th class="cellalignment1824" id="r1c2-t2">Process Description</th>
<th class="cellalignment1824" id="r1c3-t2">Corrective Action</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r2c1-t2" headers="r1c1-t2">
<p>CJQ0<a id="sthref1266"></a><a id="sthref1267"></a><a id="sthref1268"></a></p>
</td>
<td class="cellalignment1820" headers="r2c1-t2 r1c2-t2">
<p>Job Queue Scheduler Process</p>
</td>
<td class="cellalignment1820" headers="r2c1-t2 r1c3-t2">
<p>Change the <a id="sthref1269"></a><a id="sthref1270"></a><code>JOB_QUEUE_PROCESSES</code> dynamic parameter to the value 0. The change will take effect immediately without having to restart the instance.</p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r3c1-t2" headers="r1c1-t2">
<p>QMN0<a id="sthref1271"></a><a id="sthref1272"></a><a id="sthref1273"></a></p>
</td>
<td class="cellalignment1820" headers="r3c1-t2 r1c2-t2">
<p>Advanced Queue Time Manager</p>
</td>
<td class="cellalignment1820" headers="r3c1-t2 r1c3-t2">
<p>Change the <a id="sthref1274"></a><a id="sthref1275"></a><code>AQ_TM_PROCESSES</code> dynamic parameter to the value 0. The change will take effect immediately without having to restart the instance.</p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r4c1-t2" headers="r1c1-t2">
<p>DBSNMP<a id="sthref1276"></a><a id="sthref1277"></a><a id="sthref1278"></a></p>
</td>
<td class="cellalignment1820" headers="r4c1-t2 r1c2-t2">
<p>Oracle Enterprise Manager Management Agent</p>
</td>
<td class="cellalignment1820" headers="r4c1-t2 r1c3-t2">
<p>Issue the <code>emctl stop agent</code> command from the operating system prompt.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" --></div>
<!-- class="sect2" -->
<a id="i637861"></a>
<div id="SBYDB4913" class="sect2">
<h3 class="sect2"><span class="secnum">A.4.3</span> Switchover Fails with the <a id="sthref1279"></a><a id="sthref1280"></a><a id="sthref1281"></a>ORA-01102 Error</h3>
<p>Suppose the standby database and the primary database reside on the same site. After both the <a id="sthref1282"></a><a id="sthref1283"></a><code>ALTER DATABASE COMMIT TO SWITCHOVER TO PHYSICAL</code> <code>STANDBY</code> and the <code>ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY</code> statements are successfully executed, shut down and restart the physical standby database and the primary database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is not necessary to shut down and restart the physical standby database if it has not been opened read-only since the instance was started.</div>
<p>However, the startup of the second database fails with ORA-01102 error "cannot mount database in <code>EXCLUSIVE</code> mode."</p>
<p>This could happen during the switchover if you did not set the <code>DB_UNIQUE_NAME</code> parameter in the initialization parameter file that is used by the standby database (that is, the original primary database). If the <a id="sthref1284"></a><a id="sthref1285"></a><code>DB_UNIQUE_NAME</code> parameter of the standby database is not set, the standby and the primary databases both use the same mount lock and cause the ORA-01102 error during the startup of the second database.</p>
<p>Action: Add <code>DB_UNIQUE_NAME=</code><code><span class="codeinlineitalic">unique_database_name</span></code> to the initialization parameter file used by the standby database, and shut down and restart the standby and primary databases.</p>
</div>
<!-- class="sect2" -->
<a id="i634321"></a>
<div id="SBYDB4914" class="sect2">
<h3 class="sect2"><span class="secnum">A.4.4</span> Redo Data Is Not Applied After Switchover</h3>
<p>The archived redo log files are not applied to the new standby database after the switchover.</p>
<p>This might happen because some environment or initialization parameters were not properly set after the switchover.</p>
<p>Action:</p>
<ul>
<li>
<p>Check the <a id="sthref1286"></a><a id="sthref1287"></a><code>tnsnames.ora</code> file at the new primary site and the <code>listener.ora</code> file at the new standby site. There should be entries for a listener at the standby site and a corresponding service name at the primary site.</p>
</li>
<li>
<p>Start the listener at the standby site if it has not been started.</p>
</li>
<li>
<p>Check if the <code>LOG_ARCHIVE_DEST_</code><code><span class="codeinlineitalic">n</span></code> initialization parameter was set to properly transmit redo data from the primary site to the standby site. For example, query the <code>V$ARCHIVE_DEST</code> fixed view at the primary site as follows:</p>
<pre>
SQL&gt; SELECT DEST_ID, STATUS, DESTINATION FROM V$ARCHIVE_DEST;
</pre>
<p>If you do not see an entry corresponding to the standby site, you need to set <code>LOG_ARCHIVE_DEST_</code><code><span class="codeinlineitalic">n</span></code> and <code>LOG_ARCHIVE_DEST_STATE_</code><code><span class="codeinlineitalic">n</span></code> initialization parameters.</p>
</li>
<li>
<p>Set the <code>STANDBY_ARCHIVE_DEST</code> and <code>LOG_ARCHIVE_FORMAT</code> initialization parameters correctly at the standby site so that the archived redo log files are applied to the desired location. (Note that the <code>STANDBY_ARCHIVE_DEST</code> parameter has been deprecated and is supported for backward compatibility only.)</p>
</li>
<li>
<p>At the standby site, set the<a id="sthref1288"></a><a id="sthref1289"></a> <code>DB_FILE_NAME_CONVERT</code> and<a id="sthref1290"></a><a id="sthref1291"></a> <code>LOG_FILE_NAME_CONVERT</code> initialization parameters. Set the <code>STANDBY_FILE_MANAGEMENT</code> initialization parameter to <code>AUTO</code> if you want the standby site to automatically add new datafiles that are created at the primary site.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i637876"></a>
<div id="SBYDB4915" class="sect2">
<h3 class="sect2"><span class="secnum">A.4.5</span> Roll Back After <a id="sthref1292"></a><a id="sthref1293"></a><a id="sthref1294"></a>Unsuccessful Switchover and Start Over</h3>
<p>For physical standby databases in situations where an error occurred and it is not possible to continue with the switchover, it might still be possible to revert the new physical standby database back to the primary role by using the following steps. (This functionality is available starting with Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2).)</p>
<ol>
<li>
<p>Shut down and mount the new standby database (old primary).</p>
</li>
<li>
<p>Start Redo Apply on the new standby database.</p>
</li>
<li>
<p>Verify that the new standby database is ready to be switched back to the primary role. Query the <code>SWITCHOVER_STATUS</code> column of the <code>V$DATABASE</code> view on the new standby database. For example:</p>
<pre>
SQL&gt; SELECT SWITCHOVER_STATUS FROM V$DATABASE;
 
SWITCHOVER_STATUS 
----------------- 
TO_PRIMARY 
1 row selected
</pre>
<p>A value of <code>TO PRIMARY</code> or <code>SESSIONS ACTIVE</code> indicates that the new standby database is ready to be switched to the primary role. Continue to query this column until the value returned is either <code>TO PRIMARY</code> or <code>SESSIONS ACTIVE</code>.</p>
</li>
<li>
<p>Issue the following statement to convert the new standby database back to the primary role:</p>
<pre>
SQL&gt; ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY WITH SESSION SHUTDOWN;
</pre>
<p>If this statement is successful, the database will be running in the primary database role, and you do not need to perform any more steps.</p>
<p>If this statement is unsuccessful, then continue with Step 5.</p>
</li>
<li>
<p>When the switchover to change the role from primary to physical standby was initiated, a trace file was written in the log directory. This trace file contains the SQL statements required to re-create the original primary control file. Locate the trace file and extract the SQL statements into a temporary file. Execute the temporary file from SQL*Plus. This will revert the new standby database back to the primary role.</p>
</li>
<li>
<p>Shut down the original physical standby database.</p>
</li>
<li>
<p>Create a new standby control file. This is necessary to resynchronize the primary database and physical standby database. Copy the physical standby control file to the original physical standby system. <a href="create_ps.htm#i68937">Section 3.2.2</a> describes how to create a physical standby control file.</p>
</li>
<li>
<p>Restart the original physical standby instance.</p>
<p>If this procedure is successful and archive gap management is enabled, the FAL processes will start and re-archive any missing archived redo log files to the physical standby database. Force a log switch on the primary database and examine the alert logs on both the primary database and physical standby database to ensure the archived redo log file sequence numbers are correct.</p>
<p>See <a href="log_transport.htm#BABIDDDC">Section 6.4.3.1</a> for information about archive gap management and <a href="trace.htm#g638947">Appendix F</a> for information about locating the trace files.</p>
</li>
<li>
<p>Try the switchover again.</p>
<p>At this point, the Data Guard configuration has been rolled back to its initial state, and you can try the switchover operation again (after correcting any problems that might have led to the initial unsuccessful switchover).</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJHACH"></a>
<div id="SBYDB4916" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">A.5</span> Problems Switching Over to a Logical Standby Database</h2>
<p>A switchover operation involving a logical standby database usually consists of two phases: preparing and committing. The exceptions to this are for rolling upgrades of Oracle software using a logical standby database or if you are using Data Guard broker. If you experience failures in the context of doing a rolling upgrade using a logical standby database or during a switchover operation initiated by Data Guard broker, you should go directly to <a href="#BABJAADG">Section A.5.2</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle recommends that Flashback Database be enabled for all databases in a Data Guard configuration. The steps in this section assume that you have Flashback Database enabled on all databases in your Data Guard configuration.</div>
<div id="SBYDB4917" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1295"></a>
<h3 class="sect2"><span class="secnum">A.5.1</span> Failures During the Prepare Phase of a Switchover Operation</h3>
<p>If a failure occurs during the preparation phase of a switchover operation, you should cancel the switchover and retry the switchover operation from the very beginning.</p>
<a id="BABIADHC"></a>
<div id="SBYDB4918" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">A.5.1.1</span> Failure While Preparing the Primary Database</h4>
<p>If you encounter failure while executing the <code>ALTER DATABASE PREPARE TO SWITCHOVER TO LOGICAL STANDBY</code> statement, you can cancel the prepare phase of a switchover by issuing the following SQL statement at the primary database:</p>
<pre>
SQL&gt; ALTER DATABASE PREPARE TO SWITCHOVER TO LOGICAL STANDBY CANCEL;
</pre>
<p>You can now retry the switchover operation from the beginning.</p>
</div>
<!-- class="sect3" -->
<a id="BABDBDED"></a>
<div id="SBYDB4919" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">A.5.1.2</span> Failure While Preparing the Logical Standby Database</h4>
<p>If you encounter failure while executing the <code>ALTER DATABASE PREPARE TO SWITCHOVER TO PRIMARY</code> statement, you will need to cancel the prepare operation at the primary database and at the target standby database. Take the following steps:</p>
<ol>
<li>
<p>At the primary database, cancel the statement you had issued to prepare for the switchover:</p>
<pre>
SQL&gt; ALTER DATABASE PREPARE TO SWITCHOVER TO LOGICAL STANDBY CANCEL;
</pre></li>
<li>
<p>At the logical standby database that was the target of the switchover, cancel the statement you had issued to prepare to switch over:</p>
<pre>
SQL&gt; ALTER DATABASE PREPARE TO SWITCHOVER TO PRIMARY CANCEL;
</pre>
<p>You can now retry the switchover operation from the beginning.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABJAADG"></a>
<div id="SBYDB4920" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">A.5.2</span> Failures During the Commit Phase of a Switchover Operation</h3>
<p>Although committing to a switchover involves a single SQL statement, internally a number of operations are performed. The corrective actions that you need to take depend on the state of the commit to switchover operation when the error was encountered.</p>
<div id="SBYDB01415" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1296"></a>
<h4 class="sect3"><span class="secnum">A.5.2.1</span> Failure to Convert the Original Primary Database</h4>
<p>If you encounter failures while executing the <code>ALTER DATABASE COMMIT TO SWITCHOVER TO LOGICAL STANDBY</code> statement, you can take the following steps:</p>
<ol>
<li>
<p>Check the <code>DATABASE_ROLE</code> column of the <code>V$DATABASE</code> fixed view on the original primary database:</p>
<pre>
SQL&gt; SELECT DATABASE_ROLE FROM V$DATABASE;
</pre>
<ul>
<li>
<p>If the column contains a value of <code>LOGICAL STANDBY</code>, the switchover operation has completed, but has failed during a post-switchover task. In this situation, Oracle recommends that you shut down and reopen the database.</p>
</li>
<li>
<p>If the column contains a value of <code>PRIMARY</code>, proceed to Step 2.</p>
</li>
</ul>
</li>
<li>
<p>Perform the following query on the original primary:</p>
<pre>
SQL&gt; SELECT COUNT(*) FROM SYSTEM.LOGSTDBY$PARAMETERS -
&gt; WHERE NAME = 'END_PRIMARY';
</pre>
<ul>
<li>
<p>If the query returns a 0, the primary is in a state identical to that it was in before the commit to switchover command was issued. You do not need to take any corrective action. You can proceed with the commit to switchover operation or cancel the switchover operation as outlined in <a href="#BABDBDED">Section A.5.1.2</a>.</p>
</li>
<li>
<p>If the query returns a 1, the primary is in an inconsistent state, and you need to proceed to Step 3.</p>
</li>
</ul>
</li>
<li>
<p>Take corrective action at the original primary database to maintain its ability to be protected by existing or newly instantiated logical standby databases.</p>
<p>You can either fix the underlying cause of the error raised during the commit to switchover operation and reissue the SQL statement (<code>ALTER DTABASE COMMIT TO SWITCHOVER TO LOGICAL STANDBY</code>) or you can take the following steps:</p>
<ol>
<li>
<p>From the alert log of the instance where you initiated the commit to switchover command, determine the SCN needed to flash back to the original primary. This information is displayed after the <code>ALTER DATABASE COMMIT TO SWITCHOVER TO LOGICAL STANDBY</code> SQL statement:</p>
<pre>
LOGSTDBY: Preparing the COMMIT TO SWITCHOVER TO LOGICAL STANDBY DDL at scn [flashback_scn].
</pre></li>
<li>
<p>Shut down all instances of the primary database:</p>
<pre>
SQL&gt; SHUTDOWN IMMEDIATE;
</pre></li>
<li>
<p>Mount the primary database in exclusive mode:</p>
<pre>
SQL&gt; STARTUP MOUNT;
</pre></li>
<li>
<p>Flash back the database to the SCN taken from the alert log:</p>
<pre>
SQL&gt; FLASHBACK DATABASE TO BEFORE SCN &lt;flashback_scn&gt;;
</pre></li>
<li>
<p>Open the primary database:</p>
<pre>
SQL&gt; STARTUP;
</pre></li>
<li>
<p>Lower the database guard at the original primary database:</p>
<pre>
SQL&gt; ALTER DATABASE GUARD NONE;
</pre></li>
</ol>
<p>At this point the primary is in a state identical to that it was in before the commit switchover command was issued. You do not need to take any corrective action. you can proceed with the commit to switchover operation or cancel the switchover operation as outlined in <a href="#BABIADHC">Section A.5.1.1</a>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="SBYDB01420" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1297"></a>
<h4 class="sect3"><span class="secnum">A.5.2.2</span> Failure to Convert the Target Logical Standby Database</h4>
<p>If you encounter failures while executing the <code>ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY</code> statement, take the following steps:</p>
<ol>
<li>
<p>Check the <code>DATABASE_ROLE</code> column of the <code>V$DATABASE</code> fixed view on the target standby database:</p>
<pre>
SQL&gt; SELECT DATABASE_ROLE FROM V$DATABASE;
</pre>
<ul>
<li>
<p>If the column contains a value <code>PRIMARY</code>, the switchover operation has completed, but has failed during a post-switchover task. In this situation, you must perform the following steps:</p>
<ol>
<li>
<p>Shut down and reopen the database.</p>
</li>
<li>
<p>Issue an <code>ALTER DATABASE GUARD NONE</code> command to remove write restrictions to the database.</p>
</li>
</ol>
</li>
<li>
<p>If the column contains a value of <code>LOGICAL STANDBY</code>, proceed to Step 2.</p>
</li>
</ul>
</li>
<li>
<p>Perform the following query on the target logical standby:</p>
<pre>
SQL&gt; SELECT COUNT(*) FROM SYSTEM.LOGSTDBY$PARAMETERS -
&gt; WHERE NAME = 'BEGIN_PRIMARY';
</pre>
<ul>
<li>
<p>If the query returns a 0, the logical standby is in a state identical to that it was in before the commit to switchover command was issued. You do not need to take any corrective action. You can proceed with the commit to switchover operations or cancel the switchover operation as outlined in <a href="#BABDBDED">Section A.5.1.2</a>.</p>
</li>
<li>
<p>If the query returns a 1, the logical standby is in an inconsistent state, and you should proceed to Step 3.</p>
</li>
</ul>
</li>
<li>
<p>Take corrective action at the logical standby to maintain its ability to either become the new primary or become a bystander to a different new primary.</p>
<p>You can either fix the underlying cause of the error raised during the commit to switchover operation and reissue the SQL statement (<code>ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY</code>) or you can take the following steps to flash back the logical standby database to a point of consistency just prior to the commit to switchover attempt:</p>
<ol>
<li>
<p>From the alert log of the instance where you initiated the commit to switchover command, determine the SCN needed to flash back to the logical standby. This information is displayed after the <code>ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY</code> SQL statement:</p>
<pre>
LOGSTDBY: Preparing the COMMIT TO SWITCHOVER TO PRIMARY DDL at scn [flashback_scn].
</pre></li>
<li>
<p>Shut down all instances of the target standby database:</p>
<pre>
SQL&gt; SHUTDOWN IMMEDIATE;
</pre></li>
<li>
<p>Mount the target logical standby database:</p>
<pre>
SQL&gt; STARTUP MOUNT;
</pre></li>
<li>
<p>Flash back the target logical standby to the desired SCN:</p>
<pre>
SQL&gt; FLASHBACK DATABASE TO BEFORE SCN &lt;flashback_scn&gt;;
</pre></li>
<li>
<p>Open the database (in case of an Oracle RAC, open all instances);</p>
<pre>
SQL&gt; STARTUP OPEN;
</pre></li>
</ol>
</li>
</ol>
<p>At this point the target standby is in a state identical to that it was in before the commit to switchover command was issued. You do not need to take any further corrective action. You can proceed with the commit to switchover operation.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i634786"></a>
<div id="SBYDB4921" class="sect1">
<h2 class="sect1"><span class="secnum">A.6</span> What to Do If <a id="sthref1298"></a><a id="sthref1299"></a>SQL Apply Stops</h2>
<p><a id="sthref1300"></a>Apply services cannot apply unsupported DML statements, DDL statements, and Oracle supplied packages to a logical standby database running SQL Apply.</p>
<p>When an unsupported statement or package is encountered, SQL Apply stops. You can take the actions described in <a href="#g640603">Table A-2</a> to correct the situation and start SQL Apply on the logical standby database again.</p>
<div id="SBYDB5087" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref1301"></a><a id="g640603"></a>Table A-2 Fixing Typical SQL Apply Errors</p>
<table class="cellalignment1823" title="Fixing Typical SQL Apply Errors" summary="Lists typical reasons why SQL Apply stops and describes possible solutions to correct each situation." dir="ltr">
<thead>
<tr class="cellalignment1814">
<th class="cellalignment1824" id="r1c1-t5">If...</th>
<th class="cellalignment1824" id="r1c2-t5">Then...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r2c1-t5" headers="r1c1-t5">
<p>You suspect an unsupported statement or Oracle supplied package was encountered</p>
</td>
<td class="cellalignment1820" headers="r2c1-t5 r1c2-t5">
<p>Find the last statement in the <a id="sthref1302"></a><a id="sthref1303"></a><code>DBA_LOGSTDBY_EVENTS</code> view. This will indicate the statement and error that caused SQL Apply to fail. If an incorrect SQL statement caused SQL Apply to fail, transaction information, as well as the statement and error information, can be viewed. The transaction information can be used with LogMiner tools to understand the cause of the problem.</p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r3c1-t5" headers="r1c1-t5">
<p>An error requiring database management occurred, such as running out of space in a particular tablespace</p>
</td>
<td class="cellalignment1820" headers="r3c1-t5 r1c2-t5">
<p>Fix the problem and resume SQL Apply using the <a id="sthref1304"></a><a id="sthref1305"></a><code>ALTER DATABASE START LOGICAL STANDBY APPLY</code> statement.</p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r4c1-t5" headers="r1c1-t5">
<p>An error occurred because a SQL statement was entered incorrectly, such as an incorrect standby database filename being entered in a tablespace statement</p>
</td>
<td class="cellalignment1820" headers="r4c1-t5 r1c2-t5">
<p>Enter the correct SQL statement and use the <a id="sthref1306"></a><a id="sthref1307"></a><code>DBMS_LOGSTDBY.SKIP_TRANSACTION</code> procedure to ensure the incorrect statement is ignored the next time SQL Apply is run. Then, restart SQL Apply using the <code>ALTER DATABASE START LOGICAL STANDBY APPLY</code> statement.</p>
</td>
</tr>
<tr class="cellalignment1814">
<td class="cellalignment1820" id="r5c1-t5" headers="r1c1-t5">
<p>An error occurred because skip parameters were incorrectly set up, such as specifying that all DML for a given table be skipped but <code>CREATE</code>, <code>ALTER</code>, and <code>DROP TABLE</code> statements were not specified to be skipped</p>
</td>
<td class="cellalignment1820" headers="r5c1-t5 r1c2-t5">
<p>Issue the <a id="sthref1308"></a><a id="sthref1309"></a><code>DBMS_LOGSTDBY.SKIP('TABLE','schema_name','table_name',null)</code> procedure, then restart SQL Apply.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>See <a href="views.htm#g1009239">Chapter 17</a> for information about querying the <code>DBA_LOGSTDBY_EVENTS</code> view to determine the cause of failures.</p>
</div>
<!-- class="sect1" -->
<a id="i635902"></a>
<div id="SBYDB00440" class="sect1">
<h2 class="sect1"><span class="secnum">A.7</span> Network Tuning for Redo Data Transmission<a id="sthref1310"></a><a id="sthref1311"></a></h2>
<p>For optimal performance, set the Oracle Net <code>SDU</code> parameter to 32 kilobytes in each Oracle Net connect descriptor used by redo transport services.</p>
<p>The following example shows a database initialization parameter file segment that defines a remote destination <code>netserv</code>:</p>
<pre>
LOG_ARCHIVE_DEST_3='SERVICE=netserv'
</pre>
<p>The f<a id="sthref1312"></a><a id="sthref1313"></a>ollowing example shows the definition of that service name in the <a id="sthref1314"></a><a id="sthref1315"></a><a id="sthref1316"></a><a id="sthref1317"></a><code>tnsnames.ora</code> file:</p>
<pre>
netserv=(DESCRIPTION=(SDU=32768)(ADDRESS=(PROTOCOL=tcp)(HOST=host) (PORT=1521)) (CONNECT_DATA=(SERVICE_NAME=srvc)))
</pre>
<p>The following example shows the definition in the <code>listener.ora</code> file:</p>
<pre>
LISTENER=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=tcp)
(HOST=host)(PORT=1521))))

SID_LIST_LISTENER=(SID_LIST=(SID_DESC=(SDU=32768)(SID_NAME=sid)
(GLOBALDBNAME=srvc)(ORACLE_HOME=/oracle)))
</pre>
<p>If you archive to a remote site using a high-latency or high-bandwidth network link, you can improve performance by using the <code>SQLNET.SEND_BUF_SIZE</code> and <code>SQLNET.RECV_BUF_SIZE</code> Oracle Net profile parameters to increase the size of the network send and receive I/O buffers.</p>
<p>See <a class="olink NETAG" href="../../network.112/e41945/toc.htm"><span class="italic">Oracle Database Net Services Administrator's Guide</span></a> for information about other ways to change the Oracle NET SDU parameter.</p>
</div>
<!-- class="sect1" -->
<a id="i637895"></a>
<div id="SBYDB4922" class="sect1">
<h2 class="sect1"><span class="secnum">A.8</span> Slow Disk Performance on Standby Databases</h2>
<p>If asynchronous I/O on the file system itself is showing performance problems, try mounting the file system using the Direct I/O option or setting the <code>FILESYSTEMIO_OPTIONS=SETALL</code> initialization parameter. The maximum I/O size setting is 1 MB.</p>
</div>
<!-- class="sect1" -->
<a id="i639505"></a>
<div id="SBYDB4923" class="sect1">
<h2 class="sect1"><span class="secnum">A.9</span> Log Files Must Match to Avoid Primary Database Shutdown</h2>
<p>If you have configured a standby redo log on one or more standby databases in the configuration, ensure the size of the standby redo log files on each standby database exactly matches the size of the online redo log files on the primary database.</p>
<p>At log switch time, if there are no available standby redo log files that match the size of the new current online redo log file on the primary database:</p>
<ul>
<li>
<p>The primary database will shut down if it is operating in maximum protection mode,</p>
<p><span class="bolditalic">or</span></p>
</li>
<li>
<p>The RFS process on the standby database will create an archived redo log file on the standby database and write the following message in the alert log:</p>
<pre>
No standby log files of size &lt;#&gt; blocks available.
</pre></li>
</ul>
<p>For example, if the primary database uses two online redo log groups whose log files are 100K, then the standby database should have 3 standby redo log groups with log file sizes of 100K.</p>
<p>Also, whenever you add a redo log group to the primary database, you must add a corresponding standby redo log group to the standby database. This reduces the probability that the primary database will be adversely affected because a standby redo log file of the required size is not available at log switch time.</p>
</div>
<!-- class="sect1" -->
<a id="CHDBDBHH"></a>
<div id="SBYDB4924" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">A.10</span> Troubleshooting a Logical Standby Database</h2>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1014367">Recovering from Errors</a></p>
</li>
<li>
<p><a href="#CHDHHHFC">Troubleshooting SQL*Loader Sessions</a></p>
</li>
<li>
<p><a href="#CHDDIEGJ">Troubleshooting Long-Running Transactions</a></p>
</li>
<li>
<p><a href="#CHDFEDBG">Troubleshooting ORA-1403 Errors with Flashback Transactions</a></p>
</li>
</ul>
<a id="i1014367"></a>
<div id="SBYDB4925" class="sect2">
<h3 class="sect2"><span class="secnum">A.10.1</span> Recovering <a id="sthref1318"></a>from Errors</h3>
<p>Logical standby databases maintain user tables, sequences, and jobs. To maintain other objects, you must reissue the DDL statements seen in the redo data stream.</p>
<p>If SQL Apply fails, an error is recorded in the <code>DBA_LOGSTDBY_EVENTS</code> table. The following sections demonstrate how to recover from two such errors.</p>
<div id="SBYDB4926" class="sect3"><a id="sthref1319"></a>
<h4 class="sect3"><span class="secnum">A.10.1.1</span> DDL Transactions Containing File Specifications</h4>
<p>DDL statements are executed the same way on the primary database and the logical standby database. If the underlying file structure is the same on both databases, the DDL will execute on the standby database as expected.</p>
<p>If an error was caused by a DDL transaction containing a file specification that did not match in the logical standby database environment, perform the following steps to fix the problem:</p>
<ol>
<li>
<p>Use the <code>ALTER SESSION DISABLE</code> <code>GUARD</code> statement to bypass the database guard so you can make modifications to the logical standby database:</p>
<pre>
SQL&gt; ALTER SESSION DISABLE GUARD;
</pre></li>
<li>
<p>Execute the DDL statement, using the correct file specification, and then reenable the database guard. For example:</p>
<pre>
SQL&gt; <a id="sthref1320"></a><a id="sthref1321"></a>ALTER TABLESPACE t_table ADD DATAFILE '/dbs/t_db.f' SIZE 100M REUSE;
SQL&gt; ALTER SESSION ENABLE GUARD;
</pre></li>
<li>
<p>Start SQL Apply on the logical standby database and skip the failed transaction.</p>
<pre>
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE -
&gt; SKIP FAILED TRANSACTION;
</pre></li>
</ol>
<p>In some situations, the problem that caused the transaction to fail can be corrected and SQL Apply restarted without skipping the transaction. An example of this might be when available space is exhausted. (Do not let the primary and logical standby databases diverge when skipping DDL transactions. If possible, you should manually execute a compensating transaction in place of the skipped transaction.)</p>
<p>The following example shows SQL Apply stopping, the error being corrected, and then restarting SQL Apply:</p>
<pre>
SQL&gt; SET LONG 1000
SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT  = 'DD-MON-YY HH24:MI:SS';

Session altered.

SQL&gt; SELECT EVENT_TIME, COMMIT_SCN, EVENT, STATUS FROM DBA_LOGSTDBY_EVENTS;

EVENT_TIME              COMMIT_SCN
------------------ ---------------
EVENT
-------------------------------------------------------------------------------
STATUS
-------------------------------------------------------------------------------
22-OCT-03 15:47:58

ORA-16111: log mining and apply setting up

22-OCT-03 15:48:04          209627
insert into "SCOTT"."EMP"
values
   "EMPNO" = 7900,
   "ENAME" = 'ADAMS',
   "JOB" = 'CLERK',
   "MGR" IS NULL,
   "HIREDATE" = TO_DATE('22-OCT-03', 'DD-MON-RR'),
   "SAL" = 950,
   "COMM" IS NULL,
   "DEPTNO" IS NULL
ORA-01653: unable to extend table SCOTT.EMP by %200 bytes in tablespace T_TABLE
</pre>
<p>In the example, the <code>ORA-01653</code> message indicates that the tablespace was full and unable to extend itself. To correct the problem, add a new datafile to the tablespace. For example:</p>
<pre>
SQL&gt; <a id="sthref1322"></a><a id="sthref1323"></a><a id="sthref1324"></a>ALTER TABLESPACE t_table ADD DATAFILE '/dbs/t_db.f' SIZE 60M;
Tablespace altered.
</pre>
<p>Then, restart SQL Apply:</p>
<pre>
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered.
</pre>
<p>When SQL Apply restarts, the transaction that failed will be reexecuted and applied to the logical standby database.</p>
</div>
<!-- class="sect3" -->
<div id="SBYDB4927" class="sect3"><a id="sthref1325"></a>
<h4 class="sect3"><span class="secnum">A.10.1.2</span> Recovering from DML Failures</h4>
<p>Do not use the <code>SKIP_TRANSACTION</code> procedure to filter DML failures. Not only is the DML that is seen in the events table skipped, but so is all the DML associated with the transaction. This will cause multiple tables.</p>
<p>DML failures usually indicate a problem with a specific table. For example, assume the failure is an out-of-storage error that you cannot resolve immediately. The following steps demonstrate one way to respond to this problem.</p>
<ol>
<li>
<p>Bypass the table, but not the transaction, by adding the table to the skip list:</p>
<pre>
SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP('DML','SCOTT','EMP');
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
</pre>
<p>From this point on, DML activity for the <code>SCOTT.EMP</code> table is not applied. After you correct the storage problem, you can fix the table, provided you set up a database link to the primary database that has administrator privileges to run procedures in the <code>DBMS_LOGSTDBY</code> package.</p>
</li>
<li id="i1047427">
<p>Using the database link to the primary database, drop the local <code>SCOTT.EMP</code> table and then re-create it, and pull the data over to the standby database.</p>
<pre>
SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
SQL&gt; EXECUTE DBMS_LOGSTDBY.INSTANTIATE_TABLE('SCOTT','EMP','PRIMARYDB');
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
</pre></li>
<li>
<p>To ensure a consistent view across the newly instantiated table and the rest of the database, wait for SQL Apply to catch up with the primary database before querying this table. Refer to <a href="manage_ls.htm#i1016645">Section 10.5.5, "Adding or Re-Creating Tables On a Logical Standby Database"</a> for a detailed example.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDHHHFC"></a>
<div id="SBYDB4928" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">A.10.2</span> Troubleshooting SQL*Loader Sessions</h3>
<p>Oracle SQL*Loader provides a method of loading data from different sources into the Oracle Database. This section analyzes some of the features of the SQL*Loader utility as it pertains to SQL Apply.</p>
<p>Regardless of the method of data load chosen, the SQL*Loader control files contain an instruction on what to do to the current contents of the Oracle table into which the new data is to be loaded, via the keywords of <code>APPEND</code> and <code>REPLACE</code>. The following examples show how to use these keywords on a table named <code>LOAD_STOK</code>:</p>
<ul>
<li>
<p>When using the <code>APPEND keyword</code>, the new data to be loaded is appended to the contents of the <code>LOAD_STOK</code> table:</p>
<pre>
LOAD DATA
INTO TABLE LOAD_STOK APPEND
</pre></li>
<li>
<p>When using the <code>REPLACE</code> keyword, the contents of the <code>LOAD_STOK</code> table are deleted prior to loading new data. Oracle SQL*Loader uses the <code>DELETE</code> statement to purge the contents of the table, in a single transaction:</p>
<pre>
LOAD DATA
INTO TABLE LOAD_STOK REPLACE
</pre></li>
</ul>
<p>Rather than using the <code>REPLACE</code> keyword in the SQL*Loader script, Oracle recommends that prior to loading the data, issue the SQL*Plus <code>TRUNCATE TABLE</code> command against the table on the primary database. This will have the same effect of purging both the primary and standby databases copy of the table in a manner that is both fast and efficient because the <code>TRUNCATE TABLE</code> command is recorded in the online redo log files and is issued by SQL Apply on the logical standby database.</p>
<p>The SQL*Loader script may continue to contain the <code>REPLACE</code> keyword, but it will now attempt to <code>DELETE</code> zero rows from the object on the primary database. Because no rows were deleted from the primary database, there will be no redo recorded in the redo log files. Therefore, no <code>DELETE</code> statement will be issued against the logical standby database.</p>
<p>Issuing the <code>REPLACE</code> keyword without the SQL statement <code>TRUNCATE TABLE</code> provides the following potential problems for SQL Apply when the transaction needs to be applied to the logical standby database.</p>
<ul>
<li>
<p>If the table currently contains a significant number of rows, then these rows need to be deleted from the standby database. Because SQL Apply is not able to determine the original syntax of the statement, SQL Apply must issue a <code>DELETE</code> statement for each row purged from the primary database.</p>
<p>For example, if the table on the primary database originally had 10,000 rows, then Oracle SQL*Loader will issue a single <code>DELETE</code> statement to purge the 10,000 rows. On the standby database, SQL Apply does not know that all rows are to be purged, and instead must issue 10,000 individual <code>DELETE</code> statements, with each statement purging a single row.</p>
</li>
<li>
<p>If the table on the standby database does not contain an index that can be used by SQL Apply, then the <code>DELETE</code> statement will issue a Full Table Scan to purge the information.</p>
<p>Continuing with the previous example, because SQL Apply has issued 10,000 individual <code>DELETE</code> statements, this could result in 10,000 Full Table Scans being issued against the standby database.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDDIEGJ"></a>
<div id="SBYDB4929" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">A.10.3</span> Troubleshooting Long-Running Transactions</h3>
<p>One of the primary causes for long-running transactions in a SQL Apply environment is because of Full Table Scans. Additionally, long-running transactions could be the result of SQL statements being replicated to the standby database, such as when creating or rebuilding an index.</p>
<p class="subhead2"><a id="SBYDB5088"></a>Identifying Long-Running Transactions</p>
<p>If SQL Apply is executing a single SQL statement for a long period of time, then a warning message similar to the following is reported in the alert log of the SQL Apply instance:</p>
<pre>
Mon Feb 17 14:40:15 2003
WARNING: the following transaction makes no progress
WARNING: in the last 30 seconds for the given message!
WARNING: xid =
0x0016.007.000017b6 cscn = 1550349, message# = 28, slavid = 1
knacrb: no offending session found (not ITL pressure)
</pre>
<p>Note the following about the warning message:</p>
<ul>
<li>
<p>This warning is similar to the warning message returned for interested transaction list (ITL) pressure, with the exception being the last line that begins with <code>knacrb</code>. The final line indicates:</p>
<ul>
<li>
<p>A Full Table Scan may be occurring</p>
</li>
<li>
<p>This issue has nothing to do with interested transaction list (ITL) pressure</p>
</li>
</ul>
</li>
<li>
<p>This warning message is reported only if a single statement takes more than 30 seconds to execute.</p>
</li>
</ul>
<p>It may not be possible to determine the SQL statement being executed by the long-running statement, but the following SQL statement may help in identifying the database objects on which SQL Apply is operating:</p>
<pre>
SQL&gt; SELECT SAS.SERVER_ID -
&gt;  , SS.OWNER -
&gt;  , SS.OBJECT_NAME -
&gt;  , SS.STATISTIC_NAME -
&gt;  , SS.VALUE -
&gt;  FROM V$SEGMENT_STATISTICS SS -
&gt;  , V$LOCK L -
&gt;  , V$STREAMS_APPLY_SERVER SAS -
&gt;  WHERE SAS.SERVER_ID = &amp;SLAVE_ID -
&gt;  AND L.SID = SAS.SID -
&gt;  AND L.TYPE = 'TM' -
&gt;  AND SS.OBJ# = L.ID1;
</pre>
<p>Additionally, you can issue the following SQL statement to identify the SQL statement that has resulted in a large number of disk reads being issued per execution:</p>
<pre>
SQL&gt; SELECT SUBSTR(SQL_TEXT,1,40) -
&gt;  , DISK_READS -
&gt;  , EXECUTIONS -
&gt;  , DISK_READS/EXECUTIONS -
&gt;  , HASH_VALUE -
&gt;  , ADDRESS -
&gt;  FROM V$SQLAREA -
&gt;  WHERE DISK_READS/GREATEST(EXECUTIONS,1) &gt; 1 -
&gt;  AND ROWNUM &lt; 10 -
&gt;  ORDER BY DISK_READS/GREATEST(EXECUTIONS,1) DESC;
</pre>
<p>Oracle recommends that all tables have primary key constraints defined, which automatically means that the column is defined as <code>NOT NULL</code>. For any table where a primary-key constraint cannot be defined, an index should be defined on an appropriate column that is defined as <code>NOT NULL</code>. If a suitable column does not exist on the table, then the table should be reviewed and, if possible, skipped by SQL Apply. The following steps describe how to skip all DML statements issued against the <code>FTS</code> table on the <code>SCOTT</code> schema:</p>
<ol>
<li>
<p>Stop SQL Apply:</p>
<pre>
SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
Database altered
</pre></li>
<li>
<p>Configure the skip procedure for the <code>SCOTT.FTS</code> table for all DML transactions:</p>
<pre>
SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP(stmt =&gt; 'DML' , -
&gt;  schema_name =&gt; 'SCOTT' , -
&gt;  object_name =&gt; 'FTS');
PL/SQL procedure successfully completed
</pre></li>
<li>
<p>Start SQL Apply:</p>
<pre>
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered
</pre></li>
</ol>
<p class="subhead2"><a id="SBYDB5089"></a>Troubleshooting ITL Pressure</p>
<p>Interested transaction list (ITL) pressure is reported in the alert log of the SQL Apply instance. <a href="#CHDIGFHH">Example A-3</a> shows an example of the warning messages.</p>
<div id="SBYDB5090" class="example">
<p class="titleinexample"><a id="CHDIGFHH"></a>Example A-3 Warning Messages Reported for ITL Pressure</p>
<pre>
Tue Apr 22 15:50:42 2003
WARNING: the following transaction makes no progress
WARNING: in the last 30 seconds for the given message!
WARNING: xid =
0x0006.005.000029fa cscn = 2152982, message# = 2, slavid = 17
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SBYDB5091"></a>Real-Time Analysis</p>
<p>The messages shown in <a href="#CHDIGFHH">Example A-3</a> indicate that the SQL Apply process (<code>slavid</code>) #17 has not made any progress in the last 30 seconds. To determine the SQL statement being issued by the Apply process, issue the following query:</p>
<pre>
SQL&gt; SELECT SA.SQL_TEXT -
&gt;  FROM V$SQLAREA SA -
  &gt;  , V$SESSION S -
  &gt;  , V$STREAMS_APPLY_SERVER SAS -
  &gt;  WHERE SAS.SERVER_ID = &amp;SLAVEID -
  &gt;  AND S.SID = SAS.SID -
  &gt;  AND SA.ADDRESS = S.SQL_ADDRESS

SQL_TEXT
------------------------------------------------------------
insert into "APP"."LOAD_TAB_1" p("PK","TEXT")values(:1,:2)
</pre>
<p>An alternative method to identifying ITL pressure is to query the <code>V$LOCK</code> view, as shown in the following example. Any session that has a request value of 4 on a <code>TX</code> lock, is waiting for an ITL to become available.</p>
<pre>
SQL&gt; SELECT SID,TYPE,ID1,ID2,LMODE,REQUEST -
&gt; FROM V$LOCK -
&gt; WHERE TYPE = 'TX'

SID        TY ID1        ID2        LMODE      REQUEST
---------- -- ---------- ---------- ---------- ----------
         8 TX     327688         48          6          0
        10 TX     327688         48          0          4
</pre>
<p>In this example, <code>SID 10</code> is waiting for the <code>TX</code> lock held by <code>SID 8</code>.</p>
<p class="subhead2"><a id="SBYDB5092"></a>Post-Incident Review</p>
<p>Pressure for a segment's ITL is unlikely to last for an extended period of time. In addition, ITL pressure that lasts for less than 30 seconds will not be reported in the standby databases alert log. Therefore, to determine which objects have been subjected to ITL pressure, issue the following statement:</p>
<pre>
SQL&gt; SELECT OWNER, OBJECT_NAME, OBJECT_TYPE -
&gt;  FROM V$SEGMENT_STATISTICS -
&gt;  WHERE STATISTIC_NAME = 'ITL waits' -
&gt;  AND VALUE &gt; 0 -
&gt;  ORDER BY VALUE;
</pre>
<p>This statement reports all database segments that have had ITL pressure at some time since the instance was last started.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This SQL statement is not limited to a logical standby databases in the Data Guard environment. It is applicable to any Oracle database.</div>
<p class="subhead2"><a id="SBYDB5093"></a>Resolving ITL Pressure</p>
<p>To increase the <code>INITRANS</code> integer for a particular database object, it is necessary to first stop SQL Apply.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about specifying the <code>INITRANS</code> integer, which it the initial number of concurrent transaction entries allocated within each data block allocated to the database object</div>
<p>The following example shows the necessary steps to increase the <code>INITRANS</code> for table <code>load_tab_1</code> in the schema <code>app</code>.</p>
<ol>
<li>
<p>Stop SQL Apply:</p>
<pre>
SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
Database altered.
</pre></li>
<li>
<p>Temporarily bypass the database guard:</p>
<pre>
SQL&gt; ALTER SESSION DISABLE GUARD;
Session altered.
</pre></li>
<li>
<p>Increase the <code>INITRANS</code> on the standby database. For example:</p>
<pre>
SQL&gt; ALTER TABLE APP.LOAD_TAB_1 INITRANS 30;
Table altered
</pre></li>
<li>
<p>Reenable the database guard:</p>
<pre>
SQL&gt; ALTER SESSION ENABLE GUARD;
Session altered
</pre></li>
<li>
<p>Start SQL Apply:</p>
<pre>
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered.
</pre></li>
</ol>
<p>Also, consider modifying the database object on the primary database, so in the event of a switchover, the error should not occur on the new standby database.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFEDBG"></a>
<div id="SBYDB4930" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">A.10.4</span> Troubleshooting ORA-1403 Errors with Flashback Transactions</h3>
<p>If SQL Apply returns the <code>ORA-1403: No Data Found</code> error, then it may be possible to use Flashback Transaction to reconstruct the missing data. This is reliant upon the <code>UNDO_RETENTION</code> initialization parameter specified on the standby database instance.</p>
<p>Under normal circumstances, the <code>ORA-1403</code> error should not be seen in a logical standby database environment. The error occurs when data in a table that is being managed by SQL Apply is modified directly on the standby database and then the same data is modified on the primary database. When the modified data is updated on the primary database and is subsequently received on the logical standby database, SQL Apply verifies the original version of the data is present on the standby database before updating the record. When this verification fails, the <code>ORA-1403: No Data Found</code> error is returned.</p>
<p class="subhead2"><a id="SBYDB5094"></a>The Initial Error</p>
<p>When SQL Apply verification fails, the error message is reported in the alert log of the logical standby database and a record is inserted in the <code>DBA_LOGSTDBY_EVENTS</code> view.The information in the alert log is truncated, while the error is reported in it's entirety in the database view. For example:</p>
<pre>
LOGSTDBY stmt: UPDATE "SCOTT"."MASTER"
  SET
    "NAME" = 'john'
  WHERE 
    "PK" = 1 and 
    "NAME" = 'andrew' and 
    ROWID = 'AAAAAAAAEAAAAAPAAA'
LOGSTDBY status: ORA-01403: no data found
LOGSTDBY PID 1006, oracle@staco03 (P004)
LOGSTDBY XID 0x0006.00e.00000417, Thread 1, RBA 0x02dd.00002221.10
</pre>
<p class="subhead2"><a id="SBYDB5095"></a>The Investigation</p>
<p>The first step is to analyze the historical data of the table that caused the error. This can be achieved using the <code>VERSIONS</code> clause of the <code>SELECT</code> statement. For example, you can issue the following query on the primary database:</p>
<pre>
SELECT VERSIONS_XID
      , VERSIONS_STARTSCN
      , VERSIONS_ENDSCN
      , VERSIONS_OPERATION
      , PK
      , NAME
   FROM SCOTT.MASTER
        VERSIONS BETWEEN SCN MINVALUE AND MAXVALUE
  WHERE PK = 1
  ORDER BY NVL(VERSIONS_STARTSCN,0);

VERSIONS_XID     VERSIONS_STARTSCN VERSIONS_ENDSCN V  PK NAME
---------------- ----------------- --------------- - --- -------
03001900EE070000           3492279         3492290 I   1 andrew
02000D00E4070000           3492290                 D   1 andrew
</pre>
<p>Depending upon the amount of undo retention that the database is configured to retain (<code>UNDO_RETENTION</code>) and the activity on the table, the information returned might be extensive and you may need to change the versions between syntax to restrict the amount of information returned.From the information returned, it can be seen that the record was first inserted at SCN 3492279 and then was deleted at SCN 3492290 as part of transaction ID 02000D00E4070000.Using the transaction ID, the database should be queried to find the scope of the transaction. This is achieved by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> view.</p>
<pre>
SELECT OPERATION
     , UNDO_SQL
  FROM FLASHBACK_TRANSACTION_QUERY
 WHERE XID = HEXTORAW('02000D00E4070000');

OPERATION  UNDO_SQL
---------- ------------------------------------------------
DELETE     insert into "SCOTT"."MASTER"("PK","NAME") values
           ('1','andrew');
BEGIN
</pre>
<p>Note that there is always one row returned representing the start of the transaction. In this transaction, only one row was deleted in the master table. The <code>UNDO_SQL</code> column when executed will restore the original data into the table.</p>
<pre>
SQL&gt; INSERT INTO "SCOTT"."MASTER"("PK","NAME") VALUES ('1','ANDREW');SQL&gt; COMMIT;
</pre>
<p>When you restart SQL Apply, the transaction will be applied to the standby database:</p>
<pre>
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="appendix" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1813">
<tr>
<td class="cellalignment1820">
<table class="cellalignment1818">
<tr>
<td class="cellalignment1817"><a href="partpage3.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1817"><a href="upgrades.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1822">
<table class="cellalignment1816">
<tr>
<td class="cellalignment1817"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1817"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1817"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1817"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1817"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1817"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
