<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using Indexes and Clusters</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-06-30T4:25:6Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Performance Tuning Guide" />
<meta name="dcterms.identifier" content="E41573-04" />
<meta name="dcterms.isVersionOf" content="PFGRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="stats.htm" title="Previous" type="text/html" />
<link rel="Next" href="optplanmgmt.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41573.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">22/31</span> <!-- End Header -->
<div id="PFGRF004" class="chapter"><a id="g27061"></a> <a id="i17778"></a>
<h1 class="chapter"><span class="secnum">14</span> Using Indexes and Clusters</h1>
<p>This chapter provides an overview of data access methods using indexes and clusters that can enhance or degrade performance.</p>
<p>The chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i2678">Understanding Index Performance</a></p>
</li>
<li>
<p><a href="#i9946">Using Function-based Indexes for Performance</a></p>
</li>
<li>
<p><a href="#i21879">Using Partitioned Indexes for Performance</a></p>
</li>
<li>
<p><a href="#i17143">Using Index-Organized Tables for Performance</a></p>
</li>
<li>
<p><a href="#i23051">Using Bitmap Indexes for Performance</a></p>
</li>
<li>
<p><a href="#i17719">Using Bitmap Join Indexes for Performance</a></p>
</li>
<li>
<p><a href="#i7872">Using Domain Indexes for Performance</a></p>
</li>
<li>
<p><a href="#i12132">Using Table Clusters for Performance</a></p>
</li>
<li>
<p><a href="#i7690">Using Hash Clusters for Performance</a></p>
</li>
</ul>
<a id="i2678"></a>
<div id="PFGRF94772" class="sect1">
<h2 class="sect1"><span class="secnum">14.1</span> Understanding Index Performance</h2>
<p>This section describes the following:</p>
<ul>
<li>
<p><a href="#i2730">Tuning the Logical Structure</a></p>
</li>
<li>
<p><a href="#i22940">Index Tuning using the SQLAccess Advisor</a></p>
</li>
<li>
<p><a href="#i2769">Choosing Columns and Expressions to Index</a></p>
</li>
<li>
<p><a href="#i2773">Choosing Composite Indexes</a></p>
</li>
<li>
<p><a href="#i2777">Writing Statements That Use Indexes</a></p>
</li>
<li>
<p><a href="#i2781">Writing Statements That Avoid Using Indexes</a></p>
</li>
<li>
<p><a href="#i7530">Re-creating Indexes</a></p>
</li>
<li>
<p><a href="#i6512">Using Nonunique Indexes to Enforce Uniqueness</a></p>
</li>
<li>
<p><a href="#i6516">Using Enabled Novalidated Constraints</a></p>
</li>
</ul>
<a id="i2730"></a>
<div id="PFGRF94773" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.1</span> Tuning the Logical Structure</h3>
<p><a id="sthref1220"></a>Although query optimization helps avoid the use of nonselective indexes within query execution, the SQL engine must continue to maintain all indexes defined against a table, regardless of whether queries make use of them. Index maintenance can present a significant CPU and I/O resource demand in any write-intensive application. In other words, do not build indexes unless necessary.</p>
<p>To maintain optimal performance, <a id="sthref1221"></a>drop indexes that an application is not using. You can find indexes that are not being used by using the <code>ALTER</code> <code>INDEX</code> <code>MONITORING</code> <code>USAGE</code> functionality over a period that is representative of your workload. This monitoring feature records whether an index has been used. If you find that an index has not been used, then drop it. Make sure you are monitoring a representative workload to avoid dropping an index which is used, but not by the workload you sampled.</p>
<p>Also, indexes within an application sometimes have uses that are not immediately apparent from a survey of statement execution plans. An example of this is a foreign key index on a parent table, which prevents share locks from being taken out on a child table.</p>
<p>If you are deciding whether to create new indexes to tune statements, then you can also use the <code>EXPLAIN</code> <code>PLAN</code> statement to determine whether the optimizer chooses to use these indexes when the application is run. If you create new indexes to tune a statement that is currently parsed, then Oracle Database invalidates the statement.</p>
<p>When the statement is next parsed, the optimizer automatically chooses a new execution plan that could potentially use the new index. If you create new indexes on a remote database to tune a distributed statement, then the optimizer considers these indexes when the statement is next parsed.</p>
<p>Note that creating an index to tune one statement can affect the optimizer's choice of execution plans for other statements. For example, if you create an index to be used by one statement, then the optimizer can choose to use that index for other statements in the application as well. For this reason, reexamine the application's performance and execution plans, and rerun the SQL trace facility after you have tuned those statements that you initially identified for tuning.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax and semantics of the <code>ALTER</code> <code>INDEX</code> <code>MONITORING</code> <code>USAGE</code> statement</p>
</li>
<li>
<p><a class="olink ADFNS" href="../../appdev.112/e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> to learn about foreign keys</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i22940"></a>
<div id="PFGRF94774" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.2</span> Index Tuning using the SQLAccess Advisor</h3>
<p>SQL Access Advisor is an alternative to manually determining which indexes are required. This advisor recommends a set of indexes when invoked from Oracle Enterprise Manager or run through the <code>DBMS_ADVISOR</code> package APIs. SQL Access Advisor either recommends using a workload or it generates a hypothetical workload for a specified schema.</p>
<p>Various workload sources are available, such as the current contents of the SQL cache, a user-defined set of SQL statements, or a SQL tuning set. Given a workload, SQL Access Advisor generates a set of recommendations from which you can select the indexes to be implemented. An implementation script is provided that can be executed manually or automatically through Oracle Enterprise Manager.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="advisor.htm#CHDEEBAI">"Overview of SQL Access Advisor"</a></div>
</div>
<!-- class="sect2" -->
<a id="i2769"></a>
<div id="PFGRF94775" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.3</span> Choosing Columns and Expressions to Index</h3>
<p>A key is a column or expression on which you can build an index. <a id="sthref1222"></a><a id="sthref1223"></a>Follow these guidelines for choosing keys to index:</p>
<ul>
<li>
<p>Consider indexing keys that appear frequently in <code>WHERE</code> clauses.</p>
</li>
<li>
<p>Consider indexing keys that frequently join tables in SQL statements. For more information on optimizing joins, see the <a href="#i7690">"Using Hash Clusters for Performance"</a>.</p>
</li>
<li>
<p>Choose index keys that have high selectivity. The selectivity<a id="sthref1224"></a> of an index<a id="sthref1225"></a> is the percentage of rows in a table having the same value for the indexed key. An index's selectivity is optimal if few rows have the same value.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Oracle Database automatically creates indexes, or uses existing indexes, on the keys and expressions of unique and primary keys that you define with integrity constraints.</div>
<p>Indexing low selectivity columns can be helpful when the data distribution is skewed so that one or two values occur much less often than other values.</p>
</li>
<li>
<p>Do not use standard B-tree indexes on keys or expressions with few distinct values. Such keys or expressions usually have poor selectivity and therefore do not optimize performance unless the frequently selected key values appear less frequently than the other key values. You can use bitmap indexes effectively in such cases, unless the index is modified frequently, as in a high concurrency OLTP application.</p>
</li>
<li>
<p>Do not index frequently modified columns. <code>UPDATE</code> statements that modify indexed columns and <code>INSERT</code> and <code>DELETE</code> statements that modify indexed tables take longer than if there were no index. Such SQL statements<a id="sthref1226"></a> must modify data in indexes and data in tables<a id="sthref1227"></a>. They also create additional undo and redo.</p>
</li>
<li>
<p>Do not index keys that appear only in <code>WHERE</code> clauses with functions or operators. A <code>WHERE</code> clause that uses a function, other than <code>MIN</code> or <code>MAX</code>, or an operator with an indexed key does not make available the access path that uses the index except with function-based indexes.</p>
</li>
<li>
<p>Consider indexing foreign keys of referential integrity constraints in cases in which a large number of concurrent <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements access the parent and child tables. Such an index allows <code>UPDATE</code>s and <code>DELETE</code>s on the parent table without share locking the child table.</p>
</li>
<li>
<p>When choosing to index a key, consider whether the performance gain for queries is worth the performance loss for <code>INSERT</code>s, <code>UPDATE</code>s, and <code>DELETE</code>s and the use of the space required to store the index. You might want to experiment by comparing the processing times of the SQL statements with and without indexes. You can measure processing time with the SQL trace facility.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink ADFNS" href="../../appdev.112/e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for more information on the effects of foreign keys on locking</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i2773"></a>
<div id="PFGRF94776" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.4</span> Choosing Composite Indexes</h3>
<p><a id="sthref1228"></a><a id="sthref1229"></a>A composite index contains multiple key columns. Composite indexes can provide additional advantages over single-column indexes:</p>
<ul>
<li>
<p>Improved selectivity<a id="sthref1230"></a><a id="sthref1231"></a></p>
<p>Sometimes you can combine two or more columns or expressions, each with poor selectivity, to form a composite index with higher selectivity.</p>
</li>
<li>
<p>Reduced I/O<a id="sthref1232"></a></p>
<p>If all columns selected by a query are in a composite index, then Oracle Database can return these values from the index without accessing the table.</p>
</li>
</ul>
<p>A SQL statement can use an access path involving a composite index when the statement contains constructs that use a leading portion of the index.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This is no longer the case with index skip scans. See <a href="optimops.htm#i51571">"Index Skip Scans"</a>.</div>
<p>A leading portion of an index is a set of one or more columns that were specified first and consecutively in the list of columns in the <code>CREATE</code> <code>INDEX</code> statement that created the index. Consider this <code>CREATE</code> <code>INDEX</code> statement:</p>
<pre>
CREATE INDEX comp_ind 
ON table1(x, y, z);
</pre>
<ul>
<li>
<p><code>x</code>, <code>xy</code>, and <code>xyz</code> combinations of columns are leading portions of the index</p>
</li>
<li>
<p><code>yz</code>, <code>y</code>, and <code>z</code> combinations of columns are <span class="italic">not</span> leading portions of the index</p>
</li>
</ul>
<div id="PFGRF94777" class="sect3"><a id="sthref1233"></a>
<h4 class="sect3"><span class="secnum">14.1.4.1</span> Choosing Keys for Composite Indexes</h4>
<p>Follow these guidelines for choosing keys for composite indexes:</p>
<ul>
<li>
<p>Consider creating a composite index on keys that appear together frequently in <code>WHERE</code> clause conditions combined with <code>AND</code> operators, especially if their combined selectivity is better than the selectivity of either key individually.</p>
</li>
<li>
<p>If several queries select the same set of keys based on one or more key values, then consider creating a composite index containing all of these keys.</p>
</li>
</ul>
<p>Of course, consider the guidelines associated with the general performance advantages and trade-offs of indexes described in the previous sections.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94778" class="sect3"><a id="sthref1234"></a>
<h4 class="sect3"><span class="secnum">14.1.4.2</span> Ordering Keys for Composite Indexes</h4>
<p>Follow these guidelines for ordering keys in composite indexes:</p>
<ul>
<li>
<p>Create the index so the keys used in <code>WHERE</code> clauses make up a leading portion.</p>
</li>
<li>
<p>If some keys appear in <code>WHERE</code> clauses more frequently, then create the index so that the more frequently selected keys make up a leading portion to allow the statements that use only these keys to use the index.</p>
</li>
<li>
<p>If all keys appear in <code>WHERE</code> clauses equally often but the data is physically ordered on one of the keys, then place this key first in the composite index.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i2777"></a>
<div id="PFGRF94779" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.5</span> Writing Statements That Use Indexes</h3>
<p><a id="sthref1235"></a><a id="sthref1236"></a><a id="sthref1237"></a>Even after you create an index, the optimizer cannot use an access path that uses the index simply because the index exists. The optimizer can choose such an access path for a SQL statement only if it contains a construct that makes the access path available. To allow the query optimizer the option of using an index access path, ensure that the statement contains a construct that makes such an access path available.</p>
</div>
<!-- class="sect2" -->
<a id="i2781"></a>
<div id="PFGRF94780" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.6</span> Writing Statements That Avoid Using Indexes</h3>
<p><a id="sthref1238"></a><a id="sthref1239"></a><a id="sthref1240"></a>In some cases, you might want to prevent a SQL statement from using an access path that uses an existing index. You may want to take this approach if you know that the index is not very <a id="sthref1241"></a><a id="sthref1242"></a>selective and a full table scan would be more efficient. If the statement contains a construct that makes such an index access path available, then you can force the optimizer to use a full table scan through one of the following methods:</p>
<ul>
<li>
<p>Use the <a id="sthref1243"></a><a id="sthref1244"></a><code>NO_INDEX</code> hint to give the query optimizer maximum flexibility while disallowing the use of a certain index.</p>
</li>
<li>
<p>Use the <code>FULL<a id="sthref1245"></a></code> hint<a id="sthref1246"></a> to instruct the optimizer to choose a full table scan instead of an index scan.</p>
</li>
<li>
<p>Use the <code><a id="sthref1247"></a>INDEX</code> or <code>I<a id="sthref1248"></a>NDEX_COMBINE</code> hints to instruct the optimizer to use one index or a set of listed indexes instead of another.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a href="hintsref.htm#i8327">Chapter 19, "Using Optimizer Hints"</a> for more information on the <code>NO_INDEX</code>, <code>FULL</code>, <code>INDEX</code>, and <code>INDEX_COMBINE</code> and hints</div>
</li>
</ul>
<p>Parallel execution uses indexes effectively. It does not perform parallel index range scans, but it does perform parallel index lookups for parallel nested loop join execution. If an index is very selective (there are few rows for each index entry), then it might be better to use sequential index lookup rather than parallel table scan.</p>
</div>
<!-- class="sect2" -->
<a id="i7530"></a>
<div id="PFGRF94781" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.7</span> Re-creating Indexes</h3>
<p>You might want to re-create an <a id="sthref1249"></a>index to compact it and minimize fragmented space, or to change the index's storage characteristics. When creating a new index that is a subset of an existing index or when rebuilding an existing index with new storage characteristics, Oracle Database might use the existing index instead of the base table to improve the performance of the index build.</p>
<p>However, in some cases using the base table instead of the existing index is beneficial. Consider an index on a table on which a lot of DML has been performed. Because of the DML, the size of the index can increase to the point where each block is only 50% full, or even less. If the index refers to most of the columns in the table, then the index could actually be larger than the table. In this case, it is faster to use the base table rather than the index to re-create the index.</p>
<p>Use the <code><a id="sthref1250"></a><a id="sthref1251"></a>ALTER</code> <code>INDEX<a id="sthref1252"></a></code> ... <code>REBUILD</code> statement to reorganize or compact an existing index or to change its storage characteristics. The <code>REBUILD</code> statement uses the existing index as the basis for the new one. All index storage statements are supported, such as <code>STORAGE</code> (for extent allocation), <code>TABLESPACE</code> (to move the index to a new tablespace), and <code>INITRANS</code> (to change the initial number of entries).</p>
<p>Usually, <code>ALTER</code> <code>INDEX</code> ... <code>REBUILD</code> is faster than dropping and re-creating an index, because this statement uses the fast full scan feature. It reads all the index blocks using multiblock I/O, then discards the branch blocks. A further advantage of this approach is that the old index is still available for queries while the rebuild is in progress.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink SQLRF008" href="../../server.112/e41084/statements_1.htm#SQLRF008"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code>CREATE</code> <code>INDEX</code> and <code>ALTER</code> <code>INDEX</code> statements and restrictions on rebuilding indexes</div>
</div>
<!-- class="sect2" -->
<div id="PFGRF94782" class="sect2"><a id="sthref1253"></a>
<h3 class="sect2"><span class="secnum">14.1.8</span> Compacting Indexes</h3>
<p>You can coalesce leaf blocks of an index by using the <code>ALTER</code> <code>INDEX</code> statement with the <code>COALESCE</code> option. This option lets you combine leaf levels of an index to free blocks for reuse. You can also rebuild the index online.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about the syntax for this statement</div>
</div>
<!-- class="sect2" -->
<a id="i6512"></a>
<div id="PFGRF94783" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.9</span> Using Nonunique Indexes to Enforce Uniqueness</h3>
<p><a id="sthref1254"></a>You can use an existing nonunique index on a table to enforce <a id="sthref1255"></a>uniqueness, either for <code><a id="sthref1256"></a>UNIQUE</code> constraints or the unique aspect of a <code><a id="sthref1257"></a>PRIMARY</code> <code>KEY</code> constraint. The advantage of this approach is that the index remains available and valid when the constraint is disabled. Therefore, enabling a disabled <code>UNIQUE</code> or <code>PRIMARY</code> <code>KEY</code> constraint does not require rebuilding the unique index associated with the constraint. This can yield significant time savings on enable operations for large tables.</p>
<p>Using a nonunique <a id="sthref1258"></a>index to enforce uniqueness also lets you eliminate redundant indexes. You do not need a unique index on a primary key column if that column is included as the prefix of a composite index. You can use the existing index to enable and enforce the constraint. You also save significant space by not duplicating the index. However, if the existing index is partitioned, then the partitioning key of the index must also be a subset of the <code>UNIQUE</code> key; otherwise, Oracle Database creates an additional unique index to enforce the constraint.</p>
</div>
<!-- class="sect2" -->
<a id="i6516"></a>
<div id="PFGRF94784" class="sect2">
<h3 class="sect2"><span class="secnum">14.1.10</span> Using Enabled Novalidated Constraints</h3>
<p><a id="sthref1259"></a><a id="sthref1260"></a><a id="sthref1261"></a><a id="sthref1262"></a>An enabled novalidated constraint behaves similarly to an enabled validated constraint for new data. Placing a constraint in the enabled novalidated state signifies that any new data entered into the table must conform to the constraint. Existing data is not checked. By placing a constraint in the enabled novalidated state, you enable the constraint without locking the table.</p>
<p>If you change a constraint from disabled to enabled, then the table must be locked. No new DML, queries, or DDL can occur, because no mechanism can ensure that operations on the table conform to the constraint during the enable operation. The enabled novalidated state prevents users from performing operations on the table that violate the constraint.</p>
<p>The database can validate an enabled novalidated constraint with a parallel, consistent-read query of the table to determine whether any data violates the constraint. The database performs no locking, so the enable operation does not block readers or writers. In addition, the database can validate enabled novalidated constraints in parallel. The database can validate multiple constraints at the same time and check the validity of each constraint using parallel query.</p>
<p>Use the following approach to create tables with constraints and indexes:</p>
<ol>
<li>
<p>Create the tables with the constraints. <code>NOT</code> <code>NULL</code> constraints can be unnamed and should be created enabled and validated. You should name all other constraints (<code>CHECK</code>, <code>UNIQUE</code>, <code>PRIMARY</code> <code>KEY</code>, and <code>FOREIGN</code> <code>KEY</code>) and create them disabled.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
By default, constraints are created in the <code>ENABLED</code> state.</div>
</li>
<li>
<p>Load old data into the tables.</p>
</li>
<li>
<p>Create all indexes, including indexes needed for constraints.</p>
</li>
<li>
<p>Enable novalidate all constraints. Do this to primary keys before foreign keys.</p>
</li>
<li>
<p>Allow users to query and modify data.</p>
</li>
<li>
<p>With a separate <code>ALTER</code> <code>TABLE</code> statement for each constraint, validate all constraints. Do this to primary keys before foreign keys. For example,</p>
<pre>
CREATE TABLE t (a NUMBER CONSTRAINT apk PRIMARY KEY DISABLE,
b NUMBER NOT NULL);
CREATE TABLE x (c NUMBER CONSTRAINT afk REFERENCES t DISABLE);
</pre></li>
</ol>
<pre>
</pre>
<p>Now load data into table <code>t</code>.</p>
<pre>
CREATE UNIQUE INDEX tai ON t (a); 
CREATE INDEX tci ON x (c); 
ALTER TABLE t MODIFY CONSTRAINT apk ENABLE NOVALIDATE;
ALTER TABLE x MODIFY CONSTRAINT afk ENABLE NOVALIDATE;
</pre>
<pre>
</pre>
<p>At this point, users can start performing <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT</code> operations on table <code>t</code>.</p>
<pre>
ALTER TABLE t ENABLE CONSTRAINT apk;
ALTER TABLE x ENABLE CONSTRAINT afk;
</pre>
<pre>
</pre>
<p>Now the constraints are enabled and validated.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT021" href="../../server.112/e40540/datainte.htm#CNCPT021"><span class="italic">Oracle Database Concepts</span></a> for a complete discussion of integrity constraints</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i9946"></a>
<div id="PFGRF94785" class="sect1">
<h2 class="sect1"><span class="secnum">14.2</span> Using Function-based Indexes for Performance</h2>
<p><a id="sthref1263"></a><a id="sthref1264"></a>A function-based index includes columns that are either transformed by a function, such as the <code>UPPER</code> function, or included in an expression, such as <code>col1</code> + <code>col2</code>. With a function-based index, you can store computation-intensive expressions in the index.</p>
<p>Defining a function-based index on the transformed column or expression allows that data to be returned using the index when that function or expression is used in a <code>WHERE</code> clause or an <code>ORDER</code> <code>BY</code> clause. This allows Oracle Database to bypass computing the value of the expression when processing <code>SELECT</code> and <code>DELETE</code> statements. Therefore, a function-based index can be beneficial when frequently-executed SQL statements include transformed columns, or columns in expressions, in a <code>WHERE</code> or <code>ORDER</code> <code>BY</code> clause.</p>
<p>Oracle Database treats descending indexes as function-based indexes. The columns marked <code>DESC</code> are sorted in descending order.</p>
<p>For example, function-based indexes defined with the <code>UPPER</code>(<code><span class="codeinlineitalic">column_name</span></code>) or <code>LOWER</code>(<code><span class="codeinlineitalic">column_name</span></code>) keywords allow case-insensitive searches. The index created in the following statement:</p>
<pre>
CREATE INDEX uppercase_idx ON employees (UPPER(last_name));
</pre>
<p>facilitates processing queries such as:</p>
<pre>
SELECT * FROM employees
    WHERE UPPER(last_name) = 'MARKSON';
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS" href="../../appdev.112/e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> and <a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on using function-based indexes</p>
</li>
<li>
<p><a class="olink SQLRF012" href="../../server.112/e41084/statements_5.htm#SQLRF012"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information on the <code>CREATE</code> <code>INDEX</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i21879"></a>
<div id="PFGRF94786" class="sect1">
<h2 class="sect1"><span class="secnum">14.3</span> Using Partitioned Indexes for Performance</h2>
<p>Similar to partitioned tables, partitioned indexes improve manageability, availability, performance, and scalability. They can either be partitioned independently (global indexes) or automatically linked to a table's partitioning method (local indexes).</p>
<p>Oracle Database supports both range and hash partitioned global indexes. In a range partitioned global index, each index partition contains values defined by a partition bound. In a hash partitioned global index, each partition contains values determined by the Oracle Database hash function.</p>
<p>The hash method can improve performance of indexes where a small number leaf blocks in the index have high contention in multiuser OLTP environment. In some OLTP applications, index insertions happen only at the right edge of the index. This situation could occur when the index is defined on monotonically increasing columns. In such situations, the right edge of the index becomes a hotspot because of contention for index pages, buffers, latches for update, and additional index maintenance activity, which results in performance degradation.</p>
<p>With hash partitioned global indexes index entries are hashed to different partitions based on partitioning key and the number of partitions. This spreads out contention over number of defined partitions, resulting in increased throughput. Hash-partitioned global indexes would benefit TPC-H refresh functions that are executed as massive PDMLs into huge fact tables because contention for buffer latches would be spread out over multiple partitions.</p>
<p>With hash partitioning, an index entry is mapped to a particular index partition based on the hash value generated by Oracle Database. The syntax to create hash-partitioned global index is very similar to hash-partitioned table. Queries involving equality and <code>IN</code> predicates on index partitioning key can efficiently use global hash partitioned index to answer queries quickly.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT010" href="../../server.112/e40540/tablecls.htm#CNCPT010"><span class="italic">Oracle Database Concepts</span></a> and <a class="olink ADMIN01506" href="../../server.112/e25494/tables.htm#ADMIN01506"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on global indexes tables</div>
</div>
<!-- class="sect1" -->
<a id="i17143"></a>
<div id="PFGRF94787" class="sect1">
<h2 class="sect1"><span class="secnum">14.4</span> Using Index-Organized Tables for Performance</h2>
<p>An index-organized table differs from an ordinary table in that the data for the table is held in its associated index. Changes to the table data, such as adding new rows, updating rows, or deleting rows, result only in updating the index. Because data rows are stored in the index, index-organized tables provide faster key-based access to table data for queries that involve exact match or range search or both.</p>
<p>A parent/child relationship is an example of a situation that may warrant an index-organized table. For example, a members table has a child table containing phone numbers. Phone numbers for a member are changed and added over time. In a heap-organized table, rows are inserted in data blocks where they fit. However, when you query the members table, you always retrieve the phone numbers from the child table. To make the retrieval more efficient, you can store the phone numbers in an index-organized table so that phone records for a given member are inserted near each other in the data blocks.</p>
<p>In some circumstances, an index-organized table may provide a performance advantage over a heap-organized table. For example, if a query requires fewer blocks in the cache, then the database uses the buffer cache more efficiently. If fewer distinct blocks are needed for a query, then a single physical I/O may retrieve all necessary data, requiring a smaller amount of I/O for each query.</p>
<p>Global hash-partitioned indexes are supported for index-organized tables and can provide performance benefits in a multiuser OLTP environment. Index-organized tables are useful when you must store related pieces of data together or physically store data in a specific order.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT010" href="../../server.112/e40540/tablecls.htm#CNCPT010"><span class="italic">Oracle Database Concepts</span></a> and <a class="olink ADMIN01506" href="../../server.112/e25494/tables.htm#ADMIN01506"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on index-organized tables</div>
</div>
<!-- class="sect1" -->
<a id="i23051"></a>
<div id="PFGRF94788" class="sect1">
<h2 class="sect1"><span class="secnum">14.5</span> Using Bitmap Indexes for Performance</h2>
<p><a id="sthref1265"></a><a id="sthref1266"></a>Bitmap indexes can substantially improve performance of queries that have all of the following characteristics:</p>
<ul>
<li>
<p>The <code>WHERE</code> clause contains multiple predicates on low- or medium-cardinality columns.</p>
</li>
<li>
<p>The individual predicates on these low- or medium-cardinality columns select a large number of rows.</p>
</li>
<li>
<p>The bitmap indexes used in the queries have been created on some or all of these low- or medium-cardinality columns.</p>
</li>
<li>
<p>The tables in the queries contain many rows.</p>
</li>
</ul>
<p>You can use multiple bitmap indexes to evaluate the conditions on a single table. Bitmap indexes are thus highly advantageous for complex <span class="italic">ad hoc</span> queries that contain lengthy <code>WHERE</code> clauses. Bitmap indexes can also provide optimal performance for aggregate queries and for optimizing joins in star schemas.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink CNCPT010" href="../../server.112/e40540/tablecls.htm#CNCPT010"><span class="italic">Oracle Database Concepts</span></a> and <a class="olink DWHSG006" href="../../server.112/e25554/indexes.htm#DWHSG006"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on bitmap indexing</div>
</div>
<!-- class="sect1" -->
<a id="i17719"></a>
<div id="PFGRF94789" class="sect1">
<h2 class="sect1"><span class="secnum">14.6</span> Using Bitmap Join Indexes for Performance</h2>
<p>In addition to a bitmap index on a single table, you can create a bitm<a id="sthref1267"></a>ap join index, which is a bitmap index for the join of two or more tables. A bitmap join index is a space-saving way to reduce the volume of data that must be joined by performing restrictions in advance. For each value in a column of a table, a bitmap join index stores the rowids of corresponding rows in another table. In a data warehousing environment, the join condition is an equi-inner join between the primary key column(s) of the dimension tables and the foreign key column(s) in the fact table.</p>
<p>Bitmap join indexes are much more efficient in storage than materialized join views, an alternative for materializing joins in advance. Materialized join views do not compress the rowids of the fact tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG006" href="../../server.112/e25554/indexes.htm#DWHSG006"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for examples and restrictions of bitmap join indexes</div>
</div>
<!-- class="sect1" -->
<a id="i7872"></a>
<div id="PFGRF94790" class="sect1">
<h2 class="sect1"><span class="secnum">14.7</span> Using Domain Indexes for Performance</h2>
<p><a id="sthref1268"></a><a id="sthref1269"></a>Domain indexes are built using the indexing logic supplied by a user-defined indextype. An indextype provides an efficient mechanism to access data that satisfy certain operator predicates. Typically, the user-defined indextype is part of an Oracle Database option, like the Spatial option. For example, the <code>SpatialIndextype</code> allows efficient search and retrieval of spatial data that overlap a given bounding box.</p>
<p>The cartridge determines the parameters you can specify in creating and maintaining the domain index. Similarly, the performance and storage characteristics of the domain index are presented in the specific cartridge documentation.</p>
<p>Refer to the appropriate cartridge documentation for information such as the following:</p>
<ul>
<li>
<p>What data types can be indexed?</p>
</li>
<li>
<p>What indextypes are provided?</p>
</li>
<li>
<p>What operators does the indextype support?</p>
</li>
<li>
<p>How can the domain index be created and maintained?</p>
</li>
<li>
<p>How do we efficiently use the operator in queries?</p>
</li>
<li>
<p>What are the performance characteristics?</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
You can also create index types with the <code>CREATE</code> <code>INDEXTYPE</code> statement.</div>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink SPATL" href="../../appdev.112/e11830/toc.htm"><span class="italic">Oracle Spatial Developer's Guide</span></a> for information about the <code>SpatialIndextype</code></div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i12132"></a>
<div id="PFGRF94791" class="sect1">
<h2 class="sect1"><span class="secnum">14.8</span> Using Table Clusters for Performance</h2>
<p>A <span class="bold">table cluster</span> is a group of one or more tables that are physically stored together because they share common columns and usually appear together in SQL statements. Because the database physically stores related rows together, disk access time improves. To create a cluster, use the <code>CREATE</code> <code>CLUSTER</code> statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT" href="../e40540/toc.htm"><span class="italic">Oracle Database Concepts</span></a> for more information on clusters</div>
<p><a id="sthref1270"></a><a id="sthref1271"></a>Follow these guidelines when deciding whether to cluster tables:</p>
<ul>
<li>
<p>Cluster tables that are accessed frequently by the application in join statements.</p>
</li>
<li>
<p>Do not cluster tables if the application joins them only occasionally or modifies their common column values frequently. Modifying a row's cluster key value takes longer than modifying the value in an unclustered table, because Oracle Database might need to migrate the modified row to another block to maintain the cluster.</p>
</li>
<li>
<p>Do not cluster tables if the application often performs full table scans of only one of the tables. A full table scan of a clustered table can take longer than a full table scan of an unclustered table. Oracle Database is likely to read more blocks because the tables are stored together.</p>
</li>
<li>
<p>Cluster master-detail tables if you often select a master record and then the corresponding detail records. Detail records are stored in the same data block(s) as the master record, so they are likely still to be in memory when you select them, requiring Oracle Database to perform less I/O.</p>
</li>
<li>
<p>Store a detail table alone in a cluster if you often select many detail records of the same master. This measure improves the performance of queries that select detail records of the same master, but does not decrease the performance of a full table scan on the master table. An alternative is to use an index organized table.</p>
</li>
<li>
<p>Do not cluster tables if the data from all tables with the same cluster key value exceeds more than one or two data blocks. To access a row in a clustered table, Oracle Database reads all blocks containing rows with that value. If these rows take up multiple blocks, then accessing a single row could require more reads than accessing the same row in an unclustered table.</p>
</li>
<li>
<p>Do not cluster tables when the number of rows for each cluster key value varies significantly. This causes waste of space for the low cardinality key value; it causes collisions for the high cardinality key values. Collisions degrade performance.</p>
</li>
</ul>
<p>Consider the benefits and drawbacks of clusters for the application. For example, you might decide that the performance gain for join statements outweighs the performance loss for statements that modify cluster key values. You might want to experiment and compare processing times with the tables both clustered and stored separately.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on creating clusters</div>
</div>
<!-- class="sect1" -->
<a id="i7690"></a>
<div id="PFGRF94792" class="sect1">
<h2 class="sect1"><span class="secnum">14.9</span> Using Hash Clusters for Performance</h2>
<p>Hash clusters group table data by applying a hash function to each row's cluster key value. All rows with the same cluster key value are stored together on disk. Consider the benefits and drawbacks of hash clusters for the application. You might want to experiment and compare processing times with a particular table in a hash cluster and alone with an index.</p>
<p><a id="sthref1272"></a>Follow these guidelines for choosing when to use hash clusters:</p>
<ul>
<li>
<p>Use hash clusters to store tables accessed frequently by SQL statements with <code>WHERE</code> clauses, if the <code>WHERE</code> clauses contain equality conditions that use the same column or combination of columns. Designate this column or combination of columns as the cluster key.</p>
</li>
<li>
<p>Store a table in a hash cluster if you can determine how much space is required to hold all rows with a given cluster key value, including rows to be inserted immediately and rows to be inserted in the future.</p>
</li>
<li>
<p>Use sorted hash <a id="sthref1273"></a><a id="sthref1274"></a>clusters, where rows corresponding to each value of the hash function are sorted on a specific columns in ascending order, when the database can improve response time on operations with this sorted clustered data.</p>
</li>
<li>
<p>Do not store a table in a hash cluster if the application often performs full table scans and if you must allocate a great deal of space to the hash cluster in anticipation of the table growing. Such full table scans must read all blocks allocated to the hash cluster, even though some blocks might contain few rows. Storing the table alone reduces the number of blocks read by full table scans.</p>
</li>
<li>
<p>Do not store a table in a hash cluster if the application frequently modifies the cluster key values. Modifying a row's cluster key value can take longer than modifying the value in an unclustered table, because Oracle Database might need to migrate the modified row to another block to maintain the cluster.</p>
</li>
</ul>
<p>Storing a single table in a hash cluster can be useful, regardless of whether the table is joined frequently with other tables, as long as hashing is appropriate for the table based on the considerations in this list.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN019" href="../../server.112/e25494/hash.htm#ADMIN019"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manage hash clusters</p>
</li>
<li>
<p><a class="olink SQLRF01201" href="../../server.112/e41084/statements_5001.htm#SQLRF01201"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code>CREATE</code> <code>CLUSTER</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1679">
<tr>
<td class="cellalignment1688">
<table class="cellalignment1684">
<tr>
<td class="cellalignment1683"><a href="stats.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1683"><a href="optplanmgmt.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1690">
<table class="cellalignment1682">
<tr>
<td class="cellalignment1683"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1683"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1683"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1683"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1683"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1683"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
