<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Designing and Developing for Performance</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-06-30T4:25:4Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Performance Tuning Guide" />
<meta name="dcterms.identifier" content="E41573-04" />
<meta name="dcterms.isVersionOf" content="PFGRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="part2.htm" title="Previous" type="text/html" />
<link rel="Next" href="technique.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41573.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/31</span> <!-- End Header -->
<div id="PFGRF030" class="chapter"><a id="g34949"></a> <a id="i2905"></a>
<h1 class="chapter"><span class="secnum">2</span> Designing and Developing for Performance</h1>
<p>Optimal system performance begins with design and continues throughout the life of your system. Carefully consider performance issues during the initial design phase so that you can tune your system more easily during production.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i27789">Oracle Methodology</a></p>
</li>
<li>
<p><a href="#i27794">Understanding Investment Options</a></p>
</li>
<li>
<p><a href="#i27798">Understanding Scalability</a></p>
</li>
<li>
<p><a href="#i27874">System Architecture</a></p>
</li>
<li>
<p><a href="#i28071">Application Design Principles</a></p>
</li>
<li>
<p><a href="#i28257">Workload Testing, Modeling, and Implementation</a></p>
</li>
<li>
<p><a href="#i28309">Deploying New Applications</a></p>
</li>
</ul>
<a id="i27789"></a>
<div id="PFGRF94087" class="sect1">
<h2 class="sect1"><span class="secnum">2.1</span> Oracle Methodology</h2>
<p>System performance has become increasingly important as computer systems get larger and more complex as the Internet plays a bigger role in business applications. To accommodate this, Oracle has produced a performance methodology based on years of designing and performance experience. This methodology explains clear and simple activities that can dramatically improve system performance.</p>
<p>Performance strategies vary in their effectiveness, and systems with different purposes&mdash;such as operational systems and decision support systems&mdash;require different performance skills. This book examines the considerations that any database designer, administrator, or performance expert should focus their efforts on.</p>
<p>System performance is designed and built into a system. It does not just happen. Performance problems are usually the result of contention for, or exhaustion of, some system resource. When a system resource is exhausted, the system cannot scale to higher levels of performance. This new performance methodology is based on careful planning and design of the database, to prevent system resources from becoming exhausted and causing down-time. By eliminating resource conflicts, systems can be made scalable to the levels required by the business.</p>
</div>
<!-- class="sect1" -->
<a id="i27794"></a>
<div id="PFGRF94088" class="sect1">
<h2 class="sect1"><span class="secnum">2.2</span> Understanding Investment Options</h2>
<p>With the availability of relatively inexpensive, high-powered processors, memory, and disk drives, there is a temptation to buy more system resources to improve performance. In many situations, new CPUs, memory, or more disk drives can indeed provide an immediate performance improvement. However, any performance increases achieved by adding hardware should be considered a short-term relief to an immediate problem. If the demand and load rates on the application continue to grow, then the chance of the same problem occurring soon is likely.</p>
<p>In other situations, additional hardware does not improve the system's performance at all. Poorly designed systems perform poorly no matter how much extra hardware is allocated. Before purchasing additional hardware, ensure that serialization or single threading is not occurring within the application. Long-term, it is generally more valuable to increase the efficiency of your application in terms of the number of physical resources used for each business transaction.</p>
</div>
<!-- class="sect1" -->
<a id="i27798"></a>
<div id="PFGRF94089" class="sect1">
<h2 class="sect1"><span class="secnum">2.3</span> Understanding Scalability</h2>
<p>The word <span class="italic">scalability</span> is used in many contexts in development environments. The following section provides an explanation of scalability that is aimed at application designers and performance specialists.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CJHGCIBA">What is Scalability?</a></p>
</li>
<li>
<p><a href="#CJHDCEDB">System Scalability</a></p>
</li>
<li>
<p><a href="#CJHFIHFC">Factors Preventing Scalability</a></p>
</li>
</ul>
<a id="CJHGCIBA"></a>
<div id="PFGRF94090" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.1</span> What is Scalability?</h3>
<p><a id="sthref40"></a>Scalability is a system's ability to process more workload, with a proportional increase in system resource usage. In other words, in a scalable system, if you double the workload, then the system uses twice as many system resources. This sounds obvious, but due to conflicts within the system, the resource usage might exceed twice the original workload.</p>
<p>Examples of poor scalability due to resource conflicts include the following:</p>
<ul>
<li>
<p>Applications requiring significant concurrency management as user populations increase</p>
</li>
<li>
<p>Increased locking activities</p>
</li>
<li>
<p>Increased data consistency workload</p>
</li>
<li>
<p>Increased operating system workload</p>
</li>
<li>
<p>Transactions requiring increases in data access as data volumes increase</p>
</li>
<li>
<p>Poor SQL and index design resulting in a higher number of logical I/Os for the same number of rows returned</p>
</li>
<li>
<p>Reduced availability, because database objects take longer to maintain</p>
</li>
</ul>
<p>An application is said to be unscalable if it exhausts a system resource to the point where no more throughput is possible when its workload is increased. Such applications result in fixed throughputs and poor response times.</p>
<p>Examples of resource exhaustion include the following:</p>
<ul>
<li>
<p>Hardware exhaustion</p>
</li>
<li>
<p>Table scans in high-volume transactions causing inevitable disk I/O shortages</p>
</li>
<li>
<p>Excessive network requests, resulting in network and scheduling bottlenecks</p>
</li>
<li>
<p>Memory allocation causing paging and swapping</p>
</li>
<li>
<p>Excessive process and thread allocation causing operating system thrashing</p>
</li>
</ul>
<p>This means that application designers must create a design that uses the same resources, regardless of user populations and data volumes, and does not put loads on the system resources beyond their limits.</p>
</div>
<!-- class="sect2" -->
<a id="CJHDCEDB"></a>
<div id="PFGRF94091" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.2</span> System Scalability</h3>
<p><a id="sthref41"></a><a id="sthref42"></a>Applications that are accessible through the Internet have more complex performance and availability requirements. Some applications are designed and written only for Internet use, but even typical back-office applications&mdash;such as a general ledger application&mdash;might require some or all data to be available online.</p>
<p>Characteristics of Internet age applications include the following:</p>
<ul>
<li>
<p>Availability 24 hours a day, 365 days a year</p>
</li>
<li>
<p>Unpredictable and imprecise number of concurrent users</p>
</li>
<li>
<p>Difficulty in capacity planning</p>
</li>
<li>
<p>Availability for any type of query</p>
</li>
<li>
<p>Multitier architectures</p>
</li>
<li>
<p>Stateless middleware</p>
</li>
<li>
<p>Rapid development timescale</p>
</li>
<li>
<p>Minimal time for testing</p>
</li>
</ul>
<p><a href="#i27836">Figure 2-1</a> illustrates the classic workload growth curve, with demand growing at an increasing rate. Applications must scale with the increase of workload and also when additional hardware is added to support increasing demand. Design errors can cause the implementation to reach its maximum, regardless of additional hardware resources or re-design efforts.</p>
<div id="PFGRF94092" class="figure">
<p class="titleinfigure"><a id="i27836"></a>Figure 2-1 Workload Growth Curve</p>
<img width="496" height="272" src="img/pfgrf213.gif" alt="Description of Figure 2-1 follows" /><br />
<a id="sthref43" href="img_text/pfgrf213.htm">Description of "Figure 2-1 Workload Growth Curve"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Applications are challenged by very short development timeframes with limited time for testing and evaluation. However, bad design typically means that you must later rearchitect and reimplement the system. If you deploy an application with known architectural and implementation limitations on the Internet, and if the workload exceeds the anticipated demand, then failure is a real possibility. From a business perspective, poor performance can mean a loss of customers. If Web users do not get a response in seven seconds, then the user's attention could be lost forever.</p>
<p>In many cases, the cost of re-designing a system with the associated downtime costs in migrating to new implementations exceeds the costs of properly building the original system. The moral of the story is simple: design and implement with scalability in mind from the start.</p>
</div>
<!-- class="sect2" -->
<a id="CJHFIHFC"></a>
<div id="PFGRF94093" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.3</span> Factors Preventing Scalability<a id="sthref44"></a></h3>
<p>When building applications, designers and architects should aim for as close to perfect scalability as possible. This is sometimes called <a id="sthref45"></a><a id="sthref46"></a><span class="italic">linear</span> scalability, where system throughput is directly proportional to the number of CPUs.</p>
<p><a id="sthref47"></a>In real life, linear scalability is impossible for reasons beyond a designer's control. However, making the application design and implementation as scalable as possible should ensure that current and future performance objectives can be achieved through expansion of hardware components and the evolution of CPU technology.</p>
<p>Factors that may prevent linear scalability include:</p>
<ul>
<li>
<p>Poor application design, implementation, and configuration</p>
<p>The application has the biggest impact on scalability. For example:</p>
<ul>
<li>
<p>Poor schema design can cause expensive SQL that do not scale.</p>
</li>
<li>
<p>Poor transaction design can cause locking and serialization problems.</p>
</li>
<li>
<p>Poor connection management can cause poor response times and unreliable systems.</p>
</li>
</ul>
<p>However, the design is not the only problem. The physical implementation of the application can be the weak link. For example:</p>
<ul>
<li>
<p>Systems can move to production environments with bad I/O strategies.</p>
</li>
<li>
<p>The production environment could use different execution plans than those generated in testing.</p>
</li>
<li>
<p>Memory-intensive applications that allocate a large amount of memory without much thought for freeing the memory at run time can cause excessive memory usage.</p>
</li>
<li>
<p>Inefficient memory usage and memory leaks put a high stress on the operating virtual memory subsystem. This impacts performance and availability.</p>
</li>
</ul>
</li>
<li>
<p>Incorrect sizing of hardware components<a id="sthref48"></a></p>
<p>Bad capacity planning of all hardware components is becoming less of a problem as relative hardware prices decrease. However, too much capacity can mask scalability problems as the workload is increased on a system.</p>
</li>
<li>
<p>Limitations of software components</p>
<p>All software components have scalability and resource usage limitations. This applies to application servers, database servers, and operating systems. Application design should not place demands on the software beyond what it can handle.</p>
</li>
<li>
<p>Limitations of Hardware Components<a id="sthref49"></a></p>
<p>Hardware is not perfectly scalable. Most multiprocessor computers can get close to linear scaling with a finite number of CPUs, but after a certain point each additional CPU can increase performance overall, but not proportionately. There might come a time when an additional CPU offers no increase in performance, or even degrades performance. This behavior is very closely linked to the workload and the operating system setup.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
These factors are based on Oracle Server Performance group's experience of tuning unscalable systems.</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i27874"></a>
<div id="PFGRF94094" class="sect1">
<h2 class="sect1"><span class="secnum">2.4</span> System Architecture</h2>
<p><a id="sthref50"></a>There are two main parts to a system's architecture:</p>
<ul>
<li>
<p><a href="#i27886">Hardware and Software Components</a></p>
</li>
<li>
<p><a href="#i28013">Configuring the Right System Architecture for Your Requirements</a></p>
</li>
</ul>
<a id="i27886"></a>
<div id="PFGRF94095" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.1</span> Hardware and Software Components</h3>
<p>This section discusses:</p>
<ul>
<li>
<p><a href="#CJHHCIHF">Hardware Components</a></p>
</li>
<li>
<p><a href="#CJHJFDHE">Software Components</a></p>
</li>
</ul>
<a id="CJHHCIHF"></a>
<div id="PFGRF94096" class="sect3">
<h4 class="sect3"><span class="secnum">2.4.1.1</span> Hardware Components<a id="sthref51"></a><a id="sthref52"></a><a id="sthref53"></a></h4>
<p>Today's designers and architects are responsible for sizing and capacity planning of hardware at each tier in a multitier environment. It is the architect's responsibility to achieve a balanced design. This is analogous to a bridge designer who must consider all the various payload and structural requirements for the bridge. A bridge is only as strong as its weakest component. As a result, a bridge is designed in balance, such that all components reach their design limits simultaneously.</p>
<p>The main hardware components include:</p>
<ul>
<li>
<p><a href="#i27909">CPU</a></p>
</li>
<li>
<p><a href="#i27913">Memory</a></p>
</li>
<li>
<p><a href="#i27917">I/O Subsystem</a></p>
</li>
<li>
<p><a href="#i27921">Network</a></p>
</li>
</ul>
<a id="i27909"></a>
<div id="PFGRF94097" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.1.1.1</span> CPU</h5>
<p><a id="sthref54"></a><a id="sthref55"></a>There can be one or more CPUs, and they can vary in processing power from simple CPUs found in hand-held devices to high-powered server CPUs. Sizing of other hardware components is usually a multiple of the CPUs on the system. See <a href="os.htm#g12613">Chapter 9, "Managing Operating System Resources"</a>.</p>
</div>
<!-- class="sect4" -->
<a id="i27913"></a>
<div id="PFGRF94098" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.1.1.2</span> Memory</h5>
<p><a id="sthref56"></a><a id="sthref57"></a>Database and application servers require considerable amounts of memory to cache data and avoid time-consuming disk access. See <a href="memory.htm#g77696">Chapter 7, "Configuring and Using Memory"</a>.</p>
</div>
<!-- class="sect4" -->
<a id="i27917"></a>
<div id="PFGRF94099" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.1.1.3</span> I/O Subsystem</h5>
<p><a id="sthref58"></a>The I/O subsystem can vary between the hard disk on a client PC and high performance disk arrays. Disk arrays can perform thousands of I/Os each second and provide availability through redundancy in terms of multiple I/O paths and hot pluggable mirrored disks. See <a href="iodesign.htm#g37279">Chapter 8, "I/O Configuration and Design"</a>.</p>
</div>
<!-- class="sect4" -->
<a id="i27921"></a>
<div id="PFGRF94100" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.1.1.4</span> Network</h5>
<p><a id="sthref59"></a><a id="sthref60"></a>All computers in a system are connected to a network, from a modem line to a high speed internal LAN. The primary concerns with network specifications are bandwidth (volume) and latency (speed).</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CJHJFDHE"></a>
<div id="PFGRF94101" class="sect3">
<h4 class="sect3"><span class="secnum">2.4.1.2</span> Software Components<a id="sthref61"></a><a id="sthref62"></a><a id="sthref63"></a></h4>
<p>The same way computers have common hardware components, applications have common functional components. By dividing software development into functional components, it is possible to better comprehend the application design and architecture. Some components of the system are performed by existing software bought to accelerate application implementation, or to avoid re-development of common components.</p>
<p>The difference between software components and hardware components is that while hardware components only perform one task, a piece of software can perform the roles of various software components. For example, a disk drive only stores and retrieves data, but a client program can manage the user interface and perform business logic.</p>
<p>Most applications involve the following components:</p>
<ul>
<li>
<p><a href="#i27976">Managing the User Interface</a></p>
</li>
<li>
<p><a href="#i27984">Implementing Business Logic</a></p>
</li>
<li>
<p><a href="#i27992">Managing User Requests and Resource Allocation</a></p>
</li>
<li>
<p><a href="#i28004">Managing Data and Transactions</a></p>
</li>
</ul>
<a id="i27976"></a>
<div id="PFGRF94102" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.1.2.1</span> Managing the User Interface</h5>
<p><a id="sthref64"></a><a id="sthref65"></a>This component is the most visible to application users, and includes the following functions:</p>
<ul>
<li>
<p>Displaying the screen to the user</p>
</li>
<li>
<p>Collecting user data and transferring it to business logic</p>
</li>
<li>
<p>Validating data entry</p>
</li>
<li>
<p>Navigating through levels or states of the application</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="i27984"></a>
<div id="PFGRF94103" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.1.2.2</span> Implementing Business Logic</h5>
<p><a id="sthref66"></a><a id="sthref67"></a><a id="sthref68"></a>This component implements core business rules that are central to the application function. Errors made in this component can be very costly to repair. This component is implemented by a mixture of declarative and procedural approaches. An example of a declarative activity is defining unique and foreign keys. An example of procedure-based logic is implementing a discounting strategy.</p>
<p>Common functions of this component include:</p>
<ul>
<li>
<p>Moving a data model to a relational table structure</p>
</li>
<li>
<p>Defining constraints in the relational table structure</p>
</li>
<li>
<p>Coding procedural logic to implement business rules</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="i27992"></a>
<div id="PFGRF94104" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.1.2.3</span> Managing User Requests and Resource Allocation</h5>
<p><a id="sthref69"></a><a id="sthref70"></a><a id="sthref71"></a>This component is implemented in all pieces of software. However, there are some requests and resources that can be influenced by the application design and some that cannot.</p>
<p>In a multiuser application, most resource allocation by user requests are handled by the database server or the operating system. However, in a large application where the number of users and their usage pattern is unknown or growing rapidly, the system architect must be proactive to ensure that no single software component becomes overloaded and unstable.</p>
<p>Common functions of this component include:</p>
<ul>
<li>
<p>Connection management with the database</p>
</li>
<li>
<p>Executing SQL efficiently (cursors and SQL sharing)</p>
</li>
<li>
<p>Managing client state information</p>
</li>
<li>
<p>Balancing the load of user requests across hardware resources</p>
</li>
<li>
<p>Setting operational targets for hardware and software components</p>
</li>
<li>
<p>Persistent queuing for asynchronous execution of tasks</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="i28004"></a>
<div id="PFGRF94105" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.1.2.4</span> Managing Data and Transactions</h5>
<p><a id="sthref72"></a><a id="sthref73"></a><a id="sthref74"></a>This component is largely the responsibility of the database server and the operating system.</p>
<p>Common functions of this component include:</p>
<ul>
<li>
<p>Providing concurrent access to data using locks and transactional semantics</p>
</li>
<li>
<p>Providing optimized access to the data using indexes and memory cache</p>
</li>
<li>
<p>Ensuring that data changes are logged in the event of a hardware failure</p>
</li>
<li>
<p>Enforcing any rules defined for the data</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i28013"></a>
<div id="PFGRF94106" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.2</span> Configuring the Right System Architecture for Your Requirements</h3>
<p><a id="sthref75"></a>Configuring the initial system architecture is a largely iterative process. System architects must satisfy the system requirements within budget and schedule constraints. If the system requires interactive users transacting business-making decisions based on the contents of a database, then user requirements drive the architecture. If there are few interactive users on the system, then the architecture is process-driven.</p>
<p>Examples of interactive user applications:</p>
<ul>
<li>
<p>Accounting and bookkeeping applications</p>
</li>
<li>
<p>Order entry systems</p>
</li>
<li>
<p>Email servers</p>
</li>
<li>
<p>Web-based retail applications</p>
</li>
<li>
<p>Trading systems</p>
</li>
</ul>
<p>Examples of process-driven applications:</p>
<ul>
<li>
<p>Utility billing systems</p>
</li>
<li>
<p>Fraud detection systems</p>
</li>
<li>
<p>Direct mail</p>
</li>
</ul>
<p>In many ways, process-driven applications are easier to design than multiuser applications because the user interface element is eliminated. However, because the objectives are process-oriented, system architects not accustomed to dealing with large data volumes and different success factors can become confused. Process-driven applications draw from the skills sets used in both user-based applications and data warehousing. Therefore, this book focuses on evolving system architectures for interactive users.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Generating a system architecture is not a deterministic process. It requires careful consideration of business requirements, technology choices, existing infrastructure and systems, and actual physical resources, such as budget and manpower.</div>
<p>The following questions should stimulate thought on system architecture, though they are not a definitive guide to system architecture. These questions demonstrate how business requirements can influence the architecture, ease of implementation, and overall performance and availability of a system. For example:</p>
<ul>
<li>
<p><a id="sthref76"></a>How many users must the system support?</p>
<p>Most applications fall into one of the following categories:</p>
<ul>
<li>
<p>Very few users on a lightly-used or exclusive computer</p>
<p>For this type of application, there is usually one user. The focus of the application design is to make the single user as productive as possible by providing good response time, yet make the application require minimal administration. Users of these applications rarely interfere with each other and have minimal resource conflicts.</p>
</li>
<li>
<p>A medium to large number of users in a corporation using shared applications</p>
<p>For this type of application, the users are limited by the number of employees in the corporation actually transacting business through the system. Therefore, the number of users is predictable. However, delivering a reliable service is crucial to the business. The users must share a resource, so design efforts must address response time under heavy system load, escalation of resource for each session usage, and room for future growth.</p>
</li>
<li>
<p>An infinite user population distributed on the Internet</p>
<p>For this type of application, extra engineering effort is required to ensure that no system component exceeds its design limits. This creates a bottleneck that halts or destabilizes the system. These applications require complex load balancing, stateless application servers, and efficient database connection management. In addition, use statistics and governors to ensure that the user receives feedback if the database cannot satisfy their requests because of system overload.</p>
</li>
</ul>
</li>
<li>
<p><a id="sthref77"></a>What will be the user interaction method?</p>
<p>The choices of user interface range from a simple Web browser to a custom client program.</p>
</li>
<li>
<p><a id="sthref78"></a>Where are the users located?</p>
<p>The distance between users influences how the application is engineered to cope with network latencies. The location also affects which times of the day are busy, when it is impossible to perform batch or system maintenance functions.</p>
</li>
<li>
<p><a id="sthref79"></a><a id="sthref80"></a>What is the network speed?</p>
<p>Network speed affects the amount of data and the conversational nature of the user interface with the application and database servers. A highly conversational user interface can communicate with back-end servers on every key stroke or field level validation. A less conversational interface works on a screen-sent and a screen-received model. On a slow network, it is impossible to achieve high data entry speeds with a highly conversational user interface.</p>
</li>
<li>
<p>How much data will the user access, and how much of that data is largely read only?</p>
<p><a id="sthref81"></a><a id="sthref82"></a><a id="sthref83"></a>The amount of data queried online influences all aspects of the design, from table and index design to the presentation layers. Design efforts must ensure that user response time is not a function of the size of the database. If the application is largely read only, then replication and data distribution to local caches in the application servers become a viable option. This also reduces workload on the core transactional server.</p>
</li>
<li>
<p><a id="sthref84"></a><a id="sthref85"></a>What is the user response time requirement?</p>
<p>Consideration of the user type is important. If the user is an executive who requires accurate information to make split second decisions, then user response time cannot be compromised. Other types of users, such as users performing data entry activities, might not need such a high level of performance.</p>
</li>
<li>
<p><a id="sthref86"></a><a id="sthref87"></a>Do users expect 24 hour service?</p>
<p>This is mandatory for today's Internet applications where trade is conducted 24 hours a day. However, corporate systems that run in a single time zone might be able to tolerate after-hours downtime. You can use this after-hours downtime to run batch processes or to perform system administration. In this case, it might be more economic not to run a fully-available system.</p>
</li>
<li>
<p>Must all changes be made in real time?</p>
<p>It is important to determine whether transactions must be executed within the user response time, or if they can be queued for asynchronous execution.</p>
</li>
</ul>
<p>The following are secondary questions, which can also influence the design, but really have more impact on budget and ease of implementation. For example:</p>
<ul>
<li>
<p><a id="sthref88"></a>How big will the database be?</p>
<p>This influences the sizing of the database server. On servers with a very large database, it might be necessary to have a bigger computer than dictated by the workload. This is because the administration overhead with large databases is largely a function of the database size. As tables and indexes grow, it takes proportionately more CPUs to allow table reorganizations and index builds to complete in an acceptable time limit.</p>
</li>
<li>
<p>What is the required throughput of business transactions?</p>
</li>
<li>
<p>What are the availability requirements?</p>
</li>
<li>
<p>Do skills exist to build and administer this application?</p>
</li>
<li>
<p>What compromises are forced by budget constraints?</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i28071"></a>
<div id="PFGRF94107" class="sect1">
<h2 class="sect1"><span class="secnum">2.5</span> Application Design Principles</h2>
<p><a id="sthref89"></a><a id="sthref90"></a>This section describes the following design decisions that are involved in building applications:</p>
<ul>
<li>
<p><a href="#i28076">Simplicity In Application Design</a></p>
</li>
<li>
<p><a href="#CJHEEEGI">Data Modeling</a></p>
</li>
<li>
<p><a href="#CJHCJIDB">Table and Index Design</a></p>
</li>
<li>
<p><a href="#i28177">Using Views</a></p>
</li>
<li>
<p><a href="#i29012">SQL Execution Efficiency</a></p>
</li>
<li>
<p><a href="#CJHJHBHA">Implementing the Application</a></p>
</li>
<li>
<p><a href="#CJHFIEDA">Trends in Application Development</a></p>
</li>
</ul>
<a id="i28076"></a>
<div id="PFGRF94108" class="sect2">
<h3 class="sect2"><span class="secnum">2.5.1</span> Simplicity In Application Design</h3>
<p>Applications are no different than any other designed and engineered product. Well-designed structures, computers, and tools are usually reliable, easy to use and maintain, and simple in concept. In the most general terms, if the design looks correct, then it probably is. This principle should always be kept in mind when building applications.</p>
<p>Consider the following design issues:</p>
<ul>
<li>
<p>If the table design is so complicated that nobody can fully understand it, then the table is probably poorly designed.</p>
</li>
<li>
<p>If SQL statements are so long and involved that it would be impossible for any optimizer to effectively optimize it in real time, then there is probably a bad statement, underlying transaction, or table design.</p>
</li>
<li>
<p>If there are indexes on a table and the same columns are repeatedly indexed, then there is probably a poor index design.</p>
</li>
<li>
<p>If queries are submitted without suitable qualification for rapid response for online users, then there is probably a poor user interface or transaction design.</p>
</li>
<li>
<p>If the calls to the database are abstracted away from the application logic by many layers of software, then there is probably a bad software development method.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CJHEEEGI"></a>
<div id="PFGRF94109" class="sect2">
<h3 class="sect2"><span class="secnum">2.5.2</span> Data Modeling</h3>
<p><a id="sthref91"></a><a id="sthref92"></a>Data modeling is important to successful relational application design. You must perform this modeling in a way that quickly represents the business practices. Heated debates may occur about the correct data model. The important thing is to apply greatest modeling efforts to those entities affected by the most frequent business transactions. In the modeling phase, there is a great temptation to spend too much time modeling the non-core data elements, which results in increased development lead times. Use of modeling tools can then rapidly generate schema definitions and can be useful when a fast prototype is required.</p>
</div>
<!-- class="sect2" -->
<a id="CJHCJIDB"></a>
<div id="PFGRF94110" class="sect2">
<h3 class="sect2"><span class="secnum">2.5.3</span> Table and Index Design</h3>
<p><a id="sthref93"></a>Table design is largely a compromise between flexibility and performance of core transactions. To keep the database flexible and able to accommodate unforeseen workloads, the table design should be very similar to the data model, and it should be normalized to at least 3rd normal form. However, certain core transactions required by users can require selective denormalization for performance purposes.</p>
<p>Examples of this technique include storing tables pre-joined, the addition of derived columns, and aggregate values. Oracle Database provides numerous options for storage of aggregates and pre-joined data by clustering and materialized view functions. These features allow a simpler table design to be adopted initially.</p>
<p>Again, focus and resources should be spent on the business critical tables, so that optimal performance can be achieved. For non-critical tables, shortcuts in design can be adopted to enable a more rapid application development. However, if prototyping and testing a non-core table becomes a performance problem, then remedial design effort should be applied immediately.</p>
<p><a id="sthref94"></a>Index design is also a largely iterative process, based on the SQL generated by application designers. However, it is possible to make a sensible start by building indexes that enforce primary key constraints and indexes on known access patterns, such as a person's name. As the application evolves, and as you perform testing on realistic amounts of data, you may need to improve the performance of specific queries by building a better index. Consider the following list of indexing design ideas when building a new index:</p>
<ul>
<li>
<p><a href="#i28115">Appending Columns to an Index or Using Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#i28121">Using a Different Index Type</a></p>
</li>
<li>
<p><a href="#i28140">Finding the Cost of an Index</a></p>
</li>
<li>
<p><a href="#i28156">Serializing within Indexes</a></p>
</li>
<li>
<p><a href="#i28160">Ordering Columns in an Index</a></p>
</li>
</ul>
<a id="i28115"></a>
<div id="PFGRF94111" class="sect3">
<h4 class="sect3"><span class="secnum">2.5.3.1</span> Appending Columns to an Index or Using Index-Organized Tables</h4>
<p><a id="sthref95"></a><a id="sthref96"></a>One of the easiest ways to speed up a query is to reduce the number of logical I/Os by eliminating a table access from the execution plan. This can be done by appending to the index all columns referenced by the query. These columns are the select list columns, and any required join or sort columns. This technique is particularly useful in speeding up online applications response times when time-consuming I/Os are reduced. This is best applied when testing the application with properly sized data for the first time.</p>
<p>The most aggressive form of this technique is to build an index-organized table (IOT). However, you must be careful that the increased leaf size of an IOT does not undermine the efforts to reduce I/O.</p>
</div>
<!-- class="sect3" -->
<a id="i28121"></a>
<div id="PFGRF94112" class="sect3">
<h4 class="sect3"><span class="secnum">2.5.3.2</span> Using a Different Index Type</h4>
<p>There are several index types available, and each index has benefits for certain situations. The following list gives performance ideas associated with each index type.</p>
<div id="PFGRF94113" class="sect4"><a id="sthref97"></a>
<h5 class="sect4"><span class="secnum">2.5.3.2.1</span> B-Tree Indexes</h5>
<p><a id="sthref98"></a><a id="sthref99"></a>These indexes are the standard index type, and they are excellent for primary key and highly-selective indexes. Used as concatenated indexes, the database can use B-tree indexes to retrieve data sorted by the index columns.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94114" class="sect4"><a id="sthref100"></a>
<h5 class="sect4"><span class="secnum">2.5.3.2.2</span> Bitmap Indexes</h5>
<p><a id="sthref101"></a><a id="sthref102"></a>These indexes are suitable for low cardinality data. Through compression techniques, they can generate a large number of rowids with minimal I/O. Combining bitmap indexes on non-selective columns allows efficient <code>AND</code> and <code>OR</code> operations with a great number of rowids with minimal I/O. Bitmap indexes are particularly efficient in queries with <code>COUNT</code>(), because the query can be satisfied within the index.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94115" class="sect4"><a id="sthref103"></a>
<h5 class="sect4"><span class="secnum">2.5.3.2.3</span> Function-based Indexes</h5>
<p><a id="sthref104"></a><a id="sthref105"></a>These indexes allow access through a B-tree on a value derived from a function on the base data. Function-based indexes have some limitations with regards to the use of nulls, and they require that you have the query optimizer enabled.</p>
<p>Function-based indexes are particularly useful when querying on composite columns to produce a derived result or to overcome limitations in the way data is stored in the database. An example is querying for line items in an order exceeding a certain value derived from (sales price - discount) x quantity, where these were columns in the table. Another example is to apply the <code>UPPER</code> function to the data to allow case-insensitive searches.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94116" class="sect4"><a id="sthref106"></a>
<h5 class="sect4"><span class="secnum">2.5.3.2.4</span> Partitioned Indexes</h5>
<p><a id="sthref107"></a><a id="sthref108"></a>Partitioning a global index allows partition pruning to take place within an index access, which results in reduced I/Os. By definition of good range or list partitioning, fast index scans of the correct index partitions can result in very fast query times.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94117" class="sect4"><a id="sthref109"></a>
<h5 class="sect4"><span class="secnum">2.5.3.2.5</span> Reverse Key Indexes</h5>
<p><a id="sthref110"></a><a id="sthref111"></a>These indexes are designed to eliminate index hot spots on insert applications. These indexes are excellent for insert performance, but they are limited because the database cannot use them for index range scans.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i28140"></a>
<div id="PFGRF94118" class="sect3">
<h4 class="sect3"><span class="secnum">2.5.3.3</span> Finding the Cost of an Index</h4>
<p><a id="sthref112"></a>Building and maintaining an index structure can be expensive, and it can consume resources such as disk space, CPU, and I/O capacity. Designers must ensure that the benefits of any index outweigh the negatives of index maintenance.</p>
<p>Use this simple estimation guide for the cost of index maintenance: each index maintained by an <code>INSERT</code>, <code>DELETE</code>, or <code>UPDATE</code> of the indexed keys requires about three times as much resource as the actual DML operation on the table. Thus, if you <code>INSERT</code> into a table with three indexes, then the insertion is approximately 10 times slower than an <code>INSERT</code> into a table with no indexes. For DML, and particularly for <code>INSERT</code>-heavy applications, the index design should be seriously reviewed, which might require a compromise between the query and <code>INSERT</code> performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11735" href="../../server.112/e25494/indexes.htm#ADMIN11735"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to monitor index usage</div>
</div>
<!-- class="sect3" -->
<a id="i28156"></a>
<div id="PFGRF94119" class="sect3">
<h4 class="sect3"><span class="secnum">2.5.3.4</span> Serializing within Indexes</h4>
<p><a id="sthref113"></a><a id="sthref114"></a>Use of sequences, or timestamps, to generate key values that are indexed themselves can lead to database hotspot problems, which affect response time and throughput. This is usually the result of a monotonically growing key that results in a right-growing index. To avoid this problem, try to generate keys that insert over the full range of the index. This results in a well-balanced index that is more scalable and space efficient. You can achieve this by using a reverse key index or using a cycling sequence to prefix and sequence values.</p>
</div>
<!-- class="sect3" -->
<a id="i28160"></a>
<div id="PFGRF94120" class="sect3">
<h4 class="sect3"><span class="secnum">2.5.3.5</span> Ordering Columns in an Index</h4>
<p><a id="sthref115"></a><a id="sthref116"></a><a id="sthref117"></a><a id="sthref118"></a>Designers should be flexible in defining any rules for index building. Depending on your circumstances, use one of the following two ways to order the keys in an index:</p>
<ul>
<li>
<p>Order columns with most <a id="sthref119"></a>selectivity first. This method is the most commonly used because it provides the fastest access with minimal I/O to the actual rowids required. This technique is used mainly for primary keys and for very selective range scans.</p>
</li>
<li>
<p>Order columns to reduce I/O by clustering or sorting data. In large range scans, I/Os can usually be reduced by ordering the columns in the least selective order, or in a manner that sorts the data in the way it should be retrieved. See <a href="data_acc.htm#g27061">Chapter 14, "Using Indexes and Clusters"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i28177"></a>
<div id="PFGRF94121" class="sect2">
<h3 class="sect2"><span class="secnum">2.5.4</span> Using Views</h3>
<p><a id="sthref120"></a>Views can speed up and simplify application design. A simple view definition can mask data model complexity from the programmers whose priorities are to retrieve, display, collect, and store data.</p>
<p>However, while views provide clean programming interfaces, they can cause sub-optimal, resource-intensive queries. The worst type of view use is when a view references other views, and when they are joined in queries. In many cases, developers can satisfy the query directly from the table without using a view. Usually, because of their inherent properties, views make it difficult for the optimizer to generate the optimal execution plan.</p>
</div>
<!-- class="sect2" -->
<a id="i29012"></a>
<div id="PFGRF94122" class="sect2">
<h3 class="sect2"><span class="secnum">2.5.5</span> SQL Execution Efficiency</h3>
<p>In the design and architecture phase of any system development, care should be taken to ensure that the application developers understand SQL execution efficiency. To achieve this goal, the development environment must support the following characteristics:</p>
<ul>
<li>
<p>Good database connection management</p>
<p>Connecting to the database is an expensive operation that is highly unscalable. Therefore, the number of concurrent connections to the database should be minimized as much as possible. A simple system, where a user connects at application initialization, is ideal. However, in a Web-based or multitiered application, where application servers are used to multiplex database connections to users, this can be difficult. With these types of applications, design efforts should ensure that database connections are pooled and are not reestablished for each user request.</p>
</li>
<li>
<p>Good cursor usage and management</p>
<p>Maintaining user connections is equally important to minimizing the parsing activity on the system. Parsing is the process of interpreting a SQL statement and creating an execution plan for it. This process has many phases, including syntax checking, security checking, execution plan generation, and loading shared structures into the shared pool. There are two types of parse operations:</p>
<ul>
<li>
<p><a id="sthref121"></a><a id="sthref122"></a>Hard parsing</p>
<p>A SQL statement is submitted for the first time, and no match is found in the shared pool. Hard parses are the most resource-intensive and unscalable, because they perform all the operations involved in a parse.</p>
</li>
<li>
<p><a id="sthref123"></a><a id="sthref124"></a>Soft parsing</p>
<p>A SQL statement is submitted for the first time, and a match <span class="italic">is</span> found in the shared pool. The match can be the result of previous execution by another user. The SQL statement is shared, which is good for performance. However, soft parses are not ideal, because they still require syntax and security checking, which consume system resources.</p>
</li>
</ul>
<p>Because parsing should be minimized as much as possible, application developers should design their applications to parse SQL statements once and execute them many times. This is done through cursors. Experienced SQL programmers should be familiar with the concept of opening and re-executing cursors.</p>
<p>Application developers must also ensure that SQL statements are shared within the shared pool. To achieve this goal, use bind variables to represent the parts of the query that change from execution to execution. If this is not done, then the SQL statement is likely to be parsed once and never re-used by other users. To ensure that SQL is shared, use bind variables and do not use string literals with SQL statements. For example:</p>
<p>Statement with string literals:</p>
<pre>
SELECT * FROM employees 
  WHERE last_name LIKE 'KING';
</pre>
<p>Statement with bind variables:</p>
<pre>
SELECT * FROM employees 
  WHERE last_name LIKE :1;
</pre>
<p>The following example shows the results of some tests on a simple OLTP application:</p>
<pre>
Test                         #Users Supported
No Parsing all statements           270 
Soft Parsing all statements         150
Hard Parsing all statements          60
Re-Connecting for each Transaction   30
</pre>
<p>These tests were performed on a four-CPU computer. The differences increase as the number of CPUs on the system increase. See <a href="sql_overview.htm#g42927">Chapter 16, "SQL Tuning Overview"</a> for information about optimizing SQL statements.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CJHJHBHA"></a>
<div id="PFGRF94123" class="sect2">
<h3 class="sect2"><span class="secnum">2.5.6</span> Implementing the Application</h3>
<p><a id="sthref125"></a><a id="sthref126"></a><a id="sthref127"></a>The choice of development environment and programming language is largely a function of the skills available in the development team and architectural decisions made when specifying the application. There are, however, some simple performance management rules that can lead to scalable, high-performance applications.</p>
<ol>
<li>
<p>Choose a development environment suitable for software components, and do not let it limit your design for performance decisions. If it does, then you probably chose the wrong language or environment.</p>
<ul>
<li>
<p><a id="sthref128"></a>User interface</p>
<p>The programming model can vary between HTML generation and calling the windowing system directly. The development method should focus on response time of the user interface code. If HTML or Java is being sent over a network, then try to minimize network volume and interactions.</p>
</li>
<li>
<p><a id="sthref129"></a>Business logic</p>
<p>Interpreted languages, such as Java and PL/SQL, are ideal to encode business logic. They are fully portable, which makes upgrading logic relatively easy. Both languages are syntactically rich to allow code that is easy to read and interpret. If business logic requires complex mathematical functions, then a compiled binary language might be needed. The business logic code can be on the client computer, the application server, and the database server. However, the application server is the most common location for business logic.</p>
</li>
<li>
<p><a id="sthref130"></a><a id="sthref131"></a>User requests and resource allocation</p>
<p>Most of this is not affected by the programming language, but tools and fourth generation languages that mask database connection and cursor management might use inefficient mechanisms. When evaluating these tools and environments, check their database connection model and their use of cursors and bind variables.</p>
</li>
<li>
<p>Data management and transactions</p>
<p>Most of this is not affected by the programming language.</p>
</li>
</ul>
</li>
<li>
<p>When implementing a software component, implement its function and not the functionality associated with other components. Implementing another component's functionality results in sub-optimal designs and implementations. This applies to all components.</p>
</li>
<li>
<p>Do not leave gaps in functionality or have software components under-researched in design, implementation, or testing. In many cases, gaps are not discovered until the application is rolled out or tested at realistic volumes. This is usually a sign of poor architecture or initial system specification. Data archival and purge modules are most frequently neglected during initial system design, build, and implementation.</p>
</li>
<li>
<p>When implementing procedural logic, implement in a procedural language, such as C, Java, or PL/SQL. When implementing data access (queries) or data changes (DML), use SQL. This rule is specific to the business logic modules of code where procedural code is mixed with data access (nonprocedural SQL) code. There is great temptation to put procedural logic into the SQL access. This tends to result in poor SQL that is resource-intensive. SQL statements with <code>DECODE</code> case statements are very often candidates for optimization, as are statements with a large amount of <code>OR</code> predicates or set operators, such as <code>UNION</code> and <code>MINUS</code>.</p>
</li>
<li>
<p>Cache frequently accessed, rarely changing data that is expensive to retrieve on a repeated basis. However, make this cache mechanism easy to use, and ensure that it is indeed cheaper than accessing the data in the original method. This is applicable to all modules where frequently used data values should be cached or stored locally, rather than be repeatedly retrieved from a remote or expensive data store.</p>
<p>The most common examples of candidates for local caching include the following:</p>
<ul>
<li>
<p>Today's date. <code>SELECT</code> <code>SYSDATE</code> <code>FROM</code> <code>DUAL</code> can account for over 60% of the workload on a database.</p>
</li>
<li>
<p>The current user name.</p>
</li>
<li>
<p>Repeated application variables and constants, such as tax rates, discounting rates, or location information.</p>
</li>
<li>
<p>Caching data locally can be further extended into building a local data cache into the application server middle tiers. This helps take load off the central database servers. However, care should be taken when constructing local caches so that they do not become so complex that they cease to give a performance gain.</p>
</li>
<li>
<p>Local sequence generation.</p>
</li>
</ul>
<p>The design implications of using a cache should be considered. For example, if a user is connected at midnight and the date is cached, then the user's date value becomes invalid.</p>
</li>
<li>
<p>Optimize the interfaces between components, and ensure that all components are used in the most scalable configuration. This rule requires minimal explanation and applies to all modules and their interfaces.</p>
</li>
<li>
<p>Use foreign key references. Enforcing referential integrity through an application is expensive. You can maintain a foreign key reference by selecting the column value of the child from the parent and ensuring that it exists. The foreign key constraint enforcement supplied by Oracle&mdash;which does not use SQL&mdash;is fast, easy to declare, and does not create network traffic.</p>
</li>
<li>
<p>Consider setting up action and module names in the application to use with <a id="sthref132"></a>End-to-End Application Tracing. This allows greater flexibility in tracing workload problems. See <a href="sqltrace.htm#i19083">"End-to-End Application Tracing"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CJHFIEDA"></a>
<div id="PFGRF94124" class="sect2">
<h3 class="sect2"><span class="secnum">2.5.7</span> Trends in Application Development</h3>
<p><a id="sthref133"></a>The two biggest challenges in application development today are the increased use of Java to replace compiled C or C++ applications, and increased use of object-oriented techniques, influencing the schema design.</p>
<p>Java provides better portability of code and availability to programmers. However, there are several performance implications associated with Java. Because Java is an interpreted language, it is slower at executing similar logic than compiled languages, such as C. As a result, resource usage of client computers increases. This requires more powerful CPUs to be applied in the client or middle-tier computers and greater care from programmers to produce efficient code.</p>
<p>Because Java is an object-oriented language, it encourages insulation of data access into classes not performing the business logic. As a result, programmers might invoke methods without knowledge of the efficiency of the data access method being used. This tends to result in minimal database access and uses the simplest and crudest interfaces to the database.</p>
<p>With this type of software design, queries do not always include all the <code>WHERE</code> predicates to be efficient, and row filtering is performed in the Java program. This is very inefficient. In addition, for DML operations&mdash;and especially for <code>INSERT</code>s&mdash;single <code>INSERT</code>s are performed, making use of the array interface impossible. In some cases, this is made more inefficient by procedure calls. More resources are used moving the data to and from the database than in the actual database calls.</p>
<p>In general, it is best to place data access calls next to the business logic to achieve the best overall transaction design.</p>
<p><a id="sthref134"></a>The acceptance of object-orientation at a programming level has led to the creation of object-oriented databases within the Oracle Server. This has manifested itself in many ways, from storing object structures within <code>BLOB</code>s and only using the database effectively as an indexed card file to the use of the Oracle Database object-relational features.</p>
<p>If you adopt an object-oriented approach to schema design, then ensure that you do not lose the flexibility of the relational storage model. In many cases, the object-oriented approach to schema design ends up in a heavily denormalized data structure that requires considerable maintenance and <code>REF</code> pointers associated with objects. Often, these designs represent a step backward to the hierarchical and network database designs that were replaced with the relational storage method.</p>
<p>In summary, if you are storing your data in your database for the long-term, and if you anticipate a degree of ad hoc queries or application development on the same schema, then the relational storage method probably gives the best performance and flexibility.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i28257"></a>
<div id="PFGRF94125" class="sect1">
<h2 class="sect1"><span class="secnum">2.6</span> Workload Testing, Modeling, and Implementation</h2>
<p>This section describes workload estimation, modeling, implementation, and testing. This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CJHJIGFJ">Sizing Data</a></p>
</li>
<li>
<p><a href="#CJHCCEJB">Estimating Workloads</a></p>
</li>
<li>
<p><a href="#CJHEDFHH">Application Modeling</a></p>
</li>
<li>
<p><a href="#CJHEHIAD">Testing, Debugging, and Validating a Design</a></p>
</li>
</ul>
<a id="CJHJIGFJ"></a>
<div id="PFGRF94126" class="sect2">
<h3 class="sect2"><span class="secnum">2.6.1</span> Sizing Data</h3>
<p>You could experience errors in your sizing estimates when dealing with variable length data if you work with a poor sample set. As data volumes grow, your key lengths could grow considerably, altering your assumptions for column sizes.</p>
<p>When the system becomes operational, it becomes more difficult to predict database growth, especially for indexes. Tables grow over time, and indexes are subject to the individual behavior of the application in terms of key generation, insertion pattern, and deletion of rows. The worst case is where you insert using an ascending key, and then delete most rows from the left-hand side but not all the rows. This leaves gaps and wasted space. If you have index use like this, then ensure that you know how to use the online index rebuild facility.</p>
<p>DBAs should monitor space allocation for each object and look for objects that may grow out of control. A good understanding of the application can highlight objects that may grow rapidly or unpredictably. This is a crucial part of both performance and availability planning for any system. When implementing the production database, the design should attempt to ensure that minimal space management takes place when interactive users are using the application. This applies for all data, temp, and rollback segments.</p>
</div>
<!-- class="sect2" -->
<a id="CJHCCEJB"></a>
<div id="PFGRF94127" class="sect2">
<h3 class="sect2"><span class="secnum">2.6.2</span> Estimating Workloads</h3>
<p><a id="sthref135"></a><a id="sthref136"></a>Considering the number of variables involved, estimation of workloads for capacity planning and testing purposes is extremely difficult. However, designers must specify computers with CPUs, memory, and disk drives, and eventually roll out an application. There are several techniques used for sizing, and each technique has merit. When sizing, it is best to use the following two methods to validate your decision-making process and provide supporting documentation:</p>
<ul>
<li>
<p><a href="#CJHECJII">Extrapolating From a Similar System</a></p>
</li>
<li>
<p><a href="#CJHICGJA">Benchmarking</a></p>
</li>
</ul>
<a id="CJHECJII"></a>
<div id="PFGRF94128" class="sect3">
<h4 class="sect3"><span class="secnum">2.6.2.1</span> Extrapolating From a Similar System</h4>
<p><a id="sthref137"></a><a id="sthref138"></a><a id="sthref139"></a>This is an entirely empirical approach where an existing system of similar characteristics and known performance is used as a basis system. The specification of this system is then modified by the sizing specialist according to the known differences. This approach has merit in that it correlates with an existing system, but it provides little assistance when dealing with the differences.</p>
<p>This approach is used in nearly all large engineering disciplines when preparing the cost of an engineering project, such as a large building, a ship, a bridge, or an oil rig. If the reference system is an order of magnitude different in size from the anticipated system, then some components may have exceeded their design limits.</p>
</div>
<!-- class="sect3" -->
<a id="CJHICGJA"></a>
<div id="PFGRF94129" class="sect3">
<h4 class="sect3"><span class="secnum">2.6.2.2</span> Benchmarking</h4>
<p><a id="sthref140"></a><a id="sthref141"></a><a id="sthref142"></a>The benchmarking process is both resource and time consuming, and it might not produce the correct results. By simulating an application in early development or prototype form, there is a danger of measuring something that has no resemblance to the actual production system. This sounds strange, but over the many years of benchmarking customer applications with the database development organization, Oracle has yet to see reliable correlation between the benchmark application and the actual production system. This is mainly due to the number of application inefficiencies introduced in the development process.</p>
<p>However, benchmarks have been used successfully to size systems to an acceptable level of accuracy. In particular, benchmarks are very good at determining the actual I/O requirements and testing recovery processes when a system is fully loaded.</p>
<p>Benchmarks by their nature stress all system components to their limits. As the benchmark stresses all components, be prepared to see all errors in application design and implementation manifest themselves while benchmarking. Benchmarks also test database, operating system, and hardware components. Because most benchmarks are performed in a rush, expect setbacks and problems when a system component fails. Benchmarking is a stressful activity, and it takes considerable experience to get the most out of a benchmarking exercise.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CJHEDFHH"></a>
<div id="PFGRF94130" class="sect2">
<h3 class="sect2"><span class="secnum">2.6.3</span> Application Modeling</h3>
<p><a id="sthref143"></a><a id="sthref144"></a>Modeling the application can range from complex mathematical modeling exercises to the classic simple calculations performed on the back of an envelope. Both methods have merit, with one attempting to be very precise and the other making gross estimates. The downside of both methods is that they do not allow for implementation errors and inefficiencies.</p>
<p>The estimation and sizing process is an imprecise science. However, by investigating the process, some intelligent estimates can be made. The whole estimation process makes no allowances for application inefficiencies introduced by poor SQL, index design, or cursor management. A sizing engineer should build in margin for application inefficiencies. A performance engineer should discover the inefficiencies and make the estimates look realistic. The Oracle performance method describes how to discover the application inefficiencies.</p>
</div>
<!-- class="sect2" -->
<a id="CJHEHIAD"></a>
<div id="PFGRF94131" class="sect2">
<h3 class="sect2"><span class="secnum">2.6.4</span> Testing, Debugging, and Validating a Design</h3>
<p><a id="sthref145"></a><a id="sthref146"></a><a id="sthref147"></a><a id="sthref148"></a><a id="sthref149"></a><a id="sthref150"></a><a id="sthref151"></a>The testing process mainly consists of functional and stability testing. At some point in the process, performance testing is performed.</p>
<p>The following list describes some simple rules for performance testing an application. If correctly documented, then this list provides important information for the production application and the capacity planning process after the application has gone live.</p>
<ul>
<li>
<p>Use the Automatic Database Diagnostic Monitor (ADDM) and SQL Tuning Advisor for design validation</p>
</li>
<li>
<p>Test with realistic data volumes and distributions</p>
<p>All testing must be done with fully populated tables. The test database should contain data representative of the production system in terms of data volume and cardinality between tables. All the production indexes should be built and the schema statistics should be populated correctly.</p>
</li>
<li>
<p>Use the correct optimizer mode</p>
<p>Perform all testing with the optimizer mode that you plan to use in production. All Oracle Database research and development effort is focused on the query optimizer. Therefore, the use of the query optimizer is recommended.</p>
</li>
<li>
<p>Test a single user performance</p>
<p>Test a single user on an idle or lightly-used database for acceptable performance. If a single user cannot achieve acceptable performance under ideal conditions, then multiple users cannot achieve acceptable performance under real conditions.</p>
</li>
<li>
<p>Obtain and document plans for all SQL statements</p>
<p>Obtain an execution plan for each SQL statement. Use this process to verify that the optimizer is obtaining an optimal execution plan, and that the relative cost of the SQL statement is understood in terms of CPU time and physical I/Os. This process assists in identifying the heavy use transactions that require the most tuning and performance work in the future.</p>
</li>
<li>
<p>Attempt multiuser testing</p>
<p>This process is difficult to perform accurately, because user workload and profiles might not be fully quantified. However, transactions performing DML statements should be tested to ensure that there are no locking conflicts or serialization problems.</p>
</li>
<li>
<p>Test with the correct hardware configuration</p>
<p>Test with a configuration as close to the production system as possible. Using a realistic system is particularly important for network latencies, I/O subsystem bandwidth, and processor type and speed. Failing to use this approach may result in an incorrect analysis of potential performance problems.</p>
</li>
<li>
<p>Measure steady state performance</p>
<p>When benchmarking, it is important to measure the performance under steady state conditions. Each benchmark run should have a ramp-up phase, where users are connected to the application and gradually start performing work on the application. This process allows for frequently cached data to be initialized into the cache and single execution operations&mdash;such as parsing&mdash;to be completed before the steady state condition. Likewise, at the end of a benchmark run, there should be a ramp-down period, where resources are freed from the system and users cease work and disconnect.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i28309"></a>
<div id="PFGRF94132" class="sect1">
<h2 class="sect1"><span class="secnum">2.7</span> Deploying New Applications</h2>
<p><a id="sthref152"></a><a id="sthref153"></a>This section describes the following design decisions involved in deploying applications:</p>
<ul>
<li>
<p><a href="#CJHGFEDE">Rollout Strategies</a></p>
</li>
<li>
<p><a href="#CJHCHDGG">Performance Checklist</a></p>
</li>
</ul>
<a id="CJHGFEDE"></a>
<div id="PFGRF94133" class="sect2">
<h3 class="sect2"><span class="secnum">2.7.1</span> Rollout Strategies</h3>
<p>When new applications are rolled out, two strategies are commonly adopted:</p>
<ul>
<li>
<p><a id="sthref154"></a><a id="sthref155"></a>Big Bang approach - all users migrate to the new system at once</p>
</li>
<li>
<p><a id="sthref156"></a><a id="sthref157"></a>Trickle approach - users slowly migrate from existing systems to the new one</p>
</li>
</ul>
<p>Both approaches have merits and disadvantages. The Big Bang approach relies on reliable testing of the application at the required scale, but has the advantage of minimal data conversion and synchronization with the old system, because it is simply switched off. The Trickle approach allows debugging of scalability issues as the workload increases, but might mean that data must be migrated to and from legacy systems as the transition takes place.</p>
<p>It is difficult to recommend one approach over the other, because each method has associated risks that could lead to system outages as the transition takes place. Certainly, the Trickle approach allows profiling of real users as they are introduced to the new application, and allows the system to be reconfigured while only affecting the migrated users. This approach affects the work of the early adopters, but limits the load on support services. This means that unscheduled outages only affect a small percentage of the user population.</p>
<p>The decision on how to roll out a new application is specific to each business. Any adopted approach has its own unique pressures and stresses. The more testing and knowledge that you derive from the testing process, the more you realize what is best for the rollout.</p>
</div>
<!-- class="sect2" -->
<a id="CJHCHDGG"></a>
<div id="PFGRF94134" class="sect2">
<h3 class="sect2"><span class="secnum">2.7.2</span> Performance Checklist</h3>
<p>To assist in the rollout, build a list of tasks that increase the chance of optimal performance in production and enable rapid debugging of the application. Do the following:</p>
<ol>
<li>
<p>When you create the control file for the production database, allow for growth by setting <code>MAXINSTANCES</code>, <code>MAXDATAFILES</code>, <code>MAXLOGFILES</code>, <code>MAXLOGMEMBERS</code>, and <code>MAXLOGHISTORY</code> to values higher than what you anticipate for the rollout. This technique results in more disk space usage and larger control files, but saves time later should these need extension in an emergency.</p>
</li>
<li>
<p>Set block size to the value used to develop the application. Export the schema statistics from the development or test environment to the production database if the testing was done on representative data volumes and the current SQL execution plans are correct.</p>
</li>
<li>
<p>Set the minimal number of initialization parameters. Ideally, most other parameters should be left at default. If there is more tuning to perform, then this appears when the system is under load. See <a href="build_db.htm#g27214">Chapter 4, "Configuring a Database for Performance"</a> for information about parameter settings in an initial instance configuration.</p>
</li>
<li>
<p>Be prepared to manage block contention by setting storage options of database objects. Tables and indexes that experience high <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> rates should be created with automatic segment space management. To avoid contention of rollback segments, use automatic undo management. See <a href="build_db.htm#g27214">Chapter 4, "Configuring a Database for Performance"</a> for information about undo and temporary segments.</p>
</li>
<li>
<p>All SQL statements should be verified to be optimal and their resource usage understood.</p>
</li>
<li>
<p>Validate that middleware and programs that connect to the database are efficient in their connection management and do not logon or logoff repeatedly.</p>
</li>
<li>
<p>Validate that the SQL statements use cursors efficiently. The database should parse each SQL statement once and then execute it multiple times. The most common reason this does not happen is because bind variables are not used properly and <code>WHERE</code> clause predicates are sent as string literals. If you use precompilers to develop the application, then make sure to reset the parameters <code>MAXOPENCURSORS</code>, <code>HOLD_CURSOR</code>, and <code>RELEASE_CURSOR</code> from the default values before precompiling the application.</p>
</li>
<li>
<p>Validate that all schema objects have been correctly migrated from the development environment to the production database. This includes tables, indexes, sequences, triggers, packages, procedures, functions, Java objects, synonyms, grants, and views. Ensure that any modifications made in testing are made to the production system.</p>
</li>
<li>
<p>As soon as the system is rolled out, establish a baseline set of statistics from the database and operating system. This first set of statistics validates or corrects any assumptions made in the design and rollout process.</p>
</li>
<li>
<p>Start anticipating the first bottleneck (which is inevitable) and follow the Oracle performance method to make performance improvement. For more information, see <a href="technique.htm#g14920">Chapter 3, "Performance Improvement Methods"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1679">
<tr>
<td class="cellalignment1688">
<table class="cellalignment1684">
<tr>
<td class="cellalignment1683"><a href="part2.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1683"><a href="technique.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1690">
<table class="cellalignment1682">
<tr>
<td class="cellalignment1683"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1683"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1683"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1683"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1683"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1683"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
