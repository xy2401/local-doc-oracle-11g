<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Configuring and Using Memory</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-06-30T4:25:5Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Performance Tuning Guide" />
<meta name="dcterms.identifier" content="E41573-04" />
<meta name="dcterms.isVersionOf" content="PFGRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="diag.htm" title="Previous" type="text/html" />
<link rel="Next" href="iodesign.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41573.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/31</span> <!-- End Header -->
<div id="PFGRF014" class="chapter"><a id="g77696"></a> <a id="i53187"></a>
<h1 class="chapter"><span class="secnum">7</span> Configuring and Using Memory</h1>
<p>This chapter explains how to allocate memory to Oracle Database memory caches, and how to use those caches. Proper sizing and effective use of the Oracle Database memory caches greatly improves database performance. Oracle recommends using automatic memory management to manage the memory on your system. However, you can choose to manually adjust the memory pools on your system, as described in this chapter.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i21817">Understanding Memory Allocation Issues</a></p>
</li>
<li>
<p><a href="#i29118">Configuring and Using the Buffer Cache</a></p>
</li>
<li>
<p><a href="#i30970">Configuring and Using the Shared Pool and Large Pool</a></p>
</li>
<li>
<p><a href="#i29756">Configuring and Using the Redo Log Buffer</a></p>
</li>
<li>
<p><a href="#i49320">PGA Memory Management</a></p>
</li>
<li>
<p><a href="#BGBCABED">Managing the Server and Client Result Caches</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT007" href="../../server.112/e40540/memory.htm#CNCPT007"><span class="italic">Oracle Database Concepts</span></a> for information about the memory architecture of an Oracle database</div>
</li>
</ul>
<a id="i21817"></a>
<div id="PFGRF94252" class="sect1">
<h2 class="sect1"><span class="secnum">7.1</span> Understanding Memory Allocation Issues</h2>
<p><a id="sthref352"></a><a id="sthref353"></a>Oracle Database stores information in memory caches and on disk. <a id="sthref354"></a><a id="sthref355"></a>Memory access is much faster than disk access. Disk access (physical I/O) take a significant amount of time, compared with memory access, typically in the order of 10 milliseconds. Physical I/O also increases the CPU resources required, because of the path length in device drivers and operating system event schedulers. For this reason, it is more efficient for data requests of frequently accessed objects to be perform by memory, rather than also requiring disk access.</p>
<p>A performance goal is to reduce the physical I/O overhead as much as possible, either by making it more likely that the required data is in memory, or by making the process of retrieving the required data more efficient.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BGBBDEIG">Oracle Memory Caches</a></p>
</li>
<li>
<p><a href="#BGBCIBFA">Automatic Memory Management</a></p>
</li>
<li>
<p><a href="#i58728">Automatic Shared Memory Management</a></p>
</li>
<li>
<p><a href="#i60086">Dynamically Changing Cache Sizes</a></p>
</li>
<li>
<p><a href="#BGBHEGDC">Application Considerations</a></p>
</li>
<li>
<p><a href="#BGBHEBGC">Operating System Memory Use</a></p>
</li>
<li>
<p><a href="#BGBEABFA">Iteration During Configuration</a></p>
</li>
</ul>
<a id="BGBBDEIG"></a>
<div id="PFGRF94253" class="sect2">
<h3 class="sect2"><span class="secnum">7.1.1</span> Oracle Memory Caches</h3>
<p>The main Oracle Database memory caches that affect performance are:</p>
<ul>
<li>
<p>Shared pool</p>
</li>
<li>
<p>Large pool</p>
</li>
<li>
<p>Java pool</p>
</li>
<li>
<p>Buffer cache</p>
</li>
<li>
<p>Streams pool size</p>
</li>
<li>
<p>Log buffer</p>
</li>
<li>
<p>Process-private memory, such as memory used for sorting and hash joins</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BGBCIBFA"></a>
<div id="PFGRF94254" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">7.1.2</span> Automatic Memory Management</h3>
<p>Oracle strongly recommends the use of automatic memory management to manage the memory on your system. Automatic memory management enables Oracle Database to automatically manage and tune the instance memory. Automatic memory management can be configured using a target memory size initialization parameter (<code>MEMORY_TARGET</code>) and a maximum memory size initialization parameter (<code>MEMORY_MAX_TARGET</code>). The database tunes to the target memory size, redistributing memory as needed between the system global area (SGA) and the instance program global area (instance PGA). Before setting any memory pool sizes, consider using the automatic memory management feature of Oracle Database. If you must configure memory allocations, consider using the Memory Advisor for managing memory.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11011" href="../../server.112/e25494/memory.htm#ADMIN11011"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about using automatic memory management</p>
</li>
<li>
<p><a class="olink ADMQS1034" href="../../server.112/e10897/montune.htm#ADMQS1034"><span class="italic">Oracle Database 2 Day DBA</span></a> for information about using the Memory Advisor</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i58728"></a>
<div id="PFGRF94255" class="sect2">
<h3 class="sect2"><span class="secnum">7.1.3</span> Automatic Shared Memory Management</h3>
<p><a id="sthref356"></a><a id="sthref357"></a>Automatic Shared Memory Management simplifies the configuration of the SGA. To use Automatic Shared Memory Management, set the <code><a id="sthref358"></a>SGA_TARGET</code> initialization parameter to a nonzero value and set the <code>STATISTICS_LEVEL</code> initialization parameter to <code>TYPICAL</code> or <code>ALL</code>. Set the value of the <code>SGA_TARGET</code> parameter to the amount of memory that you intend to dedicate for the SGA. In response to the workload on the system, the automatic SGA management distributes the memory appropriately for the following memory pools:</p>
<ul>
<li>
<p>Database buffer cache (default pool)</p>
</li>
<li>
<p>Shared pool</p>
</li>
<li>
<p>Large pool</p>
</li>
<li>
<p>Java pool</p>
</li>
<li>
<p>Streams pool</p>
</li>
</ul>
<p>If these automatically tuned memory pools had been set to nonzero values, those values are used as minimum levels by Automatic Shared Memory Management. You would set minimum values if an application component needs a minimum amount of memory to function properly.</p>
<p><code>SGA_TARGET</code> is a dynamic parameter that can be changed by accessing the SGA Size Advisor from the Memory Parameters SGA page in Oracle Enterprise Manager, or by querying the <code>V$SGA_TARGET_ADVICE</code> view and using the <code>ALTER</code> <code>SYSTEM</code> command. <code>SGA_TARGET</code> can be set less than or equal to the value of <code>SGA_MAX_SIZE</code> initialization parameter. Changes in the value of <code>SGA_TARGET</code> automatically resize the automatically tuned memory pools.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT802" href="../../server.112/e40540/memory.htm#CNCPT802"><span class="italic">Oracle Database Concepts</span></a> for information about the System Global Area (SGA)</p>
</li>
<li>
<p><a class="olink ADMIN00207" href="../../server.112/e25494/memory.htm#ADMIN00207"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about managing the System Global Area (SGA)</p>
</li>
</ul>
</div>
<p>If you dynamically disable <code>SGA_TARGET</code> by setting its value to 0 at instance startup, Automatic Shared Memory Management will be disabled and the current auto-tuned sizes will be used for each memory pool. If necessary, you can manually resize each memory pool using the <code>DB_CACHE_SIZE</code>, <code>SHARED_POOL_SIZE</code>, <code>LARGE_POOL_SIZE</code>, <code>JAVA_POOL_SIZE</code>, and <code>STREAMS_POOL_SIZE</code> initialization parameters. See <a href="#i60086">"Dynamically Changing Cache Sizes"</a>.</p>
<p>The following pools are manually sized components and are not affected by Automatic Shared Memory Management:</p>
<ul>
<li>
<p>Log buffer</p>
</li>
<li>
<p>Other buffer caches (such as <code>KEEP</code>, <code>RECYCLE</code>, and other nondefault block size)</p>
</li>
<li>
<p>Fixed SGA and other internal allocations</p>
</li>
</ul>
<p>To manually size these memory pools, you must set the <code>DB_KEEP_CACHE_SIZE</code>, <code>DB_RECYCLE_CACHE_SIZE</code>, <code>DB_nK_CACHE_SIZE</code>, and <code>LOG_BUFFER</code> initialization parameters. The memory allocated to these pools is deducted from the total available for <code>SGA_TARGET</code> when Automatic Shared Memory Management computes the values of the automatically tuned memory pools.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN002" href="../../server.112/e25494/create.htm#ADMIN002"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about managing initialization parameters</p>
</li>
<li>
<p><a class="olink STREP201" href="../../server.112/e10705/prep_rep.htm#STREP201"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for information about the <code><a id="sthref359"></a><a id="sthref360"></a>STREAMS_POOL_SIZE</code> initialization parameter</p>
</li>
<li>
<p><a class="olink JJDEV" href="../../java.112/e10588/toc.htm"><span class="italic">Oracle Database Java Developer's Guide</span></a> for information about Java memory usage</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i60086"></a>
<div id="PFGRF94256" class="sect2">
<h3 class="sect2"><span class="secnum">7.1.4</span> Dynamically Changing Cache Sizes</h3>
<p>If the system is not using Automatic Memory Management or Automatic Shared Memory Management, you can choose to dynamically reconfigure the sizes of the shared pool, the large pool, the buffer cache, and the process-private memory. The following sections contain details on sizing of caches:</p>
<ul>
<li>
<p><a href="#i29118">Configuring and Using the Buffer Cache</a></p>
</li>
<li>
<p><a href="#i30970">Configuring and Using the Shared Pool and Large Pool</a></p>
</li>
<li>
<p><a href="#i29756">Configuring and Using the Redo Log Buffer</a></p>
</li>
</ul>
<p>The size of these memory caches is configurable using initialization configuration parameters, such as <code>DB_CACHE_SIZE</code>, <code>JAVA_POOL_SIZE</code>, <code>LARGE_POOL_SIZE</code>, <code>LOG_BUFFER</code>, <code>and</code> <code>SHARED_POOL_SIZE</code>. The values for these parameters are also dynamically configurable using the <code>ALTER</code> <code>SYSTEM</code> statement except for the log buffer pool and process-private memory, which are static after startup.</p>
<p>Memory for the shared pool, large pool, java pool, and buffer cache is allocated in units of <span class="bold">granules</span>. The granule size is 4MB if the SGA size is less than 1GB. If the SGA size is greater than 1GB, the granule size changes to 16MB. The granule size is calculated and fixed when the instance starts up. The size does not change during the lifetime of the instance.</p>
<p>The granule size that is currently being used for SGA can be viewed in the view <code>V$SGA_DYNAMIC_COMPONENTS</code>. The same granule size is used for all dynamic components in the SGA.</p>
<p>You can expand the total SGA size to a value equal to the <code>SGA_MAX_SIZE</code> parameter. If the <code>SGA_MAX_SIZE</code> is not set, you can decrease the size of one cache and reallocate that memory to another cache if necessary. <code>SGA_MAX_SIZE</code> defaults to the aggregate setting of all the components.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>SGA_MAX_SIZE</code> cannot be dynamically resized.</div>
<p>The maximum amount of memory usable by the instance is determined at instance startup by the initialization parameter <code>SGA_MAX_SIZE</code>. You can specify <code>SGA_MAX_SIZE</code> to be larger than the sum of all of the memory components, such as buffer cache and shared pool. Otherwise, <code>SGA_MAX_SIZE</code> defaults to the actual size used by those components. Setting <code>SGA_MAX_SIZE</code> larger than the sum of memory used by all of the components lets you dynamically increase a cache size without needing to decrease the size of another cache.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
Your operating system's documentation for information about managing dynamic SGA</div>
<div id="PFGRF94257" class="sect3"><a id="sthref361"></a>
<h4 class="sect3"><span class="secnum">7.1.4.1</span> Viewing Information About Dynamic Resize Operations</h4>
<p>The following views provide information about dynamic resize operations:</p>
<ul>
<li>
<p><code>V$MEMORY_CURRENT_RESIZE_OPS</code> displays information about memory resize operations (both automatic and manual) which are currently in progress.</p>
</li>
<li>
<p><code>V$MEMORY_DYNAMIC_COMPONENTS</code> displays information about the current sizes of all dynamically tuned memory components, including the total sizes of the SGA and instance PGA.</p>
</li>
<li>
<p><code>V$MEMORY_RESIZE_OPS</code> displays information about the last 800 completed memory resize operations (both automatic and manual). This does not include in-progress operations.</p>
</li>
<li>
<p><code>V$MEMORY_TARGET_ADVICE</code> displays tuning advice for the <code>MEMORY_TARGET</code> initialization parameter.</p>
</li>
<li>
<p><code>V$SGA_CURRENT_RESIZE_OPS</code> displays information about SGA resize operations that are currently in progress. An operation can be a grow or a shrink of a dynamic SGA component.</p>
</li>
<li>
<p><code>V$SGA_RESIZE_OPS</code> displays information about the last 800 completed SGA resize operations. This does not include any operations currently in progress.</p>
</li>
<li>
<p><code>V$SGA_DYNAMIC_COMPONENTS</code> displays information about the dynamic components in SGA. This view summarizes information based on all completed SGA resize operations that occurred after startup.</p>
</li>
<li>
<p><code>V$SGA_DYNAMIC_FREE_MEMORY</code> displays information about the amount of SGA memory available for future dynamic SGA resize operations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT" href="../e40540/toc.htm"><span class="italic">Oracle Database Concepts</span></a> for more information about dynamic SGA</p>
</li>
<li>
<p><a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for detailed column information for these views</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBHEGDC"></a>
<div id="PFGRF94258" class="sect2">
<h3 class="sect2"><span class="secnum">7.1.5</span> Application Considerations</h3>
<p>When configuring memory, size the cache appropriately for the application's needs. Conversely, tuning the application's use of the caches can greatly reduce resource requirements. Efficient use of Oracle Database memory caches also reduces the load on related resources such as the latches, the CPU, and the I/O system.</p>
<p>For best performance, you should consider the following:</p>
<ul>
<li>
<p>The cache should be optimally designed to use the operating system and database resources most efficiently.</p>
</li>
<li>
<p>Memory allocations to Oracle Database memory structures should best reflect the needs of the application.</p>
</li>
</ul>
<p>Making changes or additions to an existing application might require resizing Oracle Database memory structures to meet the needs of your modified application.</p>
<p>If your application uses Java, you should investigate whether you need to modify the default configuration for the Java pool. See the <a class="olink JJDEV" href="../../java.112/e10588/toc.htm"><span class="italic">Oracle Database Java Developer's Guide</span></a> for information about Java memory usage.</p>
</div>
<!-- class="sect2" -->
<a id="BGBHEBGC"></a>
<div id="PFGRF94259" class="sect2">
<h3 class="sect2"><span class="secnum">7.1.6</span> Operating System Memory Use</h3>
<p>For most operating systems, it is important to consider the following:</p>
<ul>
<li>
<p><a href="#i39284">Reduce Paging</a></p>
</li>
<li>
<p><a href="#i38293">Fit the SGA into Main Memory</a></p>
</li>
<li>
<p><a href="#i38322">Allow Adequate Memory to Individual Users</a></p>
</li>
</ul>
<a id="i39284"></a>
<div id="PFGRF94260" class="sect3">
<h4 class="sect3"><span class="secnum">7.1.6.1</span> Reduce Paging</h4>
<p>Paging occurs when an operating system transfers memory-resident pages to disk solely to allow new pages to be loaded into memory<a id="sthref362"></a><a id="sthref363"></a><a id="sthref364"></a>. Many operating systems page to accommodate large amounts of information that do not fit into real memory. On most operating systems, paging reduces performance.</p>
<p>Use operating system utilities to examine the operating system, to identify whether there is a lot of paging on your system. If so, then the total system memory may not be large enough to hold everything for which you have allocated memory. Either increase the total memory on your system, or decrease the amount of memory allocated.</p>
</div>
<!-- class="sect3" -->
<a id="i38293"></a>
<div id="PFGRF94261" class="sect3">
<h4 class="sect3"><span class="secnum">7.1.6.2</span> Fit the SGA into Main Memory</h4>
<p><a id="sthref365"></a><a id="sthref366"></a>Because the purpose of the SGA is to store data in memory for fast access, the SGA should be within main memory. If pages of the SGA are swapped to disk, then the data is no longer quickly accessible. On most operating systems, the disadvantage of paging significantly outweighs the advantage of a large SGA.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use the <code>LOCK_SGA</code> parameter to lock the SGA into physical memory and prevent it from being paged out. The database does not use the <code>MEMORY_TARGET</code> and <code>MEMORY_MAX_TARGET</code> parameters when the <code>LOCK_SGA</code> parameter is enabled.</div>
<p>To see how much memory is allocated to the SGA and each of its internal structures, enter the following SQL*Plus statement:<a id="sthref367"></a></p>
<pre>
SHOW SGA
</pre>
<p>The output of this statement will look similar to the following:</p>
<pre>
Total System Global Area  840205000 bytes
Fixed Size                   279240 bytes
Variable Size             520093696 bytes
Database Buffers          318767104 bytes
Redo Buffers                1064960 bytes
</pre></div>
<!-- class="sect3" -->
<a id="i38322"></a>
<div id="PFGRF94262" class="sect3">
<h4 class="sect3"><span class="secnum">7.1.6.3</span> Allow Adequate Memory to Individual Users</h4>
<p>When sizing the SGA, ensure that you allow enough memory for the individual server processes and any other programs running on the system.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
Your operating system hardware and software documentation, and the Oracle documentation specific to your operating system, for more information on tuning operating system memory usage</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBEABFA"></a>
<div id="PFGRF94263" class="sect2">
<h3 class="sect2"><span class="secnum">7.1.7</span> Iteration During Configuration</h3>
<p>Configuring<a id="sthref368"></a> memory allocation<a id="sthref369"></a> involves distributing available memory to Oracle Database memory structures, depending on the needs of the application. The distribution of memory to Oracle Database structures can affect the amount of physical I/O necessary for Oracle Database t operate. Having a good first initial memory configuration also provides an indication of whether the I/O system is effectively configured.</p>
<p>It might be necessary to repeat the steps of memory allocation after the initial pass through the process. Subsequent passes let you make adjustments in earlier steps, based on changes in later steps. For example, decreasing the size of the buffer cache lets you increase the size of another memory structure, such as the shared pool.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i29118"></a>
<div id="PFGRF94264" class="sect1">
<h2 class="sect1"><span class="secnum">7.2</span> Configuring and Using the Buffer Cache</h2>
<p>For many types of operations, Oracle Database uses the buffer cache to store blocks read from disk. Oracle Database bypasses the buffer cache for particular operations, such as sorting and parallel reads. For operations that use the buffer cache, this section explains the following:</p>
<ul>
<li>
<p><a href="#i30761">Using the Buffer Cache Effectively</a></p>
</li>
<li>
<p><a href="#i30311">Sizing the Buffer Cache</a></p>
</li>
<li>
<p><a href="#i45097">Interpreting and Using the Buffer Cache Advisory Statistics</a></p>
</li>
<li>
<p><a href="#i30935">Considering Multiple Buffer Pools</a></p>
</li>
</ul>
<a id="i30761"></a>
<div id="PFGRF94265" class="sect2">
<h3 class="sect2"><span class="secnum">7.2.1</span> Using the Buffer Cache Effectively</h3>
<p>To use the buffer cache effectively, tune SQL statements for the application to avoid unnecessary resource consumption. To meet this goal, verify that frequently executed SQL statements and SQL statements that perform many buffer gets have been tuned.</p>
<p>When using parallel query, you can configure the database to use the database buffer cache instead of performing direct reads into the PGA. This configuration may be appropriate when the database servers have a large amount of memory.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="sql_overview.htm#g42927">Chapter 16, "SQL Tuning Overview"</a></p>
</li>
<li>
<p><a class="olink VLDBG010" href="../../server.112/e25523/parallel.htm#VLDBG010"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> to learn more using parallel execution</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i30311"></a>
<div id="PFGRF94266" class="sect2">
<h3 class="sect2"><span class="secnum">7.2.2</span> Sizing the Buffer Cache</h3>
<p>When configuring a new instance, it is impossible to know the correct size for the buffer cache. Typically, a database administrator makes a first estimate for the cache size, then runs a representative workload on the instance and examines the relevant statistics to see whether the cache is under or over configured.</p>
<div id="PFGRF94267" class="sect3"><a id="sthref370"></a>
<h4 class="sect3"><span class="secnum">7.2.2.1</span> Buffer Cache Advisory Statistics</h4>
<p>You can use several statistics to examine buffer cache activity, including the following:</p>
<ul>
<li>
<p><code><a id="sthref371"></a>V$DB_CACHE_ADVICE</code></p>
</li>
<li>
<p>Buffer cache hit ratio</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="PFGRF94268" class="sect3"><a id="sthref372"></a>
<h4 class="sect3"><span class="secnum">7.2.2.2</span> Using V$DB_CACHE_ADVICE</h4>
<p>This view is populated when the <code>DB_CACHE_ADVICE</code> initialization parameter is set to <code>ON</code>. This view shows the simulated miss rates for a range of potential buffer cache sizes.</p>
<p>Each cache size simulated has its own row in this view, with the predicted physical I/O activity that would take place for that size. The <code>DB_CACHE_ADVICE</code> parameter is dynamic, so the advisory can be enabled and disabled dynamically to allow you to collect advisory data for a specific workload.</p>
<p>There is some overhead associated with this advisory. When the advisory is enabled, there is a small increase in CPU usage, because additional bookkeeping is required.</p>
<p>Oracle Database uses DBA-based sampling to gather cache advisory statistics. Sampling substantially reduces both CPU and memory overhead associated with bookkeeping. Sampling is not used for a buffer pool if the number of buffers in that buffer pool is small to begin with.</p>
<p>To use <code>V$DB_CACHE_ADVICE</code>, the parameter <code>DB_CACHE_ADVICE</code> should be set to <code>ON</code>, and a representative workload should be running on the instance. Allow the workload to stabilize before querying the <code>V$DB_CACHE_ADVICE</code> view.</p>
<p>The following SQL statement returns the predicted I/O requirement for the default buffer pool for various cache sizes:</p>
<pre>
COLUMN size_for_estimate          FORMAT 999,999,999,999 heading 'Cache Size (MB)'
COLUMN buffers_for_estimate       FORMAT 999,999,999 heading 'Buffers'
COLUMN estd_physical_read_factor  FORMAT 999.90 heading 'Estd Phys|Read Factor'
COLUMN estd_physical_reads        FORMAT 999,999,999 heading 'Estd Phys| Reads'

SELECT size_for_estimate, buffers_for_estimate, estd_physical_read_factor, estd_physical_reads
   FROM V$DB_CACHE_ADVICE
   WHERE name          = 'DEFAULT'
     AND block_size    = (SELECT value FROM V$PARAMETER WHERE name = 'db_block_size')
     AND advice_status = 'ON';
</pre>
<p>The following output shows that if the cache was 212 MB, rather than the current size of 304 MB, the estimated number of physical reads would increase by a factor of 1.74 or 74%. This means it would not be advisable to decrease the cache size to 212MB.</p>
<p>However, increasing the cache size to 334MB would potentially decrease reads by a factor of .93 or 7%. If an additional 30MB memory is available on the host computer and the <code>SGA_MAX_SIZE</code> setting allows the increment, it would be advisable to increase the default buffer cache pool size to 334MB.</p>
<pre>
                                Estd Phys    Estd Phys
 Cache Size (MB)      Buffers Read Factor        Reads
---------------- ------------ ----------- ------------
              30        3,802       18.70  192,317,943      10% of Current Size 
              60        7,604       12.83  131,949,536
              91       11,406        7.38   75,865,861
             121       15,208        4.97   51,111,658
             152       19,010        3.64   37,460,786
             182       22,812        2.50   25,668,196
             212       26,614        1.74   17,850,847
             243       30,416        1.33   13,720,149
             273       34,218        1.13   11,583,180
             304       38,020        1.00   10,282,475      Current Size 
             334       41,822         .93    9,515,878
             364       45,624         .87    8,909,026
             395       49,426         .83    8,495,039
             424       53,228         .79    8,116,496
             456       57,030         .76    7,824,764
             486       60,832         .74    7,563,180
             517       64,634         .71    7,311,729
             547       68,436         .69    7,104,280
             577       72,238         .67    6,895,122
             608       76,040         .66    6,739,731      200% of Current Size 
</pre>
<p>This view assists in cache sizing by providing information that predicts the number of physical reads for each potential cache size. The data also includes a physical read factor, which is a factor by which the current number of physical reads is estimated to change if the buffer cache is resized to a given value.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
With Oracle Database, physical reads do not necessarily indicate disk reads; physical reads may well be satisfied from the file system cache.</div>
<p>The relationship between successfully finding a block in the cache and the size of the cache is not always a smooth distribution. When sizing the buffer pool, avoid the use of additional buffers that contribute little or nothing to the cache hit ratio. In the example illustrated in <a href="#i59773">Figure 7-1</a>, only narrow bands of increments to the cache size may be worthy of consideration.</p>
<div id="PFGRF94269" class="figure">
<p class="titleinfigure"><a id="i59773"></a>Figure 7-1 Physical I/O and Buffer Cache Size</p>
<img width="496" height="288" src="img/pfgrf041.gif" alt="Description of Figure 7-1 follows" /><br />
<a id="sthref373" href="img_text/pfgrf041.htm">Description of "Figure 7-1 Physical I/O and Buffer Cache Size"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Examining <a href="#i59773">Figure 7-1</a> leads to the following observations:</p>
<ul>
<li>
<p>The benefit from increasing buffers from point A to point B is considerably higher than from point B to point C.</p>
</li>
<li>
<p>The decrease in the physical I/O between points A and B and points B and C is not smooth, as indicated by the dotted line in the graph.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i56283"></a>
<div id="PFGRF94270" class="sect3">
<h4 class="sect3"><span class="secnum">7.2.2.3</span> Calculating the Buffer Cache Hit Ratio</h4>
<p>The buffer cache hit ratio calculates how often a requested block has been found in the buffer cache without requiring disk access. This ratio is computed using data selected from the dynamic performance view <code>V$SYSSTAT</code><a id="sthref374"></a>. You can use the buffer cache hit ratio to verify the physical I/O as predicted by <code>V$DB_CACHE_<a id="sthref375"></a>ADVICE</code>.</p>
<p>The statistics in <a href="#g61128">Table 7-1</a> are used to calculate the hit ratio.</p>
<div id="PFGRF94271" class="tblformal">
<p class="titleintable"><a id="sthref376"></a><a id="g61128"></a>Table 7-1 Statistics for Calculating the Hit Ratio</p>
<table class="cellalignment1686" title="Statistics for Calculating the Hit Ratio" summary="This table lists statistics that are used to calculate the buffer cache hit ratio." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t13">Statistic</th>
<th class="cellalignment1687" id="r1c2-t13">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t13" headers="r1c1-t13">
<p><code>consistent gets from cache</code><a id="sthref377"></a><a id="sthref378"></a></p>
</td>
<td class="cellalignment1688" headers="r2c1-t13 r1c2-t13">
<p>Number of times a consistent read was requested for a block from the buffer cache.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t13" headers="r1c1-t13">
<p><code>db block gets from cache</code><a id="sthref379"></a><a id="sthref380"></a></p>
</td>
<td class="cellalignment1688" headers="r3c1-t13 r1c2-t13">
<p>Number of times a CURRENT block was requested from the buffer cache.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t13" headers="r1c1-t13">
<p><code>physical reads cache</code><a id="sthref381"></a><a id="sthref382"></a></p>
</td>
<td class="cellalignment1688" headers="r4c1-t13 r1c2-t13">
<p>Total number of data blocks read from disk into buffer cache.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#i52725">Example 7-1</a> has been simplified by using values selected directly from the <code>V$SYSSTAT</code> table, rather than over an interval. It is best to calculate the delta of these statistics over an interval while your application is running, then use them to determine the hit ratio.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="diag.htm#g41683">Chapter 6, "Automatic Performance Diagnostics"</a> for more information on collecting statistics over an interval</div>
<div id="PFGRF94272" class="example">
<p class="titleinexample"><a id="i52725"></a>Example 7-1 Calculating the Buffer Cache Hit Ratio</p>
<pre>
SELECT NAME, VALUE
  FROM V$SYSSTAT
WHERE NAME IN ('db block gets from cache', 'consistent gets from cache', 'physical reads cache');
</pre>
<p>Using the values in the output of the query, <a id="sthref383"></a>calculate the hit ratio for the buffer cache with the following formula:</p>
<pre>
1 - (('physical reads cache') / ('consistent gets from cache' + 'db block gets from cache'))
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for information about the <code>V$SYSSTAT</code> view</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i45097"></a>
<div id="PFGRF94273" class="sect2">
<h3 class="sect2"><span class="secnum">7.2.3</span> Interpreting and Using the Buffer Cache Advisory Statistics</h3>
<p>There are many factors to examine before considering whether to increase or decrease the buffer cache size. For example, you should examine <code>V$DB_CACH<a id="sthref384"></a>E_ADVICE</code> data and the buffer cache hit ratio.</p>
<p>A low cache hit ratio does not imply that increasing the size of the cache would be beneficial for performance. A good cache hit ratio could wrongly indicate that the cache is adequately sized for the workload.</p>
<p>To interpret the buffer cache hit ratio, you should consider the following:</p>
<ul>
<li>
<p>Repeated scanning of the same large table or index can artificially inflate a poor cache hit ratio. Examine frequently executed SQL statements with a large number of buffer gets, to ensure that the execution plan for such SQL statements is optimal. If possible, avoid repeated scanning of frequently accessed data by performing all of the processing in a single pass or by optimizing the SQL statement.</p>
</li>
<li>
<p>If possible, avoid requerying the same data, by caching frequently accessed data in the client program or middle tier.</p>
</li>
<li>
<p>Database blocks accessed during a long full table scan are put on the tail end of the least recently used LRU list and not on the head of the list. Therefore, the blocks are aged out faster than blocks read when performing indexed lookups or small table scans. When interpreting the buffer cache data, poor hit ratios when valid large full table scans are occurring should also be considered.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Short table scans are scans performed on tables under a certain size threshold. The definition of a small table is the maximum of 2% of the buffer cache and 20, whichever is bigger.</div>
</li>
</ul>
<ul>
<li>
<p>In any large database running OLTP applications in any given unit of time, most rows are accessed either one or zero times. On this basis, there might be little purpose in keeping the block in memory for very long following its use.</p>
</li>
<li>
<p>A common mistake is to continue increasing the buffer cache size. Such increases have no effect if you are doing full table scans or operations that do not use the buffer cache.</p>
</li>
</ul>
<div id="PFGRF94274" class="sect3"><a id="sthref385"></a>
<h4 class="sect3"><span class="secnum">7.2.3.1</span> Increasing Memory Allocated to the Buffer Cache</h4>
<p>As a general rule, investigate increasing the size of the cache if the cache hit ratio is low and your application has been tuned to avoid performing full table scans.</p>
<p>To increase cache size, first set the <code><a id="sthref386"></a>DB_CACHE_ADVICE</code> initialization parameter to <code>ON</code>, and let the cache statistics stabilize. Examine the advisory data in the <code><a id="sthref387"></a>V$DB_CACHE_ADVICE</code> view to determine the next increment required to significantly decrease the amount of physical I/O performed. If it is possible to allocate the required extra memory to the buffer cache without causing the host operating system to page, then allocate this memory. To increase the amount of memory allocated to the buffer cache, increase the value of the <code>DB_CACHE_SIZE</code> initialization parameter.</p>
<p>If required, resize the buffer pools dynamically, rather than shutting down the instance to perform this change.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When the cache is resized significantly (greater than 20%), the old cache advisory value is discarded and the cache advisory is set to the new size. Otherwise, the old cache advisory value is adjusted to the new size by the interpolation of existing values.</div>
<p>The <code>DB_CACHE_SIZE</code> parameter specifies the size of the default cache for the database's standard block size. To create and use tablespaces with block sizes different than the database's standard block sizes (such as to support transportable tablespaces), you must configure a separate cache for each block size used. <code><a id="sthref388"></a></code>You can use the <code>DB_</code><code><span class="codeinlineitalic">n</span></code><code>K_CACHE_SIZE</code> parameter to configure the nonstandard block size needed (where <code><span class="codeinlineitalic">n</span></code> is 2, 4, 8, 16 or 32 and <code><span class="codeinlineitalic">n</span></code> is not the standard block size).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The process of choosing a cache size is the same, regardless of whether the cache is the default standard block size cache, the <code>KEEP</code> or <code>RECYCLE</code> cache, or a nonstandard block size cache.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> and <a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on using the <code>DB_</code><code><span class="codeinlineitalic">n</span></code><code>K_CACHE_SIZE</code> parameters</div>
</div>
<!-- class="sect3" -->
<a id="i29076"></a>
<div id="PFGRF94275" class="sect3">
<h4 class="sect3"><span class="secnum">7.2.3.2</span> Reducing Memory Allocated to the Buffer Cache</h4>
<p><a id="sthref389"></a>If the cache hit ratio is high, then the cache is probably large enough to hold the most frequently accessed data. Check <code>V$DB_CACHE_AD<a id="sthref390"></a>VICE</code> data to see whether decreasing the cache size significantly causes the number of physical I/Os to increase. If not, and if you require memory for another memory structure, then you might be able to reduce the cache size and still maintain good performance. To make the buffer cache smaller, <a id="sthref391"></a>reduce the size of the cache by changing the value for the parameter <code>DB_CACHE_SIZE<a id="sthref392"></a></code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i30935"></a>
<div id="PFGRF94276" class="sect2">
<h3 class="sect2"><span class="secnum">7.2.4</span> Considering Multiple Buffer Pools</h3>
<p>A single default buffer pool is generally adequate for most systems. However, users with detailed knowledge of an application's buffer pool might benefit from configuring multiple buffer pools.</p>
<p>With segments that have atypical access patterns, store blocks from those segments in two different buffer pools: the <code>KEEP</code> pool and the <code>RECYCLE</code> pool. A segment's access pattern may be atypical if it is constantly accessed (that is, hot) or infrequently accessed (for example, a large segment accessed by a batch job only once a day).</p>
<p><a id="sthref393"></a>Multiple<a id="sthref394"></a> buffer pools let you address these differences. You can use a <code>KEEP</code> buffer pool to maintain frequently accessed segments in the buffer cache, and a <code>RECYCLE</code> buffer pool to prevent objects from consuming unnecessary space in the cache. When an object is associated with a cache, all blocks from that object are placed in that cache. Oracle Database maintains a <code>DEFAULT</code> buffer pool for objects that have not been assigned to a specific buffer pool. The default buffer pool is of size <code><a id="sthref395"></a>DB_CACHE_SIZE</code>. Each buffer pool uses the same Least Recently Used (LRU) replacement policy (for example, if the <code>KEEP</code> pool is not large enough to store all of the segments allocated to it, then the oldest blocks age out of the cache).<a id="sthref396"></a></p>
<p>By allocating objects to appropriate buffer pools, you can:</p>
<ul>
<li>
<p>Reduce or eliminate I/Os</p>
</li>
<li>
<p>Isolate or limit an object to a separate cache</p>
</li>
</ul>
<div id="PFGRF94277" class="sect3"><a id="sthref397"></a>
<h4 class="sect3"><span class="secnum">7.2.4.1</span> Random Access to Large Segments</h4>
<p>A problem can occur with an LRU aging method when a very large segment is accessed with a large or unbounded index range scan. Here, very large means large compared to the size of the cache. Any single segment that accounts for a substantial portion (more than 10%) of nonsequential physical reads can be considered very large. Random reads to a large segment can cause buffers that contain data for other segments to be aged out of the cache. The large segment ends up consuming a large percentage of the cache, but it does not benefit from the cache.</p>
<p>Very frequently accessed segments are not affected by large segment reads because their buffers are warmed frequently enough that they do not age out of the cache. However, the problem affects warm segments that are not accessed frequently enough to survive the buffer aging caused by the large segment reads. There are three options for solving this problem:</p>
<ol>
<li>
<p>If the object accessed is an index, find out whether the index is selective. If not, tune the SQL statement to use a more selective index.</p>
</li>
<li>
<p>If the SQL statement is tuned, you can move the large segment into a separate <code>RECYCLE</code> cache so that it does not affect the other segments. The <code><a id="sthref398"></a><a id="sthref399"></a>RECYCLE</code> cache should be smaller than the <code><a id="sthref400"></a><a id="sthref401"></a>DEFAULT</code> buffer pool, and it should reuse buffers more quickly than the <code>DEFAULT</code> buffer pool.</p>
</li>
<li>
<p>Alternatively, you can move the small warm segments into a separate <code>KEEP</code> cache that is not used at all for large segments. The <code><a id="sthref402"></a><a id="sthref403"></a>KEEP</code> cache can be sized to minimize misses in the cache. You can make the response times for specific queries more predictable by putting the segments accessed by the queries in the <code>KEEP</code> cache to ensure that they do not age out.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="PFGRF94278" class="sect3"><a id="sthref404"></a>
<h4 class="sect3"><span class="secnum">7.2.4.2</span> Oracle Real Application Clusters Instances</h4>
<p>You can create multiple buffer pools for each database instance. The same set of buffer pools need not be defined for each instance of the database. Among instances, the buffer pools can be different sizes or not defined at all. Tune each instance according to the application requirements for that instance.</p>
</div>
<!-- class="sect3" -->
<a id="i45250"></a>
<div id="PFGRF94279" class="sect3">
<h4 class="sect3"><span class="secnum">7.2.4.3</span> Using Multiple Buffer Pools</h4>
<p>To define a default buffer pool for an object, use the <code>BUFFER_POOL</code> keyword of the <code>STORAGE</code> clause. This clause is valid for <code>CREATE</code> and <code>ALTER</code> <code>TABLE</code>, <code>CLUSTER</code>, and <code>INDEX</code> SQL statements. After a buffer pool has been specified, all subsequent blocks read for the object are placed in that pool.</p>
<p>If a buffer pool is defined for a partitioned table or index, then each partition of the object inherits the buffer pool from the table or index definition, unless you override it with a specific buffer pool.</p>
<p>When the buffer pool of an object is changed using the <code>ALTER</code> statement, all buffers currently containing blocks of the altered segment remain in the buffer pool they were in before the <code>ALTER</code> statement. Newly loaded blocks and any blocks that have aged out and are reloaded go into the new buffer pool.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about specifying <code>BUFFER_POOL</code> in the <code>STORAGE</code> clause</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="PFGRF94280" class="sect2"><a id="sthref405"></a>
<h3 class="sect2"><span class="secnum">7.2.5</span> Buffer Pool Data in V$DB_CACHE_ADVICE</h3>
<p>You can use <code>V$DB_CACHE_A<a id="sthref406"></a>DVICE</code> to size all pools configured on a database instance. Make the initial cache size estimate, run the representative workload, then simply query the <code>V$DB_CACHE_ADVICE</code> view for the pool you want to use.</p>
<p>For example, to query data from the <code>KEEP</code> pool:</p>
<pre>
SELECT SIZE_FOR_ESTIMATE, BUFFERS_FOR_ESTIMATE, ESTD_PHYSICAL_READ_FACTOR, ESTD_PHYSICAL_READS
  FROM V$DB_CACHE_ADVICE
    WHERE NAME          = 'KEEP'
     AND BLOCK_SIZE    = (SELECT VALUE FROM V$PARAMETER WHERE NAME = 'db_block_size')
     AND ADVICE_STATUS = 'ON';
</pre></div>
<!-- class="sect2" -->
<div id="PFGRF94281" class="sect2"><a id="sthref407"></a>
<h3 class="sect2"><span class="secnum">7.2.6</span> Buffer Pool Hit Ratios</h3>
<p>The data in <code>V$SYSSTAT</code> reflects the logical and physical reads for all buffer pools within one set of statistics. To determine the hit ratio for the buffer pools individually, query the <a id="sthref408"></a><code>V$BUFFER_POOL_STATISTICS<a id="sthref409"></a></code> view. This view maintains statistics for each pool on the number of logical reads and writes.</p>
<p>The <a id="sthref410"></a>buffer pool hit ratio can be determined using the following formula:</p>
<pre>
1 - (physical_reads/(db_block_gets + consistent_gets))
</pre>
<p>The ratio can be calculated with the following query:</p>
<pre>
SELECT NAME, PHYSICAL_READS, DB_BLOCK_GETS, CONSISTENT_GETS,
      1 - (PHYSICAL_READS / (DB_BLOCK_GETS + CONSISTENT_GETS)) "Hit Ratio"
  FROM <a id="sthref411"></a>V$BUFFER_POOL_STATISTICS;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for information about the <code>V$BUFFER_POOL_STATISTICS</code> view</div>
</div>
<!-- class="sect2" -->
<a id="i44438"></a>
<div id="PFGRF94282" class="sect2">
<h3 class="sect2"><span class="secnum">7.2.7</span> Determining Which Segments Have Many Buffers in the Pool</h3>
<p>The <code><a id="sthref412"></a>V$BH</code> view shows the data object ID of all blocks that currently reside in the SGA. To determine which segments have many buffers in the pool, you can use one of the two methods described in this section. You can either look at the buffer cache usage pattern for all segments (<a href="#i40226">Method 1</a>) or examine the usage pattern of a specific segment, (<a href="#i40230">Method 2</a>).</p>
<p class="subhead2"><a id="i40226"></a><a id="PFGRF94283"></a>Method 1</p>
<p>The following query counts the number of blocks for all segments that reside in the buffer cache at that point in time. Depending on buffer cache size, this might require a lot of sort space.</p>
<pre>
COLUMN OBJECT_NAME FORMAT A40
COLUMN NUMBER_OF_BLOCKS FORMAT 999,999,999,999

SELECT o.OBJECT_NAME, COUNT(*) NUMBER_OF_BLOCKS
     FROM DBA_OBJECTS o, V$BH bh
    WHERE o.DATA_OBJECT_ID = bh.OBJD
      AND o.OWNER         != 'SYS'
    GROUP BY o.OBJECT_NAME
    ORDER BY COUNT(*);

OBJECT_NAME                              NUMBER_OF_BLOCKS
---------------------------------------- ----------------
OA_PREF_UNIQ_KEY                                        1
SYS_C002651                                             1
..
DS_PERSON                                              78
OM_EXT_HEADER                                         701
OM_SHELL                                            1,765
OM_HEADER                                           5,826
OM_INSTANCE                                        12,644
</pre>
<p class="subhead2"><a id="i40230"></a><a id="PFGRF94284"></a>Method 2</p>
<p>Use the following steps to determine the percentage of the cache used by an individual object at a given point in time:</p>
<a id="i33821"></a>
<ol>
<li>
<p>Find the Oracle Database internal object number of the segment by entering the following query:</p>
<pre>
SELECT DATA_OBJECT_ID, OBJECT_TYPE
  FROM DBA_OBJECTS 
 WHERE OBJECT_NAME = UPPER('<span class="italic">segment_name</span>'); 
</pre>
<p><a id="sthref413"></a>Because two objects can have the same name (if they are different types of objects), use the <code>OBJECT_TYPE</code> column to identify the object of interest.</p>
</li>
<li>
<p>Find the number of buffers in the buffer cache for <code>SEGMENT_NAME</code>:</p>
<pre>
SELECT COUNT(*) BUFFERS 
  FROM V$BH
 WHERE OBJD = <span class="italic">data_object_id_value</span>; 
</pre>
<p>where <code><span class="codeinlineitalic">data_object_id_value</span></code> is from step 1.</p>
</li>
<li>
<p>Find the number of buffers in the instance:</p>
<pre>
SELECT NAME, BLOCK_SIZE, SUM(BUFFERS)
  FROM V$BUFFER_POOL
 GROUP BY NAME, BLOCK_SIZE
 HAVING SUM(BUFFERS) 0;
</pre></li>
<li>
<p>Calculate the ratio of buffers to total buffers to obtain the percentage of the cache currently used by <code>SEGMENT_NAME</code>:</p>
<pre>
% cache used by segment_name = [buffers(Step2)/total buffers(Step3)] 
</pre>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
This technique works only for a single segment. You must run the query for each partition for a partitioned object.</div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<div id="PFGRF94285" class="sect2"><a id="sthref414"></a>
<h3 class="sect2"><span class="secnum">7.2.8</span> KEEP Pool</h3>
<p>If there are certain segments in your application that are referenced frequently, then store the blocks from those segments in a separate cache called the <code>KEEP</code> buffer pool. Memory is allocated to the <code>KEEP</code> buffer pool by setting the parameter <code><a id="sthref415"></a>DB_KEEP_CACHE_SIZE</code> to the required size. The memory for the <code>KEEP</code> pool is not a subset of the default pool. Typical segments that can be kept are small reference tables that are used frequently. Application developers and DBAs can determine which tables are candidates.</p>
<p>You can check the number of blocks from candidate tables by querying <code>V$BH</code>, as described in <a href="#i44438">"Determining Which Segments Have Many Buffers in the Pool"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>NOCACHE</code> clause has no effect on a table in the <code>KEEP</code> cache.</div>
<p>The goal of the <code><a id="sthref416"></a>KEEP<a id="sthref417"></a></code> buffer pool is to retain objects in memory, thus avoiding I/O operations. The size of the <code>KEEP</code> buffer pool, therefore, depends on the objects to be kept in the buffer cache. You can compute an approximate size for the <code>KEEP</code> buffer pool by adding the blocks used by all objects assigned to this pool. If you gather statistics on the segments, you can query <code>DBA_TABLES.BLOCKS</code> and <code>DBA_TABLES</code>.<code>EMPTY_BLOCKS</code> to determine the number of blocks used.</p>
<p>Calculate the hit ratio by taking two snapshots of system performance at different times, using the previous query. Subtract the more recent values for <code>physical</code> <code>reads</code>, <code>block</code> <code>gets</code>, and <code>consistent</code> <code>gets</code> from the older values, and use the results to compute the hit ratio.</p>
<p>A buffer pool hit ratio of 100% might not be optimal. Often, you can decrease the size of your <code>KEEP</code> buffer pool and still maintain a sufficiently high hit ratio. Allocate blocks removed from the <code>KEEP</code> buffer pool to other buffer pools.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
If an object grows in size, then it might no longer fit in the <code>KEEP</code> buffer pool. You will begin to lose blocks out of the cache.</div>
<p>Each object kept in memory results in a trade-off. It is beneficial to keep frequently-accessed blocks in the cache, but retaining infrequently-used blocks results in less space for other, more active blocks.</p>
</div>
<!-- class="sect2" -->
<div id="PFGRF94286" class="sect2"><a id="sthref418"></a>
<h3 class="sect2"><span class="secnum">7.2.9</span> RECYCLE Pool</h3>
<p>It is possible to configure a <code>RECYCLE</code> buffer pool for blocks belonging to those segments that you do not want to remain in memory. The <code>RECYCLE</code> pool is good for segments that are scanned rarely or are not referenced frequently. If an application accesses the blocks of a very large object in a random fashion, then there is little chance of reusing a block stored in the buffer pool before it is aged out. This is true regardless of the size of the buffer pool (given the constraint of the amount of available physical memory). Consequently, the object's blocks need not be cached; those cache buffers can be allocated to other objects.</p>
<p>Memory is allocated to the <code>RECYCLE</code> buffer pool by setting the parameter <code><a id="sthref419"></a>DB_RECYCLE_CACHE_SIZE</code> to the required size. This memory for the <code>RECYCLE</code> buffer pool is not a subset of the default pool.</p>
<p>Do not discard blocks from memory too quickly. If the buffer pool is too small, then blocks can age out of the cache before the transaction or SQL statement has completed execution. For example, an application might select a value from a table, use the value to process some data, and then update the record. If the block is removed from the cache after the <code>SELECT</code> statement, then it must be read from disk again to perform the update. The block should be retained for the duration of the user transaction.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i30970"></a>
<div id="PFGRF94287" class="sect1">
<h2 class="sect1"><span class="secnum">7.3</span> Configuring and Using the Shared Pool and Large Pool</h2>
<p>Oracle Database uses the shared pool to cache many different types of data. Cached data includes the textual and executable forms of PL/SQL blocks and SQL statements, dictionary cache data, result cache data, and other data.</p>
<p>Proper use and sizing of the shared pool can reduce resource consumption in at least four ways:</p>
<ul>
<li>
<p>Parse overhead is avoided if the SQL statement is in the shared pool. This saves CPU resources on the host and elapsed time for the end user.</p>
</li>
<li>
<p>Latching resource usage is significantly reduced, which results in greater scalability.</p>
</li>
<li>
<p>Shared pool memory requirements are reduced, because all applications use the same pool of SQL statements and dictionary resources.</p>
</li>
<li>
<p>I/O resources are saved, because dictionary elements that are in the shared pool do not require disk access.</p>
</li>
</ul>
<p>This section covers the following:</p>
<ul>
<li>
<p><a href="#i34548">Shared Pool Concepts</a></p>
</li>
<li>
<p><a href="#i34608">Using the Shared Pool Effectively</a></p>
</li>
<li>
<p><a href="#i52830">Sizing the Shared Pool</a></p>
</li>
<li>
<p><a href="#i36899">Interpreting Shared Pool Statistics</a></p>
</li>
<li>
<p><a href="#i52838">Using the Large Pool</a></p>
</li>
<li>
<p><a href="#i45310">Using CURSOR_SPACE_FOR_TIME</a></p>
</li>
<li>
<p><a href="#i38400">Caching Session Cursors</a></p>
</li>
<li>
<p><a href="#i39982">Configuring the Reserved Pool</a></p>
</li>
<li>
<p><a href="#i32625">Keeping Large Objects to Prevent Aging</a></p>
</li>
<li>
<p><a href="#i31512">Sharing Cursors for Existing Applications</a></p>
</li>
<li>
<p><a href="#i57480">Maintaining Connections</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <span class="bold">server result cache</span> is an optional cache of query and function results within the shared pool. Information related to result caching is consolidated in <a href="#BGBCABED">"Managing the Server and Client Result Caches"</a>.</div>
<a id="i34548"></a>
<div id="PFGRF94288" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.1</span> Shared Pool Concepts</h3>
<p>The main components of the shared pool are the library cache, the dictionary cache, and, depending on your configuration, the server result cache. The library cache stores the executable (parsed or compiled) form of recently referenced SQL and PL/SQL code. The dictionary cache stores data referenced from the data dictionary. The server result cache stores the results of queries and PL/SQL function results.</p>
<p>Many of the caches in the shared pool automatically increase or decrease in size, as needed, including the library cache and the dictionary cache. Old entries are aged out to accommodate new entries when the shared pool does not have free space.</p>
<p>A cache miss on the data dictionary cache or library cache is more expensive than a miss on the buffer cache. For this reason, the shared pool should be sized to ensure that frequently used data is cached.</p>
<p>Several features make large memory allocations in the shared pool: for example, the shared server, parallel query, or Recovery Manager. Oracle recommends segregating the SGA memory used by these features by configuring a distinct memory area, called the large pool.</p>
<p>Allocation of memory from the shared pool is performed in chunks. This chunking enables large objects (over 5 KB) to be loaded into the cache without requiring a single contiguous area. In this way, the database reduces the possibility of running out of enough contiguous memory due to fragmentation.</p>
<p>Infrequently, Java, PL/SQL, or SQL cursors may make allocations out of the shared pool that are larger than 5 KB. To allow these allocations to occur most efficiently, Oracle Database segregates a small amount of the shared pool. This memory is used if the shared pool does not have enough space. The segregated area of the shared pool is called the reserved pool<span class="bolditalic">.</span></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i39982">"Configuring the Reserved Pool"</a> for more information on the reserved area of the shared pool</p>
</li>
<li>
<p><a href="#i52838">"Using the Large Pool"</a> for more information on configuring the large pool</p>
</li>
</ul>
</div>
<div id="PFGRF94289" class="sect3"><a id="sthref420"></a>
<h4 class="sect3"><span class="secnum">7.3.1.1</span> Dictionary Cache Concepts</h4>
<p>Information stored in the data dictionary cache includes usernames, segment information, profile data, tablespace information, and sequence numbers. The dictionary cache also stores descriptive information, or metadata, about schema objects. Oracle Database uses this metadata when parsing SQL cursors or during the compilation of PL/SQL programs.</p>
</div>
<!-- class="sect3" -->
<a id="i36907"></a>
<div id="PFGRF94290" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.1.2</span> Library Cache Concepts</h4>
<p>The library cache holds executable forms of SQL cursors, PL/SQL programs, and Java classes. This section focuses on tuning as it relates to cursors, PL/SQL programs, and Java classes. These are collectively referred to as application code.</p>
<p>When application code is run, Oracle Database attempts to reuse existing code if it has been executed previously and can be shared. If the parsed representation of the statement does exist in the library cache and it can be shared, then the database reuses the existing code. This is known as a <span class="bold">soft parse</span>, or a <span class="bold">library cache hit</span>. If Oracle Database cannot use existing code, then the database must build a new executable version of the application code. This is known as a <span class="bold">hard parse</span>, or a <span class="bold">library cache miss</span>. See <a href="#i40017">"SQL Sharing Criteria"</a> for details on when a SQL and PL/SQL statements can be shared.</p>
<p>Library cache misses can occur on either the parse step or the execute step when processing a SQL statement. When an application makes a parse call for a SQL statement, if the parsed representation of the statement does not exist in the library cache, then Oracle Database parses the statement and stores the parsed form in the shared pool. This is a hard parse. You might be able to reduce library cache misses on parse calls by ensuring that all sharable SQL statements are in the shared pool whenever possible.</p>
<p>If an application makes an execute call for a SQL statement, and if the executable portion of the previously built SQL statement has been aged out (that is, deallocated) from the library cache to make room for another statement, then Oracle Database implicitly reparses the statement, creating a new shared SQL area for it, and executes it. This also results in a hard parse. Usually, you can reduce library cache misses on execution calls by allocating more memory to the library cache.</p>
<p>In order to perform a hard parse, Oracle Database uses more resources than during a soft parse. Resources used for a soft parse include CPU and library cache latch gets. Resources required for a hard parse include additional CPU, library cache latch gets, and shared pool latch gets. See <a href="design.htm#i29012">"SQL Execution Efficiency"</a> for a discussion of hard and soft parsing.</p>
</div>
<!-- class="sect3" -->
<a id="i40017"></a>
<div id="PFGRF94291" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.1.3</span> SQL Sharing Criteria</h4>
<p>Oracle Database automatically determines whether a SQL statement or PL/SQL block being issued is identical to another statement currently in the shared pool.</p>
<p>Oracle Database performs the following steps to compare the text of the SQL statement to existing SQL statements in the shared pool:</p>
<ol>
<li>
<p>The text of the statement is hashed. If there is no matching hash value, then the SQL statement does not currently exist in the shared pool, and a hard parse is performed.</p>
</li>
<li>
<p>If there is a matching hash value for an existing SQL statement in the shared pool, then Oracle Database compares the text of the matched statement to the text of the statement hashed to see if they are identical. The text of the SQL statements or PL/SQL blocks must be identical, character for character, including spaces, case, and comments. For example, the following statements cannot use the same shared SQL area:</p>
<pre>
SELECT * FROM employees;
SELECT * FROM Employees;
SELECT *  FROM employees;
</pre>
<p>Usually, SQL statements that differ only in literals cannot use the same shared SQL area. For example, the following statements do not resolve to the same SQL area:</p>
<pre>
SELECT count(1) FROM employees WHERE manager_id = 121;
SELECT count(1) FROM employees WHERE manager_id = 247;
</pre>
<p>The only exception to this rule is when the parameter <code>CURSOR_SHARING</code> has been set to <code>FORCE</code>. Similar statements can share SQL areas when the <code>CURSOR_SHARING</code> is set to <code>FORCE</code>. The costs and benefits involved in using <code>CURSOR_SHARING</code> are explained in <a href="#BABDCBFC">"When to Set CURSOR_SHARING to a Nondefault Value"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for more information on the <code>CURSOR_SHARING</code> initialization parameter</div>
</li>
<li>
<p>The objects referenced in the issued statement are compared to the referenced objects of all existing statements in the shared pool to ensure that they are identical.</p>
<p>References to schema objects in the SQL statements or PL/SQL blocks must resolve to the same object in the same schema. For example, if two users each issue the following SQL statement and they each have their own <code>employees</code> table, then this statement is not considered identical, because the statement references different tables for each user:</p>
<pre>
SELECT * FROM employees;
</pre></li>
<li>
<p>Bind variables <a id="sthref421"></a>in the SQL statements must match in name, data type, and length.</p>
<p>For example, the following statements cannot use the same shared SQL area, because the bind variable names differ:</p>
<pre>
SELECT * FROM employees WHERE department_id = :department_id;
SELECT * FROM employees WHERE department_id = :dept_id;
</pre>
<p>Many Oracle products, such as Oracle Forms and the precompilers, convert the SQL before passing statements to the database. Characters are uniformly changed to uppercase, white space is compressed, and bind variables are renamed so that a consistent set of SQL statements is produced.</p>
</li>
<li>
<p>The session's environment must be identical. For example, SQL statements must be optimized using the same optimization goal.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i34608"></a>
<div id="PFGRF94296" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.2</span> Using the Shared Pool Effectively</h3>
<p>An important purpose of the shared pool is to cache the executable versions of SQL and PL/SQL statements. This allows multiple executions of the same SQL or PL/SQL code to be performed without the resources required for a hard parse, which results in significant reductions in CPU, memory, and latch usage.</p>
<p>The shared pool is also able to support unshared SQL in data warehousing applications, which execute low-concurrency, high-resource SQL statements. In this situation, using unshared SQL with literal values is recommended. Using literal values rather than bind variables allows the optimizer to make good column selectivity estimates, thus providing an optimal data access plan.</p>
<p>In an OLTP system, there are several ways to ensure efficient use of the shared pool and related resources. Discuss the following items with application developers and agree on strategies to ensure that the shared pool is used effectively:</p>
<ul>
<li>
<p><a href="#i45402">Shared Cursors</a></p>
</li>
<li>
<p><a href="#i34854">Single-User Logon and Qualified Table Reference</a></p>
</li>
<li>
<p><a href="#i43711">Use of PL/SQL</a></p>
</li>
<li>
<p><a href="#i45439">Avoid Performing DDL</a></p>
</li>
<li>
<p><a href="#i37543">Cache Sequence Numbers</a></p>
</li>
<li>
<p><a href="#i34864">Cursor Access and Management</a></p>
</li>
</ul>
<p>Efficient use of the shared pool in high-concurrency OLTP systems significantly reduces the probability of parse-related application scalability issues.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a></div>
<a id="i45402"></a>
<div id="PFGRF94297" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.2.1</span> Shared Cursors</h4>
<p>Reuse of shared SQL for multiple users running the same application, avoids hard parsing. Soft parses provide a significant reduction in the use of resources such as the shared pool and library cache latches. To share cursors, do the following:</p>
<ul>
<li>
<p>Use bind variables rather than literals in SQL statements whenever possible. For example, the following two statements cannot use the same shared area because they do not match character for character:</p>
<pre>
SELECT employee_id FROM employees WHERE department_id = 10;
SELECT employee_id FROM employees WHERE department_id = 20;
</pre>
<p>By replacing the literals with a bind variable, only one SQL statement would result, which could be executed twice:</p>
<pre>
SELECT employee_id FROM employees WHERE department_id = :dept_id;
</pre>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
For existing applications where rewriting the code to use bind variables is impractical, you can use the <code>CU<a id="sthref422"></a>RSOR_SHARING</code> initialization parameter to avoid some of the hard parse overhead. See <a href="#i31512">"Sharing Cursors for Existing Applications"</a>.</div>
</li>
</ul>
<ul>
<li>
<p>Avoid application designs that result in large numbers of users issuing dynamic, unshared SQL statements. Typically, the majority of data required by most users can be satisfied using preset queries. Use dynamic SQL where such functionality is required.</p>
</li>
<li>
<p>Ensure that users of the application do not change the optimization approach and goal for their individual sessions.</p>
</li>
<li>
<p>Establish the following policies for application developers:</p>
<ul>
<li>
<p>Standardize naming conventions for bind variables and spacing conventions for SQL statements and PL/SQL blocks.</p>
</li>
<li>
<p>Consider using stored procedures whenever possible. Multiple users issuing the same stored procedure use the same shared PL/SQL area automatically. Because stored procedures are stored in a parsed form, their use reduces run-time parsing.</p>
</li>
</ul>
</li>
<li>
<p>For SQL statements which are identical but are not being shared, you can query <code>V$SQL_SHARED_CURSOR</code> to determine why the cursors are not shared. This would include optimizer settings and bind variable mismatches.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i34854"></a>
<div id="PFGRF94298" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.2.2</span> Single-User Logon and Qualified Table Reference</h4>
<p>Large OLTP systems where users log in to the database as their own user ID can benefit from explicitly qualifying the segment owner, rather than using public synonyms. This significantly reduces the number of entries in the dictionary cache. For example:</p>
<pre>
SELECT employee_id FROM hr.employees WHERE department_id = :dept_id;
</pre>
<p>An alternative to qualifying table names is to connect to the database through a single user ID, rather than individual user IDs. User-level validation can take place locally on the middle tier. Reducing the number of distinct userIDs also reduces the load on the dictionary cache.</p>
</div>
<!-- class="sect3" -->
<a id="i43711"></a>
<div id="PFGRF94299" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.2.3</span> Use of PL/SQL</h4>
<p>Using stored PL/SQL packages can overcome many of the scalability issues for systems with thousands of users, each with individual user sign-on and public synonyms. This is because a package is executed as the owner, rather than the caller, which reduces the dictionary cache load considerably.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle encourages the use of definer's rights packages to overcome scalability issues. The benefits of reduced dictionary cache load are not as obvious with invoker's rights packages.</div>
</div>
<!-- class="sect3" -->
<a id="i45439"></a>
<div id="PFGRF94300" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.2.4</span> Avoid Performing DDL</h4>
<p>Avoid performing DDL operations on high-usage segments during peak hours. Performing DDL on such segments often results in the dependent SQL being invalidated and hence reparsed on a later execution.</p>
</div>
<!-- class="sect3" -->
<a id="i37543"></a>
<div id="PFGRF94301" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.2.5</span> Cache Sequence Numbers</h4>
<p>Allocating sufficient cache space for frequently updated sequence numbers significantly reduces the frequency of dictionary cache locks, which improves scalability. The <code>CACHE</code> keyword on the <code>CREATE</code> <code>SEQUENCE</code> or <code>ALTER</code> <code>SEQUENCE</code> statement lets you configure the number of cached entries for each sequence.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for details on the <code>CREATE SEQUENCE</code> and <code>ALTER</code> <code>SEQUENCE</code> statements</div>
</div>
<!-- class="sect3" -->
<a id="i34864"></a>
<div id="PFGRF94302" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.2.6</span> Cursor Access and Management</h4>
<p><a id="sthref423"></a><a id="sthref424"></a><a id="sthref425"></a><a id="sthref426"></a>Depending on the application tool that you are using, you can control how frequently your application performs parse calls.</p>
<p>The frequency with which your application either closes cursors or reuses existing cursors for new SQL statements affects the amount of memory used by a session and often the amount of parsing performed by that session.</p>
<p>An application that closes cursors or reuses cursors (for a different SQL statement), does not need as much session memory as an application that keeps cursors open. Conversely, that same application may need to perform more parse calls, using extra CPU and Oracle Database resources.</p>
<p>Cursors associated with SQL statements that are not executed frequently can be closed or reused for other statements, because the likelihood of reexecuting (and reparsing) that statement is low.</p>
<p>Extra parse calls are required when a cursor containing a SQL statement that will be reexecuted is closed or reused for another statement. Had the cursor remained open, it could have been reused without the overhead of issuing a parse call.</p>
<p>The ways in which you control cursor management depends on your application development tool. The following sections introduce the methods used for some Oracle Database t.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>The tool-specific documentation for more information about each tool</p>
</li>
<li>
<p><a class="olink CNCPT015" href="../../server.112/e40540/sqllangu.htm#CNCPT015"><span class="italic">Oracle Database Concepts</span></a> for more information on cursors shared SQL</p>
</li>
</ul>
</div>
<div id="PFGRF94303" class="sect4"><a id="sthref427"></a>
<h5 class="sect4"><span class="secnum">7.3.2.6.1</span> Reducing Parse Calls with OCI</h5>
<p>When using Oracle Call Interface (OCI), do not close and reopen cursors that you will be reexecuting. Instead, leave the cursors open, and change the literal values in the bind variables before execution.</p>
<p>Avoid reusing statement handles for new SQL statements when the existing SQL statement will be reexecuted in the future.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94304" class="sect4"><a id="sthref428"></a>
<h5 class="sect4"><span class="secnum">7.3.2.6.2</span> <a id="sthref429"></a>Reducing Parse Calls with the Oracle Precompilers</h5>
<p><a id="sthref430"></a>When using the Oracle precompilers, you can control when cursors are closed by setting precompiler clauses. In Oracle mode, the clauses are as follows:</p>
<ul>
<li>
<p><code>HOLD_CURSOR = YES</code> <a id="sthref431"></a></p>
</li>
<li>
<p><code>RELEASE_CURSOR = NO</code> <a id="sthref432"></a></p>
</li>
<li>
<p><code>MAXOPENCURSORS =</code> <code><span class="codeinlineitalic">desired_value</span></code> <a id="sthref433"></a></p>
</li>
</ul>
<p>Oracle Database recommends that you not use ANSI mode, in which the values of <code>HOLD_CURSOR</code> and <code>RELEASE_CURSOR</code> are switched.</p>
<p>The precompiler clauses can be specified on the precompiler command line or within the precompiler program. With these clauses, you can employ different strategies for managing cursors during execution of the program.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
Your language's precompiler manual for more information on these clauses</div>
</div>
<!-- class="sect4" -->
<div id="PFGRF94305" class="sect4"><a id="sthref434"></a>
<h5 class="sect4"><span class="secnum">7.3.2.6.3</span> Reducing Parse Calls with SQLJ</h5>
<p>Prepare the statement, then reexecute the statement with the new values for the bind variables. The cursor stays open for the duration of the session.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94306" class="sect4"><a id="sthref435"></a>
<h5 class="sect4"><span class="secnum">7.3.2.6.4</span> Reducing Parse Calls with JDBC</h5>
<p>Avoid closing cursors if they will be reexecuted, because the new literal values can be bound to the cursor for reexecution. Alternatively, JDBC provides a SQL statement cache within the JDBC client using the <code>setStmtCacheSize()</code> method. Using this method, JDBC creates a SQL statement cache that is local to the JDBC program.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink JJDBC" href="../../java.112/e16548/toc.htm"><span class="italic">Oracle Database JDBC Developer's Guide</span></a> for more information on using the JDBC SQL statement cache</div>
</div>
<!-- class="sect4" -->
<div id="PFGRF94307" class="sect4"><a id="sthref436"></a>
<h5 class="sect4"><span class="secnum">7.3.2.6.5</span> Reducing Parse Calls with Oracle Forms</h5>
<p><a id="sthref437"></a><a id="sthref438"></a>With Oracle Forms, it is possible to control some aspects of cursor management. You can exercise this control either at the trigger level, at the form level, or at run time.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i52830"></a>
<div id="PFGRF94309" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.3</span> Sizing the Shared Pool</h3>
<p>When configuring a brand new instance, it is impossible to know the correct size to make the shared pool cache. Typically, a DBA makes a first estimate for the cache size, then runs a representative workload on the instance, and examines the relevant statistics to see whether the cache is under-configured or over-configured.</p>
<p>For most OLTP applications, shared pool size is an important factor in application performance. Shared pool size is less important for applications that issue a very limited number of discrete SQL statements, such as decision support systems (DSS).</p>
<p>If the shared pool is too small, then extra resources are used to manage the limited amount of available space. This consumes CPU and latching resources, and causes contention. Optimally, the shared pool should be just large enough to cache frequently accessed objects. Having a significant amount of free memory in the shared pool is a waste of memory. When examining the statistics after the database has been running, a DBA should check that none of these mistakes are in the workload.</p>
<div id="PFGRF94310" class="sect3"><a id="sthref439"></a>
<h4 class="sect3"><span class="secnum">7.3.3.1</span> Shared Pool: Library Cache Statistics</h4>
<p>When sizing the shared pool, the goal is to ensure that SQL statements that will be executed multiple times are cached in the library cache, without allocating too much memory.</p>
<p>The statistic that shows the amount of reloading (that is, reparsing) of a previously cached SQL statement that was aged out of the cache is the <code>RELOADS</code> column in the <code>V$LIBRARYCACHE</code> view. In an application that reuses SQL effectively, on a system with an optimal shared pool size, the <code>RELOADS</code> statistic will have a value near zero.</p>
<p>The <code>INVALIDATIONS</code> column in <code>V$LIBRARYCACHE</code> view shows the number of times library cache data was invalidated and had to be reparsed. <code>INVALIDATIONS</code> should be near zero. This means SQL statements that could have been shared were invalidated by some operation (for example, a DDL). This statistic should be near zero on OLTP systems during peak loads.</p>
<p>Another key statistic is the amount of free memory in the shared pool at peak times. The amount of free memory can be queried from <code>V$SGASTAT</code>, looking at the free memory for the shared pool. Optimally, free memory should be as low as possible, without causing any reloads on the system.</p>
<p>Lastly, a broad indicator of library cache health is the library cache hit ratio. This value should be considered along with the other statistics discussed in this section and other data, such as the rate of hard parsing and whether there is any shared pool or library cache latch contention.</p>
<p>These statistics are discussed in more detail in the following section.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94311" class="sect3"><a id="sthref440"></a>
<h4 class="sect3"><span class="secnum">7.3.3.2</span> V$LIBRARYCACHE</h4>
<p>You can monitor statistics reflecting library cache activity by examining the dynamic performance view <code>V$LIBRARYCACHE</code>. These statistics reflect all library cache activity after the most recent instance startup.</p>
<p>Each row in this view contains statistics for one type of item kept in the library cache. The item described by each row is identified by the value of the <code>NAMESPACE<a id="sthref441"></a></code> column<a id="sthref442"></a>. Rows with the following <code>NAMESPACE</code> values reflect library cache activity for SQL statements and PL/SQL blocks:</p>
<ul>
<li>
<p><code>SQL</code> <code>AREA</code></p>
</li>
<li>
<p><code>TABLE/PROCEDURE</code></p>
</li>
<li>
<p><code>BODY</code></p>
</li>
<li>
<p><code>TRIGGER</code></p>
</li>
</ul>
<p>Rows with other <code>NAMESPACE</code> values reflect library cache activity for object definitions that Oracle Database uses for dependency maintenance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN003" href="../../server.112/e40402/dynviews_part.htm#REFRN003"><span class="italic">Oracle Database Reference</span></a> for information about the dynamic performance <code>V$LIBRARYCACHE</code> view</div>
<p>To examine each namespace individually, use the following query:</p>
<pre>
SELECT NAMESPACE, PINS, PINHITS, RELOADS, INVALIDATIONS
  FROM V$LIBRARYCACHE
 ORDER BY NAMESPACE;
</pre>
<p>The output of this query could look like the following:</p>
<pre>
NAMESPACE             PINS    PINHITS    RELOADS INVALIDATIONS
--------------- ---------- ---------- ---------- -------------
BODY                  8870       8819          0             0
CLUSTER                393        380          0             0
INDEX                   29          0          0             0
OBJECT                   0          0          0             0
PIPE                 55265      55263          0             0
SQL AREA          21536413   21520516      11204             2
TABLE/PROCEDURE   10775684   10774401          0             0
TRIGGER               1852       1844          0             0
</pre>
<p>To calculate the library cache hit ratio, use the following formula:</p>
<pre>
Library Cache Hit Ratio = sum(pinhits) / sum(pins)
</pre>
<p>Using the library cache hit ratio formula, the cache hit ratio is the following:</p>
<pre>
SUM(PINHITS)/SUM(PINS)
----------------------
            .999466248
</pre>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
These queries return data from instance startup, rather than statistics gathered during an interval; interval statistics can better identify the problem.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="diag.htm#g41683">Chapter 6, "Automatic Performance Diagnostics"</a> to learn how to gather information over an interval</div>
<p>Examining the returned data leads to the following observations:</p>
<ul>
<li>
<p>For the <code>SQL AREA</code> namespace, there were 21,536,413 executions.</p>
</li>
<li>
<p>11,204 of the executions resulted in a library cache miss, requiring Oracle Database t implicitly reparse a statement or block or reload an object definition because it aged out of the library cache (that is, a <code>RELOAD</code>).</p>
</li>
<li>
<p>SQL statements were invalidated two times, again causing library cache misses.</p>
</li>
<li>
<p>The hit percentage is about 99.94%. This means that only .06% of executions resulted in reparsing.</p>
</li>
</ul>
<p>The amount of free memory in the shared pool is reported in <code>V$SGASTAT</code>. Report the current value from this view using the following query:</p>
<pre>
SELECT * FROM V$SGASTAT 
 WHERE NAME = 'free memory'
   AND POOL = 'shared pool';
</pre>
<p>The output will be similar to the following:</p>
<pre>
POOL        NAME                            BYTES
----------- -------------------------- ----------
shared pool free memory                   4928280
</pre>
<p>If free memory is always available in the shared pool, then increasing the size of the pool offers little or no benefit. However, just because the shared pool is full does not necessarily mean there is a problem. It may be indicative of a well-configured system.</p>
</div>
<!-- class="sect3" -->
<a id="i50285"></a>
<div id="PFGRF94312" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.3.3</span> Shared Pool Advisory Statistics</h4>
<p>The amount of memory available for the library cache can drastically affect the parse rate of an Oracle database instance. The shared pool advisory statistics provide a database administrator with information about library cache memory, allowing a DBA to predict how changes in the size of the shared pool can affect aging out of objects in the shared pool.</p>
<p>The shared pool advisory statistics track the library cache's use of shared pool memory and predict how the library cache will behave in shared pools of different sizes. Two fixed views provide the information to determine how much memory the library cache is using, how much is currently pinned, how much is on the shared pool's LRU list, and how much time might be lost or gained by changing the size of the shared pool.</p>
<p>The following views of the shared pool advisory statistics are available. These views display any data when shared pool advisory is on. These statistics reset when the advisory is turned off.</p>
<a id="i55119"></a>
<div id="PFGRF94313" class="sect4">
<h5 class="sect4"><span class="secnum">7.3.3.3.1</span> <a id="sthref443"></a>V$SHARED_POOL_ADVICE</h5>
<p>This view displays information about estimated parse time in the shared pool for different pool sizes. The sizes range from 10% of the current shared pool size or the amount of pinned library cache memory, whichever is higher, to 200% of the current shared pool size, in equal intervals. The value of the interval depends on the current size of the shared pool.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94314" class="sect4"><a id="sthref444"></a>
<h5 class="sect4"><span class="secnum">7.3.3.3.2</span> <a id="sthref445"></a>V$LIBRARY_CACHE_MEMORY</h5>
<p>This view displays information about memory allocated to library cache memory objects in different namespaces. A memory object is an internal grouping of memory for efficient management. A library cache object may consist of one or more memory objects.</p>
</div>
<!-- class="sect4" -->
<a id="i55245"></a>
<div id="PFGRF94315" class="sect4">
<h5 class="sect4"><span class="secnum">7.3.3.3.3</span> <a id="sthref446"></a><a id="sthref447"></a>V$JAVA_POOL_ADVICE and V$JAVA_LIBRARY_CACHE_MEMORY</h5>
<p>These views contain Java pool advisory statistics that track information about library cache memory used for Java and predict how changes in the size of the Java pool can affect the parse rate.</p>
<p><code>V$JAVA_POOL_ADVICE</code> displays information about estimated parse time in the Java pool for different pool sizes. The sizes range from 10% of the current Java pool size or the amount of pinned Java library cache memory, whichever is higher, to 200% of the current Java pool size, in equal intervals. The value of the interval depends on the current size of the Java pool.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN003" href="../../server.112/e40402/dynviews_part.htm#REFRN003"><span class="italic">Oracle Database Reference</span></a> for information about the dynamic performance <code>V$SHARED_POOL_ADVICE</code>, <code>V$LIBRARY_CACHE_MEMORY</code>, <code>V$JAVA_POOL_ADVICE</code>, and <code>V$JAVA_LIBRARY_CACHE_MEMORY</code> view</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="PFGRF94316" class="sect3"><a id="sthref448"></a>
<h4 class="sect3"><span class="secnum">7.3.3.4</span> Shared Pool: Dictionary Cache Statistics</h4>
<p>Typically, if the shared pool is adequately sized for the library cache, it will also be adequate for the dictionary cache data.</p>
<p>Misses on the data dictionary cache are to be expected in some cases. On instance startup, the data dictionary cache contains no data. Therefore, any SQL statement issued is likely to result in cache misses. As more data is read into the cache, the likelihood of cache misses decreases. Eventually, the database reaches a steady state, in which the most frequently used dictionary data is in the cache. At this point, very few cache misses occur.</p>
<p>Each row in the <code>V$ROWCACHE</code> view contains statistics for a single type of data dictionary item. These statistics reflect all data dictionary activity since the most recent instance startup. The columns in the <code>V$ROWCACHE</code> view that reflect the use and effectiveness of the data dictionary cache are listed in <a href="#g61181">Table 7-2</a>.</p>
<div id="PFGRF94317" class="tblformal">
<p class="titleintable"><a id="sthref449"></a><a id="g61181"></a>Table 7-2 V$ROWCACHE Columns</p>
<table class="cellalignment1686" title="V$ROWCACHE Columns" summary="This table describes the columns in the V$ROWCACHE view that reflect the use and effectiveness of the data dictionary cache." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t39">Column</th>
<th class="cellalignment1687" id="r1c2-t39">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t39" headers="r1c1-t39">
<p><code>PARAMETER</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t39 r1c2-t39">
<p>Identifies a particular data dictionary item. For each row, the value in this column is the item prefixed by <code>dc_</code>. For example, in the row that contains statistics for file descriptions, this column has the value <code>dc_files</code>.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t39" headers="r1c1-t39">
<p><code>GETS</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t39 r1c2-t39">
<p>Shows the total number of requests for information about the corresponding item. For example, in the row that contains statistics for file descriptions, this column has the total number of requests for file description data.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t39" headers="r1c1-t39">
<p><code>GETMISSES</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t39 r1c2-t39">
<p>Shows the number of data requests which were not satisfied by the cache, requiring an I/O.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t39" headers="r1c1-t39">
<p><code>MODIFICATIONS</code></p>
</td>
<td class="cellalignment1688" headers="r5c1-t39 r1c2-t39">
<p>Shows the number of times data in the dictionary cache was updated.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Use the following query to monitor the statistics in the <code>V$ROWCACHE</code><a id="sthref450"></a> view over a period while your application is running. The derived column <code>PCT_SUCC_GETS</code> can be considered the item-specific hit ratio:</p>
<pre>
column parameter format a21
column pct_succ_gets format 999.9
column updates format 999,999,999

SELECT parameter
     , sum(gets)
     , sum(getmisses)
     , 100*sum(gets - getmisses) / sum(gets)  pct_succ_gets
     , sum(modifications)                     updates
  FROM V$ROWCACHE
 WHERE gets &gt; 0
 GROUP BY parameter;
</pre>
<p>The output of this query will be similar to the following:</p>
<pre>
PARAMETER              SUM(GETS) SUM(GETMISSES) PCT_SUCC_GETS      UPDATES
--------------------- ---------- -------------- ------------- ------------
dc_database_links             81              1          98.8            0
dc_free_extents            44876          20301          54.8       40,453
dc_global_oids                42              9          78.6            0
dc_histogram_defs           9419            651          93.1            0
dc_object_ids              29854            239          99.2           52
dc_objects                 33600            590          98.2           53
dc_profiles                19001              1         100.0            0
dc_rollback_segments       47244             16         100.0           19
dc_segments               100467          19042          81.0       40,272
dc_sequence_grants           119             16          86.6            0
dc_sequences               26973             16          99.9       26,811
dc_synonyms                 6617            168          97.5            0
dc_tablespace_quotas         120              7          94.2           51
dc_tablespaces            581248             10         100.0            0
dc_used_extents            51418          20249          60.6       42,811
dc_user_grants             76082             18         100.0            0
dc_usernames              216860             12         100.0            0
dc_users                  376895             22         100.0            0
</pre>
<p>Examining the data returned by the sample query leads to these observations:</p>
<ul>
<li>
<p>There are large numbers of misses and updates for used extents, free extents, and segments. This implies that the instance had a significant amount of dynamic space extension.</p>
</li>
<li>
<p>Based on the percentage of successful gets, and comparing that statistic with the actual number of gets, the shared pool is large enough to store dictionary cache data adequately.</p>
</li>
</ul>
<p>It is also possible to calculate an overall dictionary cache hit ratio using the following formula; however, summing up the data over all the caches will lose the finer granularity of data:</p>
<pre>
SELECT (SUM(GETS - GETMISSES - FIXED)) / SUM(GETS) "ROW CACHE" FROM V$ROWCACHE;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i36899"></a>
<div id="PFGRF94321" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.4</span> Interpreting Shared Pool Statistics</h3>
<p>Shared pool statistics indicate adjustments that can be made. The following sections describe some of your choices.</p>
<div id="PFGRF94322" class="sect3"><a id="sthref451"></a>
<h4 class="sect3"><span class="secnum">7.3.4.1</span> Increasing Memory Allocation</h4>
<p>Increasing the amount of memory for the shared pool increases the amount of memory available to the library cache, the dictionary cache, and the result cache (see <a href="#BGBEDJGF">"Managing Server Result Cache Memory with Initialization Parameters"</a>).</p>
<div id="PFGRF94323" class="sect4"><a id="sthref452"></a>
<h5 class="sect4"><span class="secnum">7.3.4.1.1</span> Allocating Additional Memory for the Library Cache</h5>
<p><span class="bold"><a id="sthref453"></a><a id="sthref454"></a><a id="sthref455"></a></span><a id="sthref456"></a>To ensure that shared SQL areas remain in the cache after their SQL statements are parsed, increase the amount of memory available to the library cache until the <code>V$LIBRARYCACHE</code>.<code>RELOADS</code> value is near zero. To increase the amount of memory available to the library cache, increase the value of the initialization parameter <code>SHARED_POOL_SIZE<a id="sthref457"></a></code>. The maximum value for this parameter depends on your operating system. This measure reduces implicit reparsing of SQL statements and PL/SQL blocks on execution.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94324" class="sect4"><a id="sthref458"></a>
<h5 class="sect4"><span class="secnum">7.3.4.1.2</span> Allocating Additional Memory to the Data Dictionary Cache</h5>
<p><a id="sthref459"></a><a id="sthref460"></a>Examine cache activity by monitoring the <code>GETS<a id="sthref461"></a><a id="sthref462"></a></code> and <code>GETMISSES<a id="sthref463"></a><a id="sthref464"></a></code> columns. For frequently accessed dictionary caches, the ratio of total <code>GETMISSES</code> to total <code>GETS</code> should be less than 10% or 15%, depending on the application.</p>
<p>Consider increasing the amount of memory available to the cache if all of the following are true:</p>
<ul>
<li>
<p>Your application is using the shared pool effectively. See <a href="#i34608">"Using the Shared Pool Effectively"</a> .</p>
</li>
<li>
<p>Your system has reached a steady state, any of the item-specific hit ratios are low, and there are a large numbers of gets for the caches with low hit ratios.</p>
</li>
</ul>
<p>Increase the amount of memory available to the data dictionary cache by increasing the value of the initialization parameter <code>SHARED_POOL_SIZE<a id="sthref465"></a></code>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="PFGRF94326" class="sect3"><a id="sthref466"></a>
<h4 class="sect3"><span class="secnum">7.3.4.2</span> Reducing Memory Allocation</h4>
<p><a id="sthref467"></a>If your <code>RELOADS</code> are near zero, and if you have a small amount of free memory in the shared pool, then the shared pool is probably large enough to hold the most frequently accessed data.</p>
<p>If you always have significant amounts of memory free in the shared pool, and if you would like to allocate this memory elsewhere, then you might be able to reduce the shared pool size and still maintain good performance.</p>
<p>To make the shared pool smaller, <a id="sthref468"></a>reduce the size of the cache by changing the value for the parameter <code>SHARED_POOL_SIZE<a id="sthref469"></a></code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i52838"></a>
<div id="PFGRF94327" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.5</span> Using the Large Pool</h3>
<p>Unlike the shared pool, the large pool does not have an LRU list. Oracle Database does not attempt to age objects out of the large pool.</p>
<p>You should consider configuring a large pool if your instance uses any of the following:</p>
<ul>
<li>
<p>Parallel query</p>
<p>Parallel query uses shared pool memory to cache parallel execution message buffers.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink VLDBG010" href="../../server.112/e25523/parallel.htm#VLDBG010"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> to learn how to perform parallel execution</p>
</li>
<li>
<p><a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on sizing the large pool with parallel query</p>
</li>
</ul>
</div>
</li>
</ul>
<ul>
<li>
<p>Recovery Manager</p>
<p>Recovery Manager uses the shared pool to cache I/O buffers during backup and restore operations. For I/O server processes and backup and restore operations, Oracle Database allocates buffers that are a few hundred kilobytes in size.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink BRADV89857" href="../../backup.112/e10642/rcmtunin.htm#BRADV89857"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information on sizing the large pool when using Recovery Manager</div>
</li>
</ul>
<ul>
<li>
<p>Shared server</p>
<p>In a shared server architecture, the session memory for each client process is included in the shared pool.</p>
</li>
</ul>
<a id="i33035"></a>
<div id="PFGRF94328" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.5.1</span> Tuning the Large Pool and Shared Pool for the Shared Server Architecture</h4>
<p>As Oracle Database allocates shared pool memory for shared server session memory, the amount of shared pool memory available for the library cache and dictionary cache decreases. If you allocate this session memory from a different pool, then Oracle Database can use the shared pool primarily for caching shared SQL and not incur the performance overhead from shrinking the shared SQL cache.</p>
<p>Oracle Database recommends using the large pool to allocate the shared server-related <a id="sthref470"></a><a id="sthref471"></a>User Global Area (UGA), rather that using the shared pool. This is because Oracle Database uses the shared pool to allocate System Global Area (SGA) memory for other purposes, such as shared SQL and PL/SQL procedures. Using the large pool instead of the shared pool decreases fragmentation of the shared pool.</p>
<p>To store shared server-related UGA in the large pool, specify a value for the initialization parameter <code>LA<a id="sthref472"></a>RGE_POOL_SIZE</code>. To see which pool (shared pool or large pool) the memory for an object resides in, check the column <code>POOL</code> in <code>V$SGASTAT</code>. The large pool is not configured by default; its minimum value is 300K. If you do not configure the large pool, then Oracle Database uses the shared pool for shared server user session memory.</p>
<p>Configure the size of the large pool based on the number of simultaneously active sessions. Each application requires a different amount of memory for session information, and your configuration of the large pool or SGA should reflect the memory requirement. For example, assuming that the shared server requires 200K to 300K to store session information for each active session. If you anticipate 100 active sessions simultaneously, then configure the large pool to be 30M, or increase the shared pool accordingly if the large pool is not configured.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
If a shared server architecture is used, then Oracle Database allocates some fixed amount of memory (about 10K) for each configured session from the shared pool, even if you have configured the large pool. The <code>CIRCUITS</code> initialization parameter specifies the maximum number of concurrent shared server connections that the database allows.</div>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink CNCPT" href="../e40540/toc.htm"><span class="italic">Oracle Database Concepts</span></a> for more information about the large pool</p>
</li>
<li>
<p><a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for complete information about initialization parameters</p>
</li>
</ul>
</div>
<div id="PFGRF94329" class="sect4"><a id="sthref473"></a>
<h5 class="sect4"><span class="secnum">7.3.5.1.1</span> Determining an Effective Setting for Shared Server UGA Storage</h5>
<p>The exact amount of UGA that Oracle Database uses depends on each application. To determine an effective setting for the large or shared pools, observe UGA use for a typical user and multiply this amount by the estimated number of user sessions.</p>
<p>Even though use of shared memory increases with shared servers, the total amount of memory use decreases. This is because there are fewer processes; therefore, Oracle Database uses less <a id="sthref474"></a>PGA memory with shared servers when compared to dedicated server environments.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For best performance with sorts using shared servers, set <code>SORT_AREA_SIZE</code> and <code>SORT_AREA_RETAINED_SIZE</code> to the same value. This keeps the sort result in the large pool instead of having it written to disk.</div>
</div>
<!-- class="sect4" -->
<div id="PFGRF94330" class="sect4"><a id="sthref475"></a>
<h5 class="sect4"><span class="secnum">7.3.5.1.2</span> Checking System Statistics in the V$SESSTAT View</h5>
<p><a id="sthref476"></a>Oracle Database collects statistics on total memory used by a session and stores them in the dynamic performance view <code>V$SESSTAT</code>. <a href="#g61160">Table 7-3</a> lists these statistics.</p>
<div id="PFGRF94331" class="tblformal">
<p class="titleintable"><a id="sthref477"></a><a id="g61160"></a>Table 7-3 V$SESSTAT Statistics Reflecting Memory</p>
<table class="cellalignment1686" title="V$SESSTAT Statistics Reflecting Memory" summary="This table describes the statistics collected in the V$SESSTAT view for total memory used." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t45">Statistic</th>
<th class="cellalignment1687" id="r1c2-t45">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t45" headers="r1c1-t45">
<p><code><a id="sthref478"></a>session UGA memory</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t45 r1c2-t45">
<p><a id="sthref479"></a><a id="sthref480"></a>The value of this statistic is the amount of memory in bytes allocated to the session.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t45" headers="r1c1-t45">
<p><code>Session UGA memory max</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t45 r1c2-t45">
<p><a id="sthref481"></a><a id="sthref482"></a>The value of this statistic is the maximum amount of memory in bytes ever allocated to the session.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>To find the value, query <code>V$STATNAME</code>. If you are using a shared server, you can use the following query to decide how much larger to make the shared pool. Issue the following queries while your application is running:</p>
<pre>
SELECT SUM(VALUE) || ' BYTES' "TOTAL MEMORY FOR ALL SESSIONS"
    FROM V$SESSTAT, V$STATNAME
    WHERE NAME = 'session uga memory'
    AND V$SESSTAT.STATISTIC# = V$STATNAME.STATISTIC#;

SELECT SUM(VALUE) || ' BYTES' "TOTAL MAX MEM FOR ALL SESSIONS"
    FROM V$SESSTAT, V$STATNAME
    WHERE NAME = 'session uga memory max'
    AND V$SESSTAT.STATISTIC# = V$STATNAME.STATISTIC#;
</pre>
<p>These queries also select from the dynamic performance view <code>V$STATNAME</code> to obtain internal identifiers for <code>session memory</code> and <code>max session memory.</code> The results of these queries could look like the following:</p>
<pre>
TOTAL MEMORY FOR ALL SESSIONS
-----------------------------
157125 BYTES

TOTAL MAX MEM FOR ALL SESSIONS
------------------------------
417381 BYTES
</pre>
<p>The result of the first query indicates that the memory currently allocated to all sessions is 157,125 bytes. This value is the total memory with a location that depends on how the sessions are connected to Oracle. If the sessions are connected to dedicated server processes, then this memory is part of the memories of the user processes. If the sessions are connected to shared server processes, then this memory is part of the shared pool.</p>
<p>The result of the second query indicates that the sum of the maximum size of the memory for all sessions is 417,381 bytes. The second result is greater than the first because some sessions have deallocated memory since allocating their maximum amounts.</p>
<p>If you use a shared server architecture, you can use the result of either of these queries to determine how much larger to make the shared pool. The first value is likely to be a better estimate than the second unless nearly all sessions are likely to reach their maximum allocations at the same time.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94332" class="sect4"><a id="sthref483"></a>
<h5 class="sect4"><span class="secnum">7.3.5.1.3</span> Limiting Memory Use for Each User Session by Setting PRIVATE_SGA</h5>
<p>You can set the <code><a id="sthref484"></a>PRIVATE_SGA</code> resource limit to restrict the memory used by each client session from the SGA. <code>PRIVATE_SGA</code> defines the number of bytes of memory used from the SGA by a session. However, this parameter is used rarely, because most DBAs do not limit SGA consumption on a user-by-user basis.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a><span class="italic">,</span> <code>ALTER</code> <code>RESOURCE</code> <code>COST</code> statement, for more information about setting the <code>PRIVATE_SGA</code> resource limit</div>
</div>
<!-- class="sect4" -->
<div id="PFGRF94333" class="sect4"><a id="sthref485"></a>
<h5 class="sect4"><span class="secnum">7.3.5.1.4</span> <a id="sthref486"></a>Reducing Memory Use with Three-Tier Connections</h5>
<p>If you have a high number of connected users, then you can reduce memory usage by implementing three-tier connections. This by-product of using a transaction process (TP) monitor is feasible only with pure transactional models because locks and uncommitted DMLs cannot be held between calls. A shared server environment offers the following advantages:</p>
<ul>
<li>
<p>It is much less restrictive of the application design than a TP monitor.</p>
</li>
<li>
<p>It dramatically reduces operating system process count and context switches by enabling users to share a pool of servers.</p>
</li>
<li>
<p>It substantially reduces overall memory usage, even though more SGA is used in shared server mode.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i45310"></a>
<div id="PFGRF94334" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.6</span> Using CURSOR_SPACE_FOR_TIME</h3>
<p>If you have no library cache misses, then you might be able to accelerate execution calls by setting the value of the initialization parameter <code>CURSOR_SPACE_FOR_TIME<a id="sthref487"></a></code> to <code>true</code>. This parameter specifies whether a cursor can be deallocated from the library cache to make room for a new SQL statement. <code>CURSOR_SPACE_FOR_TIME</code> has the following values meanings:</p>
<ul>
<li>
<p>If <code>CURSOR_SPACE_FOR_TIME</code> is set to <code>false</code> (the default), then a cursor can be deallocated from the library cache regardless of whether application cursors associated with its SQL statement are open. In this case, Oracle Database must verify that the cursor containing the SQL statement is in the library cache.</p>
</li>
<li>
<p>If <code>CURSOR_SPACE_FOR_TIME</code> is set to <code>true</code>, then a cursor can be deallocated only when all application cursors associated with its statement are closed. In this case, Oracle Database need not verify that a cursor is in the cache because it cannot be deallocated while an application cursor associated with it is open.</p>
</li>
</ul>
<p>Setting the value of the parameter to <code>true</code> saves Oracle Database a small amount of time and can slightly improve the performance of execution calls. This value also prevents the deallocation of cursors until associated application cursors are closed.</p>
<p>Do not set the value of <code>CURSOR_SPACE_FOR_TIME</code> to <code>true</code> if you have found library cache misses on execution calls. Such library cache misses indicate that the shared pool is not large enough to hold the shared SQL areas of all concurrently open cursors. If the value is <code>true</code>, and if the shared pool has no space for a new SQL statement, then the statement cannot be parsed, and Oracle Database returns an error saying that there is no more shared memory. If the value is <code>false</code>, and if there is no space for a new statement, then Oracle Database deallocates an existing cursor. Although deallocating a cursor could result in a library cache miss later (only if the cursor is reexecuted), it is preferable to an error halting your application because a SQL statement cannot be parsed.</p>
<p>Do not set the value of <code>CURSOR_SPACE_FOR_TIME</code> to <code>true</code> if the amount of memory available to each user for private SQL areas is scarce. This value also prevents the deallocation of private SQL areas associated with open cursors. If the private SQL areas for all concurrently open cursors fills your available memory so that there is no space for a new SQL statement, then the statement cannot be parsed. Oracle Database returns an error indicating that there is not enough memory.</p>
</div>
<!-- class="sect2" -->
<a id="i38400"></a>
<div id="PFGRF94335" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.7</span> Caching Session Cursors</h3>
<p>The <span class="bold">session cursor cache</span> contains closed session cursors for SQL and PL/SQL, including recursive SQL.</p>
<p>This cache can be useful for applications that use Oracle Forms because switching from one form to another closes all session cursors associated with the first form. If an application repeatedly issues parse calls on the same set of SQL statements, then reopening session cursors can degrade performance. By reusing cursors, the database can reduce parse times, leading to faster overall execution times.</p>
<div id="PFGRF95171" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref488"></a>
<h4 class="sect3"><span class="secnum">7.3.7.1</span> How the Session Cursor Cache Works</h4>
<p>A <span class="bold">session cursor</span> represents an instantiation of a <span class="bold">shared child cursor</span>, which is stored in the shared pool, for a specific session. Each session cursor stores a reference to a child cursor that it has instantiated.</p>
<p>Oracle Database checks the library cache to determine whether more than three parse requests have been issued on a given statement. If a cursor has been closed three times, then Oracle Database assumes that the session cursor associated with the statement should be cached and moves the cursor into the session cursor cache.</p>
<p>Subsequent requests to parse a SQL statement by the same session search an array for pointers to the shared cursor. If the pointer is found, then the database dereferences the pointer to determine whether the shared cursor exists. To reuse a cursor from the cache, the cache manager checks whether the cached states of the cursor match the current session and system environment.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Reuse of a cached cursor still registers as a parse, even though it is not a hard parse.</div>
<p>An LRU algorithm removes entries in the session cursor cache to make room for new entries when needed. The cache also uses an internal time-based algorithm to evict cursors that have been idle for an certain amount of time.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF95172" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref489"></a>
<h4 class="sect3"><span class="secnum">7.3.7.2</span> Enabling the Session Cursor Cache</h4>
<p>The following initialization parameters are relevant to the cursor cache:</p>
<ul>
<li>
<p><code>SESSION_CACHED_CURSORS</code></p>
<p>This parameter sets the maximum number of cached closed cursors for each session. The default setting is 50. You can use this parameter to prevent a session from opening an excessive number of cursors, thereby filling the library cache or forcing excessive hard parses.</p>
</li>
<li>
<p><code>OPEN_CURSORS</code></p>
<p>This parameter specifies the maximum number of cursors a session can have open simultaneously. For example, if <code>OPEN_CURSORS</code> is set to 1000, then each session can have up to 1000 cursors open at one time.</p>
</li>
</ul>
<p><code>SESSION_CACHED_CURSORS</code> and <code>OPEN_CURSORS</code> parameters are independent. For example, you can set <code>SESSION_CACHED_CURSORS</code> higher than <code>OPEN_CURSORS</code> because session cursors are not cached in an open state.</p>
<p class="orderedlisttitle">To enable caching of session cursors:&nbsp;</p>
<ol>
<li>
<p>Determine the maximum number of session cursors to keep in the cache.</p>
</li>
<li>
<p>Do one of the following:</p>
<ul>
<li>
<p>To enable caching statically, set the initialization parameter <code>SESSION_CACHED_CURSORS</code> to the number determined in the previous step.</p>
</li>
<li>
<p>To enable caching dynamically, <a id="sthref491"></a>execute the following statement:</p>
<pre>
ALTER SESSION SET SESSION_CACHED_CURSORS = <span class="italic">value</span>;
</pre></li>
</ul>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="PFGRF95173" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref492"></a>
<h4 class="sect3"><span class="secnum">7.3.7.3</span> Tuning the Session Cursor Cache</h4>
<p>You can query <code>V$SYSSTAT</code> to determine whether the session cursor cache is sufficiently large for the database instance.</p>
<p class="orderedlisttitle">To tune the session cursor cache:&nbsp;</p>
<ol>
<li>
<p>Determine how many cursors are currently cached in a particular session.</p>
<p>For example, enter the following query for session 35:</p>
<pre>
sys@DBS1&gt; SELECT a.value curr_cached, p.value max_cached,
  2         s.username, s.sid, s.serial#
  3  FROM   v$sesstat a, v$statname b, v$session s, v$parameter2 p
  4  WHERE  a.statistic# = b.statistic#  and s.sid=a.sid and a.sid=&amp;sid
  5  AND    p.name='session_cached_cursors'
  6  AND    b.name = 'session cursor cache count';
Enter value for sid: <span class="bold">35</span>
old   4: WHERE  a.statistic# = b.statistic#  and s.sid=a.sid and a.sid=&amp;sid
new   4: WHERE  a.statistic# = b.statistic#  and s.sid=a.sid and a.sid=35
 
CURR_CACHED MAX_CACHED USERNAME   SID    SERIAL#
----------- ---------- -------- ----- ----------
         49 50         APP         35        263
</pre>
<p>The preceding result shows that the number of cursors currently cached for session 35 is close to the maximum.</p>
</li>
<li>
<p>Find the percentage of parse calls that found a cursor in the session cursor cache.</p>
<p>For example, enter the following query for session 35:</p>
<pre>
SQL&gt; SELECT cach.value cache_hits, prs.value all_parses,
  2         round((cach.value/prs.value)*100,2) as "% found in cache"
  3  FROM   v$sesstat cach, v$sesstat prs, v$statname nm1, v$statname nm2
  4  WHERE  cach.statistic# = nm1.statistic#
  5  AND    nm1.name = 'session cursor cache hits'
  6  AND    prs.statistic#=nm2.statistic#
  7  AND    nm2.name= 'parse count (total)'
  8  AND    cach.sid= &amp;sid and prs.sid= cach.sid;
Enter value for sid: <span class="bold">35</span>
old   8: AND    cach.sid= &amp;sid and prs.sid= cach.sid
new   8: AND    cach.sid= 35 and prs.sid= cach.sid
 
CACHE_HITS ALL_PARSES % found in cache
---------- ---------- ----------------
        34        700             4.57
</pre>
<p>The preceding result shows that the number of hits in the session cursor cache for session 35 is low compared to the total number of parses.</p>
</li>
<li>
<p>Consider increasing <code>SESSION_CACHED_CURSORS</code> when the following statements are true:</p>
<ul>
<li>
<p>The session cursor cache count is close to the maximum.</p>
</li>
<li>
<p>The percentage of session cursor cache hits is low relative to the total parses.</p>
</li>
<li>
<p>The application repeatedly makes parse calls for the same queries.</p>
</li>
</ul>
<p>In this example, setting <code>SESSION_CACHED_CURSORS</code> to 100 may help boost performance.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i39982"></a>
<div id="PFGRF94336" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.8</span> Configuring the Reserved Pool</h3>
<p>Although Oracle Database breaks down very large requests for memory into smaller chunks, on some systems there might still be a requirement to find a contiguous chunk (for example, over 5 KB) of memory. (The default minimum reserved pool allocation is 4,400 bytes.)</p>
<p>If there is not enough free space in the shared pool, then Oracle Database must search for and free enough memory to satisfy this request. This operation could conceivably hold the latch resource for detectable periods of time, causing minor disruption to other concurrent attempts at memory allocation.</p>
<p>Thus, Oracle Database internally reserves a small memory area in the shared pool that the database can use if the shared pool does not have enough space. This reserved pool makes allocation of large chunks more efficient.</p>
<p>By default, Oracle Database configures a small reserved pool. The database can use this memory for operations such as PL/SQL and trigger compilation or for temporary space while loading Java objects. After the memory allocated from the reserved pool is freed, it returns to the reserved pool.</p>
<p>You probably will not need to change the default amount of space Oracle Database reserves. However, if necessary, the reserved pool size can be changed by setting the <code>SHARED_POOL_RESERVED_SIZE</code> initialization parameter. This parameter sets aside space in the shared pool for unusually large allocations.</p>
<p>For large allocations, Oracle Database attempts to allocate space in the shared pool in the following order:</p>
<ol>
<li>
<p>From the unreserved part of the shared pool.</p>
</li>
<li>
<p>From the reserved pool. If there is not enough space in the unreserved part of the shared pool, then Oracle Database checks whether the reserved pool has enough space.</p>
</li>
<li>
<p>From memory. If there is not enough space in the unreserved and reserved parts of the shared pool, then Oracle Database attempts to free enough memory for the allocation. It then retries the unreserved and reserved parts of the shared pool.</p>
</li>
</ol>
<div id="PFGRF94337" class="sect3"><a id="sthref494"></a>
<h4 class="sect3"><span class="secnum">7.3.8.1</span> Using SHARED_POOL_RESERVED_SIZE</h4>
<p>The default value for <code>SHARED_POOL_RESERVED_SIZE</code> is 5% of the <code>SHARED_POOL_SIZE</code>. This means that, by default, the reserved list is configured.</p>
<p>If you set <code>SHARED_POOL_RESERVED_SIZE</code> to more than half of <code>SHARED_POOL_SIZE</code>, then Oracle Database signals an error. Oracle Database does not let you reserve too much memory for the reserved pool. The amount of operating system memory, however, might constrain the size of the shared pool. In general, set <code>SHARED_POOL_RESERVED_SIZE</code> to 10% of <code>SHARED_POOL_SIZE</code>. For most systems, this value is sufficient if you have tuned the shared pool. If you increase this value, then the database takes memory from the shared pool. (This reduces the amount of unreserved shared pool memory available for smaller allocations.)</p>
<p>Statistics from the <code>V$SHARED_POOL_RESERVED</code> view help you tune these parameters. On a system with ample free memory to increase the size of the SGA, the goal is to have the value of <code>REQUEST_MISSES</code> equal zero. If the system is constrained for operating system memory, then the goal is to not have <code>REQUEST_FAILURES</code> or at least prevent this value from increasing.</p>
<p>If you cannot achieve these target values, then increase the value for <code>SHARED_POOL_RESERVED_SIZE</code>. Also, increase the value for <code>SHARED_POOL_SIZE</code> by the same amount, because the reserved list is taken from the shared pool.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for details on setting the <code>LARGE_POOL_SIZE</code> parameter</div>
</div>
<!-- class="sect3" -->
<div id="PFGRF94338" class="sect3"><a id="sthref495"></a>
<h4 class="sect3"><span class="secnum">7.3.8.2</span> <a id="sthref496"></a>When SHARED_POOL_RESERVED_SIZE Is Too Small</h4>
<p>The reserved pool is too small when the value for <code>REQUEST_FAILURES</code> is more than zero and increasing. To resolve this, increase the value for the <code>SHARED_POOL_RESERVED_SIZE</code> and <code>SHARED_POOL_SIZE</code> accordingly. The settings you select for these parameters depend on your system's SGA size constraints.</p>
<p>Increasing the value of <code>SHARED_POOL_RESERVED_SIZE</code> increases the amount of memory available on the reserved list without having an effect on users who do not allocate memory from the reserved list.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94339" class="sect3"><a id="sthref497"></a>
<h4 class="sect3"><span class="secnum">7.3.8.3</span> When SHARED_POOL_RESERVED_SIZE Is Too Large</h4>
<p>Too much memory might have been allocated to the reserved list if:</p>
<ul>
<li>
<p><code>REQUEST_MISSES</code> is zero or not increasing</p>
</li>
<li>
<p><code>FREE_SPACE</code> is greater than or equal to 50% of <code>SHARED_POOL_RESERVED_SIZE</code> minimum</p>
</li>
</ul>
<p>If either of these conditions is true, then decrease the value for <code>SHARED_POOL_RESERVED_SIZE</code>.</p>
</div>
<!-- class="sect3" -->
<a id="i33208"></a>
<div id="PFGRF94340" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.8.4</span> When <a id="sthref498"></a>SHARED_POOL_SIZE is Too Small</h4>
<p>The <a id="sthref499"></a><code>V$SHARED_POOL_RESERVED</code> fixed view can also indicate when the value for <code>SHARED_POOL_SIZE</code> is too small. This can be the case if <code>REQUEST_FAILURES</code> is greater than zero and increasing.</p>
<p>If you have enabled the reserved list, then decrease the value for <code>SHARED_POOL_RESERVED_SIZE</code>. If you have not enabled the reserved list, then you could increase <code>SHARED_POOL_SIZE</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i32625"></a>
<div id="PFGRF94341" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.9</span> Keeping Large Objects to Prevent Aging</h3>
<p>After an entry has been loaded into the shared pool, it cannot be moved. Sometimes, as entries are loaded and aged, the free memory can become fragmented.</p>
<p>Use the<a id="sthref500"></a> PL/SQL package <code>DBMS_SHARED_POOL</code> to manage the shared pool. Shared SQL and PL/SQL areas age out of the shared pool according to a least recently used LRU algorithm, similar to database buffers. To improve performance and prevent reparsing, you might want to prevent large SQL or PL/SQL areas from aging out of the shared pool.</p>
<p>The <code>DBMS_SHARED_POOL</code> package enables you to keep objects in shared memory, so that they do not age out with the normal LRU mechanism. By using the <code>DBMS_SHARED_POOL</code> package and by loading the SQL and PL/SQL areas before memory fragmentation occurs, the database can keep objects in memory. This technique ensures that memory is available, and it prevents the sudden, inexplicable slowdowns in user response time that occur when SQL and PL/SQL areas are accessed after aging out.</p>
<p>The <code>DBMS_SHARED_POOL</code> package is useful for the following:</p>
<ul>
<li>
<p>When loading large PL/SQL objects, such as the <code>STANDARD</code> and <code>DIUTIL</code> packages</p>
<p>When large PL/SQL objects are loaded, user response time may be affected if smaller objects that must age out of the shared pool to make room. In some cases, there might be insufficient memory to load the large objects.</p>
</li>
<li>
<p>Frequently executed triggers</p>
<p>You might want to keep compiled triggers on frequently used tables in the shared pool.</p>
</li>
<li>
<p>Sequences</p>
<p>Sequence numbers are lost when a sequence ages out of the shared pool. <code>DBMS_SHARED_POOL</code> keeps sequences in the shared pool, thus preventing the loss of sequence numbers.</p>
</li>
</ul>
<p>To use the <code>DBMS_SHARED_POOL</code> package to pin a SQL or PL/SQL area, complete the following steps:</p>
<ol>
<li>
<p>Decide which packages or cursors to pin in memory.</p>
</li>
<li>
<p>Start up the database.</p>
</li>
<li>
<p>Make the call to <code>DBMS_SHARED_POOL</code>.<code>KEEP</code> to pin your objects.</p>
<p>This procedure ensures that your system does not run out of shared memory before the kept objects are loaded. By pinning the objects early in the life of the instance, you prevent memory fragmentation that could result from pinning a large portion of memory in the middle of the shared pool.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for specific information on using <code>DBMS_SHARED_POOL</code> procedures</div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i31512"></a>
<div id="PFGRF94342" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.10</span> Sharing Cursors for Existing Applications</h3>
<p>In the context of SQL parsing, an identical statement is a statement whose text is identical to another, character for character, including spaces, case, and comments. A similar statement is identical except for the values of some literals.</p>
<p>The parse phase compares the statement text with statements in the shared pool to determine whether the statement can be shared. If the initialization parameter <code>CURSOR_SHARING=EXACT</code> (default), and if a statement in the pool is not identical, then the database does not share the SQL area. Each statement has its own parent cursor and its own execution plan based on the literal in the statement.</p>
<div id="PFGRF94343" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref501"></a>
<h4 class="sect3"><span class="secnum">7.3.10.1</span> How Similar Statements Can Share SQL Areas</h4>
<p>When SQL statements use literals rather than bind variables, a nondefault setting for <code>CURSOR_SHARING</code> enables the database to replace literals with system-generated bind variables. Using this technique, the database can sometimes reduce the number of parent cursors in the shared SQL area.</p>
<p>When <code>CURSOR_SHARING</code> is set to a nondefault value, the database performs the following steps during the parse:</p>
<ol>
<li>
<p>Searches for an identical statement in the shared pool</p>
<p>If an identical statement is found, then the database skips to Step <a href="#BABEBAEI">3</a>. Otherwise, the database proceeds to the next step.</p>
</li>
<li>
<p>Searches for a similar statement in the shared pool</p>
<p>If a similar statement is <span class="italic">not</span> found, then the database performs a hard parse. If a similar statement <span class="italic">is</span> found, then the database proceeds to the next step.</p>
</li>
<li id="BABEBAEI">
<p>Proceeds through the remaining steps of the parse phase to ensure that the execution plan of the existing statement is applicable to the new statement</p>
<p>If the plan is not applicable, then the database performs a hard parse. If the plan is applicable, then the database proceeds to the next step.</p>
</li>
<li>
<p>Shares the SQL area of the statement</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
The database does not perform literal replacement on the <code>ORDER BY</code> clause because it is not semantically correct to consider the constant column number as a literal. The column number in the <code>ORDER BY</code> clause affects the query plan and execution, so the database cannot share two cursors having different column numbers.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i40017">"SQL Sharing Criteria"</a> for more details on the various checks performed</div>
</div>
<!-- class="sect3" -->
<a id="BABDCBFC"></a>
<div id="PFGRF94345" class="sect3">
<h4 class="sect3"><span class="secnum">7.3.10.2</span> When to Set CURSOR_SHARING to a Nondefault Value</h4>
<p>The best practice is to write sharable SQL and use the default of <code>EXACT</code> for <code>CURSOR_SHARING</code>. However, for applications with many similar statements, setting <code>CURSOR_SHARING</code> can significantly improve cursor sharing, resulting in reduced memory usage, faster parses, and reduced latch contention. Consider this approach when statements in the shared pool differ only in the values of literals, and when response time is poor because of a very high number of library cache misses.</p>
<p>If stored outlines were generated with <code>CURSOR_SHARING</code> set to <code>EXACT</code>, then the database does not use stored outlines generated with literals. To avoid this problem, generate outlines with <code>CURSOR_SHARING</code> set to <code>FORCE</code> and use the <code>CREATE_STORED_OUTLINES</code> parameter.</p>
<p>Setting <code>CURSOR_SHARING</code> to <code>FORCE</code> has the following drawbacks:</p>
<ul>
<li>
<p>The database must perform extra work during the soft parse to find a similar statement in the shared pool.</p>
</li>
<li>
<p>There is an increase in the maximum lengths (as returned by <code>DESCRIBE</code>) of any selected expressions that contain literals in a <code>SELECT</code> statement. However, the actual length of the data returned does not change.</p>
</li>
<li>
<p>Star transformation is not supported.</p>
</li>
</ul>
<p>When deciding whether to set <code>CURSOR_SHARING</code> to <code>FORCE</code>, consider the performance implications of each setting. When <code>CURSOR_SHARING</code> is set to <code>FORCE</code>, the database uses one parent cursor and one child cursor for each distinct SQL statement. The database uses the same plan for each execution of the same statement. For example, consider the following statement:</p>
<pre>
SELECT * FROM hr.employees WHERE employee_id = 101
</pre>
<p>If <code>FORCE</code> is used, then the database optimizes this statement as if it contained a bind variable and uses bind peeking to estimate cardinality. Statements that differ only in the bind variable share the same execution plan.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting with Oracle Database 11<span class="italic">g</span> Release 2, setting the value of the <code>CURSOR_SHARING</code> to <code>SIMILAR</code> is obsolete. Consider adaptive cursor sharing instead.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="optimops.htm#CIHIGAHB">"Adaptive Cursor Sharing"</a></p>
</li>
<li>
<p><a href="optimops.htm#g91086">"Enabling Query Optimizer Features"</a></p>
</li>
<li>
<p><a class="olink REFRN10025" href="../../server.112/e40402/initparams044.htm#REFRN10025"><span class="italic">Oracle Database Reference</span></a> to learn about the <code>CURSOR_SHARING</code> initialization parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i57480"></a>
<div id="PFGRF94346" class="sect2">
<h3 class="sect2"><span class="secnum">7.3.11</span> Maintaining Connections</h3>
<p>Large OLTP applications with middle tiers should maintain connections, rather than connecting and disconnecting for each database request. Maintaining persistent connections saves CPU resources and database resources, such as latches.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="autostat.htm#i35653">"Operating System Statistics"</a> for a description of important operating system statistics</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i29756"></a>
<div id="PFGRF94347" class="sect1">
<h2 class="sect1"><span class="secnum">7.4</span> Configuring and Using the Redo Log Buffer</h2>
<p>Server processes making changes to data blocks in the buffer cache generate redo data into the log buffer. LGWR begins writing to copy entries from the redo log buffer to the online redo log if any of the following are true:</p>
<ul>
<li>
<p>The log buffer becomes at least one-third full</p>
</li>
<li>
<p>LGWR is posted by a server process performing a <code>COMMIT</code> or <code>ROLLBACK</code></p>
</li>
<li>
<p>DBWR posts LGWR to do so</p>
</li>
</ul>
<p>When LGWR writes redo entries from the redo log buffer to a redo log file or disk, user processes can then copy new entries over the entries in memory that have been written to disk. LGWR usually writes fast enough to ensure that space is available in the buffer for new entries, even when access to the redo log is heavy.</p>
<p>A larger buffer makes it more likely that there is space for new entries, and also gives LGWR the opportunity to efficiently write out redo records (too small a log buffer on a system with large updates means that LGWR is continuously flushing redo to disk so that the log buffer remains two-thirds empty).</p>
<p>On computers with fast processors and relatively slow disks, the processors might be filling the rest of the buffer in the time it takes the redo log writer to move a portion of the buffer to disk. A larger log buffer can temporarily mask the effect of slower disks in this situation. Alternatively, you can do one of the following:</p>
<ul>
<li>
<p>Improve the checkpointing or archiving process</p>
</li>
<li>
<p>Improve the performance of log writer (perhaps by moving all online logs to fast raw devices)</p>
</li>
</ul>
<p>Good usage of the redo log buffer is a simple matter of:</p>
<ul>
<li>
<p>Batching commit operations for batch jobs, so that log writer is able to write redo log entries efficiently</p>
</li>
<li>
<p>Using <code>NOLOGGING</code> operations when you are loading large quantities of data</p>
</li>
</ul>
<p>The size of the redo log buffer is determined by the initialization parameter <code><a id="sthref502"></a>LOG_BUFFER</code>. You cannot modify the log buffer size after instance startup.</p>
<div id="PFGRF94348" class="figure">
<p class="titleinfigure"><a id="sthref503"></a>Figure 7-2 Redo Log Buffer</p>
<img width="496" height="192" src="img/pfgrf040.gif" alt="Description of Figure 7-2 follows" /><br />
<a id="sthref504" href="img_text/pfgrf040.htm">Description of "Figure 7-2 Redo Log Buffer"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="PFGRF94349" class="sect2"><a id="sthref505"></a>
<h3 class="sect2"><span class="secnum">7.4.1</span> Sizing the Log Buffer</h3>
<p>Applications that insert, modify, or delete large volumes of data usually need to change the default log buffer size. The <a id="sthref506"></a>log buffer is small compared with the total<a id="sthref507"></a> SGA size, and a modestly sized log buffer can significantly enhance throughput on systems that perform many updates.</p>
<p>A reasonable first estimate for such systems is to the default value, which is:</p>
<pre>
MAX(0.5M, (128K * number of cpus))
</pre>
<p>On most systems, sizing the log buffer larger than 1M does not provide any performance benefit. Increasing the log buffer size does not have any negative implications on performance or recoverability. It merely uses extra memory.</p>
</div>
<!-- class="sect2" -->
<div id="PFGRF94350" class="sect2"><a id="sthref508"></a>
<h3 class="sect2"><span class="secnum">7.4.2</span> Log Buffer Statistics</h3>
<p>The statistic <code>REDO</code> <code>BUFFER</code> <code>ALLOCATION</code> <code>RETRIES<a id="sthref509"></a></code> reflects the number of times a user process waits for space in the redo log buffer. This statistic can be queried through the dynamic performance view <code>V$SYSSTAT</code><a id="sthref510"></a>.</p>
<p>Use the following query to monitor these statistics over a period while your application is running:</p>
<pre>
SELECT NAME, VALUE
  FROM V$SYSSTAT
 WHERE NAME = 'redo buffer allocation retries';
</pre>
<p>The value of <code>redo buffer allocation retries</code> should be near zero over an interval. If this value increments consistently, then processes have had to wait for space in the redo log buffer. The wait can be caused by the log buffer being too small or by checkpointing. Increase the size of the redo log buffer, if necessary, by changing the value of the initialization parameter <code>LOG_BUFFER<a id="sthref511"></a></code>. The value of this parameter is expressed in bytes. Alternatively, improve the checkpointing or archiving process.</p>
<p>Another data source is to check whether the <code>log</code> <code>buffer</code> <code>space</code> wait event is not a significant factor in the wait time for the instance; if not, the log buffer size is most likely adequate.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i49320"></a>
<div id="PFGRF01401" class="sect1">
<h2 class="sect1"><span class="secnum">7.5</span> PGA Memory Management</h2>
<p>The Program Global Area (PGA) is a private memory region containing data and control information for a server process. Access to it is exclusive to the server process and is read and written only by the Oracle Database code acting on behalf of it. An example of such information is the run-time area of a cursor. Each time a cursor is executed, a new run-time area is created for that cursor in the PGA memory region of the server process executing that cursor.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Part of the run-time area can be located in the SGA when using shared servers.</div>
<p>For complex queries (for example, decision support queries), a big portion of the run-time area is dedicated to work areas allocated by memory intensive operators, such as the following:</p>
<ul>
<li>
<p>Sort-based operators, such as <code>ORDER</code> <code>BY</code>, <code>GROUP</code> <code>BY</code>, <code>ROLLUP</code>, and window functions</p>
</li>
<li>
<p>Hash-join</p>
</li>
<li>
<p>Bitmap merge</p>
</li>
<li>
<p>Bitmap create</p>
</li>
<li>
<p>Write buffers used by bulk load operations</p>
</li>
</ul>
<p>A sort operator uses a work area (the sort area) to perform the in-memory sort of a set of rows. Similarly, a hash-join operator uses a work area (the hash area) to build a hash table from its left input.</p>
<p><a id="sthref512"></a><a id="sthref513"></a>The size of a work area can be controlled and tuned. Generally, bigger work areas can significantly improve the performance of a particular operator at the cost of higher memory consumption. Ideally, the size of a work area is big enough that it can accommodate the input data and auxiliary memory structures allocated by its associated SQL operator. This is known as the optimal size of a work area. When the size of the work area is smaller than optimal, the response time increases, because an extra pass is performed over part of the input data. This is known as the one-pass size of the work area. Under the one-pass threshold, when the size of a work area is far too small compared to the input data size, multiple passes over the input data are needed. This could dramatically increase the response time of the operator. This is known as the multi-pass size of the work area. For example, a serial sort operation that must sort 10 GB of data needs a little more than 10 GB to run optimal and at least 40 MB to run one-pass. If this sort gets less that 40 MB, then it must perform several passes over the input data.</p>
<p>The goal is to have most work areas running with an optimal size (for example, more than 90% or even 100% for pure OLTP systems), while a smaller fraction of them run with a one-pass size (for example, less than 10%). Multi-pass execution should be avoided. Even for DSS systems running large sorts and hash-joins, the memory requirement for the one-pass executions is relatively small. A system configured with a reasonable amount of PGA memory should not need to perform multiple passes over the input data.</p>
<p>Automatic PGA memory management simplifies and improves the way PGA memory is allocated. By default, PGA memory management is enabled. In this mode, Oracle Database dynamically adjusts the size of the portion of the PGA memory dedicated to work areas, based on 20% of the SGA memory size. The minimum value is 10MB.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For backward compatibility, automatic PGA memory management can be disabled by setting the value of the <code>PGA_AGGREGATE_TARGET</code> initialization parameter to 0. When automatic PGA memory management is disabled, the maximum size of a work area can be sized with the associated <code>_AREA_SIZE</code> parameter, such as the <code>SORT_AREA_SIZE</code> initialization parameter.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For information about the <code>PGA_AGGREGATE_TARGET</code>, <code>SORT_AREA_SIZE</code>, <code>HASH_AREA_SIZE</code>, <code>BITMAP_MERGE_AREA_SIZE</code> and <code>CREATE_BITMAP_AREA_SIZE</code> initialization parameters, see <a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a>.</div>
<a id="i51933"></a>
<div id="PFGRF94351" class="sect2">
<h3 class="sect2"><span class="secnum">7.5.1</span> Configuring Automatic PGA Memory</h3>
<p>When running under the automatic PGA memory management mode, sizing of work areas for all sessions becomes automatic and the <code>*_AREA_SIZE</code> parameters are ignored by all sessions running in that mode. At any given time, the total amount of PGA memory available to active work areas in the instance is automatically derived from the <code><a id="sthref514"></a>PGA_AGGREGATE_TARGET</code> initialization parameter. This amount is set to the value of <code>PGA_AGGREGATE_TARGET</code> minus the amount of PGA memory allocated by other components of the system (for example, PGA memory allocated by sessions). The resulting PGA memory is then assigned to individual active work areas, based on their specific memory requirements.</p>
<p>Under automatic PGA memory management mode, the main goal of Oracle Database is to honor the <code>PGA_AGGREGATE_TARGET</code> limit set by the DBA, by controlling dynamically the amount of PGA memory allotted to SQL work areas. At the same time, Oracle Database t to maximize the performance of all the memory-intensive SQL operations, by maximizing the number of work areas that are using an optimal amount of PGA memory (cache memory). The rest of the work areas are executed in one-pass mode, unless the PGA memory limit set by the DBA with the parameter <code>PGA_AGGREGATE_TARGET</code> is so low that multi-pass execution is required to reduce even more the consumption of PGA memory and honor the PGA target limit.</p>
<p>When configuring a brand new instance, it is hard to know precisely the appropriate setting for <code>PGA_AGGREGATE_TARGET</code>. You can determine this setting in three stages:</p>
<ol>
<li>
<p>Make a first estimate for <code>PGA_AGGREGATE_TARGET</code>. By default, Oracle Database uses 20% of the SGA size. However, this initial setting may be too low for a large DSS system.</p>
</li>
<li>
<p>Run a representative workload on the instance and monitor performance, using PGA statistics collected by Oracle Database, to see whether the maximum PGA size is under-configured or over-configured.</p>
</li>
<li>
<p>Tune <code>PGA_AGGREGATE_TARGET</code>, using Oracle PGA advice statistics.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for information about the <code>PGA_AGGREGATE_TARGET</code> initialization parameter</div>
</li>
</ol>
<p>The following sections explain this in detail:</p>
<ul>
<li>
<p><a href="#i47856">Setting PGA_AGGREGATE_TARGET Initially</a></p>
</li>
<li>
<p><a href="#i47865">Monitoring the Performance of the Automatic PGA Memory Management</a></p>
</li>
<li>
<p><a href="#i48904">Tuning PGA_AGGREGATE_TARGET</a></p>
</li>
</ul>
<a id="i47856"></a>
<div id="PFGRF94352" class="sect3">
<h4 class="sect3"><span class="secnum">7.5.1.1</span> Setting PGA_AGGREGATE_TARGET Initially</h4>
<p>The value of the <code>PGA_AGGREGATE_TARGET</code> initialization parameter (for example 100000 KB, 2500 MB, or 50 GB) should be set based on the total amount of memory available for the Oracle database instance. This value can then be tuned and dynamically modified at the instance level. <a href="#i47767">Example 7-2</a> illustrates a typical situation.</p>
<div id="PFGRF94353" class="example">
<p class="titleinexample"><a id="i47767"></a>Example 7-2 Initial Setting of PGA_AGGREGATE_TARGET</p>
<p>Assume that an Oracle database instance is configured to run on a system with 4&nbsp;GB of physical memory. Part of that memory should be left for the operating system and other non-Oracle applications running on the same hardware system. You might decide to dedicate only 80% (3.2 GB) of the available memory to the Oracle database instance.</p>
<p>You must then divide the resulting memory between the SGA and the PGA.</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>For OLTP systems, the PGA memory typically accounts for a small fraction of the total memory available (for example, 20%), leaving 80% for the SGA.</p>
</li>
<li>
<p>For DSS systems running large, memory-intensive queries, PGA memory can typically use up to 70% of that total (up to 2.2 GB in this example).</p>
</li>
</ul>
<p>Good initial values for the parameter <code>PGA_AGGREGATE_TARGET</code> might be:</p>
<ul>
<li>
<p>For OLTP<code>:</code> <code>PGA_AGGREGATE_TARGET</code> = (<code><span class="codeinlineitalic">total_mem</span></code> * 80%) * 20%</p>
</li>
<li>
<p>For DSS<code>:</code> <code>PGA_AGGREGATE_TARGET</code> = (<code><span class="codeinlineitalic">total_mem</span></code> * 80%) * 50%</p>
<p>where <code><span class="codeinlineitalic">total_mem</span></code> is the total amount of physical memory available on the system.</p>
</li>
</ul>
<p>In this example, with a value of <code><span class="codeinlineitalic">total_mem</span></code> equal to 4 GB, you can initially set <code>PGA_AGGREGATE_TARGET</code> to 1600 MB for a DSS system and to 655 MB for an OLTP system.</p>
</div>
<!-- class="sect3" -->
<a id="i47865"></a>
<div id="PFGRF94354" class="sect3">
<h4 class="sect3"><span class="secnum">7.5.1.2</span> Monitoring the Performance of the Automatic PGA Memory Management</h4>
<p>Before starting the tuning process, you need to know how to monitor and interpret the key statistics collected by Oracle Database to help in assessing the performance of the automatic PGA memory management component. Several dynamic performance views are available for this purpose:</p>
<ul>
<li>
<p><a href="#i47890">V$PGASTAT</a></p>
</li>
<li>
<p><a href="#i51470">V$PROCESS</a></p>
</li>
<li>
<p><a href="#BGBDFFCA">V$PROCESS_MEMORY</a></p>
</li>
<li>
<p><a href="#i48366">V$SQL_WORKAREA_HISTOGRAM</a></p>
</li>
<li>
<p><a href="#i48705">V$SQL_WORKAREA_ACTIVE</a></p>
</li>
<li>
<p><a href="#i48849">V$SQL_WORKAREA</a></p>
</li>
</ul>
<a id="i47890"></a>
<div id="PFGRF94355" class="sect4">
<h5 class="sect4"><span class="secnum">7.5.1.2.1</span> <a id="sthref515"></a>V$PGASTAT</h5>
<p>This view gives instance-level statistics on the PGA memory usage and the automatic PGA memory manager. For example:</p>
<pre>
SELECT * FROM V$PGASTAT;
</pre>
<p>The output of this query might look like the following:</p>
<pre>
NAME                                                          VALUE UNIT
-------------------------------------------------------- ---------- ------------
aggregate PGA target parameter                             41156608 bytes
aggregate PGA auto target                                  21823488 bytes
global memory bound                                         2057216 bytes
total PGA inuse                                            16899072 bytes
total PGA allocated                                        35014656 bytes
maximum PGA allocated                                     136795136 bytes
total freeable PGA memory                                    524288 bytes
PGA memory freed back to OS                              1713242112 bytes
total PGA used for auto workareas                                 0 bytes
maximum PGA used for auto workareas                         2383872 bytes
total PGA used for manual workareas                               0 bytes
maximum PGA used for manual workareas                       8470528 bytes
over allocation count                                           291
bytes processed                                          2124600320 bytes
extra bytes read/written                                   39949312 bytes
cache hit percentage                                          98.15 percent
</pre>
<p>The main statistics displayed in <code>V$PGASTAT</code> are as follows:</p>
<ul>
<li>
<p><code>aggregate PGA target parameter</code>: This is the current value of the initialization parameter <code>PGA_AGGREGATE_TARGET</code>. The default value is 20% of the SGA size. If you set this parameter to 0, automatic management of the PGA memory is disabled.</p>
</li>
<li>
<p><code>aggregate PGA auto target</code>: This gives the amount of PGA memory Oracle Database can use for work areas running in automatic mode. This amount is dynamically derived from the value of the parameter <code>PGA_AGGREGATE_TARGET</code> and the current work area workload. Hence, it is continuously adjusted by Oracle. If this value is small compared to the value of <code>PGA_AGGREGATE_TARGET</code>, then a lot of PGA memory is used by other components of the system (for example, PL/SQL or Java memory) and little is left for sort work areas. You must ensure that enough PGA memory is left for work areas running in automatic mode.</p>
</li>
<li>
<p><code>global memory bound</code>: This gives the maximum size of a work area executed in <code>AUTO</code> mode. This value is continuously adjusted by Oracle Database to reflect the current state of the work area workload. The global memory bound generally decreases when the number of active work areas is increasing in the system. As a rule of thumb, the value of the global bound should not decrease to less than one megabyte. If it does, then the value of <code>PGA_AGGREGATE_TARGET</code> should probably be increased.</p>
</li>
<li>
<p><code>total PGA allocated</code>: This gives the current amount of PGA memory allocated by the instance. Oracle Database tries to keep this number less than the value of <code>PGA_AGGREGATE_TARGET</code>. However, it is possible for the PGA allocated to exceed that value by a small percentage and for a short period, when the work area workload is increasing very rapidly or when the initialization parameter <code>PGA_AGGREGATE_TARGET</code> is set to a too small value.</p>
</li>
<li>
<p><code>total freeable PGA memory:</code> This indicates how much allocated PGA memory which can be freed.</p>
</li>
<li>
<p><code>total PGA used for auto workareas</code>: This indicates how much PGA memory is currently consumed by work areas running under automatic memory management mode. This number can be used to determine how much memory is consumed by other consumers of the PGA memory (for example, PL/SQL or Java):</p>
<pre>
PGA other = total PGA allocated - total PGA used for auto workareas
</pre></li>
<li>
<p><code>over allocation count</code>: This statistic is cumulative from instance startup. Over-allocating PGA memory can happen if the value of <code>PGA_AGGREGATE_TARGET</code> is too small to accommodate the <code>PGA other</code> component in the previous equation plus the minimum memory required to execute the work area workload. When this happens, Oracle Database cannot honor the initialization parameter <code>PGA_AGGREGATE_TARGET</code>, and extra PGA memory must be allocated. If over-allocation occurs, you should increase the value of <code>PGA_AGGREGATE_TARGET</code> using the information provided by the advice view <code>V$PGA_TARGET_ADVICE</code>.</p>
</li>
<li>
<p><code>total bytes processed</code>: This is the number of bytes processed by memory-intensive SQL operators since instance startup. For example, the number of byte processed is the input size for a sort operation. This number is used to compute the <code>cache</code> <code>hit</code> <code>percentage</code> metric.</p>
</li>
<li>
<p><code>extra bytes read/written</code>: When a work area cannot run optimally, one or more extra passes is performed over the input data. <code>extra</code> <code>bytes</code> <code>read/written</code> represents the number of bytes processed during these extra passes since instance startup. This number is also used to compute the <code>cache</code> <code>hit</code> <code>percentage</code>. Ideally, it should be small compared to <code>total bytes processed</code>.</p>
</li>
<li>
<p><code>cache hit percentage</code>: This metric is computed by Oracle Database to reflect the performance of the PGA memory component. It is cumulative from instance startup. A value of 100% means that all work areas executed by the system since instance startup have used an optimal amount of PGA memory. This is, of course, ideal but rarely happens except maybe for pure OLTP systems. In reality, some work areas run one-pass or even multi-pass, depending on the overall size of the PGA memory. When a work area cannot run optimally, one or more extra passes is performed over the input data. This reduces the <code>cache</code> <code>hit</code> <code>percentage</code> in proportion to the size of the input data and the number of extra passes performed. <a href="#i48203">Example 7-3</a> shows how <code>cache</code> <code>hit</code> <code>percentage</code> is affected by extra passes.</p>
</li>
</ul>
<div id="PFGRF94356" class="example">
<p class="titleinexample"><a id="i48203"></a>Example 7-3 Calculating Cache Hit Percentage</p>
<p>Consider a simple example: Four sort operations have been executed, three were small (1 MB of input data) and one was bigger (100 MB of input data). The total number of bytes processed (<code>BP</code>) by the four operations is 103 MB. If one of the small sorts runs one-pass, an extra pass over 1 MB of input data is performed. This 1 MB value is the number of <code>extra</code> <code>bytes</code> <code>read/written</code>, or <code>EBP</code>. The <code>cache</code> <code>hit</code> <code>percentage</code> is calculated by the following formula:</p>
<pre>
BP x 100 / (BP + EBP)
</pre>
<p>The <code>cache</code> <code>hit</code> <code>percentage</code> in this case is 99.03%, almost 100%. This value reflects the fact that only one of the small sorts had to perform an extra pass while all other sorts were able to run optimally. Hence, the <code>cache</code> <code>hit</code> <code>percentage</code> is almost 100%, because this extra pass over 1 MB represents a tiny overhead. However, if the big sort is the one to run one-pass, then EBP is 100 MB instead of 1 MB, and the <code>cache</code> <code>hit</code> <code>percentage</code> falls to 50.73%, because the extra pass has a much bigger impact.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="i51470"></a>
<div id="PFGRF94357" class="sect4">
<h5 class="sect4"><span class="secnum">7.5.1.2.2</span> <a id="sthref516"></a>V$PROCESS</h5>
<p>This view has one row for each Oracle process connected to the instance. The columns <code>PGA_USED_MEM</code>, <code>PGA_ALLOC_MEM</code>, <code>PGA_FREEABLE_MEM</code> and <code>PGA_MAX_MEM</code> can be used to monitor the PGA memory usage of these processes. For example:</p>
<pre>
SELECT PROGRAM, PGA_USED_MEM, PGA_ALLOC_MEM, PGA_FREEABLE_MEM, PGA_MAX_MEM 
  FROM V$PROCESS;
</pre>
<p>The output of this query might look like the following:</p>
<pre>
PROGRAM                                PGA_USED_MEM PGA_ALLOC_MEM PGA_FREEABLE_MEM PGA_MAX_MEM
-------------------------------------- ------------ ------------- ---------------- -----------
PSEUDO                                            0             0                0           0
oracle@examp1690 (PMON)                      314540        685860                0      685860
oracle@examp1690 (MMAN)                      313992        685860                0      685860
oracle@examp1690 (DBW0)                      696720       1063112                0     1063112
oracle@examp1690 (LGWR)                    10835108      22967940                0    22967940
oracle@examp1690 (CKPT)                      352716        710376                0      710376
oracle@examp1690 (SMON)                      541508        948004                0     1603364
oracle@examp1690 (RECO)                      323688        685860                0      816932
oracle@examp1690 (q001)                      233508        585128                0      585128
oracle@examp1690 (QMNC)                      314332        685860                0      685860
oracle@examp1690 (MMON)                      885756       1996548           393216     1996548
oracle@examp1690 (MMNL)                      315068        685860                0      685860
oracle@examp1690 (q000)                      330872        716200            65536      716200
oracle@examp1690 (TNS V1-V3)                 635768        928024                0     1255704
oracle@examp1690 (CJQ0)                      533476       1013540                0     1144612
oracle@examp1690 (TNS V1-V3)                 430648        812108                0      812108
</pre></div>
<!-- class="sect4" -->
<a id="BGBDFFCA"></a>
<div id="PFGRF94358" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">7.5.1.2.3</span> <a id="sthref517"></a>V$PROCESS_MEMORY</h5>
<p>This view displays dynamic PGA memory usage by named component categories for each Oracle process. This view will contain up to six rows for each Oracle process, one row for:</p>
<ul>
<li>
<p>Each named component category: Java, PL/SQL, OLAP, and SQL.</p>
</li>
<li>
<p>Freeable: memory that has been allocated to the process by the operating system, but not to a specific category.</p>
</li>
<li>
<p>Other: memory that has been allocated to a category, but not to one of the named categories.</p>
</li>
</ul>
<p>You can use the columns <code>CATEGORY</code>, <code>ALLOCATED</code>, <code>USED</code>, and <code>MAX_ALLOCATED</code> to dynamically monitor the PGA memory usage of Oracle processes for each of the six categories.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for more information on the <code>V$PROCESS_MEMORY</code> view.</div>
</div>
<!-- class="sect4" -->
<a id="i48366"></a>
<div id="PFGRF94359" class="sect4">
<h5 class="sect4"><span class="secnum">7.5.1.2.4</span> <a id="sthref518"></a>V$SQL_WORKAREA_HISTOGRAM</h5>
<p>This view shows the number of work areas executed with optimal memory size, one-pass memory size, and multi-pass memory size since instance startup. Statistics in this view are subdivided into buckets that are defined by the optimal memory requirement of the work area. Each bucket is identified by a range of optimal memory requirements specified by the values of the columns <code>LOW_OPTIMAL_SIZE</code> and <code>HIGH_OPTIMAL_SIZE</code>.</p>
<p><a href="#i48203">Example 7-3</a> and <a href="#i48395">Example 7-4</a> show two ways of using <code>V$SQL_WORKAREA_HISTOGRAM</code>.</p>
<div id="PFGRF94360" class="example">
<p class="titleinexample"><a id="i48395"></a>Example 7-4 Querying V$SQL_WORKAREA_HISTOGRAM: Non-empty Buckets</p>
<p>Consider a sort operation that requires 3 MB of memory to run optimally (cached). Statistics about the work area used by this sort are placed in the bucket defined by <code>LOW_OPTIMAL_SIZE = 2097152</code> (2 MB) and <code>HIGH_OPTIMAL_SIZE = 4194303</code> (4 MB minus 1 byte), because 3 MB falls within that range of optimal sizes. Statistics are segmented by work area size, because the performance impact of running a work area in optimal, one-pass or multi-pass mode depends mainly on the size of that work area.</p>
<p>The following query shows statistics for all non-empty buckets. Empty buckets are removed with the predicate <code>WHERE TOTAL_EXECUTION!= 0</code>.</p>
<pre>
SELECT LOW_OPTIMAL_SIZE/1024 low_kb,
       (HIGH_OPTIMAL_SIZE+1)/1024 high_kb,
       OPTIMAL_EXECUTIONS, ONEPASS_EXECUTIONS, MULTIPASSES_EXECUTIONS
  FROM V$SQL_WORKAREA_HISTOGRAM
 WHERE TOTAL_EXECUTIONS != 0;
</pre>
<p>The result of the query might look like the following:</p>
<pre>
LOW_KB HIGH_KB OPTIMAL_EXECUTIONS ONEPASS_EXECUTIONS MULTIPASSES_EXECUTIONS
------ ------- ------------------ ------------------ ----------------------
     8      16             156255                  0                      0
    16      32                150                  0                      0
    32      64                 89                  0                      0
    64     128                 13                  0                      0
   128     256                 60                  0                      0
   256     512                  8                  0                      0
   512    1024                657                  0                      0
  1024    2048                551                 16                      0
  2048    4096                538                 26                      0
  4096    8192                243                 28                      0
  8192   16384                137                 35                      0
 16384   32768                 45                107                      0
 32768   65536                  0                153                      0
 65536  131072                  0                 73                      0
131072  262144                  0                 44                      0
262144  524288                  0                 22                      0
</pre>
<p>The query result shows that, in the 1024 KB to 2048 KB bucket, 551 work areas used an optimal amount of memory, while 16 ran in one-pass mode and none ran in multi-pass mode. It also shows that all work areas under 1 MB were able to run in optimal mode.</p>
</div>
<!-- class="example" -->
<div id="PFGRF94361" class="example">
<p class="titleinexample"><a id="i48659"></a>Example 7-5 Querying V$SQL_WORKAREA_HISTOGRAM: Percent Optimal</p>
<p>You can also use <code>V$SQL_WORKAREA_HISTOGRAM</code> to find the percentage of times work areas were executed in optimal, one-pass, or multi-pass mode since startup. This query only considers work areas of a certain size, with an optimal memory requirement of at least 64 KB.</p>
<pre>
SELECT optimal_count, round(optimal_count*100/total, 2) optimal_perc, 
       onepass_count, round(onepass_count*100/total, 2) onepass_perc,
       multipass_count, round(multipass_count*100/total, 2) multipass_perc
FROM
 (SELECT decode(sum(total_executions), 0, 1, sum(total_executions)) total,
         sum(OPTIMAL_EXECUTIONS) optimal_count,
         sum(ONEPASS_EXECUTIONS) onepass_count,
         sum(MULTIPASSES_EXECUTIONS) multipass_count
    FROM v$sql_workarea_histogram
   WHERE low_optimal_size &gt;= 64*1024);
</pre>
<p>The output of this query might look like the following:</p>
<pre>
OPTIMAL_COUNT OPTIMAL_PERC ONEPASS_COUNT ONEPASS_PERC MULTIPASS_COUNT MULTIPASS_PERC
------------- ------------ ------------- ------------ --------------- --------------
         2239        81.63           504        18.37               0              0
</pre>
<p>This result shows that 81.63% of these work areas have been able to run using an optimal amount of memory. The rest (18.37%) ran one-pass. None of them ran multi-pass. Such behavior is preferable, for the following reasons:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>Multi-pass mode can severely degrade performance. A high number of multi-pass work areas has an exponentially adverse effect on the response time of its associated SQL operator.</p>
</li>
<li>
<p>Running one-pass does not require a large amount of memory; only 22 MB is required to sort 1 GB of data in one-pass mode.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="i48705"></a>
<div id="PFGRF94362" class="sect4">
<h5 class="sect4"><span class="secnum">7.5.1.2.5</span> <a id="sthref519"></a>V$SQL_WORKAREA_ACTIVE</h5>
<p>You can use this view to display the work areas that are active (or executing) in the instance. Small active sorts (under 64 KB) are excluded from the view. Use this view to precisely monitor the size of all active work areas and to determine if these active work areas spill to a temporary segment. <a href="#i49663">Example 7-6</a> shows a typical query of this view:</p>
<div id="PFGRF94363" class="example">
<p class="titleinexample"><a id="i49663"></a>Example 7-6 Querying V$SQL_WORKAREA_ACTIVE</p>
<pre>
SELECT to_number(decode(SID, 65535, NULL, SID)) sid,
       operation_type OPERATION,
       trunc(EXPECTED_SIZE/1024) ESIZE,
       trunc(ACTUAL_MEM_USED/1024) MEM,
       trunc(MAX_MEM_USED/1024) "MAX MEM",
       NUMBER_PASSES PASS,
       trunc(TEMPSEG_SIZE/1024) TSIZE
  FROM V$SQL_WORKAREA_ACTIVE
 ORDER BY 1,2;

The output of this query might look like the following:
SID         OPERATION     ESIZE       MEM   MAX MEM  PASS   TSIZE
--- ----------------- --------- --------- --------- ----- -------
  8   GROUP BY (SORT)       315       280       904     0
  8         HASH-JOIN      2995      2377      2430     1   20000
  9   GROUP BY (SORT)     34300     22688     22688     0
 11         HASH-JOIN     18044     54482     54482     0
 12         HASH-JOIN     18044     11406     21406     1  120000
</pre>
<p>This output shows that session 12 (column <code>SID</code>) is running a hash-join having its work area running in one-pass mode (<code>PASS</code> column). This work area is currently using 11406 KB of memory (<code>MEM</code> column) and has used, in the past, up to 21406 KB of PGA memory (<code>MAX</code> <code>MEM</code> column). It has also spilled to a temporary segment of size 120000 KB. Finally, the column <code>ESIZE</code> indicates the maximum amount of memory that the PGA memory manager expects this hash-join to use. This maximum is dynamically computed by the PGA memory manager according to workload.</p>
<p>When a work area is deallocated&mdash;that is, when the execution of its associated SQL operator is complete&mdash;the work area is automatically removed from the <code>V$SQL_WORKAREA_ACTIVE</code> view.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="i48849"></a>
<div id="PFGRF94364" class="sect4">
<h5 class="sect4"><span class="secnum">7.5.1.2.6</span> <a id="sthref520"></a>V$SQL_WORKAREA</h5>
<p>Oracle Database maintains cumulative work area statistics for each loaded cursor whose execution plan uses one or more work areas. Every time a work area is deallocated, the <code>V$SQL_WORKAREA</code> table is updated with execution statistics for that work area.</p>
<p><code>V$SQL_WORKAREA</code> can be joined with <code>V$SQL</code> to relate a work area to a cursor. It can even be joined to <code>V$SQL_PLAN</code> to precisely determine which operator in the plan uses a work area.</p>
<p><a href="#i49688">Example 7-7</a> shows three typical queries on the <code>V$SQL_WORKAREA</code> dynamic view:</p>
<div id="PFGRF94365" class="example">
<p class="titleinexample"><a id="i49688"></a>Example 7-7 Querying V$SQL_WORKAREA</p>
<p>The following query finds the top 10 work areas requiring most cache memory:</p>
<pre>
SELECT *
FROM   (SELECT workarea_address, operation_type, policy, estimated_optimal_size
        FROM V$SQL_WORKAREA
        ORDER BY estimated_optimal_size DESC)
 WHERE ROWNUM &lt;= 10;
</pre>
<p>The following query finds the cursors with one or more work areas that have been executed in one or even multiple passes:</p>
<pre>
col sql_text format A80 wrap 
SELECT sql_text, sum(ONEPASS_EXECUTIONS) onepass_cnt,
       sum(MULTIPASSES_EXECUTIONS) mpass_cnt 
FROM V$SQL s, V$SQL_WORKAREA wa 
WHERE s.address = wa.address 
GROUP BY sql_text 
HAVING sum(ONEPASS_EXECUTIONS+MULTIPASSES_EXECUTIONS)&gt;0;
</pre>
<p>Using the hash value and address of a particular cursor, the following query displays the cursor execution plan, including information about the associated work areas.</p>
<pre>
col "O/1/M" format a10
col name format a20
SELECT operation, options, object_name name, trunc(bytes/1024/1024) "input(MB)",
       trunc(last_memory_used/1024) last_mem,
       trunc(estimated_optimal_size/1024) optimal_mem, 
       trunc(estimated_onepass_size/1024) onepass_mem, 
       decode(optimal_executions, null, null, 
              optimal_executions||'/'||onepass_executions||'/'||
              multipasses_executions) "O/1/M"
  FROM V$SQL_PLAN p, V$SQL_WORKAREA w 
 WHERE p.address=w.address(+) 
   AND p.hash_value=w.hash_value(+) 
   AND p.id=w.operation_id(+) 
   AND p.address='88BB460C'
   AND p.hash_value=3738161960; 

OPERATION    OPTIONS  NAME     input(MB) LAST_MEM OPTIMAL_ME ONEPASS_ME O/1/M 
------------ -------- -------- --------- -------- ---------- ---------- ------
SELECT STATE                                                                  
HASH         GROUP BY               4582        8         16         16 16/0/0
HASH JOIN    SEMI                   4582     5976       5194       2187 16/0/0
TABLE ACCESS FULL     ORDERS          51                                      
TABLE ACCESS FUL      LINEITEM      1000                                      
</pre>
<p>You can get the address and hash value from the <code>V$SQL</code> view by specifying a pattern in the query. For example:</p>
<pre>
SELECT address, hash_value 
  FROM V$SQL 
WHERE sql_text LIKE '%<span class="italic">my_pattern</span>%';
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i48904"></a>
<div id="PFGRF94366" class="sect3">
<h4 class="sect3"><span class="secnum">7.5.1.3</span> Tuning PGA_AGGREGATE_TARGET</h4>
<p>To help you tune the initialization parameter <code>PGA_AGGREGATE_TARGET</code>, Oracle Database provides the <code>V$PGA_TARGET_ADVICE</code> and <code>V$PGA_TARGET_ADVICE_HISTOGRAM</code> views. By examining these views, you no longer need to use an empirical approach to tune the value of <code>PGA_AGGREGATE_TARGET</code>. Instead, you can use these views to determine how key PGA statistics will be impacted if you change the value of <code>PGA_AGGREGATE_TARGET</code>.</p>
<p>In both views, values of <code>PGA_AGGREGATE_TARGET</code> used for the prediction are derived from fractions and multiples of the current value of that parameter, to assess possible higher and lower values. Values used for the prediction range from 10 MB to a maximum of 256 GB.</p>
<p>Oracle Database generates PGA advice performance views by recording the workload history and then simulating this history for different values of <code>PGA_AGGREGATE_TARGET</code>. The simulation process happens in the background and continuously updates the workload history to produce the simulation result. You can view the result at any time by querying <code>V$PGA_TARGET_ADVICE</code> or <code>V$PGA_TARGET_ADVICE_HISTOGRAM</code>.</p>
<p>To enable automatic generation of PGA advice performance views, make sure the following parameters are set:</p>
<ul>
<li>
<p><code>PGA_AGGREGATE_TARGET</code>, to enable automatic PGA memory management (see <a href="#i47856">"Setting PGA_AGGREGATE_TARGET Initially"</a>).</p>
</li>
<li>
<p><code>STATISTICS_LEVEL</code>. Set this to <code>TYPICAL</code> (the default) or <code>ALL</code>; setting this parameter to <code>BASIC</code> turns off generation of PGA performance advice views.</p>
</li>
</ul>
<p>The content of these PGA advice performance views is reset at instance startup or when <code>PGA_AGGREGATE_TARGET</code> is altered.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Simulation cannot include all factors of real execution, so derived statistics may not exactly match up with real performance statistics. Always monitor the system after changing <code>PGA_AGGREGATE_TARGET</code> to verify that the new performance is what you expect.</div>
<a id="i49570"></a>
<div id="PFGRF94367" class="sect4">
<h5 class="sect4"><span class="secnum">7.5.1.3.1</span> V$PGA_TARGET_ADVICE</h5>
<p>This view predicts how the statistics <code>cache</code> <code>hit</code> <code>percentage</code> and <code>over</code> <code>allocation</code> <code>count</code> in <code>V$PGASTAT</code> will be impacted if you change the value of the initialization parameter <code>PGA_AGGREGATE_TARGET</code>. <a href="#i49767">Example 7-8</a> shows a typical query of this view.</p>
<div id="PFGRF94368" class="example">
<p class="titleinexample"><a id="i49767"></a>Example 7-8 Querying V$PGA_TARGET_ADVICE</p>
<pre>
SELECT round(PGA_TARGET_FOR_ESTIMATE/1024/1024) target_mb,
       ESTD_PGA_CACHE_HIT_PERCENTAGE cache_hit_perc,
       ESTD_OVERALLOC_COUNT
  FROM V$PGA_TARGET_ADVICE;
</pre>
<p>The output of this query might look like the following:</p>
<pre>
 TARGET_MB  CACHE_HIT_PERC  ESTD_OVERALLOC_COUNT
----------  --------------  --------------------
        63              23                   367
       125              24                    30
       250              30                     3
       375              39                     0
       500              58                     0
       600              59                     0
       700              59                     0
       800              60                     0
       900              60                     0
      1000              61                     0
      1500              67                     0
      2000              76                     0
      3000              83                     0
      4000              85                     0
</pre>
<p>The result of the this query can be plotted as shown in <a href="#i49818">Figure 7-3</a>:</p>
</div>
<!-- class="example" -->
<div id="PFGRF94369" class="figure">
<p class="titleinfigure"><a id="i49818"></a>Figure 7-3 Graphical Representation of V$PGA_TARGET_ADVICE</p>
<img width="600" height="608" src="img/pfgrf212.gif" alt="Description of Figure 7-3 follows" /><br />
<a id="sthref521" href="img_text/pfgrf212.htm">Description of "Figure 7-3 Graphical Representation of V$PGA_TARGET_ADVICE"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The curve shows how the PGA <code>cache</code> <code>hit</code> <code>percentage</code> improves as the value of <code>PGA_AGGREGATE_TARGET</code> increases. The shaded zone in the graph is the <code>over</code> <code>allocation</code> zone, where the value of the column <code>ESTD_OVERALLOCATION_COUNT</code> is nonzero. It indicates that <code>PGA_AGGREGATE_TARGET</code> is too small to even meet the minimum PGA memory needs. If <code>PGA_AGGREGATE_TARGET</code> is set within the <code>over</code> <code>allocation</code> zone, the memory manager will over-allocate memory and actual PGA memory consumed will be more than the limit you set. It is therefore meaningless to set a value of <code>PGA_AGGREGATE_TARGET</code> in that zone. In this particular example <code>PGA_AGGREGATE_TARGET</code> should be set to at least 375 MB.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although the theoretical maximum for the PGA <code>cache</code> <code>hit</code> <code>percentage</code> is 100%, there is a practical limit on the maximum size of a work area, which may prevent this theoretical maximum from being reached, even if you further increase <code>PGA_AGGREGATE_TARGET</code>. This should happen only in large DSS systems where the optimal memory requirement is large and might cause the value of the <code>cache</code> <code>hit</code> <code>percentage</code> to taper off at a lower percentage, like 90%.</div>
<p>Beyond the <code>over</code> <code>allocation</code> zone, the value of the PGA <code>cache</code> <code>hit</code> <code>percentage</code> increases rapidly. This is due to an increase in the number of work areas which run optimally or one-pass and a decrease in the number of multi-pass executions. At some point, around 500 MB in this example, an inflection in the curve corresponds to the point where most (probably all) work areas can run optimally or at least one-pass. After this inflection, the <code>cache</code> <code>hit</code> <code>percentage</code> keeps increasing, though at a lower pace, up to the point where it starts to taper off and shows only slight improvement with increase in <code>PGA_AGGREGATE_TARGET</code>. In <a href="#i49818">Figure 7-3</a>, this happens when <code>PGA_AGGREGATE_TARGET</code> reaches 3 GB. At that point, the <code>cache</code> <code>hit</code> <code>percentage</code> is 83% and only improves marginally (by 2%) with one extra gigabyte of PGA memory. In this example, 3 GB is probably the optimal value for <code>PGA_AGGREGATE_TARGET</code>.</p>
<p>Ideally, <code>PGA_AGGREGATE_TARGET</code> should be set at the optimal value, or at least to the maximum value possible in the region beyond the <code>over</code> <code>allocation</code> zone. As a rule of thumb, the PGA <code>cache</code> <code>hit</code> <code>percentage</code> should be higher than 60%, because at 60% the system is almost processing double the number of bytes it actually needs to process in an ideal situation. Using this particular example, it makes sense to set <code>PGA_AGGREGATE_TARGET</code> to at least 500 MB and as close as possible to 3 GB. But the right setting for the parameter <code>PGA_AGGREGATE_TARGET</code> depends on how much memory can be dedicated to the PGA component. Generally, adding PGA memory requires reducing memory for some SGA components, like the shared pool or buffer cache, because the overall memory dedicated to the instance is often bound by the amount of physical memory available on the system. Thus, any decisions to increase PGA memory must be taken in the larger context of the available memory in the system and the performance of the various SGA components (which you monitor with shared pool advisory and buffer cache advisory statistics). If you cannot take memory from the SGA, consider adding physical memory to the computer.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i50285">"Shared Pool Advisory Statistics"</a> and <a href="#i30311">"Sizing the Buffer Cache"</a></div>
</div>
<!-- class="sect4" -->
<div id="PFGRF94370" class="sect4"><a id="sthref522"></a>
<h5 class="sect4"><span class="secnum">7.5.1.3.2</span> How to Tune PGA_AGGREGATE_TARGET</h5>
<p>You can use the following steps as a tuning guideline in tuning <code>PGA_AGGREGATE_TARGET</code>:</p>
<ol>
<li>
<p>Set <code>PGA_AGGREGATE_TARGET</code> so there is no memory over-allocation; avoid setting it in the over-allocation zone. In <a href="#i49767">Example 7-8</a>, <code>PGA_AGGREGATE_TARGET</code> should be set to at least 375 MB.</p>
</li>
<li>
<p>After eliminating over-allocations, aim at maximizing the PGA <code>cache</code> <code>hit</code> <code>percentage</code>, based on your response-time requirement and memory constraints. In <a href="#i49767">Example 7-8</a>, assume you have a limit <span class="italic">X</span> on memory you can allocate to PGA.</p>
<ul>
<li>
<p>If this limit <span class="italic">X</span> is beyond the optimal value, then you would set <code>PGA_AGGREGATE_TARGET</code> to the optimal value. After this point, the incremental benefit with higher memory allocation to <code>PGA_AGGREGATE_TARGET</code> is very small. In <a href="#i49767">Example 7-8</a>, if you have 10 GB to dedicate to PGA, set <code>PGA_AGGREGATE_TARGET</code> to 3 GB, the optimal value. The remaining 7 GB is dedicated to the SGA.</p>
</li>
<li>
<p>If the limit <span class="italic">X</span> is less than the optimal value, then you would set <code>PGA_AGGREGATE_TARGET</code> to <span class="italic">X</span>. In <a href="#i49767">Example 7-8</a>, if you have only 2 GB to dedicate to PGA, set <code>PGA_AGGREGATE_TARGET</code> to 2 GB and accept a <code>cache</code> <code>hit</code> <code>percentage</code> of 75%.</p>
</li>
</ul>
</li>
</ol>
<p>Finally, like most statistics collected by Oracle Database that are cumulative since instance startup, you can take a snapshot of the view at the beginning and at the end of a time interval. You can then derive the predicted statistics for that time interval as follows:</p>
<pre>
         estd_overalloc_count = (difference in estd_overalloc_count between the two snapshots)
</pre>
<pre>
</pre>
<pre>
                                    (difference in bytes_processed between the two snapshots)
estd_pga_cache_hit_percentage = ----------------------------------------------------------------- 
                                (difference in bytes_processed + extra_bytes_rw  between the two snapshots )
</pre></div>
<!-- class="sect4" -->
<a id="i49911"></a>
<div id="PFGRF94371" class="sect4">
<h5 class="sect4"><span class="secnum">7.5.1.3.3</span> V$PGA_TARGET_ADVICE_HISTOGRAM</h5>
<p>This view predicts how the statistics displayed by the performance view <code>V$SQL_WORKAREA_HISTOGRAM</code> will be impacted if you change the value of the initialization parameter <code>PGA_AGGREGATE_TARGET</code>. You can use the dynamic view <code>V$PGA_TARGET_ADVICE_HISTOGRAM</code> to view detailed information on the predicted number of optimal, one-pass and multi-pass work area executions for the set of <code>PGA_AGGREGATE_TARGET</code> values you use for the prediction.</p>
<p>The <code>V$PGA_TARGET_ADVICE_HISTOGRAM</code> view is identical to the <code>V$SQL_WORKAREA_HISTOGRAM</code> view, with two additional columns to represent the <code>PGA_AGGREGATE_TARGET</code> values used for the prediction. Therefore, any query executed against the <code>V$SQL_WORKAREA_HISTOGRAM</code> view can be used on this view, with an additional predicate to select the desired value of <code>PGA_AGGREGATE_TARGET</code>.</p>
<div id="PFGRF94372" class="example">
<p class="titleinexample"><a id="sthref523"></a>Example 7-9 Querying V$PGA_TARGET_ADVICE_HISTOGRAM</p>
<p>The following query displays the predicted content of <code>V$SQL_WORKAREA_HISTOGRAM</code> for a value of the initialization parameter <code>PGA_AGGREGATE_TARGET</code> set to twice its current value.</p>
<pre>
SELECT LOW_OPTIMAL_SIZE/1024 low_kb, (HIGH_OPTIMAL_SIZE+1)/1024 high_kb, 
       estd_optimal_executions estd_opt_cnt, 
       estd_onepass_executions estd_onepass_cnt, 
       estd_multipasses_executions estd_mpass_cnt 
  FROM v$pga_target_advice_histogram 
 WHERE pga_target_factor = 2 
   AND estd_total_executions != 0 
 ORDER BY 1; 
</pre>
<p>The output of this query might look like the following.</p>
<pre>
LOW_KB   HIGH_KB   ESTD_OPTIMAL_CNT   ESTD_ONEPASS_CNT   ESTD_MPASS_CNT
------   -------   ----------------   ----------------   --------------
     8        16             156107                  0                0
    16        32                148                  0                0
    32        64                 89                  0                0
    64       128                 13                  0                0
   128       256                 58                  0                0
   256       512                 10                  0                0
   512      1024                653                  0                0
  1024      2048                530                  0                0
  2048      4096                509                  0                0
  4096      8192                227                  0                0
  8192     16384                176                  0                0
 16384     32768                133                 16                0
 32768     65536                 66                103                0
 65536    131072                 15                 47                0
131072    262144                  0                 48                0
262144    524288                  0                 23                0
</pre>
<p>The output shows that increasing <code>PGA_AGGREGATE_TARGET</code> by a factor of 2 will allow all work areas under 16 MB to execute in optimal mode.</p>
</div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i43571"></a>
<div id="PFGRF94373" class="sect3">
<h4 class="sect3"><span class="secnum">7.5.1.4</span> V$SYSSTAT and V$SESSTAT</h4>
<p>Statistics in the <code>V$SYSSTAT</code> and <code>V$SESSTAT</code> views show the total number of work areas executed with optimal memory size, one-pass memory size, and multi-pass memory size. These statistics are cumulative since the instance or the session was started.</p>
<p>The following query gives the total number and the percentage of times work areas were executed in these three modes since the instance was started:</p>
<pre>
SELECT name profile, cnt, decode(total, 0, 0, round(cnt*100/total)) percentage
    FROM (SELECT name, value cnt, (sum(value) over ()) total
    FROM V$SYSSTAT 
    WHERE name like 'workarea exec%');
</pre>
<p>The output of this query might look like the following:</p>
<pre>
PROFILE                                    CNT PERCENTAGE
----------------------------------- ---------- ----------
workarea executions - optimal             5395         95
workarea executions - onepass              284          5
workarea executions - multipass              0          0
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i55825"></a>
<div id="PFGRF94374" class="sect2">
<h3 class="sect2"><span class="secnum">7.5.2</span> Configuring OLAP_PAGE_POOL_SIZE</h3>
<p>The <code><a id="sthref524"></a>OLAP_PAGE_POOL_SIZE</code> initialization parameter specifies (in bytes) the maximum size of the paging cache to be allocated to an OLAP session.</p>
<p>For performance reasons, it is usually preferable to configure a small OLAP paging cache and set a larger default buffer pool with <code>DB_CACHE_SIZE</code>. An OLAP paging cache of 4 MB is fairly typical, with 2 MB used for systems with limited memory.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink OLAUG" href="../../olap.112/e17123/toc.htm"><span class="italic">Oracle OLAP User's Guide</span></a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BGBCABED"></a>
<div id="PFGRF987" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">7.6</span> Managing the Server and Client Result Caches</h2>
<p>A <span class="bold">result cache</span> is an area of memory, either in the SGA or client application memory, that stores the result of a database query or query block for reuse. The cached rows are shared across statements and sessions unless they become stale.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BGBIIBGE">Managing the Server Result Cache</a></p>
</li>
<li>
<p><a href="#BGBBIACC">Managing the Client Result Cache</a></p>
</li>
<li>
<p><a href="#BGBGEACF">Managing Memory for the Server Result Cache</a></p>
</li>
<li>
<p><a href="#BGBEGBBJ">Specifying Queries for Result Caching</a></p>
</li>
<li>
<p><a href="#BGBGFDAJ">Requirements for the Result Cache</a></p>
</li>
<li>
<p><a href="#BGBFHGIG">Accessing Result Cache Information</a></p>
</li>
</ul>
<a id="BGBIIBGE"></a>
<div id="PFGRF986" class="sect2">
<h3 class="sect2"><span class="secnum">7.6.1</span> Managing the Server Result Cache<a id="sthref525"></a></h3>
<p>The <span class="bold">server result cache</span> is a memory pool within the shared pool. This pool contains a <span class="bold">SQL query result cache</span>, which stores results of SQL queries, and a <span class="bold">PL/SQL function result cache</span>, which stores values returned by PL/SQL functions.</p>
<p>OLAP applications can benefit significantly from the use of the server result cache. The benefits highly depend on the application. Good candidates for caching are queries that access a high number of rows but return a small number, as in a data warehouse. For example, you can use advanced query rewrite with equivalences to create materialized views that materialize queries in the result cache instead of using tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT1919" href="../../server.112/e40540/memory.htm#CNCPT1919"><span class="italic">Oracle Database Concepts</span></a> for a conceptual overview of the server result cache</p>
</li>
<li>
<p><a class="olink LNPLS00817" href="../../appdev.112/e25519/subprograms.htm#LNPLS00817"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> to learn how to use the PL/SQL function result cache</p>
</li>
<li>
<p><a class="olink DWHSG0807" href="../../server.112/e25554/qradv.htm#DWHSG0807"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for examples of how to use the result cache and advance query rewrite with equivalences</p>
</li>
</ul>
</div>
<div id="PFGRF982" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref526"></a>
<h4 class="sect3"><span class="secnum">7.6.1.1</span> How the Server Result Cache Works</h4>
<p>When a query executes, the database looks in the cache memory to determine whether the result exists in the cache. If the result exists, then the database retrieves the result from memory instead of executing the query. If the result is not cached, then the database executes the query, returns the result as output, and stores the result in the result cache.</p>
<p>When users execute queries and functions repeatedly, the database retrieves rows from the cache, decreasing response time. Cached results become invalid when data in dependent database objects is modified.</p>
<p><a href="#BGBGADAA">Example 7-10</a> queries <code>hr.employees</code> and uses the <code>RESULT_CACHE</code> hint to retrieve rows from the server result cache. <a href="#BGBGADAA">Example 7-10</a> includes a portion of the execution plan, which shows that in step 1 the results are retrieved directly from the cache. The value in the <code>Name</code> column is the cache ID of the result.</p>
<div id="PFGRF95091" class="example">
<p class="titleinexample"><a id="BGBGADAA"></a>Example 7-10 Using the RESULT_CACHE Hint in a Query</p>
<pre>
SELECT   /*+ RESULT_CACHE */ department_id, AVG(salary) 
FROM     hr.employees 
GROUP BY department_id;
.
.
.
--------------------------------------------------------------
| Id | Operation          | Name                       |Rows
--------------------------------------------------------------
| 0 | SELECT STATEMENT    |                            | 11
| 1 |  <span class="bold">RESULT CACHE</span>       | <span class="bold">8fpza04gtwsfr6n595au15yj4y</span> |
| 2 |   HASH GROUP BY     |                            | 11
| 3 |    TABLE ACCESS FULL| EMPLOYEES                  | 107
--------------------------------------------------------------
</pre></div>
<!-- class="example" -->
<p>As shown in <a href="#BGBEEIHB">Example 7-11</a>, after the query is executed you can obtain detailed statistics about the cached result by querying <code>V$RESULT_CACHE_OBJECTS</code>, where the cache ID obtained from the explain plan is equal to the <code>CACHE_ID</code> value.</p>
<div id="PFGRF95092" class="example">
<p class="titleinexample"><a id="BGBEEIHB"></a>Example 7-11 Querying Statistics for Cached Results</p>
<pre>
SELECT ID, TYPE, CREATION_TIMESTAMP, BLOCK_COUNT, COLUMN_COUNT, 
       PIN_COUNT, ROW_COUNT 
FROM   V$RESULT_CACHE_OBJECTS 
WHERE  CACHE_ID = '8fpza04gtwsfr6n595au15yj4y';
.
.
.
        ID TYPE       CREATION_ BLOCK_COUNT COLUMN_COUNT  PIN_COUNT  ROW_COUNT
---------- ---------- --------- ----------- ------------ ---------- ----------
         2 Result     06-MAR-09           1            2          0         12
</pre></div>
<!-- class="example" -->
<p><a href="#BGBEDFGA">Example 7-12</a> uses the <code>RESULT_CACHE</code> hint within a <code>WITH</code> clause view. The example shows a portion of the execution plan. In step 3, the <code>RESULT CACHE</code> Operation indicates that the <code>summary</code> view results are retrieved directly from the cache.</p>
<div id="PFGRF95093" class="example">
<p class="titleinexample"><a id="BGBEDFGA"></a>Example 7-12 Using the RESULT_CACHE Hint in a WITH Clause View</p>
<pre>
WITH summary AS
( SELECT /*+ RESULT_CACHE */ department_id, avg(salary) avg_sal
  FROM   hr.employees
  GROUP BY department_id )
SELECT d.*, avg_sal
FROM   hr.departments d, summary s
WHERE  d.department_id = s.department_id;
.
.
.
---------------------------------------------------------------------------------------------------
| Id  | Operation             | Name                       | Rows | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |                            |   11 |   517 |     7  (29)| 00:00:01 |
|*  1 |  HASH JOIN            |                            |   11 |   517 |     7  (29)| 00:00:01 |
|   2 |   VIEW                |                            |   11 |   286 |     4  (25)| 00:00:01 |
|   3 |    <span class="bold">RESULT CACHE</span>       | <span class="bold">8nknvkh64ctmz94a5muf2tyb8r</span> |      |       |            |          |
|   4 |     HASH GROUP BY     |                            |   11 |    77 |     4  (25)| 00:00:01 |
|   5 |      TABLE ACCESS FULL| EMPLOYEES                  |  107 |   749 |     3   (0)| 00:00:01 |
|   6 |   TABLE ACCESS FULL   | DEPARTMENTS                |   27 |   567 |     2   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------------
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="PFGRF981" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref527"></a>
<h4 class="sect3"><span class="secnum">7.6.1.2</span> Server Result Cache Initialization Parameters</h4>
<p>The following database initialization parameters control the server result cache:</p>
<ul>
<li>
<p><code>RESULT_CACHE_MAX_SIZE</code></p>
<p>This parameter sets the memory allocated to the server result cache. The server result cache is enabled unless you set this parameter to <code>0</code>, in which case the cache is disabled.</p>
</li>
<li>
<p><code>RESULT_CACHE_MAX_RESULT</code></p>
<p>This parameter sets the maximum amount of server result cache memory that can be used for a single result. The default is 5%, but you can specify any percentage value between <code>1</code> and <code>100</code>. You can set this parameter at the system or session level.</p>
</li>
<li>
<p><code>RESULT_CACHE_REMOTE_EXPIRATION</code></p>
<p>This parameter specifies the expiration time for a result in the server result cache that depends on remote database objects. The default value is <code>0</code> minutes, which implies that results using remote objects should not be cached.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use a non zero value for this parameter, DML on the remote database does not invalidate the server result cache.</div>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for details about the server result cache initialization parameters</div>
</div>
<!-- class="sect3" -->
<a id="BGBGEACF"></a>
<div id="PFGRF980" class="sect3">
<h4 class="sect3"><span class="secnum">7.6.1.3</span> Managing Memory for the Server Result Cache</h4>
<p>You can manage memory for the server result cache by setting database initialization parameters and by using the <code><a id="sthref528"></a><a id="sthref529"></a>DBMS_RESULT_CACHE</code> package.</p>
<a id="BGBEDJGF"></a>
<div id="PFGRF94325" class="sect4">
<h5 class="sect4"><span class="secnum">7.6.1.3.1</span> Managing Server Result Cache Memory with Initialization Parameters</h5>
<p>By default, on database startup, Oracle Database allocates memory to the server result cache in the shared pool. The memory size allocated depends on the memory size of the shared pool and the memory management system. The database uses the following algorithm:</p>
<ul>
<li>
<p>When using the <code>MEMORY_TARGET</code> initialization parameter to specify the memory allocation, Oracle Database allocates 0.25% of <code>MEMORY_TARGET</code> to the result cache.</p>
</li>
<li>
<p>When you set the size of the shared pool using the <code>SGA_TARGET</code> initialization parameter, Oracle Database allocates 0.50% of <code>SGA_TARGET</code> to the result cache.</p>
</li>
<li>
<p>If you specify the size of the shared pool using the <code>SHARED_POOL_SIZE</code> initialization parameter, then Oracle Database allocates 1% of the shared pool size to the result cache.</p>
</li>
</ul>
<p>The size of the server result cache grows until reaching the maximum size. Query results larger than the available space in the cache are not cached. The database employs an LRU algorithm to age out cached results, but does not otherwise automatically release memory from the server result cache. You can use the <code>DBMS_RESULT_CACHE.FLUSH</code> procedure to purge memory.</p>
<p>You can change the memory allocated to the result cache by setting the <code><a id="sthref530"></a>RESULT_CACHE_MAX_SIZE</code> initialization parameter. In an Oracle RAC environment, the result cache itself is specific to each instance and can be sized differently on each instance. However, invalidations work across instances. To disable the server result cache in a cluster, you must explicitly set this parameter to <code>0</code> for each instance startup.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Database will not allocate more than 75% of the shared pool to the server result cache.</div>
</div>
<!-- class="sect4" -->
<div id="PFGRF94318" class="sect4"><a id="sthref531"></a>
<h5 class="sect4"><span class="secnum">7.6.1.3.2</span> Managing Server Result Cache Memory with DBMS_RESULT_CACHE</h5>
<p>The <code><a id="sthref532"></a><a id="sthref533"></a>DBMS_RESULT_CACHE</code> package provides statistics, information, and operators that enable you to manage memory allocation for the server result cache. You can use the <code>DBMS_RESULT_CACHE</code> package to perform operations such as bypassing the cache, retrieving statistics on the cache memory usage, flushing the cache, and so on.</p>
<p>For example, use the following SQL procedure to view the memory allocation statistics for the result cache:</p>
<pre>
SQLSET SERVEROUTPUT ON
EXECUTE DBMS_RESULT_CACHE.MEMORY_REPORT
</pre>
<p>The output of this command will be similar to the following:</p>
<pre>
R e s u l t  C a c h e  M e m o r y  R e p o r t
[Parameters]
Block Size = 1024 bytes
Maximum Cache Size = 950272 bytes (928 blocks)
Maximum Result Size = 47104 bytes (46 blocks)
[Memory]
Total Memory = 46340 bytes [0.048% of the Shared Pool]
... Fixed Memory = 10696 bytes [0.011% of the Shared Pool]
... State Object Pool = 2852 bytes [0.003% of the Shared Pool]
... Cache Memory = 32792 bytes (32 blocks) [0.034% of the Shared Pool]
....... Unused Memory = 30 blocks
....... Used Memory = 2 blocks
........... Dependencies = 1 blocks
........... Results = 1 blocks
............... SQL = 1 blocks
 
PL/SQL procedure successfully completed. 
</pre>
<p>To remove all existing results and clear the result cache memory, use the command:</p>
<pre>
EXECUTE DBMS_RESULT_CACHE.FLUSH
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information on the <code>DBMS_RESULT_CACHE</code> package</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBBIACC"></a>
<div id="PFGRF985" class="sect2">
<h3 class="sect2"><span class="secnum">7.6.2</span> Managing the Client Result Cache</h3>
<p>The <span class="bold">Oracle Call Interface (OCI) client result cache</span> is a memory area inside a client process that caches SQL query result sets for OCI applications. This client cache exists for each client process and is shared by all sessions inside the process. Oracle Database recommends client result caching for queries of read-only or read-mostly tables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The client result cache is distinct from the server result cache, which resides in the SGA. When client result caching is enabled, the query result set can be cached on the client, server, or both. Client caching can be enabled even if the server result cache is disabled.</div>
<p>OCI drivers such as OCCI, the JDBC OCI driver, and ODP.NET support client result caching. Performance benefits of the client result cache include:</p>
<ul>
<li>
<p>Reduced query response time</p>
<p>When queries are executed repeatedly, the application retrieves results directly from the client cache memory, resulting in faster query response time.</p>
</li>
<li>
<p>More efficient use of database resources</p>
<p>The reduction in server round trips can result in huge performance savings for server resources, for example, server CPU and I/O. These resources are freed for other tasks, thereby making the server more scalable.</p>
</li>
<li>
<p>Reduced memory cost</p>
<p>The cache uses client memory that may be cheaper than server memory.</p>
</li>
</ul>
<div id="PFGRF960" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref534"></a>
<h4 class="sect3"><span class="secnum">7.6.2.1</span> How the Client Result Cache Works</h4>
<p>The client result cache stores the results of the outermost query, which are the columns defined by the OCI application. Subqueries and query blocks are not cached.</p>
<p><a href="#BGBBHCFE">Figure 7-4</a> shows a client process with a database login session. This client process has one client result cache shared among multiple application sessions running in the client process. If the first application session runs a query, then it retrieves rows from the database and caches them in the client result cache. If other application sessions run the same query, then they also retrieve rows from the client result cache.</p>
<div id="PFGRF95094" class="figure">
<p class="titleinfigure"><a id="BGBBHCFE"></a>Figure 7-4 Client Result Cache</p>
<img width="608" height="297" src="img/pfgrf229.gif" alt="Description of Figure 7-4 follows" /><br />
<a id="sthref535" href="img_text/pfgrf229.htm">Description of "Figure 7-4 Client Result Cache"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The client result cache transparently keeps the result set consistent with session state or database changes that affect it. When a transaction changes the data or metadata of database objects used to build the cached result, the database sends an invalidation to the OCI client on its next round trip to the server.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI10103" href="../../appdev.112/e10646/oci10new.htm#LNOCI10103"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for details about the client result cache</div>
</div>
<!-- class="sect3" -->
<div id="PFGRF961" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref536"></a>
<h4 class="sect3"><span class="secnum">7.6.2.2</span> Client Result Cache Initialization Parameters</h4>
<p><a href="#BGBFGHFI">Table 7-4</a> lists the database initialization parameters that enable or influence the behavior of the client result cache.</p>
<div id="PFGRF95095" class="tblruleformal">
<p class="titleintable"><a id="sthref537"></a><a id="BGBFGHFI"></a>Table 7-4 Client Result Cache Initialization Parameters</p>
<table class="cellalignment1691" title="Client Result Cache Initialization Parameters" summary="Client Result Cache Initialization Parameters" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t72">Initialization Parameter</th>
<th class="cellalignment1687" id="r1c2-t72">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t72" headers="r1c1-t72">
<p><code>CLIENT_RESULT_CACHE_SIZE</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t72 r1c2-t72">
<p>Sets the maximum size of the client result cache for each client process. To enable the client result cache, set the size to <code>32768</code> bytes or greater. A lesser value, including the default of <code>0</code>, disables the client result cache.</p>
<p><span class="bold">Note:</span> If the <code>CLIENT_RESULT_CACHE_SIZE</code> setting disables the client cache, then a client node cannot enable it. If the <code>CLIENT_RESULT_CACHE_SIZE</code> setting enables the client cache, however, then a client node can override the setting. For example, a client node can disable client result caching or increase the size of its cache.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t72" headers="r1c1-t72">
<p><code>CLIENT_RESULT_CACHE_LAG</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t72 r1c2-t72">
<p>Specifies the amount of lag time for the client result cache. If the OCI application performs no database calls for a period, then the <span class="bold">client cache lag</span> setting forces the next statement execution call to check for validations.</p>
<p>If the OCI application accesses the database infrequently, then setting this parameter to a low value results in more round trips from the OCI client to the database to keep the client result cache synchronized with the database. The client cache lag is specified in milliseconds, with a default value of <code>3000</code> (3 seconds).</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t72" headers="r1c1-t72">
<p><code>COMPATIBLE</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t72 r1c2-t72">
<p>Specifies the release with which Oracle Database must maintain compatibility. For the client result cache to be enabled, this parameter must be set to <code>11.0.0.0</code> or higher. For client caching on views, this parameter must be set to <code>11.2.0.0.0</code> or higher.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<p>For the client result cache, an optional client configuration file overrides cache parameters set in the server parameter file. Note that you can only set the client result cache lag with a database initialization parameter.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for details about the client result cache initialization parameters</p>
</li>
<li>
<p><a class="olink LNOCI10103" href="../../appdev.112/e10646/oci10new.htm#LNOCI10103"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for parameters that you can set in a client configuration file</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBEGBBJ"></a>
<div id="PFGRF984" class="sect2">
<h3 class="sect2"><span class="secnum">7.6.3</span> Specifying Queries for Result Caching</h3>
<p>If the server or client result cache is enabled, then Oracle Database gives you control over which queries are eligible to be cached.</p>
<div id="PFGRF979" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref538"></a>
<h4 class="sect3"><span class="secnum">7.6.3.1</span> About the Result Cache Mode</h4>
<p>The <span class="bold">result cache mode</span> is a database setting that determines which queries are eligible to store result sets in the client and server result caches. Oracle Database recommends that applications cache results for queries of read-only or read-mostly database objects.</p>
<p>The <a id="sthref539"></a><code>RESULT_CACHE_MODE</code> initialization parameter determines the result cache behavior. <a href="#BGBGCGFH">Table 7-5</a> describes the values for this initialization parameter.</p>
<div id="PFGRF95096" class="tblruleformal">
<p class="titleintable"><a id="sthref540"></a><a id="BGBGCGFH"></a>Table 7-5 Values for the RESULT_CACHE_MODE Initialization Parameter</p>
<table class="cellalignment1691" title="Values for the RESULT_CACHE_MODE Initialization Parameter" summary="Values for RESULT_CACHE_MODE" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t74">Value</th>
<th class="cellalignment1687" id="r1c2-t74">Default</th>
<th class="cellalignment1687" id="r1c3-t74">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t74" headers="r1c1-t74">
<p><code>MANUAL</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t74 r1c2-t74">
<p>Yes</p>
</td>
<td class="cellalignment1688" headers="r2c1-t74 r1c3-t74">
<p>Query results can only be stored in the result cache by using a query hint or table annotation. This is the recommended value.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t74" headers="r1c1-t74">
<p><code>FORCE</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t74 r1c2-t74">
<p>No</p>
</td>
<td class="cellalignment1688" headers="r3c1-t74 r1c3-t74">
<p>All results are stored in the result cache. If a query result is not in the cache, then the database executes the query and stores the result in the cache. Subsequent executions of the same statement, including the result cache hint, retrieve data from the cache.</p>
<p>Sessions uses these results if possible. To exclude query results from the cache, you must use the <code>/*+ NO_RESULT_CACHE */</code> query hint.</p>
<p><span class="bold">Note:</span> <code>FORCE</code> mode is not recommended because the database and clients attempt to cache all queries, which can create significant performance and latching overhead. Moreover, because queries that call non-deterministic PL/SQL functions are also cached, enabling the result cache in such a broad-based manner may cause material changes to the results.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<p>You can set the <code>RESULT_CACHE_MODE</code> initialization parameter for the instance (<code>ALTER SYSTEM</code>), session (<code>ALTER SESSION</code>), or in the server parameter file.</p>
<p>If a query is eligible for caching, then the application checks the result cache to determine whether the query result set exists in the cache. If it exists, then the result is retrieved directly from the result cache. Otherwise, the database executes the query and returns the result as output and stores it in the result cache.</p>
<p>When the result cache is enabled, the database also caches queries that call non-deterministic PL/SQL functions. When caching <code>SELECT</code> statements that call such functions, the result cache tracks data dependencies for the PL/SQL functions and the database objects. However, if the function uses data that are not being tracked (such as sequences, <code>SYSDATE</code>, <code>SYS_CONTEXT</code>, and package variables), using the result cache on queries that call this function can produce stale results. In this regard, the behavior of the result cache is identical to caching PL/SQL functions. Therefore, always consider data accuracy, as well as performance, when choosing to enable the result cache.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN10270" href="../../server.112/e40402/initparams221.htm#REFRN10270"><span class="italic">Oracle Database Reference</span></a> to learn about the <code>RESULT_CACHE_MODE</code> initialization parameter</div>
</div>
<!-- class="sect3" -->
<a id="BGBFAFHA"></a>
<div id="PFGRF978" class="sect3">
<h4 class="sect3"><span class="secnum">7.6.3.2</span> Using SQL Result Cache Hints</h4>
<p>You can use <span class="bold">result cache hints</span> at the application level to control caching behavior. The SQL result cache hints take precedence over the result cache mode and result cache table annotations.</p>
<p>When the result cache mode is <code>MANUAL</code>, the <code>/*+ RESULT_CACHE */</code> hint instructs the database to cache the results of a query block and to use the cached results in future executions. <a href="#BGBIICBE">Example 7-13</a> instructs the database to cache rows for a query of the <code>sales</code> table.</p>
<div id="PFGRF95097" class="example">
<p class="titleinexample"><a id="BGBIICBE"></a>Example 7-13 RESULT_CACHE Hint</p>
<pre>
SELECT   /*+ RESULT_CACHE */ prod_id, SUM(amount_sold)
FROM     sales 
GROUP BY prod_id
ORDER BY prod_id;
</pre></div>
<!-- class="example" -->
<p>The <code>/*+ NO_RESULT_CACHE */</code> hint instructs the database <span class="italic">not</span> to cache the results in either the server or client result caches. <a href="#BGBHDGFD">Example 7-14</a> instructs the database not to cache rows for a query of the <code>sales</code> table.</p>
<div id="PFGRF95098" class="example">
<p class="titleinexample"><a id="BGBHDGFD"></a>Example 7-14 NO_RESULT_CACHE Hint</p>
<pre>
SELECT   /*+ NO_RESULT_CACHE */ prod_id, SUM(amount_sold) 
FROM     sales 
GROUP BY prod_id
ORDER BY prod_id;
</pre></div>
<!-- class="example" -->
<div id="PFGRF95099" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref541"></a>
<h5 class="sect4"><span class="secnum">7.6.3.2.1</span> RESULT_CACHE Hint in Query Blocks: Example</h5>
<p>The <code>RESULT_CACHE</code> hint applies only to the query block in which the hint is specified. If the hint is specified only in a view, then only these results are cached. Note the following characteristics of view caching:</p>
<ul>
<li>
<p>The view must be a standard view (a view created with the <code>CREATE ... VIEW</code> statement), an inline view specified in the <code>FROM</code> clause of a <code>SELECT</code> statement, or an inline view created with the <code>WITH</code> clause.</p>
</li>
<li>
<p>The result of a view query with a <span class="bold">correlated column</span>, which is a reference to an outer query block, cannot be cached.</p>
</li>
<li>
<p>Query results are stored in the server result cache, not the client result cache.</p>
</li>
<li>
<p>A caching view is not merged into its outer (or referring) query block. Adding the <code>RESULT_CACHE</code> hint to inline views disables optimizations between the outer query and inline view to maximize reusability of the cached result.</p>
</li>
</ul>
<p><a href="#BGBIDAJH">Example 7-15</a> queries the inline view <code>view1</code>. The <code>SELECT</code> from <code>view1</code> is the outer block, whereas the <code>SELECT</code> from <code>employees</code> is the inner block. Because the <code>RESULT_CACHE</code> hint is specified only in the inner block, the results of the outer query are not cached. The results of the inner query are stored in the server result cache.</p>
<div id="PFGRF95100" class="example">
<p class="titleinexample"><a id="BGBIDAJH"></a>Example 7-15 RESULT_CACHE Hint Specified in Inline View</p>
<pre>
SELECT * 
FROM   ( SELECT /*+ RESULT_CACHE */ department_id, manager_id, count(*) count 
         FROM   hr.employees 
         GROUP BY department_id, manager_id ) view1 
WHERE  department_id = 30;
</pre></div>
<!-- class="example" -->
<p>Assume that the same session runs the statement in <a href="#BGBHBHBD">Example 7-16</a>. This statement queries <code>view2</code>. Because the <code>RESULT_CACHE</code> hint is specified only in the query block in the <code>WITH</code> clause, the results of the <code>employees</code> query are eligible to be cached. Because <a href="#BGBIDAJH">Example 7-15</a> cached these results, the <code>SELECT</code> statement in the <code>WITH</code> clause in <a href="#BGBHBHBD">Example 7-16</a> can retrieve the cached rows.</p>
<div id="PFGRF95101" class="example">
<p class="titleinexample"><a id="BGBHBHBD"></a>Example 7-16 RESULT_CACHE Hint Specified in WITH View</p>
<pre>
WITH view2 AS
( SELECT /*+ RESULT_CACHE */ department_id, manager_id, count(*) count 
  FROM hr.employees 
  GROUP BY department_id, manager_id ) 
SELECT *
FROM   view2 
WHERE  count BETWEEN 1 and 5;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF20004" href="../../server.112/e41084/sql_elements006.htm#SQLRF20004"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code>RESULT_CACHE</code> and <code>NO_RESULT_CACHE</code> hints</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BGBCHGBD"></a>
<div id="PFGRF977" class="sect3">
<h4 class="sect3"><span class="secnum">7.6.3.3</span> Using Result Cache Table Annotations</h4>
<p>You can use <span class="bold">table annotations</span> to control result caching. Table annotations are in effect only for the whole query, not for query segments. The primary benefit of these annotations is avoiding the necessity of adding result cache hints to queries at the application level.</p>
<p>A table annotation has a lower precedence than a SQL hint. Thus, you can override table and session settings by using hints at the query level. Permitted values for the <code>RESULT_CACHE</code> table annotation are as follows:</p>
<ul>
<li>
<p><code>DEFAULT</code></p>
<p>If at least one table in a query is set to <code>DEFAULT</code>, then result caching is <span class="italic">not</span> enabled at the table level for this query, unless the <code>RESULT_CACHE_MODE</code> initialization parameter is set to <code>FORCE</code> or the <code>RESULT_CACHE</code> hint is specified. This is the default value.</p>
</li>
<li>
<p><code>FORCE</code></p>
<p>If all the tables of a query are marked as <code>FORCE</code>, then the query result is considered for caching. The table annotation <code>FORCE</code> takes precedence over the <code>RESULT_CACHE_MODE</code> parameter value of <code>MANUAL</code> set at the session level.</p>
</li>
</ul>
<p><a href="#BGBJIGAB">Example 7-17</a> shows the creation of the <code>sales</code> table with a table annotation that disables result caching. The example also shows a query of <code>sales</code>, whose results are not considered for caching because of the table annotation.</p>
<div id="PFGRF95102" class="example">
<p class="titleinexample"><a id="BGBJIGAB"></a>Example 7-17 DEFAULT Table Annotation</p>
<pre>
CREATE TABLE sales (...) RESULT_CACHE (MODE DEFAULT);

SELECT   prod_id, SUM(amount_sold)
FROM     sales 
GROUP BY prod_id 
ORDER BY prod_id;
</pre></div>
<!-- class="example" -->
<p>Assume that later you decide to force result caching for the <code>sales</code> table as shown in <a href="#BGBEHFAH">Example 7-18</a>. This example includes two queries of <code>sales</code>. The first query, which is frequently used and returns few rows, is eligible for caching because of the table annotation. The second query, which is a one-time query that returns many rows, uses a hint to prevent result caching.</p>
<div id="PFGRF95103" class="example">
<p class="titleinexample"><a id="BGBEHFAH"></a>Example 7-18 FORCE Table Annotation</p>
<pre>
ALTER TABLE sales RESULT_CACHE (MODE FORCE);

SELECT   prod_id, SUM(amount_sold)
FROM     sales 
GROUP BY prod_id 
HAVING   prod_id=136;

SELECT   /*+ NO_RESULT_CACHE */ * 
FROM     sales
ORDER BY time_id DESC;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code>CREATE TABLE</code> syntax and semantics</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBGFDAJ"></a>
<div id="PFGRF983" class="sect2">
<h3 class="sect2"><span class="secnum">7.6.4</span> Requirements for the Result Cache</h3>
<p>If you enable the result cache, then this setting does not <span class="italic">guarantee</span> that a specific result set will be included in the client or server cache.</p>
<div id="PFGRF976" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref542"></a>
<h4 class="sect3"><span class="secnum">7.6.4.1</span> Read Consistency Requirements for the Result Cache</h4>
<p>For a snapshot to be reusable, it must have read consistency. One of the following statements must be true for a result set to be eligible to be cached:</p>
<ul>
<li>
<p>The read-consistent snapshot used to build the result must retrieve the most current committed state of the data.</p>
</li>
<li>
<p>The query points to an explicit point in time using flashback query.</p>
</li>
</ul>
<p>If the current session has an active transaction referencing objects in a query, then the results from this query are not eligible for caching.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF975" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref543"></a>
<h4 class="sect3"><span class="secnum">7.6.4.2</span> Additional Requirements for the Result Cache</h4>
<p>You cannot cache results when the following objects or functions are in a query:</p>
<ul>
<li>
<p>Temporary tables and tables in the <code>SYS</code> or <code>SYSTEM</code> schemas</p>
</li>
<li>
<p>Sequence <code>CURRVAL</code> and <code>NEXTVAL</code> pseudo columns</p>
</li>
<li>
<p>SQL functions <code>CURRENT_DATE</code>, <code>CURRENT_TIMESTAMP</code>, <code>LOCAL_TIMESTAMP</code>, <code>USERENV/SYS_CONTEXT</code> (with non-constant variables), <code>SYS_GUID</code>, <code>SYSDATE</code>, and <code>SYS_TIMESTAMP</code></p>
</li>
</ul>
<p>The client result cache has additional limitations for result caching. Refer to <a class="olink LNOCI10103" href="../../appdev.112/e10646/oci10new.htm#LNOCI10103"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for details.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF974" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref544"></a>
<h4 class="sect3"><span class="secnum">7.6.4.3</span> Query Parameter Requirements for the Result Cache</h4>
<p>Cache results can be reused when they are <span class="bold">parameterized</span> with variable values when queries are equivalent and the parameter values are the same. Different values or bind variable names may cause cache misses. Results are parameterized if any of the following constructs are used in the query:</p>
<ul>
<li>
<p>Bind variables</p>
</li>
<li>
<p>The SQL functions <code>DBTIMEZONE</code>, <code>SESSIONTIMEZONE</code>, <code>USERENV/SYS_CONTEXT</code> (with constant variables), <code>UID</code>, and <code>USER</code></p>
</li>
<li>
<p>NLS parameters</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBFHGIG"></a>
<div id="PFGRF973" class="sect2">
<h3 class="sect2"><span class="secnum">7.6.5</span> Accessing Result Cache Information</h3>
<p>You can query database views and tables to obtain information about the server and client result caches. <a href="#BGBFDEED">Table 7-6</a> describes the most useful views and tables. The description column specifies the result cache to which they are applicable.</p>
<div id="PFGRF95104" class="tblruleformal">
<p class="titleintable"><a id="sthref545"></a><a id="BGBFDEED"></a>Table 7-6 Views and Tables Related to the Server and Client Result Caches</p>
<table class="cellalignment1691" title="Views and Tables Related to the Server and Client Result Caches" summary="Result cache views" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t78">View/Table</th>
<th class="cellalignment1687" id="r1c2-t78">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t78" headers="r1c1-t78">
<p><code>V$RESULT_CACHE_STATISTICS</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t78 r1c2-t78">
<p>Lists various server result cache settings and memory usage statistics.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t78" headers="r1c1-t78">
<p><code>V$RESULT_CACHE_MEMORY</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t78 r1c2-t78">
<p>Lists all the memory blocks in the server result cache and their corresponding statistics.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t78" headers="r1c1-t78">
<p><code>V$RESULT_CACHE_OBJECTS</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t78 r1c2-t78">
<p>Lists all the objects whose results are in the server result cache along with their attributes.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t78" headers="r1c1-t78">
<p><code>V$RESULT_CACHE_DEPENDENCY</code></p>
</td>
<td class="cellalignment1688" headers="r5c1-t78 r1c2-t78">
<p>Lists the dependency details between the results in the server cache and dependencies among these results.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r6c1-t78" headers="r1c1-t78">
<p><code>CLIENT_RESULT_CACHE_STATS$</code></p>
</td>
<td class="cellalignment1688" headers="r6c1-t78 r1c2-t78">
<p>Stores cache settings and memory usage statistics for the client result caches obtained from the OCI client processes. This statistics table has entries for each client process that is using result caching. After the client processes terminate, the database removes their entries from this table. The client table lists information similar to <code>V$RESULT_CACHE_STATISTICS</code>.</p>
<p><span class="bold">See Also:</span> <a class="olink REFRN29085" href="../../server.112/e40402/statviews_2156.htm#REFRN29085"><span class="italic">Oracle Database Reference</span></a> for details about <code>CLIENT_RESULT_CACHE_STATS$</code></p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r7c1-t78" headers="r1c1-t78">
<p><code>DBA_TABLES</code>, <code>USER_TABLES</code>, <code>ALL_TABLES</code></p>
</td>
<td class="cellalignment1688" headers="r7c1-t78 r1c2-t78">
<p>Includes a <code>RESULT_CACHE</code> column that shows the result cache mode annotation for the table. If the table has not been annotated, then this column shows <code>DEFAULT</code>. This column applies to both server and client result caching.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<p>The following sample query monitors the server result cache statistics (sample output included):</p>
<pre>
COLUMN NAME FORMAT A20
SELECT NAME, VALUE 
FROM   V$RESULT_CACHE_STATISTICS;
</pre>
<pre>
NAME                          VALUE
--------------------     ----------
Block Size (Bytes)             1024
Block Count Maximum            3136
Block Count Current              32
Result Size Maximum (Blocks)    156
Create Count Success              2
Create Count Failure              0
Find Count                        0
Invalidation Count                0
Delete Count Invalid              0
Delete Count Valid                0
</pre>
<p>The following sample query monitors the client result cache statistics (sample output included):</p>
<pre>
SELECT STAT_ID, SUBSTR(NAME,1,20), VALUE, CACHE_ID
FROM   CLIENT_RESULT_CACHE_STATS$ 
ORDER BY CACHE_ID, STAT_ID;

STAT_ID    NAME OF STATISTICS      VALUE   CACHE_ID
=======    ==================      =====   ========
    1      Block Size               256         124
    2      Block Count Max          256         124
    3      Block Count Current      128         124
    4      Hash Bucket Count       1024         124
    5      Create Count Success      10         124
    6      Create Count Failure       0         124
    7      Find Count                12         124
    8      Invalidation Count         8         124
    9      Delete Count Invalid       0         124
   10      Delete Count Valid         0         124
</pre>
<p>The <code>CLIENT_RESULT_CACHE_STATS$</code> table has statistics entries for each active client process performing client result caching. Every client process has a unique cache ID. To find the client connection information (for example, process IDs) for the sessions performing client caching, do the following:</p>
<ul>
<li>
<p>Obtain the session IDs from <code>GV$SESSION_CONNECT_INFO</code> for the <code>CLIENT_REGID</code> that exists in <code>CLIENT_RESULT_CACHE_STATS$</code> (the column name is <code>CACHE_ID</code>)</p>
</li>
<li>
<p>Query the relevant columns from <code>GV$SESSION_CONNECT_INFO</code> and <code>GV$SESSION</code></p>
</li>
</ul>
<p>For both client and server result cache statistics, a database that makes good use of result caching should show relatively low values for <code>Create Count Failure</code> and <code>Delete Count Valid</code>, while showing relatively high values for <code>Find Count</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for details about these views</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1679">
<tr>
<td class="cellalignment1688">
<table class="cellalignment1684">
<tr>
<td class="cellalignment1683"><a href="diag.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1683"><a href="iodesign.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1690">
<table class="cellalignment1682">
<tr>
<td class="cellalignment1683"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1683"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1683"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1683"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1683"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1683"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
