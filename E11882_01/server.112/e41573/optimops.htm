<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>The Query Optimizer</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-06-30T4:25:6Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Performance Tuning Guide" />
<meta name="dcterms.identifier" content="E41573-04" />
<meta name="dcterms.isVersionOf" content="PFGRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="part4.htm" title="Previous" type="text/html" />
<link rel="Next" href="ex_plan.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41573.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">19/31</span> <!-- End Header -->
<div id="PFGRF001" class="chapter"><a id="g92116"></a> <a id="i21299"></a>
<h1 class="chapter"><span class="secnum">11</span> The Query Optimizer</h1>
<p>This chapter discusses SQL processing, optimization methods, and how the <span class="bold">query optimizer</span> (usually called the <span class="bold">optimizer</span>) chooses a specific plan to execute SQL.</p>
<p>The chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i82005">Overview of the Query Optimizer</a></p>
</li>
<li>
<p><a href="#i82080">Overview of Optimizer Access Paths</a></p>
</li>
<li>
<p><a href="#i51523">Overview of Joins</a></p>
</li>
<li>
<p><a href="#i82029">Reading and Understanding Execution Plans</a></p>
</li>
<li>
<p><a href="#BABDECGJ">Controlling Optimizer Behavior</a></p>
</li>
</ul>
<a id="i82005"></a>
<div id="PFGRF94581" class="sect1">
<h2 class="sect1"><span class="secnum">11.1</span> Overview of the Query Optimizer</h2>
<p>The <a href="glossary.htm#BGBBIBBF"><span class="xreftitlebold">optimizer</span></a> is built-in software that determines the most efficient way to execute a SQL statement. <a id="sthref858"></a><a id="sthref859"></a></p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i80683">Optimizer Operations</a></p>
</li>
<li>
<p><a href="#CIHDFHBG">Components of the Query Optimizer</a></p>
</li>
<li>
<p><a href="#i79423">Bind Variable Peeking</a></p>
</li>
</ul>
<a id="i80683"></a>
<div id="PFGRF10101" class="sect2">
<h3 class="sect2"><span class="secnum">11.1.1</span> Optimizer Operations</h3>
<p>The database can execute a SQL statement in multiple ways, such as <a href="glossary.htm#BGBICFAC"><span class="xreftitlebold">full table scans</span></a>, index scans, nested loops, and <a href="glossary.htm#BGBIJCBH"><span class="xreftitlebold">hash joins</span></a>. The optimizer considers many factors related to the objects and the conditions in the query when determining an execution plan. This determination is an important step in SQL processing and can greatly affect execution time.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The optimizer might not make the same decisions from one version of Oracle Database to the next. In recent versions, the optimizer might make different decisions because better information is available.</div>
<p>When the user submits a SQL statement for execution, the optimizer performs the following steps:</p>
<ol>
<li>
<p>The optimizer generates a set of potential plans for the SQL statement based on available access paths and hints.</p>
</li>
<li>
<p>The optimizer estimates the cost of each plan based on statistics in the data dictionary. Statistics include information on the data distribution and storage characteristics of the tables, indexes, and partitions accessed by the statement.</p>
<p>The <span class="glossaryterm"><a id="sthref860"></a><a id="sthref861"></a><a id="sthref862"></a>cost</span> is an estimated value proportional to the expected resource use needed to execute the statement with a particular plan. The optimizer calculates the cost of access paths and join orders based on the estimated computer resources, which includes I/O, CPU, and memory.</p>
<p>Serial plans with higher costs take longer to execute than those with smaller costs. When using a parallel plan, resource use is not directly related to elapsed time.</p>
</li>
<li>
<p>The optimizer compares the plans and chooses the plan with the lowest cost.</p>
<p>The output from the optimizer is an <a href="glossary.htm#BGBFEJGB"><span class="xreftitlebold">execution plan</span></a> that describes the optimum method of execution. The plans shows the combination of the steps Oracle Database uses to execute a SQL statement. Each step either retrieves rows physically from the database or prepares them for the user issuing the statement.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="hintsref.htm#i8327">Chapter 19, "Using Optimizer Hints"</a> for detailed information on hints</div>
<p><a id="sthref863"></a><a id="sthref864"></a>For any SQL statement processed by Oracle Database, the optimizer performs the operations listed in <a href="#BABHJIDC">Table 11-1</a>.</p>
<div id="PFGRF94565" class="tblruleformal">
<p class="titleintable"><a id="sthref865"></a><a id="BABHJIDC"></a>Table 11-1 Optimizer Operations</p>
<table class="cellalignment1691" title="Optimizer Operations" summary="This table summarizes the operations performed by the optimizer." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t4">Operation</th>
<th class="cellalignment1687" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t4" headers="r1c1-t4">
<p>Evaluation of expressions and conditions</p>
</td>
<td class="cellalignment1688" headers="r2c1-t4 r1c2-t4">
<p>The optimizer first evaluates expressions and conditions containing constants as fully as possible.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t4" headers="r1c1-t4">
<p>Statement transformation</p>
</td>
<td class="cellalignment1688" headers="r3c1-t4 r1c2-t4">
<p>For complex statements involving, for example, correlated subqueries or views, the optimizer might transform the original statement into an equivalent join statement.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t4" headers="r1c1-t4">
<p>Choice of optimizer goals</p>
</td>
<td class="cellalignment1688" headers="r4c1-t4 r1c2-t4">
<p>The optimizer determines the goal of optimization. See <a href="#i38318">"Choosing an Optimizer Goal"</a>.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t4" headers="r1c1-t4">
<p>Choice of access paths</p>
</td>
<td class="cellalignment1688" headers="r5c1-t4 r1c2-t4">
<p>For each table accessed by the statement, the optimizer chooses one or more of the available access paths to obtain table data. See <a href="#i82080">"Overview of Optimizer Access Paths"</a>.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r6c1-t4" headers="r1c1-t4">
<p>Choice of join orders</p>
</td>
<td class="cellalignment1688" headers="r6c1-t4 r1c2-t4">
<p>For a join statement that joins more than two tables, the optimizer chooses which pair of tables is joined first, and then which table is joined to the result, and so on. See <a href="#i76330">"How the Query Optimizer Chooses Execution Plans for Joins"</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<p>Sometimes, you may have more information about a particular application's data than is available to the optimizer. In such cases you can use <a href="glossary.htm#BGBDHIIH"><span class="xreftitlebold">hints</span></a> in SQL statements to instruct the optimizer about how a statement should be executed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="stats.htm#g49431">Chapter 13, "Managing Optimizer Statistics"</a></p>
</li>
<li>
<p><a href="hintsref.htm#i8327">Chapter 19, "Using Optimizer Hints"</a></p>
</li>
<li>
<p><a class="olink CNCPT015" href="../../server.112/e40540/sqllangu.htm#CNCPT015"><span class="italic">Oracle Database Concepts</span></a> for an overview of SQL processing and the optimizer</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHDFHBG"></a>
<div id="PFGRF94582" class="sect2">
<h3 class="sect2"><span class="secnum">11.1.2</span> Components of the Query Optimizer</h3>
<p>The query optimizer operations include:</p>
<ul>
<li>
<p><a href="#i37745">Query Transformation</a></p>
</li>
<li>
<p><a href="#i37746">Estimation</a></p>
</li>
<li>
<p><a href="#i37011">Plan Generation</a></p>
</li>
</ul>
<p><a href="#i31133">Figure 11-1</a> illustrates optimizer components.</p>
<div id="PFGRF94583" class="figure">
<p class="titleinfigure"><a id="i31133"></a>Figure 11-1 Optimizer Components</p>
<img width="496" height="328" src="img/pfgrf184.gif" alt="Description of Figure 11-1 follows" /><br />
<a id="sthref866" href="img_text/pfgrf184.htm">Description of "Figure 11-1 Optimizer Components"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="i37745"></a>
<div id="PFGRF94584" class="sect3">
<h4 class="sect3"><span class="secnum">11.1.2.1</span> Query Transformation</h4>
<p>Each query portion of a statement is called a <span class="bold">query block</span>. The input to the query transformer is a parsed query, which is represented by a set of query blocks.</p>
<p>In the following example, the SQL statement consists of two query blocks. The subquery in parentheses is the <span class="bold">inner query block</span>. The <span class="bold">outer query block</span>, which is the rest of the SQL statement, retrieves names of employees in the departments whose IDs were supplied by the subquery.</p>
<pre>
SELECT first_name, last_name
FROM   employees
WHERE  department_id 
IN     (SELECT department_id FROM departments WHERE location_id = 1800);
</pre>
<p>The query form determines how query blocks are interrelated. The transformer determines whether it is advantageous to rewrite the original SQL statement into a semantically equivalent SQL statement that can be processed more efficiently.</p>
<p>The query transformer employs several query transformation techniques, including the following:</p>
<ul>
<li>
<p><a href="#i55044">View Merging</a></p>
</li>
<li>
<p><a href="#i55050">Predicate Pushing</a></p>
</li>
<li>
<p><a href="#i55054">Subquery Unnesting</a></p>
</li>
<li>
<p><a href="#i55058">Query Rewrite with Materialized Views</a></p>
</li>
</ul>
<p>Any combination of these transformations can apply to a given query.</p>
<a id="i55044"></a>
<div id="PFGRF94585" class="sect4">
<h5 class="sect4"><span class="secnum">11.1.2.1.1</span> View Merging</h5>
<p>Each view referenced in a query is expanded by the parser into a separate query block. The block essentially represents the view definition, and thus the result of a view. One option for the optimizer is to analyze the view query block separately and generate a view subplan. The optimizer then processes the rest of the query by using the view subplan to generate an overall query plan. This technique usually leads to a suboptimal query plan because the view is optimized separately.</p>
<p>In <span class="bold">view merging</span>, the transformer merges the query block representing the view into the containing query block. For example, suppose you create a view as follows:</p>
<pre>
CREATE VIEW employees_50_vw AS
  SELECT employee_id, last_name, job_id, salary, commission_pct, department_id
  FROM   employees
  WHERE  department_id = 50;
</pre>
<p>You then query the view as follows:</p>
<pre>
SELECT employee_id
FROM   employees_50_vw 
WHERE  employee_id &gt; 150;
</pre>
<p>The optimizer can use view merging to transform the query of <code>employees_50_vw</code> into the following equivalent query:</p>
<pre>
SELECT employee_id
FROM   employees
WHERE  department_id = 50 
AND    employee_id &gt; 150;
</pre>
<p>The view merging optimization applies to views that contain only selections, projections, and joins. That is, mergeable views do not contain set operators, aggregate functions, <code>DISTINCT</code>, <code>GROUP BY</code>, <code>CONNECT BY</code>, and so on.</p>
<p>To enable the optimizer to use view merging for any query issued by the user, you must grant the <code>MERGE</code> <code>ANY</code> <code>VIEW</code> privilege to the user. Grant the <code>MERGE</code> <code>VIEW</code> privilege to a user on specific views to enable the optimizer to use view merging for queries on these views. These privileges are required only under specific conditions, such as when a view is not merged because the security checks fail.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF01603" href="../../server.112/e41084/statements_9013.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code>MERGE</code> <code>ANY</code> <code>VIEW</code> and <code>MERGE</code> <code>VIEW</code> privileges</p>
</li>
<li>
<p><a class="olink REFRN10262" href="../../server.112/e40402/initparams172.htm#REFRN10262"><span class="italic">Oracle Database Reference</span></a> for more information about the <code>OPTIMIZER_SECURE_VIEW_MERGING</code> initialization parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="i55050"></a>
<div id="PFGRF94586" class="sect4">
<h5 class="sect4"><span class="secnum">11.1.2.1.2</span> Predicate Pushing</h5>
<p>In <span class="bold">predicate pushing</span>, the optimizer "pushes" the relevant predicates from the containing query block into the view query block. For views that are not merged, this technique improves the subplan of the unmerged view because the database can use the pushed-in predicates to access indexes or to use as filters.</p>
<p>For example, suppose you create a view that references two employee tables. The view is defined with a compound query that uses the <code>UNION</code> set operator, as follows:</p>
<pre>
CREATE VIEW all_employees_vw AS
  ( SELECT employee_id, last_name, job_id, commission_pct, department_id
    FROM   employees )
  UNION
  ( SELECT employee_id, last_name, job_id, commission_pct, department_id
    FROM   contract_workers );
</pre>
<p>You then query the view as follows:</p>
<pre>
SELECT last_name
FROM   all_employees_vw
WHERE  <span class="bold">department_id = 50</span>;
</pre>
<p>Because the view is a compound query, the optimizer cannot merge the view's query into the accessing query block. Instead, the optimizer can transform the accessing statement by pushing its predicate, the <code>WHERE</code> clause condition <code>department_id=50</code>, into the view's compound query. The equivalent transformed query is as follows:</p>
<pre>
SELECT last_name
FROM   ( SELECT employee_id, last_name, job_id, commission_pct, department_id
         FROM   employees
         WHERE  <span class="bold">department_id=50</span>
         UNION
         SELECT employee_id, last_name, job_id, commission_pct, department_id
         FROM   contract_workers
         WHERE  <span class="bold">department_id=50</span> );
</pre></div>
<!-- class="sect4" -->
<a id="i55054"></a>
<div id="PFGRF10104" class="sect4">
<h5 class="sect4"><span class="secnum">11.1.2.1.3</span> Subquery Unnesting</h5>
<p>In <span class="bold">subquery unnesting</span>, the optimizer transforms a nested query into an equivalent join statement, and then optimizes the join. This transformation enables the optimizer to take advantage of the join optimizer technique. The optimizer can perform this transformation only if the resulting join statement is guaranteed to return exactly the same rows as the original statement, and if subqueries do not contain aggregate functions such as <code>AVG</code>.</p>
<p>For example, suppose you connect as user <code>sh</code> and execute the following query:</p>
<pre>
SELECT * 
FROM   sales
WHERE  cust_id IN ( SELECT cust_id FROM customers );
</pre>
<p>Because the <code>customers.cust_id column</code> is a primary key, the optimizer can transform the complex query into the following join statement that is guaranteed to return the same data:</p>
<pre>
SELECT sales.* 
FROM   sales, customers
WHERE  sales.cust_id = customers.cust_id;
</pre>
<p>If the optimizer cannot transform a complex statement into a join statement, it selects execution plans for the parent statement and the subquery as though they were separate statements. The optimizer then executes the subquery and uses the rows returned to execute the parent query. To improve execution speed of the overall query plan, the optimizer orders the subplans efficiently.</p>
</div>
<!-- class="sect4" -->
<a id="i55058"></a>
<div id="PFGRF94587" class="sect4">
<h5 class="sect4"><span class="secnum">11.1.2.1.4</span> Query Rewrite with Materialized Views</h5>
<p>A <span class="bold">materialized view</span> is like a query with a result that the database materializes and stores in a table. When the database finds a user query compatible with the query associated with a materialized view, then the database can rewrite the query in terms of the materialized view. This technique improves query execution because most of the query result has been precomputed.</p>
<p>The query transformer looks for any materialized views that are compatible with the user query and selects one or more materialized views to rewrite the user query. The use of materialized views to rewrite a query is cost-based. That is, the optimizer does not rewrite the query if the plan generated without the materialized views has a lower cost than the plan generated with the materialized views.</p>
<p>Consider the following materialized view, <code>cal_month_sales_mv</code>, which aggregates the dollar amount sold each month:</p>
<pre>
CREATE MATERIALIZED VIEW cal_month_sales_mv
  ENABLE QUERY REWRITE 
AS
  SELECT t.calendar_month_desc, SUM(s.amount_sold) AS dollars
  FROM   sales s, times t 
  WHERE  s.time_id = t.time_id
  GROUP BY t.calendar_month_desc;
</pre>
<p>Assume that sales number is around one million in a typical month. The view has the precomputed aggregates for the dollar amount sold for each month. Consider the following query, which asks for the sum of the amount sold for each month:</p>
<pre>
SELECT t.calendar_month_desc, SUM(s.amount_sold)
FROM   sales s, times t
WHERE  s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
</pre>
<p>Without query rewrite, the database must access <code>sales</code> directly and compute the sum of the amount sold. This method involves reading many million rows from <code>sales</code>, which invariably increases query response time. The join also further slows query response because the database must compute the join on several million rows. With query rewrite, the optimizer transparently rewrites the query as follows:</p>
<pre>
SELECT calendar_month, dollars
FROM   cal_month_sales_mv;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG018" href="../../server.112/e25554/qrbasic.htm#DWHSG018"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn more about query rewrite</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i37746"></a>
<div id="PFGRF94589" class="sect3">
<h4 class="sect3"><span class="secnum">11.1.2.2</span> Estimation</h4>
<p><a id="sthref867"></a>The <span class="bold">estimator</span> determines the overall cost of a given execution plan. The estimator generates three different types of measures to achieve this goal:</p>
<ul>
<li>
<p><a href="#i55109">Selectivity</a></p>
<p>This measure represents a fraction of rows from a row set. The selectivity is tied to a query predicate, such as <code>last_name='Smith'</code>, or a combination of predicates.</p>
</li>
<li>
<p><a href="#i55113">Cardinality</a></p>
<p><a id="sthref868"></a><a id="sthref869"></a>This measure represents the number of rows in a row set.</p>
</li>
<li>
<p><a href="#i55117">Cost</a></p>
<p>This measure represents units of work or resource used. The query optimizer uses disk I/O, CPU usage, and memory usage as units of work.</p>
</li>
</ul>
<p>If statistics are available, then the estimator uses them to compute the measures. The statistics improve the degree of accuracy of the measures.</p>
<a id="i55109"></a>
<div id="PFGRF94590" class="sect4">
<h5 class="sect4"><span class="secnum">11.1.2.2.1</span> Selectivity</h5>
<p>The <a href="glossary.htm#BGBEJCCG"><span class="xreftitlebold">selectivity</span></a> represents a fraction of rows from a row set. The row set can be a base table, a view, or the result of a join or a <code>GROUP</code> <code>BY</code> operator. The selectivity is tied to a query predicate, such as <code>last_name</code> = <code>'Smith'</code>, or a combination of predicates, such as <code>last_name</code> = <code>'Smith'</code> <code>AND</code> <code>job_type</code> = <code>'Clerk'</code>.</p>
<p>A predicate filters a specific number of rows from a row set. Thus, the selectivity of a predicate indicates how many rows pass the predicate test. Selectivity ranges from 0.0 to 1.0. A selectivity of 0.0 means that no rows are selected from a row set, whereas a selectivity of 1.0 means that all rows are selected. A predicate becomes more selective as the value approaches 0.0 and less selective (or more unselective) as the value approaches 1.0.</p>
<p>The optimizer estimates selectivity depending on whether statistics are available:</p>
<ul>
<li>
<p>Statistics not available</p>
<p>Depending on the value of the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter, the optimizer either uses <a href="glossary.htm#BGBIBAHD"><span class="xreftitlebold">dynamic statistics</span></a> or an internal default value. The database uses different internal defaults depending on the predicate type. For example, the internal default for an equality predicate (<code>last_name</code> = <code>'Smith'</code>) is lower than for a range predicate (<code>last_name &gt;</code> <code>'Smith'</code>) because an equality predicate is expected to return a smaller fraction of rows. See <a href="stats.htm#i42991">"Controlling Dynamic Statistics"</a>.</p>
</li>
<li>
<p>Statistics available</p>
<p>When statistics are available, the estimator uses them to estimate selectivity. Assume there are 150 distinct employee last names. For an equality predicate <code>last_name =</code> <code>'Smith'</code>, selectivity is the reciprocal of the number <code><span class="codeinlineitalic">n</span></code> of distinct values of <code>last_name</code>, which in this example is .006 because the query selects rows that contain 1 out of 150 distinct values.</p>
<p>If a histogram is available on the <code>last_name</code> column, then the estimator uses the histogram instead of the number of distinct values. The histogram captures the distribution of different values in a column, so it yields better selectivity estimates, especially for columns that contain <a href="glossary.htm#BGBEFJEB"><span class="xreftitlebold">skewed data</span></a>. See <a href="stats.htm#i41591">"Viewing Histograms"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="i55113"></a>
<div id="PFGRF94591" class="sect4">
<h5 class="sect4"><span class="secnum">11.1.2.2.2</span> Cardinality</h5>
<p>Cardinality represents the number of rows in a row set. In this context, the row set can be a base table, a view, or the result of a join or <code>GROUP</code> <code>BY</code> operator.</p>
</div>
<!-- class="sect4" -->
<a id="i55117"></a>
<div id="PFGRF94592" class="sect4">
<h5 class="sect4"><span class="secnum">11.1.2.2.3</span> Cost</h5>
<p>The <span class="bold">cost</span> represents units of work or resource used in an operation. The optimizer uses disk I/O, CPU usage, and memory usage as units of work. The operation can be scanning a table, accessing rows from a table by using an index, joining two tables together, or sorting a row set. The cost is the number of work units expected to be incurred when the database executes the query and produces its result.</p>
<p>The <a href="glossary.htm#BGBDBFGI"><span class="xreftitlebold">access path</span></a> determines the number of units of work required to get data from a base table. The access path can be a table scan, a fast full index scan, or an index scan.</p>
<ul>
<li>
<p>Table scan or fast full index scan</p>
<p>During a table scan or <a href="glossary.htm#BGBIDIEF"><span class="xreftitlebold">fast full index scan</span></a>, the database reads multiple blocks from disk in a single I/O. Therefore, the cost of the scan depends on the number of blocks to be scanned and the multiblock read count value.</p>
</li>
<li>
<p>Index scan</p>
<p>The cost of an index scan depends on the levels in the B-tree, the number of index leaf blocks to be scanned, and the number of rows to be fetched using the rowid in the index keys. The cost of fetching rows using rowids depends on the <a href="glossary.htm#BGBGIIGC"><span class="xreftitlebold">index clustering factor</span></a>. See <a href="#i82433">"Assessing I/O for Blocks, not Rows"</a>.</p>
</li>
</ul>
<p>The <span class="bold">join</span> <span class="bold">cost</span> represents the combination of the individual access costs of the two row sets being joined, plus the cost of the join operation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i51523">"Overview of Joins"</a></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i37011"></a>
<div id="PFGRF94593" class="sect3">
<h4 class="sect3"><span class="secnum">11.1.2.3</span> Plan Generation</h4>
<p>The <a href="glossary.htm#BGBFDJFC"><span class="xreftitlebold">plan generator</span></a> explores various plans for a query block by trying out different access paths, join methods, and join orders. Many plans are possible because of the various combinations of different access paths, join methods, and join orders that the database can use to produce the same result. The purpose of the generator is to pick the plan with the lowest cost.</p>
<div id="PFGRF95177" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref870"></a>
<h5 class="sect4"><span class="secnum">11.1.2.3.1</span> Join Order</h5>
<p>A <span class="bold">join order</span> is the order in which different join items, such as tables, are accessed and joined together. Assume that the database joins <code>table1</code>, <code>table2</code>, and <code>table3</code>. The join order might be as follows:</p>
<ol>
<li>
<p>The database accesses <code>table1</code>.</p>
</li>
<li>
<p>The database accesses <code>table2</code> and joins its rows to <code>table1</code>.</p>
</li>
<li>
<p>The database accesses <code>table3</code> and joins its data to the result of the join between <code>table1</code> and <code>table2</code>.</p>
</li>
</ol>
</div>
<!-- class="sect4" -->
<div id="PFGRF95178" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref871"></a>
<h5 class="sect4"><span class="secnum">11.1.2.3.2</span> Query Subplans</h5>
<p>The optimizer represents each nested subquery or unmerged view by a separate query block and generates a <span class="bold">subplan</span>. The database optimizes query blocks separately from the bottom up. Thus, the database optimizes the innermost query block first and generates a subplan for it, and then lastly generates the outer query block representing the entire query.</p>
<p>The number of possible plans for a query block is proportional to the number of join items in the <code>FROM</code> clause. This number rises exponentially with the number of join items. For example, the possible plans for a join of five tables will be significantly higher than the possible plans for a join of two tables.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF95179" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref872"></a>
<h5 class="sect4"><span class="secnum">11.1.2.3.3</span> Cutoff for Plan Selection</h5>
<p>The plan generator uses an internal cutoff to reduce the number of plans it tries when finding the lowest-cost plan. The cutoff is based on the cost of the current best plan. If the current best cost is large, then the plan generator explores alternative plans to find a lower cost plan. If the current best cost is small, then the generator ends the search swiftly because further cost improvement will not be significant.</p>
<p>The cutoff works well if the plan generator starts with an initial join order that produces a plan with cost close to optimal. Finding a good initial join order is a difficult problem.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i79423"></a>
<div id="PFGRF94588" class="sect2">
<h3 class="sect2"><span class="secnum">11.1.3</span> Bind Variable Peeking<a id="sthref873"></a><a id="sthref874"></a><a id="sthref875"></a></h3>
<p>In <span class="bold">bind variable peeking</span> (also known as <span class="bold">bind peeking</span>), the optimizer looks at the value in a bind variable when the database performs a hard parse of a statement.</p>
<p>When a query uses literals, the optimizer can use the literal values to find the best plan. However, when a query uses bind variables, the optimizer must select the best plan without the presence of literals in the SQL text. This task can be extremely difficult. By peeking at bind values the optimizer can determine the selectivity of a <code>WHERE</code> clause condition as if literals <span class="italic">had</span> been used, thereby improving the plan.</p>
<div id="PFGRF95246" class="example">
<p class="titleinexample"><a id="CIHIACJE"></a>Example 11-1 Bind Peeking</p>
<p>Assume that the following 100,000 row <code>emp</code> table exists in the database. The table has the following definition:</p>
<pre>
SQL&gt; DESCRIBE emp

Name                   Null?    Type
---------------------- -------- ----------------------------------
ENAME                           VARCHAR2(20)
EMPNO                           NUMBER
PHONE                           VARCHAR2(20)
DEPTNO                          NUMBER
</pre>
<p>The data is significantly skewed in the <code>deptno</code> column. The value 10 is found in 99.9% of the rows. Each of the other <code>deptno</code> values (<code>0</code> through <code>9</code>) is found in 1% of the rows. You have gathered statistics for the table, resulting in a histogram on the <code>deptno</code> column. You define a bind variable and query <code>emp</code> using the bind value <code>9</code> as follows:</p>
<pre>
VARIABLE deptno NUMBER
EXEC :deptno := 9

SELECT /*ACS_1*/ count(*), max(empno) 
FROM   emp 
WHERE  deptno = :deptno;
</pre>
<p>The query returns 10 rows:</p>
<pre>
COUNT(*) MAX(EMPNO)
---------- ----------
    10         99
</pre>
<p>To generate the execution plan for the query, the database peeked at the value <code>9</code> during the hard parse. The optimizer generated selectivity estimates as if the user had executed the following query:</p>
<pre>
select /*ACS_1*/ count(*), max(empno)
from emp
where deptno = 9;
</pre></div>
<!-- class="example" -->
<p>When choosing a plan, the optimizer only peeks at the bind value during the hard parse. This plan may not be optimal for all possible values.</p>
<a id="CIHIGAHB"></a>
<div id="PFGRF95174" class="sect3">
<h4 class="sect3"><span class="secnum">11.1.3.1</span> Adaptive Cursor Sharing</h4>
<p>The <span class="bold">adaptive cursor sharing</span> feature enables a single statement that contains bind variables to use multiple execution plans. Cursor sharing is "adaptive" because the cursor adapts its behavior so that the database does not always use the same plan for each execution or bind variable value.</p>
<p>For appropriate queries, the database monitors data accessed over time for different bind values, ensuring the optimal choice of cursor for a specific bind value. For example, the optimizer might choose one plan for bind value <code>9</code> and a different plan for bind value <code>10</code>. Cursor sharing is "adaptive" because the cursor adapts its behavior so that the same plan is not always used for each execution or bind variable value.</p>
<p>Adaptive cursor sharing is enabled for the database by default and cannot be disabled. Note that adaptive cursor sharing does not apply to SQL statements containing more than 14 bind variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Adaptive cursor sharing is independent of the <code>CURSOR_SHARING</code> initialization parameter (see <a href="memory.htm#i31512">"Sharing Cursors for Existing Applications"</a>). Adaptive cursor sharing is equally applicable to statements that contain user-defined and system-generated bind variables.</div>
<div id="PFGRF95247" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref876"></a>
<h5 class="sect4"><span class="secnum">11.1.3.1.1</span> Bind-Sensitive Cursors</h5>
<p>A <span class="bold">bind-sensitive cursor</span> is a cursor whose optimal plan may depend on the value of a bind variable. The database monitors the behavior of a bind-sensitive cursor that uses different bind values to determine whether a different plan is beneficial.</p>
<p>The criteria used by the optimizer to decide whether a cursor is bind-sensitive include the following:</p>
<ul>
<li>
<p>The optimizer has peeked at the bind values to generate selectivity estimates.</p>
</li>
<li>
<p>A histogram exists on the column containing the bind value.</p>
</li>
</ul>
<div id="PFGRF95248" class="example">
<p class="titleinexample"><a id="sthref877"></a>Example 11-2 Bind-Sensitive Cursors</p>
<p>In <a href="#CIHIACJE">Example 11-1</a> you queried the <code>emp</code> table using the bind value <code>9</code> for <code>deptno</code>. Now you run the <code>DBMS_XPLAN.DISPLAY_CURSOR</code> function to show the query plan:</p>
<pre>
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR);
</pre>
<p>The output is as follows:</p>
<pre>
----------------------------------------------------------------------------------
| Id  | Operation                    | Name   | Rows  | Bytes | Cost (%CPU)| Time|
----------------------------------------------------------------------------------
|  0 | SELECT STATEMENT             |        |      |       |   2 (100)|         |
|  1 |  SORT AGGREGATE              |        |    1 |    16 |          |         |
|  2 |   TABLE ACCESS BY INDEX ROWID| EMP    |    1 |    16 |   2   (0)| 00:00:01|
|* 3 |    INDEX RANGE SCAN          | EMP_I1 |    1 |       |   1   (0)| 00:00:01|
----------------------------------------------------------------------------------
</pre>
<p>The plan indicates that the optimizer chose an index range scan, which is expected because of the selectivity (only 1%) of the value <code>9</code>. You can query <code>V$SQL</code> to view statistics about the cursor:</p>
<pre>
COL BIND_SENSI FORMAT a10
COL BIND_AWARE FORMAT a10
COL BIND_SHARE FORMAT a10
SELECT CHILD_NUMBER, EXECUTIONS, BUFFER_GETS, IS_BIND_SENSITIVE AS "BIND_SENSI", 
       IS_BIND_AWARE AS "BIND_AWARE", IS_SHAREABLE AS "BIND_SHARE"
FROM   V$SQL
WHERE  SQL_TEXT LIKE 'select /*ACS_1%';
</pre>
<p>As shown in the following output, one child cursor exists for this statement and has been executed once. A small number of buffer gets are associated with the child cursor. Because the <code>deptno</code> data is skewed, the database created a histogram. This histogram led the database to mark the cursor as bind-sensitive (<code>IS_BIND_SENSITIVE</code> is <code>Y</code>).</p>
<pre>
CHILD_NUMBER EXECUTIONS BUFFER_GETS BIND_SENSI BIND_AWARE BIND_SHARE
------------ ---------- ----------- ---------- ---------- ----------
           0          1          56 Y          N          Y
</pre></div>
<!-- class="example" -->
<p>For each execution of the query with a new bind value, the database records the execution statistics for the new value and compares them to the execution statistics for the previous value. If execution statistics vary greatly, then the database marks the cursor bind-aware.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF95249" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref878"></a>
<h5 class="sect4"><span class="secnum">11.1.3.1.2</span> Bind-Aware Cursors</h5>
<p>A <span class="bold">bind-aware cursor</span> is a bind-sensitive cursor eligible to use different plans for different bind values. After a cursor has been made bind-aware, the optimizer chooses plans for future executions based on the bind value and its selectivity estimate.</p>
<p>When a statement with a bind-sensitive cursor executes, the database decides whether to mark the cursor bind-aware. The decision depends on whether the cursor produces significantly different data access patterns for different bind values. If the database marks the cursor bind-aware, then the next time that the cursor executes the database does the following:</p>
<ul>
<li>
<p>Generates a new plan based on the new bind value.</p>
</li>
<li>
<p>Marks the original cursor generated for the statement as not shareable (<code>V$SQL.IS_SHAREABLE</code> is <code>N</code>). This cursor is no longer usable and will be among the first to be aged out of the shared SQL area.</p>
</li>
</ul>
<div id="PFGRF95250" class="example">
<p class="titleinexample"><a id="sthref879"></a>Example 11-3 Bind-Aware Cursors</p>
<p>In <a href="#CIHIACJE">Example 11-1</a> you queried emp using the bind value <code>9</code>. Now you query <code>emp</code> using the bind value <code>10</code>. The query returns 99,900 rows that contain the value <code>10</code>:</p>
<pre>
COUNT(*)   MAX(EMPNO)
---------- ----------
99900      100000
</pre>
<p>Because the cursor for this statement is bind-sensitive, the optimizer assumes that the cursor can be shared. Consequently, the optimizer uses the same index range scan for the value <code>10</code> as for the value <code>9</code>.</p>
<p>The <code>V$SQL</code> output shows that the same bind-sensitive cursor was executed a second time (the query using <code>10</code>) and required many more buffer gets than the first execution:</p>
<pre>
SELECT CHILD_NUMBER, EXECUTIONS, BUFFER_GETS, IS_BIND_SENSITIVE AS "BIND_SENSI", 
       IS_BIND_AWARE AS "BIND_AWARE", IS_SHAREABLE AS "BIND_SHARE"
FROM   V$SQL
WHERE  SQL_TEXT LIKE 'select /*ACS_1%';
 
CHILD_NUMBER EXECUTIONS BUFFER_GETS BIND_SENSI BIND_AWARE BIND_SHARE
------------ ---------- ----------- ---------- ---------- ----------
           0          2        1010 Y          N          Y
</pre>
<p>Now you execute the query using the value <code>10</code> a second time. The database compares statistics for previous executions and marks the cursor as bind-aware. In this case, the optimizer decides that a new plan is warranted, so it performs a hard parse of the statement and generates a new plan. The new plan uses a full table scan instead of an index range scan:</p>
<pre>
---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |       |       |   208 (100)|          |
|   1 |  SORT AGGREGATE    |      |     1 |    16 |            |          |
|*  2 |   TABLE ACCESS FULL| EMP  | 95000 |  1484K|   208   (1)| 00:00:03 |
---------------------------------------------------------------------------
</pre>
<p>A query of <code>V$SQL</code> shows that the database created an additional child cursor (child number <code>1</code>) that represents the plan containing the full table scan. This new cursor shows a lower number of buffer gets and is marked bind-aware:</p>
<pre>
SELECT CHILD_NUMBER, EXECUTIONS, BUFFER_GETS, IS_BIND_SENSITIVE AS "BIND_SENSI", 
       IS_BIND_AWARE AS "BIND_AWARE", IS_SHAREABLE AS "BIND_SHARE"
FROM   V$SQL
WHERE  SQL_TEXT LIKE 'select /*ACS_1%';
 
CHILD_NUMBER EXECUTIONS BUFFER_GETS BIND_SENSI BIND_AWARE BIND_SHARE
------------ ---------- ----------- ---------- ---------- ----------
           0          2        1010 Y          N          Y
           1          2        1522 Y          Y          Y
</pre>
<p>After you execute the query twice with value <code>10</code>, you execute it again using the more selective value <code>9</code>. Because of adaptive cursor sharing, the optimizer "adapts" the cursor and chooses an index range scan rather than a full table scan for this value.</p>
<p>A query of <code>V$SQL</code> indicates that the database created a new child cursor (child number <code>2</code>) for the execution of the query:</p>
<pre>
CHILD_NUMBER EXECUTIONS BUFFER_GETS BIND_SENSI BIND_AWARE BIND_SHARE
------------ ---------- ----------- ---------- ---------- ----------
           0          2        1010 Y          N          N
           1          1        1522 Y          Y          Y
           2          1           7 Y          Y          Y
</pre>
<p>Because the database is now using adaptive cursor sharing, the database no longer uses the original cursor (child <code>0</code>), which is not bind-aware. The shared SQL area will age out the defunct cursor.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<div id="PFGRF95251" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref880"></a>
<h5 class="sect4"><span class="secnum">11.1.3.1.3</span> Cursor Merging</h5>
<p>If the optimizer creates a plan for a bind-aware cursor, and if this plan is the same as an existing cursor, then the optimizer can perform <span class="bold">cursor merging</span>. In this case, the database merges cursors to save space in the shared SQL area. The database increases the selectivity range for the cursor to include the selectivity of the new bind.</p>
<p>Suppose you execute a query with a bind value that does not fall within the selectivity ranges of the existing cursors. The database performs a hard parse and generates a new plan and new cursor. If this new plan is the same plan used by an existing cursor, then the database merges these two cursors and deletes one of the old cursors.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="PFGRF95176" class="sect3"><a id="sthref881"></a>
<h4 class="sect3"><span class="secnum">11.1.3.2</span> Viewing Bind-Related Performance Data</h4>
<p>You can use the <code>V$</code> views for adaptive cursor sharing to see selectivity ranges, cursor information (such as whether a cursor is bind-aware or bind-sensitive), and execution statistics:</p>
<ul>
<li>
<p><code>V$SQL</code> shows whether a cursor is bind-sensitive or bind-aware</p>
</li>
<li>
<p><code>V$SQL_CS_HISTOGRAM</code> shows the distribution of the execution count across a three-bucket execution history histogram</p>
</li>
<li>
<p><code>V$SQL_CS_SELECTIVITY</code> shows the selectivity ranges stored for every predicate containing a bind variable if the selectivity was used to check cursor sharing</p>
</li>
<li>
<p><code>V$SQL_CS_STATISTICS</code> summarizes the information that the optimizer uses to determine whether to mark a cursor bind-aware.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i82080"></a>
<div id="PFGRF94599" class="sect1">
<h2 class="sect1"><span class="secnum">11.2</span> Overview of Optimizer Access Paths</h2>
<p>Access paths are ways in which data is retrieved from the database. In general, index access paths are useful for statements that retrieve a small subset of table rows, whereas full scans are more efficient when accessing a large portion of the table. Online transaction processing (OLTP) applications, which consist of short-running SQL statements with high selectivity, often are characterized by the use of index access paths. Decision support systems, however, tend to use partitioned tables and perform full scans of the relevant partitions.</p>
<p>This section describes the data access paths that the database can use to locate and retrieve any row in any table.</p>
<ul>
<li>
<p><a href="#i44851">Full Table Scans</a></p>
</li>
<li>
<p><a href="#i44963">Rowid Scans</a></p>
</li>
<li>
<p><a href="#i52300">Index Scans</a></p>
</li>
<li>
<p><a href="#i51070">Cluster Access</a></p>
</li>
<li>
<p><a href="#i51075">Hash Access</a></p>
</li>
<li>
<p><a href="#i79194">Sample Table Scans</a></p>
</li>
<li>
<p><a href="#i36043">How the Query Optimizer Chooses an Access Path</a></p>
</li>
</ul>
<a id="i44851"></a>
<div id="PFGRF94600" class="sect2">
<h3 class="sect2"><span class="secnum">11.2.1</span> Full Table Scans</h3>
<p>This type of scan reads all rows from a table and filters out those that do not meet the selection criteria. During a full table scan, all blocks in the table that are under the <a id="sthref882"></a>high water mark are scanned. The high water mark indicates the amount of used space, or space that had been formatted to receive data. Each row is examined to determine whether it satisfies the statement's <code>WHERE</code> clause.</p>
<p>When Oracle Database performs a full table scan, the blocks are read sequentially. Because the blocks are adjacent, the database can make I/O calls larger than a single block to speed up the process. The size of the read calls range from one block to the number of blocks indicated by the initialization parameter <a id="sthref883"></a><code>DB_FILE_MULTIBLOCK_READ_COUNT</code>. Using multiblock reads, the database can perform a full table scan very efficiently. The database reads each block only once.</p>
<p><a href="#i73898">Example 11-14, "EXPLAIN PLAN Output"</a> contains an example of a full table scan on the <code>employees</code> table.</p>
<div id="PFGRF94601" class="sect3"><a id="sthref884"></a>
<h4 class="sect3"><span class="secnum">11.2.1.1</span> Why a Full Table Scan Is Faster for Accessing Large Amounts of Data</h4>
<p>Full table scans are cheaper than index range scans when accessing a large fraction of the blocks in a table. Full table scans can use larger I/O calls, and making fewer large I/O calls is cheaper than making many smaller calls.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94602" class="sect3"><a id="sthref885"></a>
<h4 class="sect3"><span class="secnum">11.2.1.2</span> When the Optimizer Uses Full Table Scans</h4>
<p>The optimizer uses a full table scan in any of the following cases:</p>
<a id="i44888"></a>
<div id="PFGRF94603" class="sect4">
<h5 class="sect4"><span class="secnum">11.2.1.2.1</span> Lack of Index</h5>
<p>If the query cannot use existing indexes, then it uses a full table scan. For example, if there is a function used on the indexed column in the query, then the optimizer cannot use the index and instead uses a full table scan.</p>
<p>If you need to use the index for case-independent searches, then either do not permit mixed-case data in the search columns or create a function-based index, such as <code>UPPER</code>(<code>last_name</code>), on the search column. See <a href="data_acc.htm#i9946">"Using Function-based Indexes for Performance"</a>.</p>
</div>
<!-- class="sect4" -->
<a id="i44891"></a>
<div id="PFGRF94604" class="sect4">
<h5 class="sect4"><span class="secnum">11.2.1.2.2</span> Large Amount of Data</h5>
<p>If the optimizer thinks that the query requires most of the blocks in the table, then it uses a full table scan, even though indexes are available.</p>
</div>
<!-- class="sect4" -->
<a id="i44894"></a>
<div id="PFGRF94605" class="sect4">
<h5 class="sect4"><span class="secnum">11.2.1.2.3</span> Small Table</h5>
<p>If a table contains less than <code>DB_FILE_MULTIBLOCK_READ_COUNT</code> blocks under the high water mark, which the database can read in a single I/O call, then a full table scan might be cheaper than an index range scan, regardless of the fraction of tables being accessed or indexes present.</p>
</div>
<!-- class="sect4" -->
<a id="i44900"></a>
<div id="PFGRF94606" class="sect4">
<h5 class="sect4"><span class="secnum">11.2.1.2.4</span> High Degree of Parallelism</h5>
<p>A high degree of parallelism for a table skews the optimizer toward full table scans over range scans. Examine the <code>DEGREE</code> column in <code>ALL_TABLES</code> for the table to determine the degree of parallelism.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="PFGRF10107" class="sect3"><a id="sthref886"></a>
<h4 class="sect3"><span class="secnum">11.2.1.3</span> Full Table Scan Hints</h4>
<p>Use the hint <code>FULL(</code><code><span class="codeinlineitalic">table</span></code> <code><span class="codeinlineitalic">alias</span></code><code>)</code> to instruct the optimizer to use a full table scan. For more information on the <code>FULL</code> hint, see <a href="hintsref.htm#CHDJDIAH">"Hints for Access Paths"</a>.</p>
<p>You can use the <code>CACHE</code> and <code>NOCACHE</code> hints to indicate where the retrieved blocks are placed in the buffer cache. The <code>CACHE</code> hint instructs the optimizer to place the retrieved blocks at the most recently used end of the LRU list in the buffer cache when the database performs a full table scan.</p>
<p>Small tables are automatically cached according to the criteria in <a href="#g33259">Table 11-2</a>.</p>
<div id="PFGRF94607" class="tblruleformal">
<p class="titleintable"><a id="sthref887"></a><a id="g33259"></a>Table 11-2 Table Caching Criteria</p>
<table class="cellalignment1691" title="Table Caching Criteria" summary="This table lists the table caching criteria." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t10">Table Size</th>
<th class="cellalignment1687" id="r1c2-t10">Size Criteria</th>
<th class="cellalignment1687" id="r1c3-t10">Caching</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t10" headers="r1c1-t10">
<p>Small</p>
</td>
<td class="cellalignment1688" headers="r2c1-t10 r1c2-t10">
<p>Number of blocks &lt; 20 or 2% of total cached blocks, whichever is larger</p>
</td>
<td class="cellalignment1688" headers="r2c1-t10 r1c3-t10">
<p>If <code>STATISTICS_LEVEL</code> is se to <code>TYPICAL</code> or higher, then Oracle Database decides whether to cache a table depending on the table scan history. The database caches the table only if a future table scan is likely to find the cached blocks. If <code>STATISTICS_LEVEL</code> is set to <code>BASIC</code>, then the table is not cached.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t10" headers="r1c1-t10">
<p>Medium</p>
</td>
<td class="cellalignment1688" headers="r3c1-t10 r1c2-t10">
<p>Larger than a small table, but &lt; 10% of total cached blocks</p>
</td>
<td class="cellalignment1688" headers="r3c1-t10 r1c3-t10">
<p>Oracle Database decides whether to cache a table based on its table scan and workload history. It caches the table only if a future table scan is likely to find the cached blocks.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t10" headers="r1c1-t10">
<p>Large</p>
</td>
<td class="cellalignment1688" headers="r4c1-t10 r1c2-t10">
<p>&gt; 10% of total cached blocks</p>
</td>
<td class="cellalignment1688" headers="r4c1-t10 r1c3-t10">
<p>Not cached</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<p>Automatic caching of small tables is disabled for tables that are created or altered with the <code>CACHE</code> attribute.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94608" class="sect3"><a id="sthref888"></a>
<h4 class="sect3"><span class="secnum">11.2.1.4</span> Parallel Query Execution</h4>
<p>When a full table scan is required, the database can improve response time by using multiple parallel execution servers. In some cases, as when the database has a large amount of memory, the database can cache parallel query data in the SGA instead of using direct reads into the PGA. Typically, parallel queries occur in low-concurrency data warehouses because of the potential resource usage.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a></p>
</li>
<li>
<p><a class="olink VLDBG010" href="../../server.112/e25523/parallel.htm#VLDBG010"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> to learn more using parallel execution</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i44963"></a>
<div id="PFGRF94609" class="sect2">
<h3 class="sect2"><span class="secnum">11.2.2</span> Rowid Scans</h3>
<p><span class="bold"><a id="sthref889"></a><a id="sthref890"></a></span>The rowid of a row specifies the data file and data block containing the row and the location of the row in that block. Locating a row by specifying its rowid is the fastest way to retrieve a single row, because the exact location of the row in the database is specified.</p>
<p>To access a table by rowid, Oracle Database first obtains the rowids of the selected rows, either from the statement's <code>WHERE</code> clause or through an index scan of one or more of the table's indexes. Oracle Database then locates each selected row in the table based on its rowid.</p>
<p>In <a href="#i73898">Example 11-14, "EXPLAIN PLAN Output"</a>, the plan includes an index scan on the <code>jobs</code> and <code>departments</code> tables. The database uses the rowids retrieved to return the rows.</p>
<div id="PFGRF94610" class="sect3"><a id="sthref891"></a>
<h4 class="sect3"><span class="secnum">11.2.2.1</span> When the Optimizer Uses Rowids</h4>
<p>This is generally the second step after retrieving the rowid from an index. The table access might be required for any columns in the statement not present in the index.</p>
<p>Access by rowid does not need to follow every index scan. If the index contains all the columns needed for the statement, then table access by rowid might not occur.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Rowids are an internal representation of where the database stores data. Rowids can change between versions. Accessing data based on position is not recommended because rows can move around due to row migration and chaining, export and import, and some other operations. Foreign keys should be based on primary keys. For more information on rowids, see <a class="olink ADFNS" href="../../appdev.112/e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i52300"></a>
<div id="PFGRF94611" class="sect2">
<h3 class="sect2"><span class="secnum">11.2.3</span> Index Scans<a id="sthref892"></a><a id="sthref893"></a><a id="sthref894"></a></h3>
<p>In this method, a row is retrieved by traversing the index, using the indexed column values specified by the statement. An index scan retrieves data from an index based on the value of one or more columns in the index. To perform an index scan, Oracle Database searches the index for the indexed column values accessed by the statement. If the statement accesses only columns of the index, then Oracle Database reads the indexed column values directly from the index, rather than from the table.</p>
<p>The index contains not only the indexed value, but also the rowids of rows in the table having that value. Therefore, if the statement accesses other columns in addition to the indexed columns, then Oracle Database can find the rows in the table by using either a table access by rowid or a cluster scan.</p>
<p>An index scan can be one of the following types:</p>
<ul>
<li>
<p><a href="#i82433">Assessing I/O for Blocks, not Rows</a></p>
</li>
<li>
<p><a href="#i44986">Index Unique Scans</a></p>
</li>
<li>
<p><a href="#i45075">Index Range Scans</a></p>
</li>
<li>
<p><a href="#i45191">Index Range Scans Descending</a></p>
</li>
<li>
<p><a href="#i51571">Index Skip Scans</a></p>
</li>
<li>
<p><a href="#i82107">Full Scans</a></p>
</li>
<li>
<p><a href="#i52044">Fast Full Index Scans</a></p>
</li>
<li>
<p><a href="#i56068">Index Joins</a></p>
</li>
<li>
<p><a href="#i82117">Bitmap Indexes</a></p>
</li>
</ul>
<a id="i82433"></a>
<div id="PFGRF94612" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.1</span> Assessing I/O for Blocks, not Rows</h4>
<p>Oracle Database performs I/O by blocks. Therefore, the optimizer's decision to use full table scans is influenced by the percentage of blocks accessed, not rows. This is called the <span class="bold">index clustering factor</span>. If blocks contain single rows, then rows accessed and blocks accessed are the same.</p>
<p>However, most tables have multiple rows in each block. Consequently, the desired number of rows may be clustered in a few blocks or spread out over a larger number of blocks.</p>
<p>Although the clustering factor is a property of the index, the clustering factor actually relates to the spread of similar indexed column values within data blocks in the table. A lower clustering factor indicates that the individual rows are concentrated within fewer blocks in the table. Conversely, a high clustering factor indicates that the individual rows are scattered more randomly across blocks in the table. Therefore, a high clustering factor means that it costs more to use a range scan to fetch rows by rowid, because more blocks in the table need to be visited to return the data. <a href="#i82441">Example 11-4</a> shows how the clustering factor can affect cost.</p>
<div id="PFGRF94613" class="example">
<p class="titleinexample"><a id="i82441"></a>Example 11-4 Effects of Clustering Factor on Cost</p>
<p>Assume the following situation:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>There is a table with 9 rows.</p>
</li>
<li>
<p>There is a non-unique index on <code>col1</code> for table.</p>
</li>
<li>
<p>The <code>c1</code> column currently stores the values <code>A</code>, <code>B</code>, and <code>C</code>.</p>
</li>
<li>
<p>The table only has three data blocks.</p>
</li>
</ul>
<p>Case 1: The index clustering factor is low for the rows as they are arranged in the following diagram.</p>
<pre>
Block 1       Block 2        Block 3
-------       -------        -------
A  A  A       B  B  B        C  C  C
</pre>
<p>This is because the rows that have the same indexed column values for <code>c1</code> are located within the same physical blocks in the table. The cost of using a range scan to return all rows that have the value <code>A</code> is low because only one block in the table must be read.</p>
<p>Case 2: If the same rows in the table are rearranged so that the index values are scattered across the table blocks (rather than collocated), then the index clustering factor is higher.</p>
<pre>
Block 1       Block 2        Block 3
-------       -------        -------
A  B  C       A  B  C        A  B  C
</pre>
<p>This is because all three blocks in the table must be read in order to retrieve all rows with the value <code>A</code> in <code>col1</code>.</p>
</div>
<!-- class="sect3" -->
<a id="i44986"></a>
<div id="PFGRF94614" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.2</span> Index Unique Scans</h4>
<p>This scan returns, at most, a single rowid. Oracle Database performs a unique scan if a statement contains a <code>UNIQUE</code> or a <code>PRIMARY</code> <code>KEY</code> constraint that guarantees that only a single row is accessed.</p>
<p>In <a href="#i73898">"EXPLAIN PLAN Output"</a>, the database performs an index scan on the <code>jobs</code> and <code>departments</code> tables, using the <code>job_id_pk</code> and <code>dept_id_pk</code> indexes respectively.</p>
<div id="PFGRF94615" class="sect4"><a id="sthref895"></a>
<h5 class="sect4"><span class="secnum">11.2.3.2.1</span> When the Optimizer Uses Index Unique Scans</h5>
<p>The database uses this access path when the user specifies all columns of a unique (B-tree) index or an index created as a result of a primary key constraint with equality conditions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT010" href="../../server.112/e40540/tablecls.htm#CNCPT010"><span class="italic">Oracle Database Concepts</span></a> for more details on index structures and for detailed information on how a B-tree is searched</div>
</div>
<!-- class="sect4" -->
<div id="PFGRF94616" class="sect4"><a id="sthref896"></a>
<h5 class="sect4"><span class="secnum">11.2.3.2.2</span> Index Unique Scan Hints</h5>
<p>In general, you should not need to use a hint to do a unique scan. There might be cases where the table is across a database link and being accessed from a local table, or where the table is small enough for the optimizer to prefer a full table scan.</p>
<p>The hint <code>INDEX(</code><code><span class="codeinlineitalic">alias index_name</span></code><code>)</code> specifies the index to use, but not an access path (range scan or unique scan). For more information on the <code>INDEX</code> hint, see <a href="hintsref.htm#CHDJDIAH">"Hints for Access Paths"</a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i45075"></a>
<div id="PFGRF94617" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.3</span> Index Range Scans</h4>
<p>An index range scan is a common operation for accessing selective data. It can be bounded (bounded on both sides) or unbounded (on one or both sides). Data is returned in the ascending order of index columns. Multiple rows with identical values are sorted in ascending order by rowid.</p>
<p>If you require the data to be sorted by order, then use the <code>ORDER</code> <code>BY</code> clause, and do not rely on an index. If an index can satisfy an <code>ORDER</code> <code>BY</code> clause, then the optimizer uses this option and avoids a sort.</p>
<p>In <a href="#i69271">Example 11-5</a>, the order has been imported from a legacy system, and you are querying the order by the reference used in the legacy system. Assume this reference is the <code>order_date</code>.</p>
<div id="PFGRF94618" class="example">
<p class="titleinexample"><a id="i69271"></a>Example 11-5 Index Range Scan</p>
<pre>
SELECT order_status, order_id
  FROM orders
 WHERE order_date = :b1;

---------------------------------------------------------------------------------------
| Id  | Operation                   |  Name              | Rows  | Bytes | Cost (%CPU)|
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |                    |     1 |    20 |     3  (34)|
|   1 |  TABLE ACCESS BY INDEX ROWID| ORDERS             |     1 |    20 |     3  (34)|
|*  2 |   INDEX RANGE SCAN          | ORD_ORDER_DATE_IX  |     1 |       |     2  (50)|
---------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("ORDERS"."ORDER_DATE"=:Z)
</pre>
<p>This should be a highly selective query, and you should see the query using the index on the column to retrieve the desired rows. The data returned is sorted in ascending order by the rowids for the <code>order_date</code>. Because the index column <code>order_date</code> is identical for the selected rows here, the data is sorted by rowid.</p>
</div>
<!-- class="example" -->
<div id="PFGRF94619" class="sect4"><a id="sthref897"></a>
<h5 class="sect4"><span class="secnum">11.2.3.3.1</span> When the Optimizer Uses Index Range Scans</h5>
<p>The optimizer uses a range scan when it finds one or more leading columns of an index specified in conditions, such as the following:</p>
<ul>
<li>
<p><code>col1 = :b1</code></p>
</li>
<li>
<p><code>col1 &lt; :b1</code></p>
</li>
<li>
<p><code>col1 &gt; :b1</code></p>
</li>
<li>
<p><code>AND</code> combination of the preceding conditions for leading columns in the index</p>
</li>
<li>
<p><code>col1 like 'ASD%'</code> wild-card searches should not be in a leading position otherwise the condition <code>col1 like '%ASD'</code> does not result in a range scan</p>
</li>
</ul>
<p>Range scans can use unique or non-unique indexes. Range scans avoid sorting when index columns constitute the <code>ORDER</code> <code>BY</code>/<code>GROUP</code> <code>BY</code> clause.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94620" class="sect4"><a id="sthref898"></a>
<h5 class="sect4"><span class="secnum">11.2.3.3.2</span> Index Range Scan Hints</h5>
<p>A hint might be required if the optimizer chooses some other index or uses a full table scan. The hint <code>INDEX(</code><code><span class="codeinlineitalic">table_alias</span></code> <code><span class="codeinlineitalic">index_name</span></code><code>)</code> instructs the optimizer to use a specific index. For more information on the <code>INDEX</code> hint, see <a href="hintsref.htm#CHDJDIAH">"Hints for Access Paths"</a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i45191"></a>
<div id="PFGRF94621" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.4</span> Index Range Scans Descending</h4>
<p>An index range scan descending is identical to an index range scan, except that the data is returned in descending order. Indexes, by default, are stored in ascending order. Usually, the database uses this scan when ordering data in a descending order to return the most recent data first, or when seeking a value less than a specified value.</p>
<div id="PFGRF94622" class="sect4"><a id="sthref899"></a>
<h5 class="sect4"><span class="secnum">11.2.3.4.1</span> When the Optimizer Uses Index Range Scans Descending</h5>
<p>The optimizer uses index range scan descending when an index can satisfy an order by descending clause.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94623" class="sect4"><a id="sthref900"></a>
<h5 class="sect4"><span class="secnum">11.2.3.4.2</span> Index Range Scan Descending Hints</h5>
<p>Use the hint <code>INDEX_DESC(</code><code><span class="codeinlineitalic">table_alias</span></code> <code><span class="codeinlineitalic">index_name</span></code><code>)</code> for this access path. For more information on the <code>INDEX_DESC</code> hint, see <a href="hintsref.htm#CHDJDIAH">"Hints for Access Paths"</a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i51571"></a>
<div id="PFGRF10105" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.5</span> Index Skip Scans</h4>
<p>Index skip scans improve index scans by nonprefix columns. Often, scanning index blocks is faster than scanning table data blocks.</p>
<p>Skip scanning lets a composite index be split logically into smaller subindexes. In skip scanning, the initial column of the composite index is not specified in the query. In other words, it is skipped.</p>
<p>The database determines the number of logical subindexes by the number of distinct values in the initial column. Skip scanning is advantageous when there are few distinct values in the leading column of the composite index and many distinct values in the nonleading key of the index.</p>
<p>The database may choose an index skip scan when the leading column of the composite index is not specified in a query predicate. For example, assume that you run the following query for a customer in the <code>sh.customers</code> table:</p>
<pre>
SELECT * FROM sh.customers WHERE cust_email = 'Abbey@company.com';
</pre>
<p>The <code>customers</code> table has a column <code>cust_gender</code> whose values are either <code>M</code> or <code>F</code>. Assume that a composite index exists on the columns (<code>cust_gender</code>, <code>cust_email</code>) that was created as follows:</p>
<pre>
CREATE INDEX customers_gender_email ON sh.customers (cust_gender, cust_email);
</pre>
<p><a href="#CIHEIDFD">Example 11-6</a> shows a portion of the index entries.</p>
<div id="PFGRF95168" class="example">
<p class="titleinexample"><a id="CIHEIDFD"></a>Example 11-6 Composite Index Entries</p>
<pre>
F,Wolf@company.com,rowid
F,Wolsey@company.com,rowid
F,Wood@company.com,rowid
F,Woodman@company.com,rowid
F,Yang@company.com,rowid
F,Zimmerman@company.com,rowid
M,Abbassi@company.com,rowid
M,Abbey@company.com,rowid
</pre></div>
<!-- class="example" -->
<p>The database can use a skip scan of this index even though <code>cust_gender</code> is not specified in the <code>WHERE</code> clause.</p>
<p>In a skip scan, the number of logical subindexes is determined by the number of distinct values in the leading column. In <a href="#CIHEIDFD">Example 11-6</a>, the leading column has two possible values. The database logically splits the index into one subindex with the key <code>F</code> and a second subindex with the key <code>M</code>.</p>
<p>When searching for the record for the customer whose email is <code>Abbey@company.com</code>, the database searches the subindex with the value <code>F</code> first and then searches the subindex with the value <code>M</code>. Conceptually, the database processes the query as follows:</p>
<pre>
SELECT * FROM sh.customers WHERE cust_gender = 'F' 
  AND cust_email = 'Abbey@company.com'
UNION ALL
SELECT * FROM sh.customers WHERE cust_gender = 'M'
  AND cust_email = 'Abbey@company.com';
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF10105" href="../../server.112/e41573/optimops.htm#PFGRF10105"></a><a class="olink CNCPT88842" href="../../server.112/e40540/indexiot.htm#CNCPT88842"><span class="italic">Oracle Database Concepts</span></a> to learn more about skip scans</div>
</div>
<!-- class="sect3" -->
<a id="i82107"></a>
<div id="PFGRF10103" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.6</span> Full Scans</h4>
<p>A full index scan eliminates a sort operation, because the data is ordered by the index key. It reads the blocks singly. Oracle Database may use a full scan in any of the following situations:</p>
<ul>
<li>
<p>An <code>ORDER</code> <code>BY</code> clause that meets the following requirements is present in the query:</p>
<ul>
<li>
<p>All of the columns in the <code>ORDER</code> <code>BY</code> clause must be in the index.</p>
</li>
<li>
<p>The order of the columns in the <code>ORDER</code> <code>BY</code> clause must match the order of the leading index columns.</p>
</li>
</ul>
<p>The <code>ORDER</code> <code>BY</code> clause can contain all of the columns in the index or a subset of the columns in the index.</p>
</li>
<li>
<p>The query requires a sort merge join. The database can perform a full index scan instead of doing a full table scan followed by a sort when the query meets the following requirements:</p>
<ul>
<li>
<p>All of the columns referenced in the query must be in the index.</p>
</li>
<li>
<p>The order of the columns referenced in the query must match the order of the leading index columns.</p>
</li>
</ul>
<p>The query can contain all of the columns in the index or a subset of the columns in the index.</p>
</li>
<li>
<p>A <code>GROUP</code> <code>BY</code> clause is present in the query, and the columns in the <code>GROUP</code> <code>BY</code> clause are present in the index. The columns do not need to be in the same order in the index and the <code>GROUP</code> <code>BY</code> clause. The <code>GROUP</code> <code>BY</code> clause can contain all of the columns in the index or a subset of the columns in the index.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i49183">"Sort Merge Joins"</a></div>
</div>
<!-- class="sect3" -->
<a id="i52044"></a>
<div id="PFGRF94626" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.7</span> Fast Full Index Scans</h4>
<p>Fast full index scans are an alternative to a full table scan when the index contains all the columns that are needed for the query, and at least one column in the index key has the <code>NOT</code> <code>NULL</code> constraint. A fast full scan accesses the data in the index itself, without accessing the table. The database cannot use this scan to eliminate a sort operation because the data is not ordered by the index key. The database reads the entire index using multiblock reads, unlike a full index scan, and can scan in parallel.</p>
<p><a id="sthref901"></a><a id="sthref902"></a><a id="sthref903"></a><a id="sthref904"></a><a id="sthref905"></a>You can specify fast full index scans with the initialization parameter <code>OPTIMIZER_FEATURES_ENABLE</code> or the <code>INDEX_FFS</code> hint. A fast full scan is faster than a normal full index scan because it can use multiblock I/O and can run in parallel just like a table scan.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Setting <code>PARALLEL</code> for indexes does not impact the cost calculation.</div>
<div id="PFGRF94627" class="sect4"><a id="sthref906"></a>
<h5 class="sect4"><span class="secnum">11.2.3.7.1</span> Fast Full Index Scan Hints</h5>
<p>The fast full scan has a special index hint, <a id="sthref907"></a><code>INDEX_FFS</code>, which has the same format and arguments as the regular <code>INDEX</code> hint. For more information on the <code>INDEX_FFS</code> hint, see <a href="hintsref.htm#CHDJDIAH">"Hints for Access Paths"</a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i56068"></a>
<div id="PFGRF94628" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.8</span> Index Joins</h4>
<p>An <span class="bold">index join</span> is a hash join of several indexes that together contain all the table columns referenced in the query. If the database uses an index join, then table access is not needed because the database can retrieve all the relevant column values from the indexes. The database cannot use an index join to eliminate a sort operation.<a id="sthref908"></a><a id="sthref909"></a><a id="sthref910"></a><a id="sthref911"></a><a id="sthref912"></a></p>
<div id="PFGRF94629" class="sect4"><a id="sthref913"></a>
<h5 class="sect4"><span class="secnum">11.2.3.8.1</span> Index Join Hints</h5>
<p>You can specify an index join with the <code>INDEX_JOIN</code> hint. <a id="sthref914"></a><a id="sthref915"></a><a id="sthref916"></a><a id="sthref917"></a><a id="sthref918"></a>For more information on the <code>INDEX_JOIN</code> hint, see <a href="hintsref.htm#CHDJDIAH">"Hints for Access Paths"</a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i82117"></a>
<div id="PFGRF94630" class="sect3">
<h4 class="sect3"><span class="secnum">11.2.3.9</span> Bitmap Indexes</h4>
<p><a id="sthref919"></a>A bitmap join uses a bitmap for key values and a mapping function that converts each bit position to a rowid. Bitmaps can efficiently merge indexes that correspond to several conditions in a <code>WHERE</code> clause, using Boolean operations to resolve <code>AND</code> and <code>OR</code> conditions.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Bitmap indexes and bitmap join indexes are available only in the Oracle Enterprise Edition.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information about bitmap indexes</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i51070"></a>
<div id="PFGRF94631" class="sect2">
<h3 class="sect2"><span class="secnum">11.2.4</span> Cluster Access</h3>
<p><span class="bold"><a id="sthref920"></a></span><a id="sthref921"></a>The database uses a <span class="bold">cluster scan</span> to retrieve all rows that have the same cluster key value from a table stored in an indexed cluster. In an indexed cluster, the database stores all rows with the same cluster key value in the same data block. To perform a cluster scan, Oracle Database first obtains the rowid of one of the selected rows by scanning the cluster index. Oracle Database then locates the rows based on this rowid.</p>
</div>
<!-- class="sect2" -->
<a id="i51075"></a>
<div id="PFGRF94632" class="sect2">
<h3 class="sect2"><span class="secnum">11.2.5</span> Hash Access</h3>
<p><span class="bold"><a id="sthref922"></a></span><a id="sthref923"></a><a id="sthref924"></a>The database uses a <span class="bold">hash scan</span> to locate rows in a hash cluster based on a hash value. In a hash cluster, all rows with the same hash value are stored in the same data block. To perform a hash scan, Oracle Database first obtains the hash value by applying a hash function to a cluster key value specified by the statement. Oracle Database then scans the data blocks containing rows with that hash value.</p>
</div>
<!-- class="sect2" -->
<a id="i79194"></a>
<div id="PFGRF94633" class="sect2">
<h3 class="sect2"><span class="secnum">11.2.6</span> Sample Table Scans</h3>
<p><a id="sthref925"></a><a id="sthref926"></a><a id="sthref927"></a><a id="sthref928"></a><a id="sthref929"></a>A sample table scan retrieves a random sample of data from a simple table or a complex <code>SELECT</code> statement, such as a statement involving joins and views. The database uses this access path when a statement's <code>FROM</code> clause includes the <code>SAMPLE</code> clause or the <code>SAMPLE</code> <code>BLOCK</code> clause. To perform a sample table scan when sampling by rows with the <code>SAMPLE</code> clause, the database reads a specified percentage of rows in the table. To perform a sample table scan when sampling by blocks with the <code>SAMPLE</code> <code>BLOCK</code> clause, the database reads a specified percentage of table blocks.</p>
<p><a href="#i73167">Example 11-7</a> uses a sample table scan to access 1% of the <code>employees</code> table, sampling by blocks.</p>
<div id="PFGRF94634" class="example">
<p class="titleinexample"><a id="i73167"></a>Example 11-7 Sample Table Scan</p>
<pre>
SELECT * 
    FROM employees SAMPLE BLOCK (1); 
</pre>
<p><a id="sthref930"></a>The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>
<pre>
-------------------------------------------------------------------------
| Id  | Operation            |  Name       | Rows  | Bytes | Cost (%CPU)|
-------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |             |     1 |    68 |     3  (34)|
|   1 |  TABLE ACCESS SAMPLE | EMPLOYEES   |     1 |    68 |     3  (34)|
-------------------------------------------------------------------------
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i36043"></a>
<div id="PFGRF94635" class="sect2">
<h3 class="sect2"><span class="secnum">11.2.7</span> How the Query Optimizer Chooses an Access Path</h3>
<p><span class="bold"><a id="sthref931"></a></span>The query optimizer chooses an access path based on the following factors:</p>
<ul>
<li>
<p>The available access paths for the statement</p>
</li>
<li>
<p>The estimated cost of executing the statement, using each access path or combination of paths</p>
</li>
</ul>
<p>To choose an access path, the optimizer first determines which access paths are available by examining the conditions in the statement's <code>WHERE</code> clause and its <code>FROM</code> clause. The optimizer then generates a set of possible execution plans using available access paths and estimates the cost of each plan, using the statistics for the index, columns, and tables accessible to the statement. Finally, the optimizer chooses the execution plan with the lowest estimated cost.</p>
<p>When choosing an access path, the query optimizer is influenced by the following:</p>
<ul>
<li>
<p><a id="sthref932"></a><a id="sthref933"></a><a id="sthref934"></a><a id="sthref935"></a><a id="sthref936"></a><a id="sthref937"></a>Optimizer Hints</p>
<p>You can instruct the optimizer to use a specific access path using a hint, except when the statement's <code>FROM</code> clause contains <code>SAMPLE</code> or <code>SAMPLE</code> <code>BLOCK</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="hintsref.htm#i8327">Chapter 19, "Using Optimizer Hints"</a> for information about hints in SQL statements</div>
</li>
<li id="i73225">
<p>Old Statistics</p>
<p>For example, if a table has not been analyzed since it was created, and if it has less than <code>DB_FILE_MULTIBLOCK_READ_COUNT</code> blocks under the high water mark, then the optimizer thinks that the table is small and uses a full table scan. Review the <code>LAST_ANALYZED</code> and <code>BLOCKS</code> columns in the <code>ALL_TABLES</code> table to examine the statistics.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i51523"></a>
<div id="PFGRF94636" class="sect1">
<h2 class="sect1"><span class="secnum">11.3</span> Overview of Joins</h2>
<p><span class="bold">Joins</span> are statements that retrieve data from multiple tables. A join is characterized by multiple tables in the <code>FROM</code> clause. The existence of a join condition in the <code>WHERE</code> clause defines the relationship between the tables. In a join, one row set is called inner, and the other is called outer.</p>
<p>This section discusses:</p>
<ul>
<li>
<p><a href="#i36235">How the Query Optimizer Executes Join Statements</a></p>
</li>
<li>
<p><a href="#i76330">How the Query Optimizer Chooses Execution Plans for Joins</a></p>
</li>
<li>
<p><a href="#i49732">Nested Loop Joins</a></p>
</li>
<li>
<p><a href="#i76073">Hash Joins</a></p>
</li>
<li>
<p><a href="#i49183">Sort Merge Joins</a></p>
</li>
<li>
<p><a href="#BABDGFIE">Cartesian Joins</a></p>
</li>
<li>
<p><a href="#i50026">Outer Joins</a></p>
</li>
</ul>
<a id="i36235"></a>
<div id="PFGRF94637" class="sect2">
<h3 class="sect2"><span class="secnum">11.3.1</span> How the Query Optimizer Executes Join Statements</h3>
<p><a id="sthref938"></a><a id="sthref939"></a>To choose an execution plan for a join statement, the optimizer must make these interrelated decisions:</p>
<ul>
<li>
<p>Access Paths</p>
<p>As for simple statements, the optimizer must choose an access path to retrieve data from each table in the join statement.</p>
</li>
<li>
<p>Join Method</p>
<p>To join each pair of row sources, Oracle Database must perform a join operation. Join methods include nested loop, sort merge, cartesian, and hash joins.</p>
</li>
<li>
<p>Join Order</p>
<p>To execute a statement that joins more than two tables, Oracle Database joins two of the tables and then joins the resulting row source to the next table. This process continues until all tables are joined into the result.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i82080">"Overview of Optimizer Access Paths"</a></div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i76330"></a>
<div id="PFGRF94638" class="sect2">
<h3 class="sect2"><span class="secnum">11.3.2</span> How the Query Optimizer Chooses Execution Plans for Joins</h3>
<p>The query optimizer considers the following when choosing an execution plan:</p>
<ul>
<li>
<p>The optimizer first determines whether joining two or more tables definitely results in a row source containing at most one row. The optimizer recognizes such situations based on <code>UNIQUE</code> and <code>PRIMARY</code> <code>KEY</code> constraints on the tables. If such a situation exists, then the optimizer places these tables first in the join order. The optimizer then optimizes the join of the remaining set of tables.</p>
</li>
<li>
<p>For join statements with outer join conditions, the table with the outer join operator must come after the other table in the condition in the join order. The optimizer does not consider join orders that violate this rule. Similarly, when a subquery has been converted into an <a id="sthref940"></a><a id="sthref941"></a><a id="sthref942"></a><a id="sthref943"></a>antijoin or <a id="sthref944"></a><a id="sthref945"></a>semijoin, the tables from the subquery must come after those tables in the outer query block to which they were connected or correlated. However, hash antijoins and semijoins are able to override this ordering condition in certain circumstances.</p>
</li>
</ul>
<p>With the query optimizer, the optimizer generates a set of execution plans, according to possible join orders, join methods, and available access paths. The optimizer then estimates the cost of each plan and chooses the one with the lowest cost. The optimizer estimates costs in the following ways:</p>
<ul>
<li>
<p><a id="sthref946"></a><a id="sthref947"></a>The cost of a nested loops operation is based on the cost of reading each selected row of the outer table and each of its matching rows of the inner table into memory. The optimizer estimates these costs using the statistics in the data dictionary.</p>
</li>
<li>
<p><a id="sthref948"></a><a id="sthref949"></a>The cost of a sort merge join is based largely on the cost of reading all the sources into memory and sorting them.</p>
</li>
<li>
<p><a id="sthref950"></a><a id="sthref951"></a>The cost of a hash join is based largely on the cost of building a hash table on one of the input sides to the join and using the rows from the other of the join to probe it.</p>
</li>
</ul>
<p>The optimizer also considers other factors when determining the cost of each operation. For example:</p>
<ul>
<li>
<p>A smaller sort area size is likely to increase the cost for a sort merge join because sorting takes more CPU time and I/O in a smaller sort area. See <a href="memory.htm#i49320">"PGA Memory Management"</a> to learn how to size SQL work areas.</p>
</li>
<li>
<p>A larger multiblock read count is likely to decrease the cost for a sort merge join in relation to a nested loop join. If the database can read a large number of sequential blocks from disk in a single I/O, then an index on the inner table for the nested loop join is less likely to improve performance over a full table scan. The multiblock read count is specified by the initialization parameter<a id="sthref952"></a><a id="sthref953"></a> <code>DB_FILE_MULTIBLOCK_READ_COUNT</code>.</p>
</li>
</ul>
<p>You can use the <code>ORDERED</code> hint to override the optimizer's choice of join orders. If the <code>ORDERED</code> hint specifies a join order that violates the rule for an outer join, then the optimizer ignores the hint and chooses the order. Also, you can override the optimizer's choice of join method with hints.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="hintsref.htm#i8327">Chapter 19, "Using Optimizer Hints"</a> for more information about optimizer hints</div>
</div>
<!-- class="sect2" -->
<a id="i49732"></a>
<div id="PFGRF94639" class="sect2">
<h3 class="sect2"><span class="secnum">11.3.3</span> Nested Loop Joins</h3>
<p><a id="sthref954"></a><a id="sthref955"></a>Nested loop joins are useful when the following conditions are true:</p>
<ul>
<li>
<p>The database joins small subsets of data.</p>
</li>
<li>
<p>The join condition is an efficient method of accessing the second table.</p>
</li>
</ul>
<p>It is important to ensure that the inner table is driven from (dependent on) the outer table. If the inner table's access path is independent of the outer table, then the same rows are retrieved for every iteration of the outer loop, degrading performance considerably. In such cases, hash joins joining the two independent row sources perform better.</p>
<p>A nested loop join involves the following steps:</p>
<ol>
<li>
<p>The optimizer determines the driving table and designates it as the outer table.</p>
</li>
<li>
<p>The other table is designated as the inner table.</p>
</li>
<li>
<p>For every row in the outer table, Oracle Database accesses all the rows in the inner table. The outer loop is for every row in the outer table and the inner loop is for every row in the inner table. The outer loop appears before the inner loop in the execution plan, as follows:</p>
<pre>
NESTED LOOPS 
  <span class="italic">outer_loop</span> 
  <span class="italic">inner_loop</span> 
</pre></li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABDGFIE">"Cartesian Joins"</a></div>
<div id="PFGRF94640" class="sect3"><a id="sthref956"></a>
<h4 class="sect3"><span class="secnum">11.3.3.1</span> Original and New Implementation for Nested Loop Joins</h4>
<p>Oracle Database 11<span class="italic">g</span> introduces a new implementation for nested loop joins. As a result, execution plans that include nested loops might appear different than they did in previous releases of Oracle Database. Both the new implementation and the original implementation for nested loop joins are possible in Oracle Database 11<span class="italic">g</span>. So, when analyzing execution plans, it is important to understand that the number of <code>NESTED</code> <code>LOOPS</code> join row sources might be different.</p>
<a id="BABFCIAI"></a>
<div id="PFGRF94641" class="sect4">
<h5 class="sect4"><span class="secnum">11.3.3.1.1</span> Original Implementation for Nested Loop Joins</h5>
<p>Consider the following query:</p>
<pre>
SELECT e.first_name, e.last_name, e.salary, d.department_name
    FROM hr.employees e, hr.departments d
    WHERE d.department_name IN ('Marketing', 'Sales')
      AND e.department_id = d.department_id;
</pre>
<p>Before Oracle Database 11<span class="italic">g</span>, the execution plan for this query might appear similar to the following execution plan:</p>
<pre>
-------------------------------------------------------------------------------------------------
| Id  | Operation                   | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |                   |    19 |   722 |     3  (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |    10 |   220 |     1  (0)| 00:00:01 |
|   2 |   NESTED LOOPS              |                   |    19 |   722 |     3  (0)| 00:00:01 |
|*  3 |    TABLE ACCESS FULL        | DEPARTMENTS       |     2 |    32 |     2  (0)| 00:00:01 |
|*  4 |    INDEX RANGE SCAN         | EMP_DEPARTMENT_IX |    10 |       |     0  (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   3 - filter("D"."DEPARTMENT_NAME"='Marketing' OR "D"."DEPARTMENT_NAME"='Sales')
   4 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</pre>
<p>In this example, the outer side of the join consists of a scan of the <code>hr.departments</code> table that returns the rows that match the condition <code>department_name</code> <code>IN</code> <code>('Marketing', 'Sales')</code>. The inner loop retrieves the employees in the <code>hr.employees</code> table that are associated with those departments.</p>
</div>
<!-- class="sect4" -->
<div id="PFGRF94642" class="sect4"><a id="sthref957"></a>
<h5 class="sect4"><span class="secnum">11.3.3.1.2</span> New Implementation for Nested Loop Joins</h5>
<p>Oracle Database 11<span class="italic">g</span> introduces a new implementation for nested loop joins to reduce overall latency for physical I/O. When an index or a table block is not in the buffer cache and is needed to process the join, a physical I/O is required. Oracle Database 11<span class="italic">g</span> can batch multiple physical I/O requests and process them using a vector I/O instead of processing them one at a time.</p>
<p>As part of the new implementation for nested loop joins, two <code>NESTED</code> <code>LOOPS</code> join row sources might appear in the execution plan where only one would have appeared in prior releases. In such cases, Oracle Database allocates one <code>NESTED</code> <code>LOOPS</code> join row source to join the values from the table on the outer side of the join with the index on the inner side. A second row source is allocated to join the result of the first join, which includes the rowids stored in the index, with the table on the inner side of the join.</p>
<p>Consider the query in <a href="#BABFCIAI">"Original Implementation for Nested Loop Joins"</a>. In Oracle Database 11<span class="italic">g</span>, with the new implementation for nested loop joins, the execution plan for this query might appear similar to the following execution plan:</p>
<pre>
------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name              | Rows  | Bytes | Cost(%CPU)| Time      |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                   |    19 |   722 |     3   (0)| 00:00:01 |
|   1 |  NESTED LOOPS                |                   |       |       |            |          |
|   2 |   NESTED LOOPS               |                   |    19 |   722 |     3   (0)| 00:00:01 |
|*  3 |    TABLE ACCESS FULL         | DEPARTMENTS       |     2 |    32 |     2   (0)| 00:00:01 |
|*  4 |    INDEX RANGE SCAN          | EMP_DEPARTMENT_IX |    10 |       |     0   (0)| 00:00:01 |
|   5 |   TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |    10 |   220 |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   3 - filter("D"."DEPARTMENT_NAME"='Marketing' OR "D"."DEPARTMENT_NAME"='Sales')
   4 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</pre>
<p>In this case, the rows from the <code>hr.departments</code> table constitute the outer side of the first join. The inner side of the first join is the index <code>emp_department_ix</code>. The results of the first join constitute the outer side of the second join, which has the <code>hr.employees</code> table as its inner side.</p>
<p>There are cases where a second join row source is not allocated, and the execution plan looks the same as it did in prior releases. The following list describes such cases:</p>
<ul>
<li>
<p>All of the columns needed from the inner side of the join are present in the index, and there is no table access required. In this case, Oracle Database allocates only one join row source.</p>
</li>
<li>
<p>The order of the rows returned might be different than it was in previous releases. Hence, when Oracle Database tries to preserve a specific ordering of the rows, for example to eliminate the need for an <code>ORDER</code> <code>BY</code> sort, Oracle Database might use the original implementation for nested loop joins.</p>
</li>
<li>
<p>The <code>OPTIMIZER_FEATURES_ENABLE</code> initialization parameter is set to a release before Oracle Database 11<span class="italic">g</span>. In this case, Oracle Database uses the original implementation for nested loop joins.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="PFGRF94643" class="sect3"><a id="sthref958"></a>
<h4 class="sect3"><span class="secnum">11.3.3.2</span> When the Optimizer Uses Nested Loop Joins</h4>
<p>The optimizer uses nested loop joins when joining small number of rows, with a good driving condition between the two tables. You drive from the outer loop to the inner loop, so the order of tables in the execution plan is important.</p>
<p>The outer loop is the driving row source. It produces a set of rows for driving the join condition. The row source can be a table accessed using an index scan or a full table scan. Also, the rows can be produced from any other operation. For example, the output from a nested loop join can serve as a row source for another nested loop join.</p>
<p>The inner loop is iterated for every row returned from the outer loop, ideally by an index scan. If the access path for the inner loop is not dependent on the outer loop, then you can end up with a Cartesian product; for every iteration of the outer loop, the inner loop produces the same set of rows. Therefore, you should use other join methods when two independent row sources are joined together.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94644" class="sect3"><a id="sthref959"></a>
<h4 class="sect3"><span class="secnum">11.3.3.3</span> Nested Loop Join Hints</h4>
<p>If the optimizer chooses to use some other join method, then you can use the <code>USE_NL</code>(<code>table1 table2</code>) hint, where <code>table1</code> and <code>table2</code> are the aliases of the tables being joined.</p>
<p>For some SQL examples, the data is small enough for the optimizer to prefer full table scans and use hash joins. This is the case for the SQL example shown in <a href="#i59484">Example 11-8, "Hash Joins"</a>. However, you can add a <code>USE_NL</code> to instruct the optimizer to change the join method to nested loop. For more information on the <code>USE_NL</code> hint, see <a href="hintsref.htm#CHDBAFID">"Hints for Join Operations"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94645" class="sect3"><a id="sthref960"></a>
<h4 class="sect3"><span class="secnum">11.3.3.4</span> Nesting Nested Loops</h4>
<p>The outer loop of a nested loop can be a nested loop itself. You can nest two or more outer loops to join as many tables as needed. Each loop is a data access method, as follows:</p>
<pre>
SELECT STATEMENT
 NESTED LOOP 3
  NESTED LOOP 2          (OUTER LOOP 3.1)
   NESTED LOOP 1         (OUTER LOOP 2.1)
    OUTER LOOP 1.1     - #1
    INNER LOOP 1.2     - #2
   INNER LOOP 2.2      - #3
  INNER LOOP 3.2       - #4
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i76073"></a>
<div id="PFGRF94646" class="sect2">
<h3 class="sect2"><span class="secnum">11.3.4</span> Hash Joins</h3>
<p><a id="sthref961"></a><a id="sthref962"></a>The database uses <span class="bold">hash joins</span> to join large data sets. The optimizer uses the smaller of two tables or data sources to build a hash table on the join key in memory. It then scans the larger table, probing the hash table to find the joined rows.</p>
<p>This method is best when the smaller table fits in available memory. The cost is then limited to a single read pass over the data for the two tables.</p>
<div id="PFGRF94647" class="sect3"><a id="sthref963"></a>
<h4 class="sect3"><span class="secnum">11.3.4.1</span> When the Optimizer Uses Hash Joins</h4>
<p>The optimizer uses a hash join to join two tables if they are joined using an equijoin and if either of the following conditions are true:</p>
<ul>
<li>
<p>A large amount of data must be joined.</p>
</li>
<li>
<p>A large fraction of a small table must be joined.</p>
</li>
</ul>
<p>In <a href="#i59484">Example 11-8</a>, the database uses the table <code>orders</code> to build the hash table. The database scans the larger <code>order_items</code> later.</p>
<div id="PFGRF94648" class="example">
<p class="titleinexample"><a id="i59484"></a>Example 11-8 Hash Joins</p>
<pre>
SELECT o.customer_id, l.unit_price * l.quantity
  FROM orders o ,order_items l
 WHERE l.order_id = o.order_id;

--------------------------------------------------------------------------
| Id  | Operation            |  Name        | Rows  | Bytes | Cost (%CPU)|
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |              |   665 | 13300 |     8  (25)|
|*  1 |  HASH JOIN           |              |   665 | 13300 |     8  (25)|
|   2 |   TABLE ACCESS FULL  | ORDERS       |   105 |   840 |     4  (25)|
|   3 |   TABLE ACCESS FULL  | ORDER_ITEMS  |   665 |  7980 |     4  (25)|
--------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("L"."ORDER_ID"="O"."ORDER_ID")
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="PFGRF94649" class="sect3"><a id="sthref964"></a>
<h4 class="sect3"><span class="secnum">11.3.4.2</span> Hash Join Hints</h4>
<p>Apply the <code>USE_HASH</code> hint to instruct the optimizer to use a hash join when joining two tables together. See <a href="memory.htm#i49320">"PGA Memory Management"</a> to learn how to size SQL work areas. See <a href="hintsref.htm#CHDBAFID">"Hints for Join Operations"</a> to learn about the <code>USE_HASH</code> hint.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i49183"></a>
<div id="PFGRF94650" class="sect2">
<h3 class="sect2"><span class="secnum">11.3.5</span> Sort Merge Joins</h3>
<p><a id="sthref965"></a><a id="sthref966"></a>Sort merge joins can join rows from two independent sources. Hash joins generally perform better than sort merge joins. However, sort merge joins can perform better than hash joins if both of the following conditions exist:</p>
<ul>
<li>
<p>The row sources are sorted already.</p>
</li>
<li>
<p>A sort operation does not have to be done.</p>
</li>
</ul>
<p>However, if a sort merge join involves choosing a slower access method (an index scan as opposed to a full table scan), then the benefit of using a sort merge might be lost.</p>
<p>Sort merge joins are useful when the join condition between two tables is an inequality condition such as <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>. Sort merge joins perform better than nested loop joins for large data sets. You cannot use hash joins unless there is an equality condition.</p>
<p>In a merge join, there is no concept of a driving table. The join consists of two steps:</p>
<ol>
<li>
<p>Sort join operation: Both the inputs are sorted on the join key.</p>
</li>
<li>
<p>Merge join operation: The sorted lists are merged together.</p>
</li>
</ol>
<p>If the input is sorted by the join column, then a sort join operation is not performed for that row source. However, a sort merge join always creates a positionable sort buffer for the right side of the join so that it can seek back to the last match in the case where duplicate join key values come out of the left side of the join.</p>
<div id="PFGRF94651" class="sect3"><a id="sthref967"></a>
<h4 class="sect3"><span class="secnum">11.3.5.1</span> When the Optimizer Uses Sort Merge Joins</h4>
<p>The optimizer can choose a sort merge join over a hash join for joining large amounts of data if any of the following conditions are true:</p>
<ul>
<li>
<p>The join condition between two tables is not an equijoin.</p>
</li>
<li>
<p>Because of sorts required by other operations, the optimizer finds it is cheaper to use a sort merge than a hash join.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="PFGRF94652" class="sect3"><a id="sthref968"></a>
<h4 class="sect3"><span class="secnum">11.3.5.2</span> Sort Merge Join Hints</h4>
<p>To instruct the optimizer to use a sort merge join, apply the <code>USE_MERGE</code> hint. You might also need to give hints to force an access path.</p>
<p>There are situations where it makes sense to override the optimizer with the <code>USE_MERGE</code> hint. For example, the optimizer can choose a full scan on a table and avoid a sort operation in a query. However, there is an increased cost because a large table is accessed through an index and single block reads, as opposed to faster access through a full table scan.</p>
<p>For more information on the <code>USE_MERGE</code> hint, see <a href="hintsref.htm#CHDBAFID">"Hints for Join Operations"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDGFIE"></a>
<div id="PFGRF94653" class="sect2">
<h3 class="sect2"><span class="secnum">11.3.6</span> Cartesian Joins</h3>
<p>The database uses a <a id="sthref969"></a><a id="sthref970"></a><span class="bold">Cartesian join</span> when one or more of the tables does not have any join conditions to any other tables in the statement. The optimizer joins every row from one data source with every row from the other data source, creating the Cartesian product of the two sets.</p>
<div id="PFGRF94654" class="sect3"><a id="sthref971"></a>
<h4 class="sect3"><span class="secnum">11.3.6.1</span> When the Optimizer Uses Cartesian Joins</h4>
<p>The optimizer uses Cartesian joins when it is asked to join two tables with no join conditions. In some cases, a common filter condition between the two tables could be picked up by the optimizer as a possible join condition. In other cases, the optimizer may decide to generate a Cartesian product of two very small tables that are both joined to the same large table.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94655" class="sect3"><a id="sthref972"></a>
<h4 class="sect3"><span class="secnum">11.3.6.2</span> Cartesian Join Hints</h4>
<p>Applying the <code>ORDERED</code> hint, instructs the optimizer to use a Cartesian join. By specifying a table before its join table is specified, the optimizer does a Cartesian join.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i50026"></a>
<div id="PFGRF94656" class="sect2">
<h3 class="sect2"><span class="secnum">11.3.7</span> Outer Joins</h3>
<p>An <a id="sthref973"></a><a id="sthref974"></a>outer join extends the result of a simple join. An outer join returns all rows that satisfy the join condition and also returns some or all of those rows from one table for which no rows from the other satisfy the join condition.</p>
<a id="i77041"></a>
<div id="PFGRF94657" class="sect3">
<h4 class="sect3"><span class="secnum">11.3.7.1</span> Nested Loop Outer Joins</h4>
<p>The database uses this operation to loop through an outer join between two tables. The outer join returns the outer (preserved) table rows, even when no corresponding rows are in the inner (optional) table.</p>
<p>In a regular outer join, the optimizer chooses the order of tables (driving and driven) based on the cost. However, in a nested loop outer join, the join condition determines the order of tables. The database uses the outer table, with rows that are being preserved, to drive to the inner table.</p>
<p>The optimizer uses nested loop joins to process an outer join in the following circumstances:</p>
<ul>
<li>
<p>It is possible to drive from the outer table to inner table.</p>
</li>
<li>
<p>Data volume is low enough to make the nested loop method efficient.</p>
</li>
</ul>
<p>For an example of a nested loop outer join, you can add the <code>USE_NL</code> hint to <a href="#i76955">Example 11-9</a> to instruct the optimizer to use a nested loop. For example:</p>
<pre>
SELECT /*+ USE_NL(c o) */ cust_last_name, SUM(NVL2(o.customer_id,0,1)) "Count"
FROM   customers c, orders o
WHERE  c.credit_limit &gt; 1000
AND    c.customer_id = o.customer_id(+)
GROUP BY cust_last_name;
</pre></div>
<!-- class="sect3" -->
<a id="i76944"></a>
<div id="PFGRF94658" class="sect3">
<h4 class="sect3"><span class="secnum">11.3.7.2</span> Hash Join Outer Joins</h4>
<p>The optimizer uses hash joins for processing an outer join in the following cases:</p>
<ul>
<li>
<p>The data volume is large enough to make the hash join method efficient.</p>
</li>
<li>
<p>It is not possible to drive from the outer table to the inner table.</p>
</li>
</ul>
<p>The order of tables is determined by cost. The outer table, including preserved rows, may be used to build the hash table, or it may be used to probe one.</p>
<p><a href="#i76955">Example 11-9</a> shows a typical query that uses a hash join outer join. This example queries all customers with credit limits greater than 1000. An outer join is needed to avoid missing customers who have no orders.</p>
<div id="PFGRF94659" class="example">
<p class="titleinexample"><a id="i76955"></a>Example 11-9 Hash Join Outer Joins</p>
<pre>
SELECT cust_last_name, SUM(NVL2(o.customer_id,0,1)) "Count"
FROM   customers c, orders o
WHERE  c.credit_limit &gt; 1000
AND    c.customer_id = o.customer_id(+)
GROUP BY cust_last_name;

---------------------------------------------------------------------------------
| Id  | Operation           | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------
 
PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------|   0 | SELECT STATEMENT    |           |       |       |     7 (100)|          |
|   1 |  HASH GROUP BY      |           |   168 |  3192 |     7  (29)| 00:00:01 |
|*  2 |   <span class="bold">HASH JOIN OUTER</span>   |           |   318 |  6042 |     6  (17)| 00:00:01 |
|*  3 |    TABLE ACCESS FULL| CUSTOMERS |   260 |  3900 |     3   (0)| 00:00:01 |
|*  4 |    TABLE ACCESS FULL| ORDERS    |   105 |   420 |     2   (0)| 00:00:01 |
---------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("C"."CUSTOMER_ID"="O"."CUSTOMER_ID")
 
PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------
   3 - filter("C"."CREDIT_LIMIT"&gt;1000)
   4 - filter("O"."CUSTOMER_ID"&gt;0)
</pre>
<p>The query looks for customers which satisfy various conditions. An outer join returns <code>NULL</code> for the inner table columns along with the outer (preserved) table rows when it does not find any corresponding rows in the inner table. This operation finds all the <code>customers</code> rows that do not have any <code>orders</code> rows.</p>
<p>In this case, the outer join condition is the following:</p>
<pre>
customers.customer_id = orders.customer_id(+)
</pre>
<p>The components of this condition represent the following:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p>The outer table is <code>customers</code>.</p>
</li>
<li>
<p>The inner table is <code>orders</code>.</p>
</li>
<li>
<p>The join preserves the <code>customers</code> rows, including those rows without a corresponding row in <code>orders</code>.</p>
</li>
</ul>
<p>You could use a <code>NOT</code> <code>EXISTS</code> subquery to return the rows. However, because you are querying all the rows in the table, the hash join performs better (unless the <code>NOT</code> <code>EXISTS</code> subquery is not nested).</p>
<p>In <a href="#i76995">Example 11-10</a>, the outer join is to a multitable view. The optimizer cannot drive into the view like in a normal join or push the predicates, so it builds the entire row set of the view.</p>
<div id="PFGRF94660" class="example">
<p class="titleinexample"><a id="i76995"></a>Example 11-10 Outer Join to a Multitable View</p>
<pre>
SELECT c.cust_last_name, sum(revenue)
  FROM customers c, v_orders o
 WHERE c.credit_limit &gt; 2000
   AND o.customer_id(+) = c.customer_id
 GROUP BY c.cust_last_name;

----------------------------------------------------------------------------
| Id  | Operation              |  Name        | Rows  | Bytes | Cost (%CPU)|
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |              |   144 |  4608 |    16  (32)|
|   1 |  HASH GROUP BY         |              |   144 |  4608 |    16  (32)|
|*  2 |   HASH JOIN OUTER      |              |   663 | 21216 |    15  (27)|
|*  3 |    TABLE ACCESS FULL   | CUSTOMERS    |   195 |  2925 |     6  (17)|
|   4 |    VIEW                | V_ORDERS     |   665 | 11305 |            |
|   5 |     HASH GROUP BY      |              |   665 | 15960 |     9  (34)|
|*  6 |      HASH JOIN         |              |   665 | 15960 |     8  (25)|
|*  7 |       TABLE ACCESS FULL| ORDERS       |   105 |   840 |     4  (25)|
|   8 |       TABLE ACCESS FULL| ORDER_ITEMS  |   665 | 10640 |     4  (25)|
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("O"."CUSTOMER_ID"(+)="C"."CUSTOMER_ID")
   3 - filter("C"."CREDIT_LIMIT"&gt;2000)
   6 - access("O"."ORDER_ID"="L"."ORDER_ID")
   7 - filter("O"."CUSTOMER_ID"&gt;0)
</pre>
<p>The view definition is as follows:</p>
<pre>
CREATE OR REPLACE view v_orders AS
SELECT l.product_id, SUM(l.quantity*unit_price) revenue, 
       o.order_id, o.customer_id
  FROM orders o, order_items l
 WHERE o.order_id = l.order_id
 GROUP BY l.product_id, o.order_id, o.customer_id;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i76931"></a>
<div id="PFGRF94661" class="sect3">
<h4 class="sect3"><span class="secnum">11.3.7.3</span> Sort Merge Outer Joins</h4>
<p>When an outer join cannot drive from the outer (preserved) table to the inner (optional) table, it cannot use a hash join or nested loop joins. Then it uses the sort merge outer join for performing the join operation.</p>
<p>The optimizer uses sort merge for an outer join:</p>
<ul>
<li>
<p>If a nested loop join is inefficient. A nested loop join can be inefficient because of data volumes.</p>
</li>
<li>
<p>The optimizer finds it is cheaper to use a sort merge over a hash join because of sorts required by other operations.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="PFGRF94662" class="sect3"><a id="sthref975"></a>
<h4 class="sect3"><span class="secnum">11.3.7.4</span> Full Outer Joins</h4>
<p>A <a id="sthref976"></a><a id="sthref977"></a>full outer join acts like a combination of the left and right outer joins. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join are preserved and extended with nulls. In other words, full outer joins let you join tables together, yet still show rows that do not have corresponding rows in the joined tables.</p>
<p>The query in <a href="#i60301">Example 11-11</a> retrieves all departments and all employees in each department, but also includes:</p>
<ul>
<li>
<p>Any employees without departments</p>
</li>
<li>
<p>Any departments without employees</p>
</li>
</ul>
<div id="PFGRF94663" class="example">
<p class="titleinexample"><a id="i60301"></a>Example 11-11 Full Outer Join</p>
<pre>
SELECT d.department_id, e.employee_id
  FROM employees e
  FULL OUTER JOIN departments d
    ON e.department_id = d.department_id
 ORDER BY d.department_id;
</pre>
<p>The statement produces the following output:</p>
<pre>
DEPARTMENT_ID EMPLOYEE_ID
------------- -----------
           10         200
           20         201
           20         202
           30         114
           30         115
           30         116
...
          270
          280
                      178
                      207

125 rows selected.
</pre></div>
<!-- class="example" -->
<p>Starting with Oracle Database 11<span class="italic">g</span>, Oracle Database automatically uses a native execution method based on a hash join for executing full outer joins whenever possible. When the database uses the new method to execute a full outer join, the execution plan for the query contains <code>HASH</code> <code>JOIN</code> <code>FULL</code> <code>OUTER</code>. <a href="#BABFDHJA">Example 11-12</a> shows the execution plan for the query in <a href="#i60301">Example 11-11</a>.</p>
<div id="PFGRF94664" class="example">
<p class="titleinexample"><a id="BABFDHJA"></a>Example 11-12 Execution Plan for a Full Outer Join</p>
<pre>
----------------------------------------------------------------------------------------
| Id  | Operation               | Name       | Rows  | Bytes | Cost (%CPU)| Time      |
----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT        |            |   122 |  4758 |     6  (34)| 00:0 0:01 |
|   1 |  SORT ORDER BY          |            |   122 |  4758 |     6  (34)| 00:0 0:01 |
|   2 |   VIEW                  | VW_FOJ_0   |   122 |  4758 |     5  (20)| 00:0 0:01 |
|*  3 |    HASH JOIN FULL OUTER |            |   122 |  1342 |     5  (20)| 00:0 0:01 |
|   4 |     INDEX FAST FULL SCAN| DEPT_ID_PK |    27 |   108 |     2   (0)| 00:0 0:01 |
|   5 |     TABLE ACCESS FULL   | EMPLOYEES  |   107 |   749 |     2   (0)| 00:0 0:01 |
----------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   3 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</pre></div>
<!-- class="example" -->
<p>Notice that <code>HASH</code> <code>JOIN</code> <code>FULL</code> <code>OUTER</code> is included in the plan. Therefore, the query uses the hash full outer join execution method. Typically, when the full outer join condition between two tables is an equi-join, the hash full outer join execution method is possible, and Oracle Database uses it automatically.</p>
<p>To instruct the optimizer to consider using the hash full outer join execution method, apply the <code>NATIVE_FULL_OUTER_JOIN</code> hint. To instruct the optimizer not to consider using the hash full outer join execution method, apply the <code>NO_NATIVE_FULL_OUTER_JOIN</code> hint. The <code>NO_NATIVE_FULL_OUTER_JOIN</code> hint instructs the optimizer to exclude the native execution method when joining each specified table. Instead, the full outer join is executed as a union of left outer join and an anti-join.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i82029"></a>
<div id="PFGRF94594" class="sect1">
<h2 class="sect1"><span class="secnum">11.4</span> Reading and Understanding Execution Plans</h2>
<p><a id="sthref978"></a><a id="sthref979"></a>To execute a SQL statement, Oracle Database may need to perform many steps. Each step either retrieves rows of data physically from the database or prepares them in some way for the user issuing the statement. The combination of the steps that Oracle Database uses to execute a statement is an <span class="glossaryterm">execution plan</span>. An execution plan includes an <a id="sthref980"></a><span class="glossaryterm">access path</span> for each table that the statement accesses and an ordering of the tables (the <a id="sthref981"></a><span class="glossaryterm">join order</span>) with the appropriate <span class="glossaryterm">join method</span>.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a href="#i82080">"Overview of Optimizer Access Paths"</a></p>
</li>
<li>
<p><a href="ex_plan.htm#g42231">Chapter 12, "Using EXPLAIN PLAN"</a></p>
</li>
</ul>
</div>
<a id="i82037"></a>
<div id="PFGRF94595" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.1</span> Overview of EXPLAIN PLAN</h3>
<p><a id="sthref982"></a><a id="sthref983"></a><a id="sthref984"></a>You can examine the execution plan chosen by the optimizer for a SQL statement by using the <code>EXPLAIN PLAN</code> statement. When the statement is issued, the optimizer chooses an execution plan and then inserts data describing the plan into a database table. Simply issue the <code>EXPLAIN PLAN</code> statement and then query the output table.</p>
<p><a id="sthref985"></a>These are the basics of using the <code>EXPLAIN PLAN</code> statement:</p>
<ul>
<li>
<p>Use the SQL script <code>CATPLAN</code>.<code>SQL</code> to create a sample output table called <code>PLAN_TABLE</code> in your schema. See <a href="ex_plan.htm#i21501">"The PLAN_TABLE Output Table"</a>.</p>
</li>
<li>
<p>Include the <code>EXPLAIN PLAN</code> <code>FOR</code> clause before the SQL statement. See <a href="ex_plan.htm#i17492">"Running EXPLAIN PLAN"</a>.</p>
</li>
<li>
<p><code><a id="sthref986"></a><a id="sthref987"></a><a id="sthref988"></a></code>After issuing the <code>EXPLAIN PLAN</code> statement, use one of the scripts or package provided by Oracle Database to display the most recent plan table output. See <a href="ex_plan.htm#i16938">"Displaying PLAN_TABLE Output"</a>.</p>
</li>
<li>
<p><code><a id="sthref989"></a></code>The execution order in <code>EXPLAIN PLAN</code> output begins with the line that is the furthest indented to the right. The next step is the parent of that line. If two lines are indented equally, then the top line is normally executed first.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>The <code>EXPLAIN</code> <code>PLAN</code> output tables in this chapter were displayed with the <code><a id="sthref990"></a>utlxpls.sql</code> script.</p>
</li>
<li>
<p>The steps in the <code>EXPLAIN</code> <code>PLAN</code> output in this chapter may be different on your system. The optimizer may choose different execution plans, depending on database configurations.</p>
</li>
</ul>
</div>
</li>
</ul>
<p><a href="#i73885">Example 11-13</a> uses <code>EXPLAIN PLAN</code> to examine a SQL statement that selects the <code>employee_id</code>, <code>job_title</code>, <code>salary</code>, and <code>department_name</code> for the employees whose IDs are less than 103.</p>
<div id="PFGRF94596" class="example">
<p class="titleinexample"><a id="i73885"></a>Example 11-13 Using EXPLAIN PLAN</p>
<pre>
EXPLAIN PLAN FOR
SELECT e.employee_id, j.job_title, e.salary, d.department_name
    FROM employees e, jobs j, departments d
    WHERE  e.employee_id &lt; 103
       AND e.job_id = j.job_id 
       AND e.department_id = d.department_id;
</pre>
<p>The resulting output table in <a href="#i73898">Example 11-14</a> shows the execution plan chosen by the optimizer to execute the SQL statement in the example:</p>
</div>
<!-- class="example" -->
<div id="PFGRF94597" class="example">
<p class="titleinexample"><a id="i73898"></a>Example 11-14 EXPLAIN PLAN Output</p>
<pre>
-----------------------------------------------------------------------------------
| Id  | Operation                     |  Name        | Rows  | Bytes | Cost (%CPU)|
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |              |     3 |   189 |    10  (10)|
|   1 |  NESTED LOOPS                 |              |     3 |   189 |    10  (10)|
|   2 |   NESTED LOOPS                |              |     3 |   141 |     7  (15)|
|*  3 |    TABLE ACCESS FULL          | EMPLOYEES    |     3 |    60 |     4  (25)|
|   4 |    TABLE ACCESS BY INDEX ROWID| JOBS         |    19 |   513 |     2  (50)|
|*  5 |     INDEX UNIQUE SCAN         | JOB_ID_PK    |     1 |       |            |
|   6 |   TABLE ACCESS BY INDEX ROWID | DEPARTMENTS  |    27 |   432 |     2  (50)|
|*  7 |    INDEX UNIQUE SCAN          | DEPT_ID_PK   |     1 |       |            |
-----------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   3 - filter("E"."EMPLOYEE_ID"&lt;103)
   5 - access("E"."JOB_ID"="J"."JOB_ID")
   7 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID"


-------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |               |     3 |   189 |     8  (13)| 00:00:01 |
|   1 |  NESTED LOOPS                   |               |       |       |            |          |
|   2 |   NESTED LOOPS                  |               |     3 |   189 |     8  (13)| 00:00:01 |
|   3 |    MERGE JOIN                   |               |     3 |   141 |     5  (20)| 00:00:01 |
|   4 |     TABLE ACCESS BY INDEX ROWID | JOBS          |    19 |   513 |     2   (0)| 00:00:01 |
|   5 |      INDEX FULL SCAN            | JOB_ID_PK     |    19 |       |     1   (0)| 00:00:01 |
|*  6 |     SORT JOIN                   |               |     3 |    60 |     3  (34)| 00:00:01 |
|   7 |      TABLE ACCESS BY INDEX ROWID| EMPLOYEES     |     3 |    60 |     2   (0)| 00:00:01 |
|*  8 |       INDEX RANGE SCAN          | EMP_EMP_ID_PK |     3 |       |     1   (0)| 00:00:01 |
|*  9 |    INDEX UNIQUE SCAN            | DEPT_ID_PK    |     1 |       |     0   (0)| 00:00:01 |
|  10 |   TABLE ACCESS BY INDEX ROWID   | DEPARTMENTS   |     1 |    16 |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   6 - access("E"."JOB_ID"="J"."JOB_ID")
       filter("E"."JOB_ID"="J"."JOB_ID")
   8 - access("E"."EMPLOYEE_ID"&lt;103)
   9 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i73954"></a>
<div id="PFGRF94598" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.2</span> Steps in the Execution Plan</h3>
<p>Each row in the output table corresponds to a single step in the execution plan. Note that the step IDs with asterisks are listed in the Predicate Information section.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ex_plan.htm#g42231">Chapter 12, "Using EXPLAIN PLAN"</a></div>
<p><a id="sthref991"></a><a id="sthref992"></a>Each step of the execution plan returns a set of rows. The next step either uses these rows or, in the last step, returns the rows to the user or application issuing the SQL statement. A <span class="bold">row set</span> is a set of rows returned by a step.</p>
<p>The numbering of the step IDs reflects the order in which they are displayed in response to the <code>EXPLAIN</code> <code>PLAN</code> statement. Each step of the execution plan either retrieves rows from the database or accepts rows from one or more row sources as input.</p>
<ul>
<li>
<p><a id="sthref993"></a>The following steps in <a href="#i73898">Example 11-14</a> physically retrieve data from an object in the database:</p>
<ul>
<li>
<p>Step 3 reads all rows of the <code>employees</code> table.</p>
</li>
<li>
<p>Step 5 looks up each <code>job_id</code> in <code>JOB_ID_PK</code> index and finds the rowids of the associated rows in the <code>jobs</code> table.</p>
</li>
<li>
<p>Step 4 retrieves the rows with rowids that were returned by Step 5 from the <code>jobs</code> table.</p>
</li>
<li>
<p>Step 7 looks up each <code>department_id</code> in <code>DEPT_ID_PK</code> index and finds the rowids of the associated rows in the <code>departments</code> table.</p>
</li>
<li>
<p>Step 6 retrieves the rows with rowids that were returned by Step 7 from the <code>departments</code> table.</p>
</li>
</ul>
</li>
<li>
<p>The following steps in <a href="#i73898">Example 11-14</a> operate on rows returned by the previous row source:</p>
<ul>
<li>
<p>Step 2 performs the nested loop operation on <code>job_id</code> in the <code>jobs</code> and <code>employees</code> tables, accepting row sources from Steps 3 and 4, joining each row from Step 3 source to its corresponding row in Step 4, and returning the resulting rows to Step 2.</p>
</li>
<li>
<p>Step 1 performs the nested loop operation, accepting row sources from Step 2 and Step 6, joining each row from Step 2 source to its corresponding row in Step 6, and returning the resulting rows to Step 1.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i82080">"Overview of Optimizer Access Paths"</a> for more information on access paths</p>
</li>
<li>
<p><a href="#i51523">"Overview of Joins"</a> for more information on the methods by which Oracle Database joins row sources</p>
</li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDECGJ"></a>
<div id="PFGRF94574" class="sect1">
<h2 class="sect1"><span class="secnum">11.5</span> Controlling Optimizer Behavior</h2>
<p><a href="#CIHJCJBB">Table 11-3</a> lists initialization parameters that you can use to control the behavior of the query optimizer. You can use these parameters to enable various optimizer features to improve the performance of SQL execution.</p>
<div id="PFGRF95180" class="tblruleformal">
<p class="titleintable"><a id="sthref994"></a><a id="CIHJCJBB"></a>Table 11-3 Initialization Parameters That Control Optimizer Behavior</p>
<table class="cellalignment1691" title="Initialization Parameters That Control Optimizer Behavior" summary="Initialization parameters that control optimizer behavior" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t27">Initialization Parameter</th>
<th class="cellalignment1687" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t27" headers="r1c1-t27">
<p><a id="PFGRF94575"></a><code>CURSOR_SHARING</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t27 r1c2-t27">
<p>Converts literal values in SQL statements to bind variables. Converting the values improves cursor sharing and can affect the execution plans of SQL statements. The optimizer generates the execution plan based on the presence of the bind variables and not the actual literal values.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t27" headers="r1c1-t27">
<p><a id="PFGRF10108"></a><code>DB_FILE_MULTIBLOCK_READ_COUNT</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t27 r1c2-t27">
<p>Specifies the number of blocks that are read in a single I/O during a full table scan or index fast full scan. The optimizer uses the value of <code>DB_FILE_MULTIBLOCK_READ_COUNT</code> to cost full table scans and index fast full scans. Larger values result in a cheaper cost for full table scans and can result in the optimizer choosing a full table scan over an index scan. If this parameter is not set explicitly (or is set is 0), then the default value corresponds to the maximum I/O size that can be efficiently performed and is platform-dependent.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t27" headers="r1c1-t27">
<p><a id="PFGRF94576"></a><code>OPTIMIZER_INDEX_CACHING</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t27 r1c2-t27">
<p>Controls the costing of an index probe in conjunction with a nested loop. The range of values <code>0</code> to <code>100</code> indicates percentage of index blocks in the buffer cache, which modifies the optimizer's assumptions about index caching for nested loops and IN-list iterators. A value of <code>100</code> infers that 100% of the index blocks are likely to be found in the buffer cache and the optimizer adjusts the cost of an index probe or nested loop accordingly. Use caution when using this parameter because execution plans can change in favor of index caching.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t27" headers="r1c1-t27">
<p><a id="PFGRF94577"></a><code>OPTIMIZER_INDEX_COST_ADJ</code></p>
</td>
<td class="cellalignment1688" headers="r5c1-t27 r1c2-t27">
<p>Adjusts the cost of index probes. The range of values is 1 to 10000. The default value is 100, which means that indexes are evaluated as an access path based on the normal costing model. A value of 10 means that the cost of an index access path is one-tenth the normal cost of an index access path.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r6c1-t27" headers="r1c1-t27">
<p><a id="PFGRF94578"></a><code>OPTIMIZER_MODE</code></p>
</td>
<td class="cellalignment1688" headers="r6c1-t27 r1c2-t27">
<p>Sets the mode of the optimizer at instance startup. The possible values are <code>ALL_ROWS</code>, <code>FIRST_ROWS_</code><code><span class="codeinlineitalic">n</span></code>, and <code>FIRST_ROWS</code>. For descriptions of these parameter values, see <a href="#i38217">"Setting the OPTIMIZER_MODE Initialization Parameter"</a>.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r7c1-t27" headers="r1c1-t27">
<p><a id="PFGRF94579"></a><code>PGA_AGGREGATE_TARGET</code></p>
</td>
<td class="cellalignment1688" headers="r7c1-t27 r1c2-t27">
<p>Controls the amount of memory allocated for sorts and hash joins. Larger amounts of memory allocated for sorts or hash joins reduce the optimizer cost of these operations.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r8c1-t27" headers="r1c1-t27">
<p><a id="PFGRF94580"></a><code>STAR_TRANSFORMATION_ENABLED</code></p>
</td>
<td class="cellalignment1688" headers="r8c1-t27 r1c2-t27">
<p>Enables the optimizer to cost a star transformation for star queries (if <code>true</code>). The star transformation combines the bitmap indexes on the various fact table columns.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink REFRN001" href="../../server.112/e40402/initparams_part.htm#REFRN001"><span class="italic">Oracle Database Reference</span></a> for complete information about each initialization parameter</div>
<a id="g91086"></a>
<div id="PFGRF94572" class="sect2">
<h3 class="sect2"><span class="secnum">11.5.1</span> Enabling Query Optimizer Features</h3>
<p><a id="PFGRF94573"></a>The <code>OPTIMIZER_FEATURES_ENABLE</code> initialization parameter enables a series of optimizer-related features, depending on the release. It accepts one of a list of valid string values corresponding to the release numbers, such as <code>10.2.0.1</code> or <code>11.2.0.1</code>.</p>
<p>You can use this parameter to preserve the old behavior of the optimizer after a database upgrade. For example, if you upgrade the Oracle Database 11<span class="italic">g</span> from Release 1 (11.1.0.7) to Release 2 (11.2.0.2), then the default value of the <code>OPTIMIZER_FEATURES_ENABLE</code> parameter changes from <code>11.1.0.7</code> to <code>11.2.0.2</code>. This upgrade results in the optimizer enabling optimization features based on 11.2.0.2.</p>
<p>For backward compatibility, you might not want the query plans to change because of new optimizer features in a new release. In such a case, you can set the <code>OPTIMIZER_FEATURES_ENABLE</code> parameter to an earlier version.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle does not recommend explicitly setting the <code>OPTIMIZER_FEATURES_ENABLE</code> parameter to an earlier release. To avoid possible SQL performance regression that may result from execution plan changes, consider using SQL plan management instead. See <a href="optplanmgmt.htm#BABEAFGG">Chapter 15, "Using SQL Plan Management."</a></div>
<p class="orderedlisttitle">To set OPTIMIZER_FEATURES_ENABLE:&nbsp;</p>
<ol>
<li>
<p>Query the current optimizer features settings.</p>
<p>For example, run the following SQL*Plus command:</p>
<pre>
SQL&gt; SHOW PARAMETER optimizer_features_enable
 
NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
optimizer_features_enable            string      11.2.0.2
</pre></li>
<li>
<p>Set the optimizer features setting at the instance or session level.</p>
<p>For example, run the following SQL statement to set the optimizer version to 10.2.0.5:</p>
<pre>
SQL&gt; ALTER SYSTEM SET optimizer_features_enable='10.2.0.5';
</pre>
<p>The preceding statement disables all new optimizer features that were added in releases following release 10.2.0.5. If you upgrade to a new release and you want to enable the features available with that release, then you do not need to explicitly set the <code>OPTIMIZER_FEATURES_ENABLE</code> initialization parameter.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN10141" href="../../server.112/e40402/initparams168.htm#REFRN10141"><span class="italic">Oracle Database Reference</span></a> for information about optimizer features that are enabled when you set the <code>OPTIMIZER_FEATURES_ENABLE</code> parameter to each of the release values</div>
</div>
<!-- class="sect2" -->
<a id="i38318"></a>
<div id="PFGRF10102" class="sect2">
<h3 class="sect2"><span class="secnum">11.5.2</span> Choosing an Optimizer Goal</h3>
<p><span class="bold"><a id="sthref996"></a><a id="sthref997"></a><a id="sthref998"></a></span>You can influence the optimizer's choices by setting the optimizer goal and by gathering representative statistics for the query optimizer. You can set the following optimizer goals:</p>
<ul>
<li>
<p>Best throughput (default)</p>
<p>The database uses the least amount of resources necessary to process all rows accessed by the statement.</p>
<p>For applications performed in batch, such as Oracle Reports applications, optimize for best throughput. Usually, throughput is more important in batch applications, because the user initiating the application is only concerned with the time necessary for the application to complete. Response time is less important because the user does not examine the results of individual statements while the application is running.</p>
</li>
<li>
<p>Best response time</p>
<p>The database uses the least amount of resources necessary to process the first row accessed by a SQL statement.</p>
<p>For interactive applications such as Oracle Forms applications or SQL*Plus queries, optimize for best response time. Usually, response time is important in interactive applications because the interactive user is waiting to see the first row or first few rows accessed by the statement.</p>
</li>
</ul>
<p>The optimizer behavior when choosing an optimization approach and goal for a SQL statement is affected by the following factors:</p>
<ul>
<li>
<p><a href="#i38217">Setting the OPTIMIZER_MODE Initialization Parameter</a></p>
</li>
<li>
<p><a href="#i74078">Using Hints to Change the Optimizer Goal</a></p>
</li>
<li>
<p><a href="#i50787">Optimizer Statistics in the Data Dictionary</a></p>
</li>
</ul>
<a id="i38217"></a>
<div id="PFGRF94566" class="sect3">
<h4 class="sect3"><span class="secnum">11.5.2.1</span> Setting the OPTIMIZER_MODE Initialization Parameter</h4>
<p><a id="sthref999"></a><a id="sthref1000"></a><a id="sthref1001"></a><a id="sthref1002"></a>The <code>OPTIMIZER_MODE</code> initialization parameter establishes the default behavior for choosing an optimization approach for the instance. <a href="#BABBFFEA">Table 11-4</a> lists the possible values and description.</p>
<div id="PFGRF94567" class="tblformal">
<p class="titleintable"><a id="sthref1003"></a><a id="BABBFFEA"></a>Table 11-4 OPTIMIZER_MODE Initialization Parameter Values</p>
<table class="cellalignment1686" title="OPTIMIZER_MODE Initialization Parameter Values" summary="This table lists and describes the possible settings for the OPTIMIZER_MODE initialization parameter." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t31">Value</th>
<th class="cellalignment1687" id="r1c2-t31">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t31" headers="r1c1-t31">
<p><code>ALL_ROWS</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t31 r1c2-t31">
<p>The optimizer uses a cost-based approach for all SQL statements in the session regardless of the presence of <a id="sthref1004"></a>statistics and optimizes with a goal of best throughput (minimum resource use to complete the entire statement). This is the default value.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t31" headers="r1c1-t31">
<p><code>FIRST_ROWS_</code><code><span class="codeinlineitalic">n</span></code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t31 r1c2-t31">
<p>The optimizer uses a cost-based approach, regardless of the presence of statistics, and optimizes with a goal of best response time to return the first <span class="italic">n</span> number of rows, where <span class="italic">n</span> equals 1, 10, 100, or 1000.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t31" headers="r1c1-t31">
<p><code>FIRST_ROWS</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t31 r1c2-t31">
<p><a id="sthref1005"></a>The optimizer uses a mix of cost and heuristics to find a best plan for fast delivery of the first few rows.</p>
<p>Note that using heuristics sometimes leads the optimizer to generate a plan with a cost that is significantly larger than the cost of a plan without applying the heuristic. <code>FIRST_ROWS</code> is available for backward compatibility and plan stability; use <code>FIRST_ROWS_</code><code><span class="codeinlineitalic">n</span></code> instead.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>You can change the goal of the query optimizer for all SQL statements in a session by changing the parameter value in initialization file or by the <code>ALTER</code> <code>SESSION</code> <code>SET</code> <code>OPTIMIZER_MODE<a id="sthref1006"></a></code> statement. For example:</p>
<ul>
<li>
<p>The following statement in an initialization parameter file establishes the goal of the query optimizer for all sessions of the instance to best response time:</p>
<pre>
OPTIMIZER_MODE = FIRST_ROWS_1
</pre></li>
<li>
<p>The following SQL statement changes the goal of the query optimizer for the current session to best response time:</p>
<pre>
ALTER SESSION SET OPTIMIZER_MODE = FIRST_ROWS_1;
</pre></li>
</ul>
<p>If the optimizer uses the cost-based approach for a SQL statement, and if some tables accessed by the statement have no statistics, then the optimizer uses internal information, such as the number of data blocks allocated to these tables, to estimate other statistics for these tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN10145" href="../../server.112/e40402/initparams171.htm#REFRN10145"><span class="italic">Oracle Database Reference</span></a> to learn about <code>OPTIMIZER_MODE</code></div>
</div>
<!-- class="sect3" -->
<a id="i74078"></a>
<div id="PFGRF94568" class="sect3">
<h4 class="sect3"><span class="secnum">11.5.2.2</span> Using Hints to Change the Optimizer Goal</h4>
<p>To specify the goal of the optimizer for an individual SQL statement, use a hint from <a href="#g83023">Table 11-5</a>. Any of these hints in an individual SQL statement can override the <code><a id="sthref1007"></a>OPTIMIZER_MODE</code> initialization parameter for that SQL statement.</p>
<div id="PFGRF94569" class="tblruleformal">
<p class="titleintable"><a id="sthref1008"></a><a id="g83023"></a>Table 11-5 Hints for Changing the Query Optimizer Goal</p>
<table class="cellalignment1691" title="Hints for Changing the Query Optimizer Goal" summary="This table describes the hints that override the OPTIMIZER_MODE initialization parameter." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t33">Hint</th>
<th class="cellalignment1687" id="r1c2-t33">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t33" headers="r1c1-t33">
<p><code><a id="sthref1009"></a><a id="sthref1010"></a><a id="sthref1011"></a><a id="sthref1012"></a>FIRST_ROWS(</code><code><span class="codeinlineitalic">n</span></code><code>)</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t33 r1c2-t33">
<p>This hint instructs Oracle Database to optimize an individual SQL statement with a goal of best response time to return the first n number of rows, where <span class="italic">n</span> equals any positive integer. The hint uses a cost-based approach for the SQL statement, regardless of the presence of statistic.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t33" headers="r1c1-t33">
<p><code><a id="sthref1013"></a>ALL_ROWS</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t33 r1c2-t33">
<p>This hint explicitly chooses the cost-based approach to optimize a SQL statement with a goal of best throughput.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="hintsref.htm#i8327">Chapter 19, "Using Optimizer Hints"</a></div>
</div>
<!-- class="sect3" -->
<a id="i50787"></a>
<div id="PFGRF94570" class="sect3">
<h4 class="sect3"><span class="secnum">11.5.2.3</span> Optimizer Statistics in the Data Dictionary</h4>
<p>The statistics used by the query optimizer are stored in the data dictionary. You can use the <code><a id="sthref1014"></a>DBMS_STATS</code> package to collect exact or estimated statistics about physical storage characteristics and data distribution in these schema objects.</p>
<p>To maintain the effectiveness of the query optimizer, you must have statistics that are representative of the data. For table columns that contain values with large variations in number of duplicates, called <span class="italic">skewed data</span>, you should collect histograms.</p>
<p>The resulting statistics provide the query optimizer with information about data uniqueness and distribution. Using this information, the query optimizer is able to compute plan costs with a high degree of accuracy and choose the best execution plan based on the least cost.</p>
<p>By default, during the compilation of a SQL statement, the optimizer automatically decides whether to use <a href="glossary.htm#BGBIBAHD"><span class="xreftitlebold">dynamic statistics</span></a> by considering whether the available statistics are sufficient to generate an optimal execution plan (see <a href="stats.htm#BEIGBBCF">"When the Optimizer Uses Dynamic Statistics"</a>). If the available statistics are insufficient, then the optimizer uses dynamic statistics to augment the existing statistics.</p>
<p>Starting in Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.4), the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter has an <code>11</code> setting that enables the optimizer to gather dynamic statistics whenever it deems them necessary. For example, the optimizer can gather dynamic statistics for table scans, index access, joins, and <code>GROUP BY</code> operations, thus improving the quality of optimizer decisions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="stats.htm#g49431">Chapter 13, "Managing Optimizer Statistics"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1679">
<tr>
<td class="cellalignment1688">
<table class="cellalignment1684">
<tr>
<td class="cellalignment1683"><a href="part4.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1683"><a href="ex_plan.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1690">
<table class="cellalignment1682">
<tr>
<td class="cellalignment1683"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1683"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1683"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1683"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1683"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1683"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
