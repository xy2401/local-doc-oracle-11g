<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>SQL Tuning Overview</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-06-30T4:25:6Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Performance Tuning Guide" />
<meta name="dcterms.identifier" content="E41573-04" />
<meta name="dcterms.isVersionOf" content="PFGRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="optplanmgmt.htm" title="Previous" type="text/html" />
<link rel="Next" href="sql_tune.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41573.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">24/31</span> <!-- End Header -->
<div id="PFGRF006" class="chapter"><a id="g42927"></a>
<h1 class="chapter"><span class="secnum">16</span> SQL Tuning Overview</h1>
<p>This chapter discusses goals for tuning, how to identify high-resource SQL statements, explains what should be collected, provides tuning suggestions, and discusses how to create SQL test cases to troubleshoot problems in SQL.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i35699">Introduction to SQL Tuning</a></p>
</li>
<li>
<p><a href="#i22038">Goals for Tuning</a></p>
</li>
<li>
<p><a href="#i26072">Identifying High-Load SQL</a></p>
</li>
<li>
<p><a href="#i35740">Automatic SQL Tuning Features</a></p>
</li>
<li>
<p><a href="#i30971">Developing Efficient SQL Statements</a></p>
</li>
<li>
<p><a href="#CEGFAHGI">Building SQL Test Cases</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT015" href="../../server.112/e40540/sqllangu.htm#CNCPT015"><span class="italic">Oracle Database Concepts</span></a> for an overview of SQL</p>
</li>
<li>
<p><a class="olink ADMQS010" href="../../server.112/e10897/montune.htm#ADMQS010"><span class="italic">Oracle Database 2 Day DBA</span></a> to learn how to monitor the database</p>
</li>
</ul>
</div>
<a id="i35699"></a>
<div id="PFGRF94798" class="sect1">
<h2 class="sect1"><span class="secnum">16.1</span> Introduction to SQL Tuning</h2>
<p>SQL tuning involves the following basic steps:</p>
<ul>
<li>
<p>Identifying high load or top SQL statements that are responsible for a large share of the application workload and system resources, by reviewing past SQL execution history available in the system</p>
</li>
<li>
<p>Verifying that the execution plans produced by the query optimizer for these statements perform reasonably</p>
</li>
<li>
<p>Implementing corrective actions to generate better execution plans for poorly performing SQL statements</p>
</li>
</ul>
<p>The previous steps are repeated until the system performance reaches a satisfactory level or no more statements can be tuned.</p>
</div>
<!-- class="sect1" -->
<a id="i22038"></a>
<div id="PFGRF94799" class="sect1">
<h2 class="sect1"><span class="secnum">16.2</span> Goals for Tuning</h2>
<p>The objective of tuning a system is either to reduce the response time for end users of the system, or to reduce the resources used to process the same work. You can accomplish both of these objectives in several ways:</p>
<ul>
<li>
<p><a href="#i26861">Reduce the Workload</a></p>
</li>
<li>
<p><a href="#i26857">Balance the Workload</a></p>
</li>
<li>
<p><a href="#i26853">Parallelize the Workload</a></p>
</li>
</ul>
<a id="i26861"></a>
<div id="PFGRF94800" class="sect2">
<h3 class="sect2"><span class="secnum">16.2.1</span> Reduce the Workload</h3>
<p>SQL tuning commonly involves finding more efficient ways to process the same workload. It is possible to change the execution plan of the statement without altering the functionality to reduce the resource consumption.</p>
<p>Two examples of how you can resource usage are as follows:</p>
<ol>
<li>
<p>If a commonly executed query must access a small percentage of data in the table, then the database can execute it more efficiently by using an index. By creating such an index, you reduce the amount of resources used.</p>
</li>
<li>
<p>If a user is looking at the first twenty rows of the 10,000 rows returned in a specific sort order, and if the query (and sort order) can be satisfied by an index, then the user does not need to access and sort the 10,000 rows to see the first 20 rows.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i26857"></a>
<div id="PFGRF94801" class="sect2">
<h3 class="sect2"><span class="secnum">16.2.2</span> Balance the Workload</h3>
<p>Systems often tend to have peak usage in the daytime when real users are connected to the system, and low usage in the nighttime. If you can schedule noncritical reports and batch jobs to run in the nighttime and reduce their concurrency during day time, then the database frees up resources for the more critical programs in the day.</p>
</div>
<!-- class="sect2" -->
<a id="i26853"></a>
<div id="PFGRF94802" class="sect2">
<h3 class="sect2"><span class="secnum">16.2.3</span> Parallelize the Workload</h3>
<p>Queries that access large amounts of data (typical data warehouse queries) can often run in parallel. Parallelism is extremely useful for reducing response time in a low concurrency data warehouse. However, for OLTP environments, which tend to be high concurrency, parallelism can adversely impact other users by increasing the overall resource usage of the program.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i26072"></a>
<div id="PFGRF94803" class="sect1">
<h2 class="sect1"><span class="secnum">16.3</span> Identifying High-Load SQL</h2>
<p>This section describes the steps involved in identifying and gathering data on high-load SQL statements. High-load SQL are poorly-performing, resource-intensive SQL statements that impact the performance of an Oracle database. The following tools can identify high-load SQL statements:</p>
<ul>
<li>
<p>Automatic Database Diagnostic Monitor</p>
</li>
<li>
<p>Automatic SQL tuning</p>
</li>
<li>
<p>Automatic Workload Repository</p>
</li>
<li>
<p><code>V$SQL</code> view</p>
</li>
<li>
<p>Custom Workload</p>
</li>
<li>
<p>SQL Trace</p>
</li>
</ul>
<div id="PFGRF94804" class="sect2"><a id="sthref1329"></a>
<h3 class="sect2"><span class="secnum">16.3.1</span> Identifying Resource-Intensive SQL</h3>
<p>The first step in identifying resource-intensive SQL is to categorize the problem you are attempting to fix:</p>
<ul>
<li>
<p>Is the problem specific to a single program (or small number of programs)?</p>
</li>
<li>
<p>Is the problem generic over the application?</p>
</li>
</ul>
<div id="PFGRF94805" class="sect3"><a id="sthref1330"></a>
<h4 class="sect3"><span class="secnum">16.3.1.1</span> Tuning a Specific Program</h4>
<p>If you are tuning a specific program (GUI or 3GL), then identifying the SQL to examine is a simple matter of looking at the SQL executed within the program. Oracle Enterprise Manager (Enterprise Manager) provides tools for identifying resource intensive SQL statements, generating explain plans, and evaluating SQL performance.</p>
<p>If it is not possible to identify the SQL (for example, the SQL is generated dynamically), then use <code>SQL_TRACE</code> to generate a trace file that contains the SQL executed, then use <code>TKPROF</code> to generate an output file.</p>
<p>The SQL statements in the <code>TKPROF</code> output file can be ordered by various parameters, such as the execution elapsed time (<code>exeela</code>), which usually assists in the identification by ordering the SQL statements by elapsed time (with highest elapsed time SQL statements at the top of the file). This makes the job of identifying the poorly performing SQL easier if there are many SQL statements in the file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="sqltrace.htm#g33356">Chapter 21, "Using Application Tracing Tools"</a></p>
</li>
<li>
<p><a href="sql_tune.htm#g42443">Chapter 17, "Automatic SQL Tuning"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="PFGRF94806" class="sect3"><a id="sthref1331"></a>
<h4 class="sect3"><span class="secnum">16.3.1.2</span> Tuning an Application / Reducing Load</h4>
<p>If the whole application is performing poorly, or if you are attempting to reduce the overall CPU or I/O load on the database server, then identifying resource-intensive SQL involves the following steps:</p>
<ol>
<li>
<p>Determine which period in the day you would like to examine; typically this is the application's peak processing time.</p>
</li>
<li>
<p>Gather operating system and Oracle Database statistics at the beginning and end of that period. The minimum of Oracle Database statistics gathered should be file I/O (<code>V$FILESTAT</code>), system statistics (<code>V$SYSSTAT</code>), and SQL statistics (<code>V$SQLAREA</code>, <code>V$SQL</code>, or <code>V$SQLSTATS</code>, <code>V$SQLTEXT</code>, <code>V$SQL_PLAN</code>, and <code>V$SQL_PLAN_STATISTICS</code>).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="diag.htm#g41683">Chapter 6, "Automatic Performance Diagnostics"</a> to learn how to gather Oracle database instance performance data</p>
</li>
<li>
<p><a href="instance_tune.htm#CACGEEIF">"Real-Time SQL Monitoring"</a> for information about the <code>V$SQL_PLAN_MONITOR</code> view</p>
</li>
</ul>
</div>
</li>
<li>
<p>Using the data collected in step two, identify the SQL statements using the most resources. A good way to identify candidate SQL statements is to query <code>V$SQLSTATS</code>. <code>V$SQLSTATS</code> contains resource usage information for all SQL statements in the shared pool. The data in <code>V$SQLSTATS</code> should be ordered by resource usage. The most common resources are:</p>
<ul>
<li>
<p>Buffer gets (<code>V$SQLSTATS</code>.<code>BUFFER_GETS</code>, for high CPU using statements)</p>
</li>
<li>
<p>Disk reads (<code>V$SQLSTATS</code>.<code>DISK_READS</code>, for high I/O statements)</p>
</li>
<li>
<p>Sorts (<code>V$SQLSTATS</code>.<code>SORTS</code>, for many sorts)</p>
</li>
</ul>
</li>
</ol>
<p>One method to identify which SQL statements are creating the highest load is to compare the resources used by a SQL statement to the total amount of that resource used in the period. For <code>BUFFER_GETS</code>, divide each SQL statement's <code>BUFFER_GETS</code> by the total number of buffer gets during the period. The total number of buffer gets in the system is available in the <code>V$SYSSTAT</code> table, for the statistic session logical reads.</p>
<p>Similarly, it is possible to apportion the percentage of disk reads a statement performs out of the total disk reads performed by the system by dividing <code>V$SQL_STATS.DISK_READS</code> by the value for the <code>V$SYSSTAT</code> statistic physical reads. The SQL sections of the Automatic Workload Repository report include this data, so you do not need to perform the percentage calculations manually.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN003" href="../../server.112/e40402/dynviews_part.htm#REFRN003"><span class="italic">Oracle Database Reference</span></a> for information about dynamic performance views</div>
<p>After you have identified the candidate SQL statements, the next stage is to gather information that is necessary to examine the statements and tune them.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="PFGRF94807" class="sect2"><a id="sthref1332"></a>
<h3 class="sect2"><span class="secnum">16.3.2</span> Gathering Data on the SQL Identified</h3>
<p>If you are most concerned with CPU, then examine the top SQL statements that performed the most <code>BUFFER_GETS</code> during that interval. Otherwise, start with the SQL statement that performed the most <code>DISK_READS</code>.</p>
<div id="PFGRF94808" class="sect3"><a id="sthref1333"></a>
<h4 class="sect3"><span class="secnum">16.3.2.1</span> Information to Gather During Tuning</h4>
<p>The tuning process begins by determining the structure of the underlying tables and indexes. The information gathered includes the following:</p>
<ol>
<li>
<p>Complete SQL text from <code>V$SQLTEXT</code></p>
</li>
<li>
<p>Structure of the tables referenced in the SQL statement, usually by describing the table in SQL*Plus</p>
</li>
<li>
<p>Definitions of any indexes (columns, column orders), and whether the indexes are unique or non-unique</p>
</li>
<li>
<p>Optimizer statistics for the segments (including the number of rows each table, selectivity of the index columns), including the date when the segments were last analyzed</p>
</li>
<li>
<p>Definitions of any views referred to in the SQL statement</p>
</li>
<li>
<p>Repeat steps two, three, and four for any tables referenced in the view definitions found in step five</p>
</li>
<li>
<p>Optimizer plan for the SQL statement (either from <code>EXPLAIN</code> <code>PLAN</code>, <code>V$SQL_PLAN</code>, or the <code>TKPROF</code> output)</p>
</li>
<li>
<p>Any previous optimizer plans for that SQL statement</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is important to generate and review execution plans for all of the key SQL statements in your application. Doing so lets you compare the optimizer execution plans of a SQL statement when the statement performed well to the plan when that the statement is not performing well. Having the comparison, along with information such as changes in data volumes, can assist in identifying the cause of performance degradation.</div>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i35740"></a>
<div id="PFGRF94809" class="sect1">
<h2 class="sect1"><span class="secnum">16.4</span> Automatic SQL Tuning Features</h2>
<p>Because the manual SQL tuning process poses many challenges to the application developer, the SQL tuning process has been automated by the automatic SQL tuning features of Oracle Database. These features are designed to work equally well for OLTP and Data Warehouse type applications:</p>
<ul>
<li>
<p><a href="#BABBJGEI">ADDM</a></p>
</li>
<li>
<p><a href="#BABGAEBA">SQL Tuning Advisor</a></p>
</li>
<li>
<p><a href="#BABFIHEF">SQL Tuning Sets</a></p>
</li>
<li>
<p><a href="#BABBAEJD">SQL Access Advisor</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="sql_tune.htm#g42443">Chapter 17, "Automatic SQL Tuning"</a>.</div>
<a id="BABBJGEI"></a>
<div id="PFGRF94810" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">16.4.1</span> ADDM</h3>
<p>The <a id="sthref1334"></a><a id="sthref1335"></a><a id="sthref1336"></a><a id="sthref1337"></a>Automatic Database Diagnostic Monitor (ADDM) analyzes the information collected by the AWR for possible performance problems with Oracle Database, including high-load SQL statements. See <a href="diag.htm#i37241">"Overview of the Automatic Database Diagnostic Monitor"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABGAEBA"></a>
<div id="PFGRF94811" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">16.4.2</span> SQL Tuning Advisor</h3>
<p><a id="sthref1338"></a><a id="sthref1339"></a>SQL Tuning Advisor optimizes SQL statements that have been identified as high-load SQL statements. By default, Oracle Database automatically identifies problematic SQL statements and implements tuning recommendations using SQL Tuning Advisor during system maintenance windows as an automated maintenance task, searching for ways to improve the execution plans of the high-load SQL statements. You can also choose to run SQL Tuning Advisor at any time on any given SQL workload to improve performance. See <a href="sql_tune.htm#i34782">"Tuning Reactively with SQL Tuning Advisor"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABFIHEF"></a>
<div id="PFGRF94812" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">16.4.3</span> SQL Tuning Sets</h3>
<p>When multiple SQL statements serve as input to ADDM, SQL Tuning Advisor, or SQL Access Advisor, the database constructs and stores a <a id="sthref1340"></a>SQL tuning set (STS). The STS includes the set of SQL statements along with their associated execution context and basic execution statistics. See <a href="sql_tune.htm#i34915">"Managing SQL Tuning Sets"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABBAEJD"></a>
<div id="PFGRF94813" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">16.4.4</span> SQL Access Advisor</h3>
<p>In addition to SQL Tuning Advisor, <a id="sthref1341"></a>SQL Access Advisor provides advice on materialized views, indexes, and materialized view logs. SQL Access Advisor helps you achieve performance goals by recommending the proper set of materialized views, materialized view logs, and indexes for a given workload. In general, as the number of materialized views and indexes and the space allocated to them is increased, query performance improves. SQL Access Advisor considers the trade-offs between space usage and query performance, and recommends the most cost-effective configuration of new and existing materialized views and indexes. See <a href="advisor.htm#i1026391">"Using SQL Access Advisor"</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i30971"></a>
<div id="PFGRF94814" class="sect1">
<h2 class="sect1"><span class="secnum">16.5</span> Developing Efficient SQL Statements</h2>
<p>This section describes ways you can improve SQL statement efficiency:</p>
<ul>
<li>
<p><a href="#i28375">Verifying Optimizer Statistics</a></p>
</li>
<li>
<p><a href="#i28403">Reviewing the Execution Plan</a></p>
</li>
<li>
<p><a href="#i28528">Restructuring the SQL Statements</a></p>
</li>
<li>
<p><a href="#i25277">Restructuring the Indexes</a></p>
</li>
<li>
<p><a href="#i22336">Modifying or Disabling Triggers and Constraints</a></p>
</li>
<li>
<p><a href="#i22339">Restructuring the Data</a></p>
</li>
<li>
<p><a href="#i23988">Maintaining Execution Plans Over Time</a></p>
</li>
<li>
<p><a href="#i25211">Visiting Data as Few Times as Possible</a></p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
The guidelines described in this section are oriented to production of frequently executed SQL. Most techniques that are discouraged here can legitimately be employed in ad hoc statements or in applications run infrequently where performance is not critical.</div>
</li>
</ul>
<a id="i28375"></a>
<div id="PFGRF94815" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.1</span> Verifying Optimizer Statistics</h3>
<p>The query optimizer uses statistics gathered on tables and indexes when determining the optimal execution plan. If these statistics have not been gathered, or if the statistics are no longer representative of the data stored within the database, then the optimizer does not have sufficient information to generate the best plan.</p>
<p>Things to check:</p>
<ul>
<li>
<p>If you gather statistics for some tables in your database, then it is probably best to gather statistics for all tables. This is especially true if your application includes SQL statements that perform joins.</p>
</li>
<li>
<p>If the optimizer statistics in the data dictionary are no longer representative of the data in the tables and indexes, then gather new statistics. One way to check whether the dictionary statistics are stale is to compare the real cardinality (row count) of a table to the value of <code>DBA_TABLES.NUM_ROWS</code>. Additionally, if there is significant data skew on predicate columns, then consider using histograms.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i28403"></a>
<div id="PFGRF94816" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.2</span> Reviewing the Execution Plan</h3>
<p>When tuning (or writing) a SQL statement in an OLTP environment, the goal is to drive from the table that has the most selective filter. This means that there are fewer rows passed to the next step. If the next step is a join, then this means that fewer rows are joined. Check to see whether the access paths are optimal.</p>
<p>When examining the optimizer execution plan, look for the following:</p>
<ul>
<li>
<p>The driving table has the best filter.</p>
</li>
<li>
<p>The join order in each step returns the fewest number of rows to the next step (that is, the join order should reflect, where possible, going to the best not-yet-used filters).</p>
</li>
<li>
<p>The join method is appropriate for the number of rows being returned. For example, nested loop joins through indexes may not be optimal when the statement returns many rows.</p>
</li>
<li>
<p>The database uses views efficiently. Look at the <code>SELECT</code> list to see whether access to the view is necessary.</p>
</li>
<li>
<p>There are any unintentional Cartesian products (even with small tables).</p>
</li>
<li>
<p>Each table is being accessed efficiently:</p>
<p>Consider the predicates in the SQL statement and the number of rows in the table. Look for suspicious activity, such as a full table scans on tables with large number of rows, which have predicates in the where clause. Determine why an index is not used for such a selective predicate.</p>
<p>A full table scan does not mean inefficiency. It might be more efficient to perform a full table scan on a small table, or to perform a full table scan to leverage a better join method (for example, hash_join) for the number of rows returned.</p>
</li>
</ul>
<p>If any of these conditions are not optimal, then consider restructuring the SQL statement or the indexes available on the tables.</p>
</div>
<!-- class="sect2" -->
<a id="i28528"></a>
<div id="PFGRF94817" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.3</span> Restructuring the SQL Statements</h3>
<p>Often, rewriting an inefficient SQL statement is easier than modifying it. If you understand the purpose of a given statement, then you might be able to quickly and easily write a new statement that meets the requirement.</p>
<div id="PFGRF94818" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1342"></a>
<h4 class="sect3"><span class="secnum">16.5.3.1</span> Compose Predicates Using AND and =</h4>
<p>To improve SQL efficiency, use <a id="sthref1343"></a>equijoins whenever possible. Statements that perform equijoins on untransformed column values are the easiest to tune.</p>
</div>
<!-- class="sect3" -->
<a id="i25024"></a>
<div id="PFGRF94819" class="sect3">
<h4 class="sect3"><span class="secnum">16.5.3.2</span> Avoid Transformed Columns in the WHERE Clause</h4>
<p>Use <a id="sthref1344"></a>untransformed column values. For example, use:</p>
<pre>
WHERE a.order_no = b.order_no
</pre>
<p>rather than:</p>
<pre>
WHERE TO_NUMBER (SUBSTR(a.order_no, INSTR(b.order_no, '.') - 1))
= TO_NUMBER (SUBSTR(a.order_no, INSTR(b.order_no, '.') - 1))
</pre>
<p>Do not use SQL functions in predicate clauses or <code>WHERE</code> clauses. Any expression using a column, such as a function having the column as its argument, causes the optimizer to ignore the possibility of using an index on that column, even a unique index, unless there is a function-based index defined that the database can use.</p>
<p>Avoid mixed-mode <a id="sthref1345"></a>expressions, and beware of implicit <a id="sthref1346"></a>type conversions. When you want to use an index on the <code>VARCHAR2</code> column <code>charcol</code>, but the <code>WHERE</code> clause looks like this:</p>
<pre>
AND charcol = <span class="italic">numexpr</span>
</pre>
<p>where <code>numexpr</code> is an expression of number type (for example, 1, <code>USERENV</code>('<code>SESSIONID</code>'), <code>numcol</code>, <code>numcol</code>+0,...), Oracle Database translates that expression into:</p>
<pre>
AND TO_NUMBER(charcol) = <span class="italic">numexpr</span>
</pre>
<p>Avoid the following kinds of complex expressions:</p>
<ul>
<li>
<p><code>col1</code> = <code>NVL</code> <code>(:b1</code>,<code>col1)</code></p>
</li>
<li>
<p><code>NVL</code> (<code>col1,-999</code>) = &hellip;.</p>
</li>
<li>
<p><code>TO_DATE</code>(), <code>TO_NUMBER</code>(), and so on</p>
</li>
</ul>
<p>These expressions prevent the optimizer from assigning valid cardinality or selectivity estimates and can in turn affect the overall plan and the join method.</p>
<p>Add the predicate versus using <code>NVL</code>() technique.</p>
<p>For example:</p>
<pre>
SELECT employee_num, full_name Name, employee_id 
  FROM mtl_employees_current_view 
  WHERE (employee_num = NVL (:b1,employee_num)) AND (organization_id=:1) 
  ORDER BY employee_num;
</pre>
<p>Also:</p>
<pre>
SELECT employee_num, full_name Name, employee_id 
  FROM mtl_employees_current_view 
  WHERE (employee_num = :b1) AND (organization_id=:1) 
  ORDER BY employee_num;
</pre>
<p>If a column of type <code>NUMBER</code> is used in a <code>WHERE</code> clause to filter predicates with a literal value, then use a <code>TO_NUMBER</code> function in the <code>WHERE</code> clause predicate to ensure you can use the index on the <code>NUMBER</code> column. For example, if <code>numcol</code> is a column of type <code>NUMBER</code>, then a <code>WHERE</code> clause containing <code>numcol=TO_NUMBER('5')</code> enables the database to use the index on <code>numcol</code>.</p>
<p>If a query joins two tables, and if the join columns have different data types (for example, <code>NUMBER</code> and <code>VARCHAR2</code>), then Oracle Database implicitly performs data type conversion. For example, if the join condition is <code>varcol=numcol</code>, then the database implicitly converts the condition to <code>TO_NUMBER(varcol)=numcol</code>. If an index exists on the <code>varcol</code> column, then explicitly set the type conversion to <code>varcol=TO_CHAR(numcol)</code>, thus enabling the database to use the index.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="data_acc.htm#g27061">Chapter 14, "Using Indexes and Clusters"</a> for more information on function-based indexes</div>
</div>
<!-- class="sect3" -->
<a id="i22179"></a>
<div id="PFGRF94820" class="sect3">
<h4 class="sect3"><span class="secnum">16.5.3.3</span> Write Separate SQL Statements for Specific Tasks</h4>
<p>SQL is not a procedural language. Using one piece of SQL to do many different things usually results in a less-than-optimal result for each task. If you want SQL to accomplish different things, then write various statements, rather than writing one statement to do different things depending on the parameters you give it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Forms and Reports are powerful development tools that allow application logic to be coded using PL/SQL (triggers or program units). This helps reduce the complexity of SQL by allowing complex logic to be handled in the Forms or Reports. You can also invoke a server side PL/SQL package that performs the few SQL statements in place of a single large complex SQL statement. Because the package is a server-side unit, there are no issues surrounding client to database round-trips and network traffic.</div>
<p>It is always better to write separate SQL statements for different tasks, but if you must use one SQL statement, then you can make a very complex statement slightly less complex by using the <code>UNION</code> <code>ALL</code> operator.</p>
<p>Optimization (determining the execution plan) takes place before the database knows the values substituted in the query. An execution plan cannot, therefore, depend on what those values are. For example:</p>
<pre>
SELECT info 
FROM tables
WHERE ... 
</pre>
<pre>
AND somecolumn BETWEEN DECODE(:loval, 'ALL', somecolumn, :loval)
AND DECODE(:hival, 'ALL', somecolumn, :hival);
</pre>
<pre>
</pre>
<p>Written as shown, the database cannot use an index on the <code>somecolumn</code> column, because the expression involving that column uses the same column on both sides of the <code>BETWEEN</code>.</p>
<p>This is not a problem if there is some other highly selective, indexable condition you can use to access the driving table. Often, however, this is not the case. Frequently, you might want to use an index on a condition like that shown but need to know the values of :<code>loval</code>, and so on, in advance. With this information, you can rule out the <code>ALL</code> case, which should not use the index.</p>
<p>To use the index whenever real values are given for :<code>loval</code> and :<code>hival</code> (if you expect narrow ranges, even ranges where :<code>loval</code> often equals :<code>hival</code>), you can rewrite the example in the following logically equivalent form:</p>
<pre>
SELECT /* change this half of UNION ALL if other half changes */ info
FROM   tables 
WHERE  ... 
</pre>
<pre>
AND    somecolumn BETWEEN :loval AND :hival
AND   (:hival != 'ALL' AND :loval != 'ALL') 
</pre>
<pre>
UNION ALL 
SELECT /* Change this half of UNION ALL if other half changes. */ info
FROM   tables
WHERE  ... 
</pre>
<pre>
AND (:hival = 'ALL' OR :loval = 'ALL');
</pre>
<pre>
</pre>
<p>If you run <code>EXPLAIN</code> <code>PLAN</code> on the new query, then you seem to get both a desirable and an undesirable execution plan. However, the first condition the database evaluates for either half of the <code>UNION</code> <code>ALL</code> is the combined condition on whether <code>:hival</code> and <code>:loval</code> are <code>ALL</code>. The database evaluates this condition before actually getting any rows from the execution plan for that part of the query.</p>
<p>When the condition comes back false for one part of the <code>UNION</code> <code>ALL</code> query, that part is not evaluated further. Only the part of the execution plan that is optimum for the values provided is actually carried out. Because the final conditions on <code>:hival</code> and <code>:loval</code> are guaranteed to be mutually exclusive, only one half of the <code>UNION</code> <code>ALL</code> actually returns rows. (The <code>ALL</code> in <code>UNION</code> <code>ALL</code> is logically valid because of this exclusivity. It allows the plan to be carried out without an expensive sort to rule out duplicate rows for the two halves of the query.)</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i22206"></a>
<div id="PFGRF94821" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.4</span> Controlling the Access Path and Join Order with Hints</h3>
<p>You can influence the optimizer's choices by setting the optimizer approach and goal, and by gathering representative statistics for the query optimizer. Sometimes, the application designer, who has more information about a particular application's data than is available to the optimizer, can choose a more effective way to execute a SQL statement. You can use hints in SQL statements to instruct the optimizer about how the statement should be executed.</p>
<p><a id="sthref1347"></a>Hints, such as /*+<code>FULL</code> */ control access paths. For example:</p>
<pre>
SELECT /*+ FULL(e) */ e.last_name
  FROM employees e
 WHERE e.job_id = 'CLERK';
</pre>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a href="optimops.htm#g92116">Chapter 11, "The Query Optimizer"</a> and <a href="hintsref.htm#i8327">Chapter 19, "Using Optimizer Hints"</a></div>
<p><a id="sthref1348"></a><a id="sthref1349"></a>Join order can have a significant effect on performance. The main objective of SQL tuning is to avoid performing unnecessary work to access rows that do not affect the result. This leads to three general rules:</p>
<ul>
<li>
<p>Avoid a full-table scan if it is more efficient to get the required rows through an index.</p>
</li>
<li>
<p>Avoid using an index that fetches 10,000 rows from the driving table if you could instead use another index that fetches 100 rows.</p>
</li>
<li>
<p>Choose the join order so as to join fewer rows to tables later in the join order.</p>
</li>
</ul>
<p>The following example shows how to tune join order effectively:</p>
<pre>
SELECT info
FROM taba a, tabb b, tabc c
WHERE a.acol BETWEEN 100 AND 200
</pre>
<pre>
AND b.bcol BETWEEN 10000 AND 20000
AND c.ccol BETWEEN 10000 AND 20000
AND a.key1 = b.key1
AND a.key2 = c.key2;
</pre>
<pre>
</pre>
<ol>
<li>
<p>Choose the driving table and the driving index (if any).</p>
<p>The first three conditions in the previous example are filter conditions applying to only a single table each. The last two conditions are join conditions.</p>
<p>Filter conditions dominate the choice of driving table and index. In general, the driving table is the one containing the filter condition that eliminates the highest percentage of the table. Thus, because the range of 100 to 200 is narrow compared with the range of <code>acol</code>, but the ranges of 10000 and 20000 are relatively large, <code>taba</code> is the driving table, all else being equal.</p>
<p>With nested loop joins, the joins all happen through the join indexes, the indexes on the primary or foreign keys used to connect that table to an earlier table in the join tree. Rarely do you use the indexes on the non-join conditions, except for the driving table. Thus, after <code>taba</code> is chosen as the driving table, use the indexes on <code>b</code>.<code>key1</code> and <code>c</code>.<code>key2</code> to drive into <code>tabb</code> and <code>tabc</code>, respectively.</p>
</li>
<li>
<p>Choose the best <a id="sthref1350"></a>join order, driving to the best unused filters earliest.</p>
<p>You can reduce the work of the following join by first joining to the table with the best still-unused filter. Thus, if "<code>bcol</code> <code>BETWEEN</code> ..." is more restrictive (rejects a higher percentage of the rows seen) than "<code>ccol</code> <code>BETWEEN</code> ...", then the last join becomes easier (with fewer rows) if <code>tabb</code> is joined before <code>tabc</code>.</p>
</li>
<li>
<p>You can use the <code>ORDERED</code> or <code>STAR</code> hint to force the join order.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="hintsref.htm#CHDGGCHC">"Hints for Join Orders"</a></div>
</li>
</ol>
<div id="PFGRF94822" class="sect3"><a id="sthref1351"></a>
<h4 class="sect3"><span class="secnum">16.5.4.1</span> Use Caution When Managing Views</h4>
<p>Be careful when joining views, when performing <a id="sthref1352"></a>outer joins to views, and when reusing an existing view for a new purpose.</p>
<a id="i22260"></a>
<div id="PFGRF94823" class="sect4">
<h5 class="sect4"><span class="secnum">16.5.4.1.1</span> Use Caution When Joining Complex Views</h5>
<p>Joins to complex views are not recommended, particularly joins from one complex view to another. Often this results in the entire view being instantiated, and then the query is run against the view data.</p>
<p>For example, the following statement creates a view that lists employees and departments:</p>
<pre>
CREATE OR REPLACE VIEW emp_dept
AS
SELECT d.department_id, d.department_name, d.location_id,
     e.employee_id, e.last_name, e.first_name, e.salary, e.job_id
FROM  departments d
     ,employees e
WHERE e.department_id (+) = d.department_id;
</pre>
<p>The following query finds employees in a specified state:</p>
<pre>
SELECT v.last_name, v.first_name, l.state_province
  FROM locations l, emp_dept v
 WHERE l.state_province = 'California'
  AND   v.location_id = l.location_id (+);
</pre>
<p>In the following plan table output, note that the <code>emp_dept</code> view is instantiated:</p>
<pre>
--------------------------------------------------------------------------------
| Operation                 |  Name    |  Rows | Bytes|  Cost  | Pstart| Pstop |
--------------------------------------------------------------------------------
| SELECT STATEMENT          |          |       |      |        |       |       |
|  FILTER                   |          |       |      |        |       |       |
|   NESTED LOOPS OUTER      |          |       |      |        |       |       |
|    VIEW                   |EMP_DEPT  |       |      |        |       |       |
|     NESTED LOOPS OUTER    |          |       |      |        |       |       |
|      TABLE ACCESS FULL    |DEPARTMEN |       |      |        |       |       |
|      TABLE ACCESS BY INDEX|EMPLOYEES |       |      |        |       |       |
|       INDEX RANGE SCAN    |EMP_DEPAR |       |      |        |       |       |
|    TABLE ACCESS BY INDEX R|LOCATIONS |       |      |        |       |       |
|     INDEX UNIQUE SCAN     |LOC_ID_PK |       |      |        |       |       |
--------------------------------------------------------------------------------
</pre></div>
<!-- class="sect4" -->
<a id="i24836"></a>
<div id="PFGRF94824" class="sect4">
<h5 class="sect4"><span class="secnum">16.5.4.1.2</span> Do Not Recycle Views</h5>
<p>Beware of writing a view for one purpose and then using it for other purposes to which it might be ill-suited. Querying from a view requires all tables from the view to be accessed for the data to be returned. Before reusing a view, determine whether all tables in the view need to be accessed to return the data. If not, then do not use the view. Instead, use the base table(s), or if necessary, define a new view. The goal is to refer to the minimum number of tables and views necessary to return the required data.</p>
<p>Consider the following example:</p>
<pre>
SELECT department_name 
FROM emp_dept
WHERE department_id = 10;
</pre>
<p>The entire view is first instantiated by performing a join of the <code>employees</code> and <code>departments</code> tables and then aggregating the data. However, you can obtain <code>department_name</code> and <code>department_id</code> directly from the <code>departments</code> table. It is inefficient to obtain this information by querying the <code>emp_dept</code> view.</p>
</div>
<!-- class="sect4" -->
<a id="i22276"></a>
<div id="PFGRF94825" class="sect4">
<h5 class="sect4"><span class="secnum">16.5.4.1.3</span> Use Caution When Unnesting Subque<a id="sthref1353"></a>ries</h5>
<p>Subquery unnesting merges the body of the subquery into the body of the statement that contains it, allowing the optimizer to consider them together when evaluating access paths and joins.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for an explanation of the dangers with subquery unnesting</div>
</div>
<!-- class="sect4" -->
<a id="i22299"></a>
<div id="PFGRF94826" class="sect4">
<h5 class="sect4"><span class="secnum">16.5.4.1.4</span> Use Caution When Performing Outer Joins to Views</h5>
<p>In the case of an outer join to a multi-table view, the query optimizer (in Release 8.1.6 and later) can drive from an outer join column, if an equality predicate is defined on it.</p>
<p>An outer join <span class="italic">within</span> a view is problematic because the performance implications of the outer join are not visible.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="PFGRF94827" class="sect3"><a id="sthref1354"></a>
<h4 class="sect3"><span class="secnum">16.5.4.2</span> Store Intermediate Results</h4>
<p>Intermediate, or staging, tables are quite common in relational database systems, because they temporarily store some intermediate results. In many applications they are useful, but Oracle Database requires additional resources to create them. Always consider whether the benefit they could bring is more than the cost to create them. Avoid staging tables when the information is not reused multiple times.</p>
<p>Some additional considerations:</p>
<ul>
<li>
<p>Storing intermediate results in staging tables could improve application performance. In general, whenever an intermediate result is usable by multiple following queries, it is worthwhile to store it in a staging table. The benefit of not retrieving data multiple times with a complex statement at the second usage of the intermediate result is better than the cost to materialize it.</p>
</li>
<li>
<p>Long and complex queries are hard to understand and optimize. Staging tables can break a complicated SQL statement into several smaller statements, and then store the result of each step.</p>
</li>
<li>
<p>Consider using materialized views. These are precomputed tables comprising aggregated or joined data from fact and possibly dimension tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../e25554/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for detailed information on using materialized views</div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i25277"></a>
<div id="PFGRF94828" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.5</span> Restructuring the Indexes</h3>
<p>Often, there is a beneficial impact on performance by restructuring indexes. This can involve the following:</p>
<ul>
<li>
<p>Remove nonselective indexes to speed the DML.</p>
</li>
<li>
<p>Index performance-critical access paths.</p>
</li>
<li>
<p>Consider reordering columns in existing concatenated indexes.</p>
</li>
<li>
<p>Add columns to the index to improve selectivity.</p>
</li>
</ul>
<p><a id="i25283"></a>Do not use indexes as a panacea. Application developers sometimes think that performance improves when they create more indexes. If a single programmer creates an appropriate index, then this index may improve the application's performance. However, if 50 developers each create an index, then application performance will probably be hampered.</p>
</div>
<!-- class="sect2" -->
<a id="i22336"></a>
<div id="PFGRF94829" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.6</span> Modifying or Disabling Triggers and Constraints</h3>
<p>Using triggers consumes system resources. If you use too many triggers, then performance may be adversely affected. In this case, you might need to modify or disable the triggers.</p>
</div>
<!-- class="sect2" -->
<a id="i22339"></a>
<div id="PFGRF94830" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.7</span> Restructuring the Data</h3>
<p>After restructuring the indexes and the statement, consider restructuring the data:</p>
<ul>
<li>
<p>Introduce derived values. Avoid <code>GROUP</code> <code>BY</code> in response-critical code.</p>
</li>
<li>
<p>Review your data design. Change the design of your system if it can improve performance.</p>
</li>
<li>
<p>Consider partitioning, if appropriate.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i23988"></a>
<div id="PFGRF94831" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.8</span> Maintaining Execution Plans Over Time</h3>
<p>You can maintain the existing execution plan of SQL statements over time either using stored statistics or SQL plan baselines. Storing optimizer statistics for tables will apply to all SQL statements that refer to those tables. Storing an execution plan as a SQL plan baseline maintains the plan for set of SQL statements. If both statistics and a SQL plan baseline are available for a SQL statement, then the optimizer first uses a cost-based search method to build a best-cost plan, and then tries to find a matching plan in the SQL plan baseline. If a match is found, then the optimizer proceeds using this plan. Otherwise, it evaluates the cost of each of the accepted plans in the SQL plan baseline and selects the plan with the lowest cost.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="optplanmgmt.htm#BABEAFGG">Chapter 15, "Using SQL Plan Management"</a></p>
</li>
<li>
<p><a href="stats.htm#g49431">Chapter 13, "Managing Optimizer Statistics"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i25211"></a>
<div id="PFGRF94832" class="sect2">
<h3 class="sect2"><span class="secnum">16.5.9</span> Visiting Data as Few Times as Possible</h3>
<p>Applications should try to access each row only once. This reduces network traffic and reduces database load. Consider doing the following:</p>
<ul>
<li>
<p><a href="#i26629">Combine Multiples Scans Using CASE Expressions</a></p>
</li>
<li>
<p><a href="#i26634">Use DML with RETURNING Clause</a></p>
</li>
<li>
<p><a href="#i25629">Modify All the Data Needed in One Statement</a></p>
</li>
</ul>
<a id="i26629"></a>
<div id="PFGRF94833" class="sect3">
<h4 class="sect3"><span class="secnum">16.5.9.1</span> Combine Multiples Scans Using CASE Expressions</h4>
<p>Often, it is necessary to calculate different aggregates on various sets of tables. Usually, you achieve this goal with multiple scans on the table, but it is easy to calculate all the aggregates with a single scan. Eliminating <span class="italic">n</span>-1 scans can greatly improve performance.</p>
<p>You can combine multiple scans into one scan by moving the <code>WHERE</code> condition of each scan into a <code>CASE</code> expression, which filters the data for the aggregation. For each aggregation, there could be another column that retrieves the data.</p>
<p>The following example asks for the count of all employees who earn less then 2000, between 2000 and 4000, and more than 4000 each month. You can obtain this result by executing three separate queries:</p>
<pre>
SELECT COUNT (*)
  FROM employees
  WHERE salary &lt; 2000;

SELECT COUNT (*)
  FROM employees
  WHERE salary BETWEEN 2000 AND 4000;

SELECT COUNT (*)
  FROM employees
  WHERE salary&gt;4000;
</pre>
<p>However, it is more efficient to run the entire query in a single statement. Each number is calculated as one column. The count uses a filter with the <code>CASE</code> expression to count only the rows where the condition is valid. For example:</p>
<pre>
SELECT COUNT (CASE WHEN salary &lt; 2000 
                   THEN 1 ELSE null END) count1, 
       COUNT (CASE WHEN salary BETWEEN 2001 AND 4000 
                   THEN 1 ELSE null END) count2, 
       COUNT (CASE WHEN salary &gt; 4000 
                   THEN 1 ELSE null END) count3 
  FROM employees; 
</pre>
<p>This is a very simple example. The ranges could be overlapping, the functions for the aggregates could be different, and so on.</p>
</div>
<!-- class="sect3" -->
<a id="i26634"></a>
<div id="PFGRF94834" class="sect3">
<h4 class="sect3"><span class="secnum">16.5.9.2</span> Use DML with RETURNING Clause</h4>
<p>When appropriate, use <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>... <code>RETURNING</code> to select and modify data with a single call. This technique improves performance by reducing the number of calls to the database.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax on the <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements</div>
</div>
<!-- class="sect3" -->
<a id="i25629"></a>
<div id="PFGRF94835" class="sect3">
<h4 class="sect3"><span class="secnum">16.5.9.3</span> Modify All the Data Needed in One Statement</h4>
<p>When possible, use array processing. This means that an array of bind variable values is passed to Oracle Database for repeated execution. This is appropriate for iterative processes in which multiple rows of a set are subject to the same operation.</p>
<p>For example:</p>
<pre>
BEGIN
 FOR pos_rec IN (SELECT * 
   FROM order_positions 
   WHERE order_id = :id) LOOP
      DELETE FROM order_positions
      WHERE order_id = pos_rec.order_id AND
        order_position = pos_rec.order_position;
 END LOOP;
 DELETE FROM orders 
 WHERE order_id = :id;
END;
</pre>
<p>Alternatively, you could define a cascading constraint on <code>orders</code>. In the previous example, one <code>SELECT</code> and <span class="italic">n</span> <code>DELETE</code>s are executed. When a user issues the <code>DELETE</code> on <code>orders</code> <code>DELETE</code> <code>FROM</code> <code>orders</code> <code>WHERE</code> <code>order_id</code> = <code>:id</code>, the database automatically deletes the positions with a single <code>DELETE</code> statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> or <a class="olink HETER" href="../../server.112/e11050/toc.htm"><span class="italic">Oracle Database Heterogeneous Connectivity User's Guide</span></a> to learn how to tune distributed queries</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGFAHGI"></a>
<div id="PFGRF16001" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">16.6</span> Building SQL Test Cases</h2>
<p>For many SQL-related problems, obtaining a reproducible test case makes it easier to resolve the problem. Starting with the 11<span class="italic">g</span> Release 2 (11.2), Oracle Database contains the <a id="sthref1355"></a>SQL Test Case Builder, which automates the somewhat difficult and time-consuming process of gathering and reproducing as much information as possible about a problem and the environment in which it occurred.</p>
<p>SQL Test Case Builder captures information pertaining to a SQL-related problem, along with the exact environment under which the problem occurred, so that you can reproduce and test the problem on a separate database. After the test case is ready, you can upload the problem to Oracle Support to enable support personnel to reproduce and troubleshoot the problem.</p>
<p>The information gathered by SQL Test Case Builder includes the query being executed, table and index definitions (but not the actual data), PL/SQL functions, procedures, and packages, optimizer statistics, and initialization parameter settings.</p>
<div id="PFGRF94836" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1356"></a>
<h3 class="sect2"><span class="secnum">16.6.1</span> Creating a Test Case</h3>
<p>You can access the SQL Test Case Builder from Enterprise Manager or manually using the <code>DBMS_SQLDIAG</code> package.</p>
<div id="PFGRF94837" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1357"></a>
<h4 class="sect3"><span class="secnum">16.6.1.1</span> Accessing SQL Test Case Builder from Enterprise Manager</h4>
<p>From Enterprise Manager, the SQL Test Case Builder is accessible only when a SQL incident occurs. A SQL-related problem is referred to as a SQL incident, and each SQL incident is identified by an incident number. You can access the SQL Test Case Builder from the <code>Support Workbench</code> page in Enterprise Manager.</p>
<p>You can access the <code>Support Workbench</code> page in either of the following ways:</p>
<ul>
<li>
<p>In the Database Home page of Enterprise Manager, under <code>Diagnostic Summary</code>, click the link to <code>Active Incidents</code> (indicating the number of active incidents). This opens the <code>Support Workbench</code> page, with the incidents listed in a table.</p>
</li>
<li>
<p>Click <span class="bold">Advisor Central</span> under <code>Related Links</code> to open the <code>Advisor Central</code> page. Next, click <span class="bold">SQL Advisors</span> and then <span class="bold">Click here to go to Support Workbench</span> to open the <code>Support Workbench</code> page.</p>
</li>
</ul>
<p>From the <code>Support Workbench</code> page, to access the SQL Test Case Builder:</p>
<ol>
<li>
<p>Click an incident ID to open the problem details for the particular incident.</p>
</li>
<li>
<p>Next, click <span class="bold">Oracle Support</span> in the <code>Investigate and Resolve</code> section.</p>
</li>
<li>
<p>Click <span class="bold">Generate Additional Dumps and Test Cases</span>.</p>
</li>
<li>
<p>For a particular incident, click the icon in the <code>Go To Task</code> column to run the SQL Test Case Builder.</p>
<p>The output of the SQL Test Case Builder is a SQL script that contains the commands required to re-create all the necessary objects and the environment. SQL Test Case Builder stores the file in the following location, where <span class="italic">inc_num</span> refers to the incident number and <span class="italic">run_num</span> refers to the run number:</p>
<pre>
$ADR_HOME/incident/incdir_<span class="italic">inc_num</span>/SQLTCB_<span class="italic">run num</span>
</pre>
<p>For example, a valid output file name could be as follows:</p>
<pre>
$ORACLE_HOME/log/diag/rdbms/dbsa/dbsa/incident/incdir_2657/SQLTCB_1
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<div id="PFGRF94838" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1358"></a>
<h4 class="sect3"><span class="secnum">16.6.1.2</span> Accessing SQL Test Case Builder Using <a id="sthref1359"></a>DBMS_SQLDIAG</h4>
<p>You can also invoke the SQL Test Case Builder manually, using the <code>DBMS_SQLDIAG</code> package. This package consists of various subprograms for the SQL Test Case Builder, some of which are listed in <a href="#CEGHEBIC">Table 16-1</a>.</p>
<div id="PFGRF94839" class="tblformal">
<p class="titleintable"><a id="sthref1360"></a><a id="CEGHEBIC"></a>Table 16-1 SQL Test Case Builder Procedures in DBMS_SQLDIAG</p>
<table class="cellalignment1686" title="SQL Test Case Builder Procedures in DBMS_SQLDIAG " summary="Procedures in DBMS_SQLDIAG" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t18">Procedure Name</th>
<th class="cellalignment1687" id="r1c2-t18">Function</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t18" headers="r1c1-t18">
<p><code>EXPORT_SQL_TESTCASE</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t18 r1c2-t18">
<p>Generates a SQL test case</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t18" headers="r1c1-t18">
<p><code>EXPORT_SQL_TESTCASE_DIR_BY_INC</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t18 r1c2-t18">
<p>Generates a SQL test case corresponding to the incident ID passed as an argument</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t18" headers="r1c1-t18">
<p><code>EXPORT_SQL_TESTCASE_DIR_BY_TXT</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t18 r1c2-t18">
<p>Generates a SQL test case corresponding to the SQL text passed as an argument</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>For more information on this package and all of its procedures and parameters, see <a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1679">
<tr>
<td class="cellalignment1688">
<table class="cellalignment1684">
<tr>
<td class="cellalignment1683"><a href="optplanmgmt.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1683"><a href="sql_tune.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1690">
<table class="cellalignment1682">
<tr>
<td class="cellalignment1683"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1683"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1683"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1683"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1683"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1683"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
