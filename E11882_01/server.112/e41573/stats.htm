<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Managing Optimizer Statistics</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-06-30T4:25:6Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Performance Tuning Guide" />
<meta name="dcterms.identifier" content="E41573-04" />
<meta name="dcterms.isVersionOf" content="PFGRF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="ex_plan.htm" title="Previous" type="text/html" />
<link rel="Next" href="data_acc.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41573.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">21/31</span> <!-- End Header -->
<div id="PFGRF003" class="chapter"><a id="g49431"></a> <a id="i13546"></a>
<h1 class="chapter"><span class="secnum">13</span> Managing Optimizer Statistics</h1>
<p>This chapter explains why statistics are important for the query optimizer and how to gather and use optimizer statistics with the <code>DBMS_STATS</code> package.</p>
<p>The chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i37048">Overview of Optimizer Statistics</a></p>
</li>
<li>
<p><a href="#i41282">Managing Automatic Optimizer Statistics Collection</a></p>
</li>
<li>
<p><a href="#i41448">Gathering Statistics Manually</a></p>
</li>
<li>
<p><a href="#i41496">System Statistics</a></p>
</li>
<li>
<p><a href="#i41497">Managing Statistics</a></p>
</li>
<li>
<p><a href="#i42991">Controlling Dynamic Statistics</a></p>
</li>
<li>
<p><a href="#i41506">Viewing Statistics</a></p>
</li>
</ul>
<a id="i37048"></a>
<div id="PFGRF94712" class="sect1">
<h2 class="sect1"><span class="secnum">13.1</span> Overview of Optimizer Statistics</h2>
<p><a id="sthref1134"></a><a id="sthref1135"></a><span class="bold">Optimizer statistics</span> describe details about the database and the objects in the database. The query optimizer uses these statistics to choose the best execution plan for each SQL statement.</p>
<p>Optimizer statistics include the following:</p>
<ul>
<li>
<p>Table statistics</p>
<ul>
<li>
<p>Number of rows</p>
</li>
<li>
<p>Number of blocks</p>
</li>
<li>
<p>Average row length</p>
</li>
</ul>
</li>
<li>
<p>Column statistics</p>
<ul>
<li>
<p>Number of distinct values (NDV) in column</p>
</li>
<li>
<p>Number of nulls in column</p>
</li>
<li>
<p>Data distribution (histogram)</p>
</li>
<li>
<p>Extended statistics</p>
</li>
</ul>
</li>
<li>
<p>Index statistics</p>
<ul>
<li>
<p>Number of leaf blocks</p>
</li>
<li>
<p>Levels</p>
</li>
<li>
<p>Clustering factor</p>
</li>
</ul>
</li>
<li>
<p>System statistics</p>
<ul>
<li>
<p>I/O performance and utilization</p>
</li>
<li>
<p>CPU performance and utilization</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not confuse optimizer statistics with performance statistics visible through <code>V$</code> views.</div>
</li>
</ul>
</li>
</ul>
<p>The database stores optimizer statistics in the data dictionary. You can access these statistics using data dictionary views.</p>
<p>Because objects in a database can change constantly, you must update statistics regularly so that they accurately describe these objects. Oracle Database automatically maintains optimizer statistics.</p>
<p>You can maintain optimizer statistics manually using the <code>DBMS_STATS</code> package. For example, you can save and restore copies of statistics. You can export statistics from one database and import those statistics into another database. For example, you can export statistics from a production system to a test system. You can also lock statistics to prevent them from changing.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i41506">"Viewing Statistics"</a></p>
</li>
<li>
<p><a href="#i41282">"Managing Automatic Optimizer Statistics Collection"</a> or <a href="#i41448">"Gathering Statistics Manually"</a></p>
</li>
<li>
<p><a href="#i41856">"Locking Statistics for a Table or Schema"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i41282"></a>
<div id="PFGRF94713" class="sect1">
<h2 class="sect1"><span class="secnum">13.2</span> Managing Automatic Optimizer Statistics Collection</h2>
<p>Oracle recommends that you enable <span class="bold">automatic optimizer statistics collection</span>. In this case, the database automatically collects optimizer statistics for tables with absent or stale statistics. If fresh statistics are required for a table, then the database collects them both for the table and associated indexes.</p>
<p>Automatic collection eliminates many manual tasks associated with managing the optimizer. It also significantly reduces the risks of generating poor execution plans because of missing or stale statistics.</p>
<p>Automatic optimizer statistics collection calls the <code>DBMS_STATS.GATHER_DATABASE_STATS_JOB_PROC</code> procedure. This internal procedure operates similarly to the <code>DBMS_STATS.GATHER_DATABASE_STATS</code> procedure using the <code>GATHER</code> <code>AUTO</code> option. The main difference is that <code>GATHER_DATABASE_STATS_JOB_PROC</code> prioritizes database objects that require statistics, so that objects that most need updated statistics are processed first, before the maintenance window closes.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CIHDGIID">Enabling and Disabling Automatic Optimizer Statistics Collection</a></p>
</li>
<li>
<p><a href="#CIHEAECA">Considerations When Gathering Statistics</a></p>
</li>
</ul>
<a id="CIHDGIID"></a>
<div id="PFGRF94714" class="sect2">
<h3 class="sect2"><span class="secnum">13.2.1</span> Enabling and Disabling Automatic Optimizer Statistics Collection</h3>
<p>The automated maintenance tasks infrastructure (known as <span class="bold">AutoTask</span>) schedules tasks to run automatically in Oracle Scheduler windows known as <span class="bold">maintenance windows</span>. By default, one window is scheduled for each day of the week. Automatic optimizer statistics collection runs as part of AutoTask and is enabled by default to run in all predefined maintenance windows.</p>
<p>If for some reason automatic optimizer statistics collection is disabled, then you can enable it using the <code>ENABLE</code> procedure in the <code>DBMS_AUTO_TASK_ADMIN</code> package:</p>
<pre>
BEGIN
  DBMS_AUTO_TASK_ADMIN.ENABLE(
     client_name =&gt; 'auto optimizer stats collection' 
,    operation   =&gt; NULL
,    window_name =&gt; NULL
);
END;
/
</pre>
<p>When you want to disable automatic optimizer statistics collection, you can disable it using the <code>DISABLE</code> procedure in the <code>DBMS_AUTO_TASK_ADMIN</code> package:</p>
<pre>
BEGIN
  DBMS_AUTO_TASK_ADMIN.DISABLE(
     client_name =&gt; 'auto optimizer stats collection'
,    operation   =&gt; NULL 
,    window_name =&gt; NULL
);
END;
/
</pre>
<p>Automatic optimizer statistics collection relies on the modification monitoring feature, described in <a href="#i41884">"Determining Stale Statistics"</a>. If this feature is disabled, then the automatic optimizer statistics collection job cannot detect stale statistics. This feature is enabled when the <code>STATISTICS_LEVEL</code> parameter is set to <code>TYPICAL</code> or <code>ALL</code>. <code>TYPICAL</code> is the default value.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN0235" href="../../server.112/e25494/tasks.htm#ADMIN0235"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about the AutoTask infrastructure</p>
</li>
<li>
<p><a class="olink ARPLS032" href="../../appdev.112/e40758/d_autotaskadm.htm#ARPLS032"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code>DBMS_AUTO_TASK_ADMIN</code> package</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHEAECA"></a>
<div id="PFGRF94715" class="sect2">
<h3 class="sect2"><span class="secnum">13.2.2</span> Considerations When Gathering Statistics</h3>
<p>This section discusses:</p>
<ul>
<li>
<p><a href="#i41788">When to Use Manual Statistics</a></p>
</li>
<li>
<p><a href="#i41810">Restoring Previous Versions of Statistics</a></p>
</li>
<li>
<p><a href="#i41811">Locking Statistics</a></p>
</li>
</ul>
<a id="i41788"></a>
<div id="PFGRF94716" class="sect3">
<h4 class="sect3"><span class="secnum">13.2.2.1</span> When to Use Manual Statistics</h4>
<p>Automatic optimizer statistics collection should be sufficient for most database objects being modified at a moderate speed. However, in some cases the collection may not be adequate. Because the collection runs during maintenance windows, the statistics on tables that are significantly modified throughout the day may become stale. There are typically two types of such objects:</p>
<ul>
<li>
<p>Volatile tables that are deleted or truncated and rebuilt during the course of the day.</p>
</li>
<li>
<p>Objects that are the target of large bulk loads which add 10% or more to the object's total size.</p>
</li>
</ul>
<p>For highly volatile tables, there are two approaches:</p>
<ul>
<li>
<p>The statistics on these tables can be null. When Oracle Database encounters a table with no statistics, the database dynamically gathers the necessary statistics as part of query optimization. The <code>OPTIMIZER_DYNAMIC_SAMPLING</code> parameter controls this dynamic statistics feature. Set this parameter to a value of <code>2</code> (default) or higher. You can set the statistics to null by deleting and then locking the statistics:</p>
<pre>
BEGIN
  DBMS_STATS.DELETE_TABLE_STATS('OE','ORDERS');
  DBMS_STATS.LOCK_TABLE_STATS('OE','ORDERS');
END;
/
</pre>
<p>See <a href="#i43032">"Dynamic Statistics Levels"</a> to learn how to set the levels for dynamic statistics.</p>
</li>
<li>
<p>The statistics on these tables can be set to values that represent the typical state of the table. You should gather statistics on the table when the table has a representative number of rows, and then lock the statistics.</p>
<p>This may be more effective than automatic optimizer statistic collection, because any statistics generated on the table during the overnight batch window may not be the most appropriate statistics for the daytime workload.</p>
</li>
</ul>
<p>For tables that are bulk-loaded, run the statistics-gathering procedures on the tables immediately following the load process. Preferably, run the procedures as part of the same script or job that is running the bulk load.</p>
<p>The database can collect statistics for external tables in the following ways:</p>
<ul>
<li>
<p><code>GATHER_TABLE_STATS</code> procedure</p>
</li>
<li>
<p><code>GATHER_SCHEMA_STATS</code> procedure</p>
</li>
<li>
<p><code>GATHER_DATABASE_STATS</code> procedure</p>
</li>
<li>
<p>Automatic optimizer statistics collection processing</p>
</li>
</ul>
<p>If you are using <code>GATHER_TABLE_STATS</code>, then explicitly set the <code>ESTIMATE_PERCENT</code> option to <code>NULL</code>, <code>100</code>, or <code>AUTO_SAMPLE</code> because sampling on external tables is not supported. Because the database does not permit data manipulation against external tables, the database never marks statistics on external tables as stale. If new statistics are required for an external table, for example, because the underlying data files change, then drop the existing statistics and regather them.</p>
<p>If the monitoring feature is disabled by setting <code>STATISTICS_LEVEL</code> to <code>BASIC</code>, then automatic optimizer statistics collection cannot detect stale statistics. In this case, you must manually gather statistics. See <a href="#i41884">"Determining Stale Statistics"</a> to learn about the automatic monitoring facility.</p>
<p>System statistics are another type of statistic that you must gather manually. The database does not gather these statistics automatically. See <a href="#i41496">"System Statistics"</a> for more information.</p>
<p>You must manually collect statistics on fixed objects, such as the dynamic performance tables, using <code>GATHER_FIXED_OBJECTS_STATS</code> procedure. Fixed objects record current database activity. You should gather statistics when the database has representative activity.</p>
</div>
<!-- class="sect3" -->
<a id="i41810"></a>
<div id="PFGRF94717" class="sect3">
<h4 class="sect3"><span class="secnum">13.2.2.2</span> Restoring Previous Versions of Statistics</h4>
<p>Whenever statistics in dictionary are modified, old versions of statistics are saved automatically for future restoring. You can restore statistics using <code>RESTORE</code> procedures of <code>DBMS_STATS</code> package. See <a href="#i41814">"Restoring Previous Versions of Statistics"</a> for more information.</p>
</div>
<!-- class="sect3" -->
<a id="i41811"></a>
<div id="PFGRF94718" class="sect3">
<h4 class="sect3"><span class="secnum">13.2.2.3</span> Locking Statistics</h4>
<p>In some cases, you may want to prevent any new statistics from being gathered on a table or schema by the <code>DBMS_STATS_JOB</code> process, such as highly volatile tables discussed in <a href="#i41788">"When to Use Manual Statistics"</a>. In those cases, the <code>DBMS_STATS</code> package provides procedures for locking the statistics for a table or schema. See <a href="#i41856">"Locking Statistics for a Table or Schema"</a> for more information.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i41448"></a>
<div id="PFGRF94719" class="sect1">
<h2 class="sect1"><span class="secnum">13.3</span> Gathering Statistics Manually</h2>
<p><a id="sthref1136"></a>If you do not use automatic optimizer statistics collection, then you must run <code>DBMS_STATS</code> to manually collect statistics in all schemas, including system schemas. If the database content changes regularly, then you must also gather statistics regularly to ensure that the statistics accurately represent characteristics of database objects.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CIHFJFBE">Gathering Statistics with DBMS_STATS Procedures</a></p>
</li>
<li>
<p><a href="#CIHHIBFI">Setting Preferences for Manual Statistics Gathering</a></p>
</li>
<li>
<p><a href="#CIHGDEEI">When to Gather Statistics</a></p>
</li>
<li>
<p><a href="#CIHFDAEC">Comparing Statistics with DBMS_STATS Functions</a></p>
</li>
</ul>
<a id="CIHFJFBE"></a>
<div id="PFGRF30102" class="sect2">
<h3 class="sect2"><span class="secnum">13.3.1</span> Gathering Statistics with DBMS_STATS Procedures</h3>
<p><a id="sthref1137"></a>You can gather statistics with the <code>DBMS_STATS</code> package. This PL/SQL package is also used to modify, view, export, import, and delete statistics.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not use the <code>COMPUTE</code> and <code>ESTIMATE</code> clauses of <code><a id="sthref1138"></a>ANALYZE</code> statement to collect optimizer statistics. These clauses are supported solely for backward compatibility and may be removed in a future release. The <code>DBMS_STATS</code> package collects a broader, more accurate set of statistics, and gathers statistics more efficiently.
<p>You may continue to use <code>ANALYZE</code> statement for other purposes not related to optimizer statistics collection:</p>
<ul>
<li>
<p>To use the <code>VALIDATE</code> or <code>LIST</code> <code>CHAINED</code> <code>ROWS</code> clauses</p>
</li>
<li>
<p>To collect information on free list blocks</p>
</li>
</ul>
</div>
<p>The <code>DBMS_STATS</code> package can gather statistics on table and indexes and individual columns and partitions of tables. It does not gather cluster statistics. However, you can use <code>DBMS_STATS</code> to gather statistics on individual tables instead of the whole cluster.</p>
<p>If you generate statistics for a table, column, or index, and if the data dictionary contains statistics for the object, then Oracle Database updates the existing statistics. The older statistics are saved. You can restore them later if necessary. See <a href="#i41814">"Restoring Previous Versions of Statistics"</a>.</p>
<p>When gathering statistics on system schemas, you can use the procedure <code>DBMS_STATS.GATHER_DICTIONARY_STATS</code>. This procedure gathers statistics for all system schemas, including <code>SYS</code> and <code>SYSTEM,</code> and other optional schemas, such as <code>CTXSYS</code> and <code>DRSYS</code>.</p>
<p>When statistics are updated for a database object, Oracle Database invalidates any currently parsed SQL statements that access the object. The next time such a statement executes, the statement is re-parsed and the optimizer automatically chooses a new execution plan based on the new statistics. Distributed statements accessing objects with new statistics on remote databases are not invalidated. The new statistics take effect the next time the SQL statement is parsed.</p>
<p><a href="#CIHDGFHA">Table 13-1</a> lists the procedures in the <code><a id="sthref1139"></a>DBMS_STATS</code> <a id="sthref1140"></a>package for gathering statistics on database objects.</p>
<div id="PFGRF94720" class="tblformal">
<p class="titleintable"><a id="sthref1141"></a><a id="CIHDGFHA"></a>Table 13-1 <a id="i41347"></a><span class="bold">Statistics Gathering Procedures in the DBMS_STATS Package</span></p>
<table class="cellalignment1686" title="Statistics Gathering Procedures in the DBMS_STATS Package" summary="This table lists the procedures of the DBMS_STATS package for gathering statistics on database objects and lists the corresponding statistics that each procedure collects." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t6">Procedure</th>
<th class="cellalignment1687" id="r1c2-t6">Collects</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t6" headers="r1c1-t6">
<p><code><a id="sthref1142"></a>GATHER_INDEX_STATS</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t6 r1c2-t6">
<p>Index statistics</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t6" headers="r1c1-t6">
<p><code><a id="sthref1143"></a>GATHER_TABLE_STATS</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t6 r1c2-t6">
<p>Table, column, and index statistics</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t6" headers="r1c1-t6">
<p><code><a id="sthref1144"></a>GATHER_SCHEMA_STATS</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t6 r1c2-t6">
<p>Statistics for all objects in a schema</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t6" headers="r1c1-t6">
<p><code><a id="sthref1145"></a>GATHER_DICTIONARY_STATS</code></p>
</td>
<td class="cellalignment1688" headers="r5c1-t6 r1c2-t6">
<p>Statistics for all dictionary objects</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r6c1-t6" headers="r1c1-t6">
<p><code><a id="sthref1146"></a>GATHER_DATABASE_STATS</code></p>
</td>
<td class="cellalignment1688" headers="r6c1-t6 r1c2-t6">
<p>Statistics for all objects in a database</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for syntax and examples of all <code>DBMS_STATS</code> procedures</div>
<p>When using any of these procedures, there are several important considerations for statistics gathering:</p>
<ul>
<li>
<p><a href="#i42181">Statistics Gathering Using Sampling</a></p>
</li>
<li>
<p><a href="#i42217">Parallel Statistics Gathering</a></p>
</li>
<li>
<p><a href="#i42218">Statistics on Partitioned Objects</a></p>
</li>
<li>
<p><a href="#i42219">Column Statistics and Histograms</a></p>
</li>
<li>
<p><a href="#i41884">Determining Stale Statistics</a></p>
</li>
<li>
<p><a href="#i42228">User-Defined Statistics</a></p>
</li>
</ul>
<a id="i42181"></a>
<div id="PFGRF94721" class="sect3">
<h4 class="sect3"><span class="secnum">13.3.1.1</span> Statistics Gathering Using Sampling</h4>
<p><a id="sthref1147"></a>The statistics-gathering operations can utilize sampling to estimate statistics. Sampling is an important technique for gathering statistics. Gathering statistics without sampling requires full table scans and sorts of entire tables. Sampling minimizes the resources necessary to gather statistics.</p>
<p>Sampling is specified using the <code>ESTIMATE_PERCENT</code> argument to the <code>DBMS_STATS</code> procedures. While you can set the sampling percentage to any value, Oracle recommends setting the <code>ESTIMATE_PERCENT</code> parameter of the <code>DBMS_STATS</code> gathering procedures to <code>DBMS_STATS</code>.<code>AUTO_SAMPLE_SIZE</code> to maximize performance gains while achieving necessary statistical accuracy. <code>AUTO_SAMPLE_SIZE</code> lets Oracle Database determine the best sample size necessary for good statistics, based on the statistical property of the object. Because each type of statistics has different requirements, the size of the actual sample taken may not be the same across the table, columns, or indexes. For example, to collect table and column statistics for all tables in the <code>OE</code> schema with auto-sampling, you could use:</p>
<pre>
EXECUTE DBMS_STATS.GATHER_SCHEMA_STATS('OE',DBMS_STATS.AUTO_SAMPLE_SIZE);
</pre>
<p><a id="sthref1148"></a>When the <code>ESTIMATE_PERCENT</code> parameter is manually specified, the <code>DBMS_STATS</code> gathering procedures may automatically increase the sampling percentage if the specified percentage did not produce a large enough sample. This ensures the stability of the estimated values by reducing fluctuations.</p>
</div>
<!-- class="sect3" -->
<a id="i42217"></a>
<div id="PFGRF94722" class="sect3">
<h4 class="sect3"><span class="secnum">13.3.1.2</span> Parallel Statistics Gathering</h4>
<p>The statistics-gathering operations can run either serially or in parallel. You can specify the degree of parallelism with the <code>DEGREE</code> argument to the <code>DBMS_STATS</code> gathering procedures. The database can use parallel statistics gathering in conjunction with sampling. Oracle recommends setting the <code>DEGREE</code> parameter to <code>DBMS_STATS.AUTO_DEGREE</code>. This setting allows Oracle Database to choose an appropriate degree of parallelism based on the size of the object and the settings for the parallel-related <code>init.ora</code> parameters.</p>
<p>Note that certain types of index statistics are not gathered in parallel, including cluster indexes, domain indexes, and bitmap join indexes.</p>
</div>
<!-- class="sect3" -->
<a id="i42218"></a>
<div id="PFGRF94723" class="sect3">
<h4 class="sect3"><span class="secnum">13.3.1.3</span> Statistics on Partitioned Objects</h4>
<p>For partitioned tables and indexes, <code>DBMS_STATS</code> can gather separate statistics for each partition and global statistics for the entire table or index. Similarly, for composite partitioning, <code>DBMS_STATS</code> can gather separate statistics for subpartitions, partitions, and the entire table or index.</p>
<div id="PFGRF95252" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1149"></a>
<h5 class="sect4"><span class="secnum">13.3.1.3.1</span> Granularity of Statistics Gathering</h5>
<p>Depending on the SQL statement undergoing optimization, the optimizer can choose to use partition, subpartition, or global statistics. Both global and partition statistics are important for most applications.</p>
<p>You determine the type of partitioning statistics to be gathered using the <code>GRANULARITY</code> argument to the <code>DBMS_STATS</code> procedures. Oracle recommends setting <code>GRANULARITY</code> to <code>AUTO</code> to gather subpartition, partition, or global statistics depending on the partition type. The <code>ALL</code> setting always gathers all types of statistics.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn more about <code>DBMS_STATS</code></div>
</div>
<!-- class="sect4" -->
<div id="PFGRF95253" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1150"></a>
<h5 class="sect4"><span class="secnum">13.3.1.3.2</span> Incremental Statistics Gathering</h5>
<p>With partitioned tables, you typically add new data into a new partition. As you add new partitions and load data, you must gather statistics on the new partition and keep global statistics up to date.</p>
<p>You can use <code>INCREMENTAL</code> to decide whether the database performs a full table scan to maintain the global statistics of a partitioned table. You can use the <code>DBMS_STATS.SET_TABLE_PREF</code> procedure to change the <code>INCREMENTAL</code> value.</p>
<p>When <code>INCREMENTAL=false</code> (default), the database always uses a full table scan to maintain global statistics. This is a highly resource-intensive and time-consuming operation for large tables. An alternative to mandatory full table scans is gathering <span class="bold">incremental statistics</span>. When the following criteria are met, the database updates global statistics incrementally by scanning <span class="italic">only</span> the partitions that have changed:</p>
<ul>
<li>
<p>The <code>INCREMENTAL</code> value for the partitioned table is <code>true</code>.</p>
</li>
<li>
<p>The <code>PUBLISH</code> value for the partitioned table is <code>true</code>.</p>
</li>
<li>
<p>The user specifies <code>AUTO_SAMPLE_SIZE</code> for <code>ESTIMATE_PERCENT</code> and <code>AUTO</code> for <code>GRANULARITY</code> when gathering statistics on the table.</p>
</li>
</ul>
<p>Gathering table statistics incrementally has the following consequences:</p>
<ul>
<li>
<p>The <code>SYSAUX</code> tablespace consumes additional space to maintain global statistics for partitioned tables.</p>
</li>
<li>
<p>If a table uses composite partitioning, then the database only gathers statistics for modified subpartitions. The database does not gather statistics at the subpartition level for unmodified subpartitions. In this way, the database reduces work by skipping unmodified partitions.</p>
</li>
<li>
<p>If a table uses incremental statistics, and if this table has a locally partitioned index, then the database gathers index statistics at the global level and for modified (not unmodified) index partitions. The database does not generate global index statistics from the partition-level index statistics. Rather, the database gathers global index statistics by performing a full index scan.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn more about <code>DBMS_STATS</code></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i42219"></a>
<div id="PFGRF94724" class="sect3">
<h4 class="sect3"><span class="secnum">13.3.1.4</span> Column Statistics and Histograms</h4>
<p>When gathering statistics on a table, <code>DBMS_STATS</code> gathers information about the data distribution of the columns within the table. The most basic information about the data distribution is the maximum value and minimum value of the column. However, this level of statistics may be insufficient for the optimizer's needs if the data within the column is skewed. For skewed data distributions, histograms can also be created as part of the column statistics to describe the data distribution of a given column. Histograms are described in more details in <a href="#i41591">"Viewing Histograms"</a>.</p>
<p>Histograms are specified using the <code>METHOD_OPT</code> argument of the <code>DBMS_STATS</code> gathering procedures. Oracle recommends setting the <code>METHOD_OPT</code> to <code>FOR</code> <code>ALL</code> <code>COLUMNS</code> <code>SIZE</code> <code>AUTO</code>. With this setting, Oracle Database automatically determines which columns require histograms and the number of buckets (size) of each histogram. You can also manually specify which columns should have histograms and the size of each histogram.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you need to remove all rows from a table when using <code>DBMS_STATS</code>, use <code>TRUNCATE</code> instead of dropping and re-creating the same table. When you drop a table, workload information used by the auto-histogram gathering feature and saved statistics history used by the <code>RESTORE_*_STATS</code> procedures is lost. Without this data, these features do not function properly.</div>
</div>
<!-- class="sect3" -->
<a id="i41884"></a>
<div id="PFGRF94738" class="sect3">
<h4 class="sect3"><span class="secnum">13.3.1.5</span> Determining Stale Statistics</h4>
<p><a id="sthref1151"></a>You must regularly gather statistics on database objects as these database objects are modified over time. To determine whether a given database object needs new database statistics, Oracle Database provides a table monitoring facility. This monitoring is enabled by default when <code>STATISTICS_LEVEL</code> is set to <code>TYPICAL</code> or <code>ALL</code>.</p>
<p>Monitoring tracks the approximate number of <code>INSERT</code>s, <code>UPDATE</code>s, and <code>DELETE</code>s for that table and whether the table has been truncated since the last time statistics were gathered. You can access information about changes of tables in the <code>USER_TAB_MODIFICATIONS</code> view. Following a data-modification, there may be a few minutes delay while Oracle Database propagates the information to this view. Use the <code>DBMS_STATS.FLUSH_DATABASE_MONITORING_INFO</code> procedure to immediately reflect the outstanding monitored information kept in the memory.</p>
<p>The <code>GATHER_DATABASE_STATS</code> or <code>GATHER_SCHEMA_STATS</code> procedures gather new statistics for tables with stale statistics when the <code>OPTIONS</code> parameter is set to <code>GATHER</code> <code>STALE</code> or <code>GATHER</code> <code>AUTO</code>. <a id="sthref1152"></a>If a monitored table has been modified more than 10%, then these statistics are considered stale and gathered again.</p>
</div>
<!-- class="sect3" -->
<a id="i42228"></a>
<div id="PFGRF94739" class="sect3">
<h4 class="sect3"><span class="secnum">13.3.1.6</span> User-Defined Statistics</h4>
<p><a id="sthref1153"></a>You can create user-defined optimizer statistics to support user-defined indexes and functions. When you associate a statistics type with a column or domain index, Oracle Database calls the statistics collection method in the statistics type whenever statistics are gathered for database objects.</p>
<p>You should gather new column statistics on a table after creating a function-based index to allow Oracle Database to collect column statistics equivalent information for the expression. You can perform this task by calling the statistics-gathering procedure with the <code>METHOD_OPT</code> argument set to <code>FOR</code> <code>ALL</code> <code>HIDDEN</code> <code>COLUMNS</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHHIBFI"></a>
<div id="PFGRF95153" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.3.2</span> Setting Preferences for Manual Statistics Gathering</h3>
<p>You can use the <code>DBMS_STATS.SET_*_PREFS</code> procedures to set the default values for parameters used by the <code>DBMS_STATS</code> procedures that gather statistics. You can set a preference for each parameter at a table, schema, database, and global level, thus providing a fine granularity of control.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In previous releases, you used the <code>DBMS_STATS.SET_PARM</code> procedure to set the default parameter values. The scope of these changes was all operations that occurred after running <code>SET_PARM</code>. In Oracle Database 11<span class="italic">g</span>, <code>SET_PARM</code> is deprecated.</div>
<p>You can use the <code>DBMS_STATS.SET_*_PREFS</code> procedures to change the following parameters:</p>
<ul>
<li>
<p><code>AUTOSTATS_TARGET</code> (<code>SET_GLOBAL_PREFS</code> only)</p>
</li>
<li>
<p><code>CASCADE</code></p>
</li>
<li>
<p><code>DEGREE</code></p>
</li>
<li>
<p><code>ESTIMATE_PERCENT</code></p>
</li>
<li>
<p><code>GRANULARITY</code></p>
</li>
<li>
<p><code>INCREMENTAL</code></p>
</li>
<li>
<p><code>METHOD_OPT</code></p>
</li>
<li>
<p><code>NO_INVALIDATE</code></p>
</li>
<li>
<p><code>PUBLISH</code></p>
</li>
<li>
<p><code>STALE_PERCENT</code></p>
</li>
</ul>
<p><a href="#CIHIEJAG">Table 13-2</a> lists the <code>DBMS_STATS</code> procedures for setting preferences. Parameter values set in the <code>DBMS_STAT.GATHER_*_STATS</code> procedures overrule other settings. If a parameter has not been set, then the database checks for a table-level preference. If no table preference exists, then the database uses the <code>GLOBAL</code> preference.</p>
<div id="PFGRF95154" class="tblformal">
<p class="titleintable"><a id="sthref1154"></a><a id="CIHIEJAG"></a>Table 13-2 Setting Preferences for Gathering Statistics</p>
<table class="cellalignment1686" title="Setting Preferences for Gathering Statistics" summary="DBMS_STATS Procedures for Setting Preferences" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t12">Procedure</th>
<th class="cellalignment1687" id="r1c2-t12">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t12" headers="r1c1-t12">
<p><code>SET_TABLE_PREFS</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t12 r1c2-t12">
<p>Enables you to change the default values of the parameters used by the <code>DBMS_STATS.GATHER_*_STATS</code> procedures for the specified table only.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t12" headers="r1c1-t12">
<p><code>SET_SCHEMA_PREFS</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t12 r1c2-t12">
<p>Enables you to change the default values of the parameters used by the <code>DBMS_STATS.GATHER_*_STATS</code> procedures for all existing objects in the specified schema.</p>
<p>This procedure calls <code>SET_TABLE_PREFS</code> for each of the tables in the specified schema. Because it uses <code>SET_TABLE_PREFS</code>, calling <code>SET_SCHEMA_PREFS</code> does not affect any new objects created after it has been run. New objects use the <code>GLOBAL_PREF</code> values for all parameters.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t12" headers="r1c1-t12">
<p><code>SET_DATABASE_PREFS</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t12 r1c2-t12">
<p>Enables you to change the default values of the parameters used by the <code>DBMS_STATS.GATHER_*_STATS</code> procedures for all user-defined schemas in the database. You can include system-owned schemas such as <code>SYS</code> and <code>SYSTEM</code> by setting the <code>ADD_SYS</code> parameter to <code>TRUE</code>.</p>
<p>This procedure calls <code>SET_TABLE_PREFS</code> for each table in the specified schema. Because it uses <code>SET_TABLE_PREFS</code>, calling <code>SET_SCHEMA_PREFS</code> does not affect any new objects created after it has been run. New objects use the <code>GLOBAL_PREF</code> values for all parameters.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t12" headers="r1c1-t12">
<p><code>SET_GLOBAL_PREFS</code></p>
</td>
<td class="cellalignment1688" headers="r5c1-t12 r1c2-t12">
<p>Enables you to change the default values of the parameters used by the <code>DBMS_STATS.GATHER_*_STATS</code> procedures for any object in the database that does not have an existing table preference.</p>
<p>All parameters default to the global setting unless a table preference is set or the parameter is explicitly set in the <code>DBMS_STATS.GATHER_*_STATS</code> command. Changes made by this procedure <span class="italic">will</span> affect any new objects created after it has been run. New objects use the <code>GLOBAL_PREF</code> values for all parameters.</p>
<p>With <code>GLOBAL_PREFS</code>, you can set a default value for the parameter <code>AUTOSTAT_TARGET</code>. This additional parameter controls which objects the automatic statistic gathering job running in the nightly maintenance window looks after. Possible values for this parameter are <code>ALL</code>, <code>ORACLE</code>, and <code>AUTO</code> (default).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for syntax and examples of all <code>DBMS_STATS</code> procedures</div>
</div>
<!-- class="sect2" -->
<a id="CIHGDEEI"></a>
<div id="PFGRF94740" class="sect2">
<h3 class="sect2"><span class="secnum">13.3.3</span> When to Gather Statistics</h3>
<p><a id="sthref1155"></a>When gathering statistics manually, you not only need to determine how to gather statistics, but also when and how often to gather new statistics.</p>
<p>For an application in which tables are incrementally modified, you may only need to gather new statistics every week or every month. The simplest way to gather statistics in these environments is to use a script or job scheduling tool to regularly run the <code>GATHER_SCHEMA_STATS</code> and <code>GATHER_DATABASE_STATS</code> procedures. The frequency of collection intervals should balance the task of providing accurate statistics for the optimizer against the processing overhead incurred by the statistics collection process.</p>
<p>For tables that are substantially modified in batch operations, such as with bulk loads, gather statistics on these tables as part of the batch operation. Call the <code>DBMS_STATS</code> procedure as soon as the load operation completes.</p>
<p>Sometimes only a single partition is modified. In such cases, you can gather statistics only on the modified partitions rather than on the entire table. However, gathering global statistics for the partitioned table may still be necessary.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>GATHER_SCHEMA_STATS</code> and <code>GATHER_DATABASE_STATS</code> procedures in the <code>DBMS_STATS</code> package</div>
</div>
<!-- class="sect2" -->
<a id="CIHFDAEC"></a>
<div id="PFGRF94741" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.3.4</span> Comparing Statistics with DBMS_STATS Functions</h3>
<p><code>DBMS_STATS</code> enables you to compare statistics for a table from two different sources. <a href="#CIHDIEGE">Table 13-3</a> lists the functions in the <code><a id="sthref1156"></a>DBMS_STATS</code> <a id="sthref1157"></a>package for comparing statistics.</p>
<div id="PFGRF94742" class="tblformal">
<p class="titleintable"><a id="sthref1158"></a><a id="CIHDIEGE"></a>Table 13-3 <span class="bold">Functions That Compare Statistics in the DBMS_STATS Package</span></p>
<table class="cellalignment1686" title="Functions That Compare Statistics in the DBMS_STATS Package" summary="This table lists the procedures of the DBMS_STATS package for gathering statistics on database objects and lists the corresponding statistics that each procedure collects." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t15">Procedure</th>
<th class="cellalignment1687" id="r1c2-t15">Compares</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t15" headers="r1c1-t15">
<p><code><a id="sthref1159"></a>DIFF_TABLE_STATS_IN_PENDING</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t15 r1c2-t15">
<p>Pending statistics and statistics as of a timestamp or statistics from dictionary</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t15" headers="r1c1-t15">
<p><code><a id="sthref1160"></a>DIFF_TABLE_STATS_IN_STATTAB</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t15 r1c2-t15">
<p>Statistics for a table from two different sources</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t15" headers="r1c1-t15">
<p><code><a id="sthref1161"></a>DIFF_TABLE_STATS_IN_HISTORY</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t15 r1c2-t15">
<p>Statistics for a table from two timestamps in past and statistics as of that timestamp</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The functions in <a href="#CIHDIEGE">Table 13-3</a> also compare the statistics of dependent objects such as indexes, columns, and partitions. They display statistics of the objects from both sources if the difference between those statistics exceeds a certain threshold. You can specify the threshold as an argument to the function, with a default of 10%. Oracle Database uses the statistics corresponding to the first source as basis for computing the differential percentage.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>DIFF_TABLE_STATS_*</code> functions in the <code>DBMS_STATS</code> package</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i41496"></a>
<div id="PFGRF94743" class="sect1">
<h2 class="sect1"><span class="secnum">13.4</span> System Statistics</h2>
<p><a id="sthref1162"></a>System statistics describe the system's hardware characteristics, such as I/O and CPU performance and utilization, to the query optimizer. When choosing an execution plan, the optimizer estimates the I/O and CPU resources required for each query. System statistics enable the query optimizer to more accurately estimate I/O and CPU costs, enabling the query optimizer to choose a better execution plan.</p>
<p>When Oracle Database gathers system statistics, it analyzes system activity in a specified time period (workload statistics) or simulates a workload (noworkload statistics). The statistics are collected using the <code>DBMS_STATS.GATHER_SYSTEM_STATS</code> procedure. Oracle highly recommends that you gather system statistics.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must have DBA privileges or <code>GATHER_SYSTEM_STATISTICS</code> role to update dictionary system statistics.</div>
<p><a href="#g43900">Table 13-4</a> lists the optimizer system statistics gathered by the <code>DBMS_STATS</code> package and the options for gathering or manually setting specific system statistics.</p>
<div id="PFGRF94744" class="tblformalwidemax">
<p class="titleintable"><a id="sthref1163"></a><a id="g43900"></a>Table 13-4 Optimizer System Statistics in the DBMS_STAT Package</p>
<table class="cellalignment1691" title="Optimizer System Statistics in the DBMS_STAT Package" summary="This table describes the optimizer system statistics gathered by the DBMS_STATS package and explains when and how the statistics can be gathered." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t18">Parameter Name</th>
<th class="cellalignment1687" id="r1c2-t18">Description</th>
<th class="cellalignment1687" id="r1c3-t18">Initialization</th>
<th class="cellalignment1687" id="r1c4-t18">Options for Gathering or Setting Statistics</th>
<th class="cellalignment1687" id="r1c5-t18">Unit</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t18" headers="r1c1-t18">
<p><code>cpuspeedNW</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t18 r1c2-t18">
<p>Represents noworkload CPU speed. CPU speed is the average number of CPU cycles in each second.</p>
</td>
<td class="cellalignment1688" headers="r2c1-t18 r1c3-t18">
<p>At system startup</p>
</td>
<td class="cellalignment1688" headers="r2c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>NOWORKLOAD</code> or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r2c1-t18 r1c5-t18">
<p>Millions/sec.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t18" headers="r1c1-t18">
<p><code>ioseektim</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t18 r1c2-t18">
<p>I/O seek time equals seek time + latency time + operating system overhead time.</p>
</td>
<td class="cellalignment1688" headers="r3c1-t18 r1c3-t18">
<p>At system startup</p>
<p>10 (default)</p>
</td>
<td class="cellalignment1688" headers="r3c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>NOWORKLOAD</code> or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r3c1-t18 r1c5-t18">
<p>ms</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t18" headers="r1c1-t18">
<p><code>iotfrspeed</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t18 r1c2-t18">
<p>I/O transfer speed is the rate at which an Oracle database can read data in the single read request.</p>
</td>
<td class="cellalignment1688" headers="r4c1-t18 r1c3-t18">
<p>At system startup</p>
<p>4096 (default)</p>
</td>
<td class="cellalignment1688" headers="r4c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>NOWORKLOAD</code> or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r4c1-t18 r1c5-t18">
<p>Bytes/ms</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t18" headers="r1c1-t18">
<p><code>cpuspeed</code></p>
</td>
<td class="cellalignment1688" headers="r5c1-t18 r1c2-t18">
<p>Represents workload CPU speed. CPU speed is the average number of CPU cycles in each second.</p>
</td>
<td class="cellalignment1688" headers="r5c1-t18 r1c3-t18">
<p>None</p>
</td>
<td class="cellalignment1688" headers="r5c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>NOWORKLOAD</code>, <code>INTERVAL</code>, or <code>START|STOP</code>, or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r5c1-t18 r1c5-t18">
<p>Millions/sec.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r6c1-t18" headers="r1c1-t18">
<p><code>maxthr</code></p>
</td>
<td class="cellalignment1688" headers="r6c1-t18 r1c2-t18">
<p>Maximum I/O throughput is the maximum throughput that the I/O subsystem can deliver.</p>
</td>
<td class="cellalignment1688" headers="r6c1-t18 r1c3-t18">
<p>None</p>
</td>
<td class="cellalignment1688" headers="r6c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>NOWORKLOAD</code>, <code>INTERVAL</code>, or <code>START|STOP</code>, or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r6c1-t18 r1c5-t18">
<p>Bytes/sec.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r7c1-t18" headers="r1c1-t18">
<p><code>slavethr</code></p>
</td>
<td class="cellalignment1688" headers="r7c1-t18 r1c2-t18">
<p>Slave I/O throughput is the average parallel slave I/O throughput.</p>
</td>
<td class="cellalignment1688" headers="r7c1-t18 r1c3-t18">
<p>None</p>
</td>
<td class="cellalignment1688" headers="r7c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>INTERVAL</code> or <code>START|STOP</code>, or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r7c1-t18 r1c5-t18">
<p>Bytes/sec.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r8c1-t18" headers="r1c1-t18">
<p><code>sreadtim</code></p>
</td>
<td class="cellalignment1688" headers="r8c1-t18 r1c2-t18">
<p>Single block read time is the average time to read a single block randomly.</p>
</td>
<td class="cellalignment1688" headers="r8c1-t18 r1c3-t18">
<p>None</p>
</td>
<td class="cellalignment1688" headers="r8c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>INTERVAL</code> or <code>START|STOP</code>, or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r8c1-t18 r1c5-t18">
<p>ms</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r9c1-t18" headers="r1c1-t18">
<p><code>mreadtim</code></p>
</td>
<td class="cellalignment1688" headers="r9c1-t18 r1c2-t18">
<p>Multiblock read is the average time to read a multiblock sequentially.</p>
</td>
<td class="cellalignment1688" headers="r9c1-t18 r1c3-t18">
<p>None</p>
</td>
<td class="cellalignment1688" headers="r9c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>INTERVAL</code> or <code>START|STOP</code>, or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r9c1-t18 r1c5-t18">
<p>ms</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r10c1-t18" headers="r1c1-t18">
<p><code>mbrc</code></p>
</td>
<td class="cellalignment1688" headers="r10c1-t18 r1c2-t18">
<p>Multiblock count is the average multiblock read count sequentially.</p>
</td>
<td class="cellalignment1688" headers="r10c1-t18 r1c3-t18">
<p>None</p>
</td>
<td class="cellalignment1688" headers="r10c1-t18 r1c4-t18">
<p>Set <code>gathering_mode</code> = <code>INTERVAL</code> or <code>START|STOP</code>, or set statistics manually.</p>
</td>
<td class="cellalignment1688" headers="r10c1-t18 r1c5-t18">
<p>blocks</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p>Unlike table, index, or column statistics, Oracle Database does not invalidate parsed SQL statements when system statistics are updated. All new SQL statements are parsed using new statistics.</p>
<p>Oracle Database offers two options for gathering system statistics:</p>
<ul>
<li>
<p><a href="#CIHIEIIA">Workload Statistics</a></p>
</li>
<li>
<p><a href="#CIHGHDFG">Noworkload Statistics</a></p>
</li>
</ul>
<p>These options better facilitate the gathering process to the physical database and workload: when workload system statistics are gathered, noworkload system statistics are ignored. Noworkload system statistics are initialized to default values at the first database startup.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information on the procedures in the <code>DBMS_STATS</code> package for implementing system statistics</div>
<a id="CIHIEIIA"></a>
<div id="PFGRF94745" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.4.1</span> Workload Statistics</h3>
<p>Workload statistics include the following:</p>
<ul>
<li>
<p>Single and multiblock read times</p>
</li>
<li>
<p><code>mbrc</code></p>
</li>
<li>
<p>CPU speed (<code>cpuspeed</code>)</p>
</li>
<li>
<p>Maximum system throughput</p>
</li>
<li>
<p>Average slave throughput</p>
</li>
</ul>
<p>single and multiblock read times, <code>mbrc</code>, CPU speed (<code>cpuspeed</code>), maximum system throughput, and average slave throughput. The database computes <code>sreadtim</code>, <code>mreadtim</code>, and <code>mbrc</code> by comparing the number of physical sequential and random reads between two points in time from the beginning to the end of a workload. The database implements these values through counters that change when the buffer cache completes synchronous read requests.</p>
<p>Because the counters are in the buffer cache, they include not only I/O delays, but also waits related to latch contention and task switching. Workload statistics thus depend on the activity the system had during the workload window. If system is I/O bound (both latch contention and I/O throughput), then the statistics reflect this situation and therefore promotes a less I/O-intensive plan after the database uses the statistics. Furthermore, workload statistics gathering does not generate additional overhead.</p>
<a id="CIHFHEAE"></a>
<div id="PFGRF94746" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">13.4.1.1</span> Gathering Workload Statistics</h4>
<p>To gather workload statistics, perform either of the following tasks:</p>
<ul>
<li>
<p>Run the <code>DBMS_STATS.GATHER_SYSTEM_STATS('start')</code> procedure at the beginning of the workload window, then the <code>DBMS_STATS.GATHER_SYSTEM_STATS('stop')</code> procedure at the end of the workload window.</p>
</li>
<li>
<p>Run <code>DBMS_STATS.GATHER_SYSTEM_STATS('interval', interval=&gt;N)</code> where <code>N</code> is the number of minutes when statistics gathering is stopped automatically.</p>
</li>
</ul>
<p>To delete system statistics, run <code>dbms_stats.delete_system_stats()</code>. Workload statistics are deleted and reset to the default noworkload statistics.</p>
</div>
<!-- class="sect3" -->
<div id="PFGRF94747" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1164"></a>
<h4 class="sect3"><span class="secnum">13.4.1.2</span> Multiblock Read Count</h4>
<p>If you gather workload statistics, then the <code>mbrc</code> value gathered as part of the workload statistics is used to estimate the cost of a full table scan. However, during the gathering process of workload statistics, Oracle Database may not gather the <code>mbrc</code> and <code>mreadtim</code> values if no table scans are performed during serial workloads, as is often the case with OLTP systems. However, full table scans occur frequently on DSS systems but may run parallel and bypass the buffer cache. In such cases, Oracle Database still gathers the <code>sreadtim</code> value because the database performs index lookup using the buffer cache.</p>
<p>If Oracle Database cannot gather or validate gathered <code>mbrc</code> or <code>mreadtim</code> values, but has gathered <code>sreadtim</code> and <code>cpuspeed</code> values, then the database uses only the <code>sreadtim</code> and <code>cpuspeed</code> values for costing. In this case, the optimizer uses the value of the initialization parameter <code>DB_FILE_MULTIBLOCK_READ_COUNT</code> to cost a full table scan. However, if <code>DB_FILE_MULTIBLOCK_READ_COUNT</code> is not set or is set to 0 (zero), then the optimizer uses a value of 8 for costing.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHGHDFG"></a>
<div id="PFGRF94748" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.4.2</span> Noworkload Statistics</h3>
<p>Noworkload statistics consist of I/O transfer speed, I/O seek time, and CPU speed (<code>cpuspeednw</code>). The major difference between workload statistics and noworkload statistics lies in the gathering method.</p>
<p>Noworkload statistics gather data by submitting random reads against all data files, while workload statistics uses counters updated when database activity occurs. <code>ioseektim</code> represents the time it takes to position the disk head to read data. Its value usually varies from 5 ms to 15 ms, depending on disk rotation speed and the disk or RAID specification. The I/O transfer speed represents the speed at which one operating system process can read data from the I/O subsystem. Its value varies greatly, from a few MBs per second to hundreds of MBs per second. Oracle Database uses relatively conservative default settings for I/O transfer speed.</p>
<p>Oracle Database uses noworkload statistics and the CPU cost model by default. The values of noworkload statistics are initialized to defaults at the first instance startup:</p>
<pre>
ioseektim = 10ms
iotrfspeed = 4096 bytes/ms
cpuspeednw = gathered value, varies based on system
</pre>
<p>If workload statistics are gathered, then Oracle Database ignores noworkload statistics and uses workload statistics instead.</p>
<a id="CIHIAIDE"></a>
<div id="PFGRF94749" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">13.4.2.1</span> Gathering Noworkload Statistics</h4>
<p>To gather noworkload statistics, run <code>DBMS_STATS.GATHER_SYSTEM_STATS()</code> with no arguments. There is an overhead on the I/O system during the gathering process of noworkload statistics. The gathering process may take from a few seconds to several minutes, depending on I/O performance and database size.</p>
<p>The information is analyzed and verified for consistency. In some cases, the value of noworkload statistics may remain its default value. In such cases, repeat the statistics gathering process or set the value manually to values that the I/O system has according to its specifications by using the <code>DBMS_STATS.SET_SYSTEM_STATS</code> procedure.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i41497"></a>
<div id="PFGRF94750" class="sect1">
<h2 class="sect1"><span class="secnum">13.5</span> Managing Statistics<a id="sthref1165"></a></h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#BEIEGBGI">Pending Statistics</a></p>
</li>
<li>
<p><a href="#BEIEEIJA">Managing Extended Statistics</a></p>
</li>
<li>
<p><a href="#i41814">Restoring Previous Versions of Statistics</a></p>
</li>
<li>
<p><a href="#i41854">Exporting and Importing Statistics</a></p>
</li>
<li>
<p><a href="#i41855">Restoring Statistics Versus Importing or Exporting Statistics</a></p>
</li>
<li>
<p><a href="#i41856">Locking Statistics for a Table or Schema</a></p>
</li>
<li>
<p><a href="#i41857">Setting Statistics</a></p>
</li>
<li>
<p><a href="#i41866">Handling Missing Statistics</a></p>
</li>
</ul>
<a id="BEIEGBGI"></a>
<div id="PFGRF94751" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.5.1</span> Pending Statistics</h3>
<p>Starting with Oracle Database 11<span class="italic">g</span> Release 2 (11.2), you have the following options when gathering statistics:</p>
<ul>
<li>
<p>Publish the statistics automatically at the end of the gather operation (default behavior)</p>
</li>
<li>
<p>Save the new statistics saved as pending</p>
</li>
</ul>
<p>Saving the new statistics as pending allows you to validate the new statistics and publish them only if they are satisfactory.</p>
<p>To check whether the statistics will be automatically published as soon as they are gathered, use the <code>DBMS_STATS</code> package as follows:</p>
<pre>
SELECT DBMS_STATS.GET_PREFS('PUBLISH') PUBLISH FROM DUAL;
</pre>
<p>The preceding query returns either <code>TRUE</code> or <code>FALSE</code>. <code>TRUE</code> indicates that the statistics will be published as and when they are gathered, while <code>FALSE</code> indicates that the statistics will be kept pending.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The database stores published statistics in data dictionary views such as <code>USER_TAB_STATISTICS</code> and <code>USER_IND_STATISTICS</code>. The database stores pending statistics in views such as <code>USER_TAB_PENDING_STATS</code> and <code>USER_IND_PENDING_STATS</code>.</div>
<p>You can change the <code>PUBLISH</code> setting at either the schema or the table level. For example, to change the <code>PUBLISH</code> setting for the <code>customers</code> table in the <code>SH</code> schema, execute the statement:</p>
<pre>
EXEC DBMS_STATS.SET_TABLE_PREFS('SH', 'CUSTOMERS', 'PUBLISH', 'false');
</pre>
<p>Subsequently, when you gather statistics on the <code>customers</code> table, the statistics will not be automatically published when the gather job completes. Instead, the database stores the newly gathered statistics in the <code>USER_TAB_PENDING_STATS</code> table.</p>
<p>By default, the optimizer uses the published statistics stored in the data dictionary views. If you want the optimizer to use the newly collected pending statistics, then set the initialization parameter <code>OPTIMIZER_USE_PENDING_STATISTICS</code> to <code>TRUE</code> (the default value is <code>FALSE</code>), and run a workload against the table or schema:</p>
<pre>
ALTER SESSION SET OPTIMIZER_USE_PENDING_STATISTICS = TRUE;
</pre>
<p>The optimizer will use the pending statistics instead of the published statistics when compiling SQL statements. If the pending statistics are valid, then you can make them public by executing the following statement:</p>
<pre>
EXEC DBMS_STATS.PUBLISH_PENDING_STATS(null, null);
</pre>
<p>You can also publish the pending statistics for a specific database object. For example, by using the following statement:</p>
<pre>
EXEC DBMS_STATS.PUBLISH_PENDING_STATS('SH','CUSTOMERS');
</pre>
<p>If you do not want to publish the pending statistics, delete them by executing the following statement:</p>
<pre>
EXEC DBMS_STATS.DELETE_PENDING_STATS('SH','CUSTOMERS');
</pre>
<p>You can export pending statistics using <code>DBMS_STATS.EXPORT_PENDING_STATS</code> function. Exporting pending statistics to a test system enables you to run a full workload against the new statistics.</p>
</div>
<!-- class="sect2" -->
<a id="BEIEEIJA"></a>
<div id="PFGRF94725" class="sect2">
<h3 class="sect2"><span class="secnum">13.5.2</span> Managing Extended Statistics<a id="sthref1166"></a></h3>
<p><code>DBMS_STATS</code> enables you to collect extended statistics, which are statistics that can improve cardinality estimates when multiple predicates exist on different columns of a table, or when predicates use expressions. An extension is either a column group or an expression.</p>
<p>Oracle Database supports the following types of extended statistics:</p>
<ul>
<li>
<p>Column group statistics</p>
<p>This type of extended statistics can improve cardinality estimates when multiple columns from the same table occur together in a SQL statement. See <a href="#CIHFICCB">"Managing Column Group Statistics"</a>.</p>
</li>
<li>
<p>Expression statistics</p>
<p>This type of extended statistics improves optimizer estimates when predicates use expressions, for example, built-in or user-defined functions. See <a href="#BEICJCJH">"Managing Expression Statistics"</a>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot create extended statistics on virtual columns. See <a class="olink SQLRF54467" href="../../server.112/e41084/statements_7002.htm#SQLRF54467"><span class="italic">Oracle Database SQL Language Reference</span></a> for a list of restrictions on virtual columns.</div>
<a id="CIHFICCB"></a>
<div id="PFGRF10131" class="sect3">
<h4 class="sect3"><span class="secnum">13.5.2.1</span> Managing Column Group Statistics<a id="sthref1167"></a></h4>
<p>When the <code>WHERE</code> clause of a query specifies multiple columns from a single table (multiple single column predicates), the relationship between the columns can strongly affect the combined selectivity for the column group.</p>
<p>For example, consider the <code>customers</code> table in the <code>sh</code> schema. The columns <code>cust_state_province</code> and <code>country_id</code> are related, with <code>cust_state_province</code> determining the <code>country_id</code> for each customer. Suppose you query the <code>customers</code> table where the <code>cust_state_province</code> is <code>California</code>:</p>
<pre>
SELECT COUNT(*)
FROM   sh.customers 
WHERE  cust_state_province = 'CA';
</pre>
<p>The preceding query returns the following value:</p>
<pre>
 COUNT(*)
----------
    3341
</pre>
<p>Adding an extra predicate on the <code>country_id</code> column does not change the result when the <code>country_id</code> is 52790 (United States of America). Assume that you run the following query:</p>
<pre>
SELECT COUNT(*) 
FROM   customers 
WHERE  cust_state_province = 'CA' 
AND    country_id=52790;
</pre>
<p>The preceding query returns the same value as the previous query:</p>
<pre>
 COUNT(*)
----------
    3341
</pre>
<p>Assume that the <code>country_id</code> has a different value, such as 52775 (Brazil), as in the following query:</p>
<pre>
SELECT COUNT(*) 
FROM   customers 
WHERE  cust_state_province = 'CA' 
AND    country_id=52775;
</pre>
<p>In this case the returned value is as follows:</p>
<pre>
 COUNT(*)
----------
       0
</pre>
<p>With individual column statistics, the optimizer has no way of knowing that the <code>cust_state_province</code> and the <code>country_id</code> columns are related. By gathering statistics on these columns as a group (column group), the optimizer has a more accurate selectivity value for the group, instead of having to generate the value based on the individual column statistics.</p>
<p>You can create column groups manually by using the <code><a id="sthref1168"></a>DBMS_STATS</code> package. You can use this package to create a column group, get the name of a column group, or delete a column group from a table.</p>
<div id="PFGRF94726" class="sect4"><a id="sthref1169"></a>
<h5 class="sect4"><span class="secnum">13.5.2.1.1</span> Creating a Column Group</h5>
<p>Use the <code><a id="sthref1170"></a><a id="sthref1171"></a>CREATE_EXTENDED_STATISTICS</code> function to create a column group. The <code>CREATE_EXTENDED_STATISTICS</code> function returns the system-generated name of the newly created column group. <a href="#BEICHEBF">Table 13-5</a> lists the input parameters for this function.</p>
<div id="PFGRF94727" class="tblformal">
<p class="titleintable"><a id="sthref1172"></a><a id="BEICHEBF"></a>Table 13-5 Parameters for the create_extended_statistics Function</p>
<table class="cellalignment1686" title="Parameters for the create_extended_statistics Function" summary="Parameters for the create_extended_statistics Function" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t22">Parameter</th>
<th class="cellalignment1687" id="r1c2-t22">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t22" headers="r1c1-t22">
<p><code>ownname</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t22 r1c2-t22">
<p>Schema owner. <code>NULL</code> indicates current schema.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t22" headers="r1c1-t22">
<p><code>tabname</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t22 r1c2-t22">
<p>Name of the table to which the column group is added.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t22" headers="r1c1-t22">
<p><code>extension</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t22 r1c2-t22">
<p>Columns in the column group.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>For example, to add a column group consisting of the <code>cust_state_province</code> and <code>country_id</code> columns to the <code>customers</code> table in <code>SH</code> schema, run the following PL/SQL block:</p>
<pre>
DECLARE
  cg_name VARCHAR2(30);
BEGIN
  cg_name := DBMS_STATS.CREATE_EXTENDED_STATS(null,'customers',  
             '(cust_state_province,country_id)');
END;
/
</pre></div>
<!-- class="sect4" -->
<div id="PFGRF94728" class="sect4"><a id="sthref1173"></a>
<h5 class="sect4"><span class="secnum">13.5.2.1.2</span> Getting a Column Group</h5>
<p>Use the <code><a id="sthref1174"></a><a id="sthref1175"></a>show_extended_stats_name</code> function to obtain the name of the column group for a given set of columns. <a href="#BEIEBABF">Table 13-6</a> lists the input parameters for this function.</p>
<div id="PFGRF94729" class="tblformal">
<p class="titleintable"><a id="sthref1176"></a><a id="BEIEBABF"></a>Table 13-6 Parameters for the show_extended_stats_name Function</p>
<table class="cellalignment1686" title="Parameters for the show_extended_stats_name Function" summary="Parameters for the show_extended_stats_name Function" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t23">Parameter</th>
<th class="cellalignment1687" id="r1c2-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t23" headers="r1c1-t23">
<p><code>ownname</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t23 r1c2-t23">
<p>Schema owner. <code>NULL</code> indicates current schema.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t23" headers="r1c1-t23">
<p><code>tabname</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t23 r1c2-t23">
<p>Name of the table to which the column group belongs.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t23" headers="r1c1-t23">
<p><code>extension</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t23 r1c2-t23">
<p>Name of the column group.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>For example, use the following query to obtain the column group name for a set of columns on the <code>customers</code> table:</p>
<pre>
SELECT SYS.DBMS_STATS.SHOW_EXTENDED_STATS_NAME('sh','customers',
       '(cust_state_province,country_id)') col_group_name 
FROM   DUAL;
</pre>
<p>The output is similar to the following:</p>
<pre>
COL_GROUP_NAME
----------------
SYS_STU#S#WF25Z#QAHIHE#MOFFMM
</pre></div>
<!-- class="sect4" -->
<div id="PFGRF94730" class="sect4"><a id="sthref1177"></a>
<h5 class="sect4"><span class="secnum">13.5.2.1.3</span> Dropping a Column Group</h5>
<p>Use the <code><a id="sthref1178"></a><a id="sthref1179"></a>DROP_EXTENDED_STATS</code> function to delete a column group from a table. <a href="#BEIJHCBE">Table 13-7</a> lists the input parameters for this function:</p>
<div id="PFGRF94731" class="tblformal">
<p class="titleintable"><a id="sthref1180"></a><a id="BEIJHCBE"></a>Table 13-7 Parameters for the drop_extended_stats Function</p>
<table class="cellalignment1686" title="Parameters for the drop_extended_stats Function" summary="Parameters for the drop_extended_stats Function" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t24">Parameter</th>
<th class="cellalignment1687" id="r1c2-t24">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t24" headers="r1c1-t24">
<p><code>ownname</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t24 r1c2-t24">
<p>Schema owner. <code>NULL</code> indicates current schema.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t24" headers="r1c1-t24">
<p><code>tabname</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t24 r1c2-t24">
<p>Name of the table to which the column group belongs.</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t24" headers="r1c1-t24">
<p><code>extension</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t24 r1c2-t24">
<p>Name of the column group to be deleted.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>For example, the following statement deletes a column group from the <code>customers</code> table:</p>
<pre>
EXEC DBMS_STATS.DROP_EXTENDED_STATS('sh','customers',
                                    '(cust_state_province,country_id)');
</pre></div>
<!-- class="sect4" -->
<div id="PFGRF94732" class="sect4"><a id="sthref1181"></a>
<h5 class="sect4"><span class="secnum">13.5.2.1.4</span> Monitoring Column Groups</h5>
<p>Use the dictionary table <code><a id="sthref1182"></a>USER_STAT_EXTENSIONS</code> to obtain information about multicolumn statistics:</p>
<pre>
SELECT EXTENSION_NAME, EXTENSION 
FROM   USER_STAT_EXTENSIONS 
WHERE  TABLE_NAME='CUSTOMERS';
</pre>
<pre>
EXTENSION_NAME                     EXTENSION
-------------------------------------------------------------------------
SYS_STU#S#WF25Z#QAHIHE#MOFFMM_     ("CUST_STATE_PROVINCE","COUNTRY_ID")
</pre>
<p>Use the following query to find the number of distinct values and find whether a histogram has been created for a column group:</p>
<pre>
SELECT e.EXTENSION col_group, t.NUM_DISTINCT, t.HISTOGRAM
FROM   USER_STAT_EXTENSIONS e, USER_TAB_COL_STATISTICS t
WHERE  e.EXTENSION_NAME=t.COLUMN_NAME
AND    e.TABLE_NAME=t.TABLE_NAME
AND    t.TABLE_NAME='CUSTOMERS';
</pre>
<pre>
COL_GROUP                             NUM_DISTINCT        HISTOGRAM
-------------------------------------------------------------------------------
("COUNTRY_ID","CUST_STATE_PROVINCE")  145                 FREQUENCY
</pre></div>
<!-- class="sect4" -->
<div id="PFGRF94733" class="sect4"><a id="sthref1183"></a>
<h5 class="sect4"><span class="secnum">13.5.2.1.5</span> Gathering Statistics on Column Groups</h5>
<p>The <code><a id="sthref1184"></a><a id="sthref1185"></a>METHOD_OPT</code> argument of the <code>DBMS_STATS</code> package enables you to gather statistics on column groups. If you set the value of this argument to <code>FOR ALL COLUMNS SIZE AUTO</code>, then the optimizer gathers statistics on all existing column groups. To collect statistics on a new column group, specify the group using <code>FOR COLUMNS</code>. The column group is automatically created as part of statistic gathering.</p>
<p>For example, the following statement creates a new column group for the <code>customers</code> table on the columns <code>cust_state_province</code>, <code>country_id</code> and gathers statistics (including histograms) on the entire table and the new column group:</p>
<pre>
EXEC DBMS_STATS.GATHER_TABLE_STATS('SH','CUSTOMERS',METHOD_OPT =&gt;
'FOR ALL COLUMNS SIZE SKEWONLY 
FOR COLUMNS (CUST_STATE_PROVINCE,COUNTRY_ID) SIZE SKEWONLY');
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The optimizer only uses multicolumn statistics with equality predicates.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEICJCJH"></a>
<div id="PFGRF94734" class="sect3">
<h4 class="sect3"><span class="secnum">13.5.2.2</span> Managing Expression Statistics<a id="sthref1186"></a></h4>
<p>When a function is applied to a column in the <code>WHERE</code> clause of a query (<code>function(col1)=constant</code>), the optimizer has no way of knowing how that function affects the selectivity of the column. By gathering expression statistics on the expression <code>function(col1)</code>, the optimizer obtains a more accurate selectivity value.</p>
<p>An example of such a function is:</p>
<pre>
SELECT COUNT(*)
FROM   CUSTOMERS
WHERE  LOWER(CUST_STATE_PROVINCE)='ca';
</pre>
<div id="PFGRF94735" class="sect4"><a id="sthref1187"></a>
<h5 class="sect4"><span class="secnum">13.5.2.2.1</span> Creating Expression Statistics</h5>
<p>You can create statistics on an expression as part of the <code><a id="sthref1188"></a><a id="sthref1189"></a>GATHER_TABLE_STATS</code> procedure:</p>
<pre>
EXEC DBMS_STATS.GATHER_TABLE_STATS('sh','customers', method_opt =&gt;
'FOR ALL COLUMNS SIZE SKEWONLY 
 FOR COLUMNS (LOWER(cust_state_province)) SIZE SKEWONLY');
</pre>
<p>You can also use the <code><a id="sthref1190"></a>CREATE_EXTENDED_STATISTICS</code> function to accomplish this:</p>
<pre>
SELECT 
DBMS_STATS.CREATE_EXTENDED_STATS(null,'customers','(LOWER(cust_state_province))') 
FROM DUAL;
</pre></div>
<!-- class="sect4" -->
<div id="PFGRF94736" class="sect4"><a id="sthref1191"></a>
<h5 class="sect4"><span class="secnum">13.5.2.2.2</span> Monitoring Expression Statistics</h5>
<p>Use the dictionary table <code><a id="sthref1192"></a>user_stat_extensions</code> to obtain information about expression statistics:</p>
<pre>
SELECT EXTENSION_NAME, EXTENSION 
FROM   USER_STAT_EXTENSIONS 
WHERE  TABLE_NAME='CUSTOMERS';
</pre>
<pre>
EXTENSION_NAME                    EXTENSION
------------------------------------------------------------------------
SYS_STUBPHJSBRKOIK9O2YV3W8HOUE    (LOWER("CUST_STATE_PROVINCE"))
</pre>
<p>Use the following query to find the number of distinct values and find whether a histogram has been created:</p>
<pre>
SELECT e.EXTENSION col_group, t.NUM_DISTINCT, t.HISTOGRAM
FROM   USER_STAT_EXTENSIONS e, USER_TAB_COL_STATISTICS t
WHERE  e.EXTENSION_NAME=t.COLUMN_NAME
AND    t.TABLE_NAME='CUSTOMERS';
</pre>
<pre>
COL_GROUP                        NUM_DISTINCT          HISTOGRAM
------------------------------------------------------------------------
(LOWER("CUST_STATE_PROVINCE"))   145                   FREQUENCY
</pre></div>
<!-- class="sect4" -->
<div id="PFGRF94737" class="sect4"><a id="sthref1193"></a>
<h5 class="sect4"><span class="secnum">13.5.2.2.3</span> Dropping Expression Statistics</h5>
<p>Use the <code><a id="sthref1194"></a><a id="sthref1195"></a>DROP_EXTENDED_STATS</code> function to delete expression statistics from a table:</p>
<pre>
EXEC DBMS_STATS.DROP_EXTENDED_STATS(null,'customers','(lower(country_id))');
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i41814"></a>
<div id="PFGRF94752" class="sect2">
<h3 class="sect2"><span class="secnum">13.5.3</span> Restoring Previous Versions of Statistics</h3>
<p><a id="sthref1196"></a>Whenever statistics in dictionary are modified, old versions of statistics are saved automatically for future restoration. You can restore statistics using <code>RESTORE</code> procedures of <code>DBMS_STATS</code> package. These procedures use a time stamp as an argument and restore statistics as of that time stamp. This is useful in case newly collected statistics leads to some sub-optimal execution plans and the administrator wants to revert to the previous set of statistics.</p>
<p>There are dictionary views that display the time of statistics modifications. These views are useful in determining the time stamp to be used for statistics restoration.</p>
<ul>
<li>
<p>Catalog view <code>DBA_OPTSTAT_OPERATIONS</code> contain history of statistics operations performed at schema and database level using <code>DBMS_STATS</code>.</p>
</li>
<li>
<p>The views <code>*_TAB_STATS_HISTORY</code> views (<code>ALL</code>, <code>DBA</code>, or <code>USER</code>) contain a history of table statistics modifications.</p>
</li>
</ul>
<p>The database purges old statistics automatically at regular intervals based on the statistics history retention setting and the time of the recent analysis of the system. You can configure retention using the <code>ALTER_STATS_HISTORY_RETENTION</code> procedure of <code>DBMS_STATS</code>. The default value is 31 days, which means that you would be able to restore the optimizer statistics to any time in last 31 days.</p>
<p>Automatic purging is enabled when <code>STATISTICS_LEVEL</code> parameter is set to <code>TYPICAL</code> or <code>ALL</code>. If automatic purging is disabled, then you must purge the old versions of statistics manually using the <code>PURGE_STATS</code> procedure.</p>
<p>The other <code>DBMS_STATS</code> procedures related to restoring and purging statistics include:</p>
<ul>
<li>
<p><code>PURGE_STATS</code>: This procedure can manually purge old versions beyond a time stamp.</p>
</li>
<li>
<p><code>GET_STATS_HISTORY_RETENTION</code>: This function can get the current statistics history retention value.</p>
</li>
<li>
<p><code>GET_STATS_HISTORY_AVAILABILITY</code>: This function gets the oldest time stamp where statistics history is available. Users cannot restore statistics to a time stamp older than the oldest time stamp.</p>
</li>
</ul>
<p><a id="sthref1197"></a>When restoring previous versions of statistics, the following limitations apply:</p>
<ul>
<li>
<p><code>RESTORE</code> procedures cannot restore user-defined statistics.</p>
</li>
<li>
<p>Old versions of statistics are not stored when the <code>ANALYZE</code> command has been used for collecting statistics.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
To remove all rows from a table when using <code>DBMS_STATS</code>, use <code>TRUNCATE</code> instead of dropping and re-creating the same table. When you drop a table, workload information used by the auto-histogram gathering feature and saved statistics history used by the <code>RESTORE_*_STATS</code> procedures is lost. Without this data, these features do not function properly.</div>
</div>
<!-- class="sect2" -->
<a id="i41854"></a>
<div id="PFGRF94753" class="sect2">
<h3 class="sect2"><span class="secnum">13.5.4</span> Exporting and Importing Statistics</h3>
<p><a id="sthref1198"></a>You can export and import statistics from the data dictionary to user-owned tables, enabling you to create multiple versions of statistics for the same schema. You can also copy statistics from one database to another database. You may want to do this to copy the statistics from a production database to a scaled-down test database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Exporting and importing statistics is a distinct concept from the Data Pump Export and Import utilities.</div>
<p>Before exporting statistics, you first need to create a table for holding the statistics. The procedure <code>DBMS_STATS.CREATE_STAT_TABLE</code> creates the statistics table. After table creation, you can export statistics from the data dictionary into the statistics table using the <code>DBMS_STATS.EXPORT_*_STATS</code> procedures. You can then import statistics using the <code>DBMS_STATS.IMPORT_*_STATS</code> procedures.</p>
<p>Note that the optimizer does not use statistics stored in a user-owned table. The only statistics used by the optimizer are the statistics stored in the data dictionary. To have the optimizer use the statistics in a user-owned tables, you must import those statistics into the data dictionary using the statistics import procedures.</p>
<p>To move statistics from one database to another, you must first export the statistics on the first database, then copy the statistics table to the second database, using the Data Pump Export and Import utilities or other mechanisms, and finally import the statistics into the second database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Data Pump <a id="sthref1199"></a>Export and <a id="sthref1200"></a>Import utilities export and import optimizer statistics from the database along with the table. When a column has system-generated names, Original Export does not export statistics with the data, but this restriction does not apply to Data Pump Export.</div>
</div>
<!-- class="sect2" -->
<a id="i41855"></a>
<div id="PFGRF94754" class="sect2">
<h3 class="sect2"><span class="secnum">13.5.5</span> Restoring Statistics Versus Importing or Exporting Statistics</h3>
<p>The functionality for restoring statistics is similar in some respects to the functionality of importing and exporting statistics. In general, use the restore capability when:</p>
<ul>
<li>
<p>You want to recover older versions of the statistics. For example, to restore the optimizer behavior to an earlier date.</p>
</li>
<li>
<p>You want the database to manage the retention and purging of statistics histories.</p>
</li>
</ul>
<p>You should use <code>EXPORT/IMPORT_*_STATS</code> procedures when:</p>
<ul>
<li>
<p>You want to experiment with multiple sets of statistics and change the values back and forth.</p>
</li>
<li>
<p>You want to move the statistics from one database to another database. For example, moving statistics from a production system to a test system.</p>
</li>
<li>
<p>You want to preserve a known set of statistics for a longer period than the desired retention date for restoring statistics.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i41856"></a>
<div id="PFGRF94755" class="sect2">
<h3 class="sect2"><span class="secnum">13.5.6</span> Locking Statistics for a Table or Schema</h3>
<p><a id="sthref1201"></a>Statistics for a table or schema can be locked. After statistics are locked, you can make no modifications to the statistics until the statistics have been unlocked. Locking procedures are useful in a static environment in which you want to guarantee that the statistics never change.</p>
<p>The <code>DBMS_STATS</code> package provides two procedures for locking (<code>LOCK_SCHEMA_STATS</code> and <code>LOCK_TABLE_STATS</code>) and two procedures for unlocking statistics (<code>UNLOCK_SCHEMA_STATS</code> and <code>UNLOCK_TABLE_STATS</code>).</p>
</div>
<!-- class="sect2" -->
<a id="i41857"></a>
<div id="PFGRF94756" class="sect2">
<h3 class="sect2"><span class="secnum">13.5.7</span> Setting Statistics</h3>
<p>You can set table, column, index, and system statistics using the <code>SET_*_STATISTICS</code> procedures. Setting statistics in the manner is not recommended, because inaccurate or inconsistent statistics can lead to poor performance.</p>
</div>
<!-- class="sect2" -->
<a id="i41866"></a>
<div id="PFGRF94761" class="sect2">
<h3 class="sect2"><span class="secnum">13.5.8</span> Handling Missing Statistics</h3>
<p><a id="sthref1202"></a>When Oracle Database encounters a table with missing statistics, by default the database dynamically gathers the statistics needed by the optimizer. However, for certain types of tables, including remote tables and external tables, Oracle Database does not gather dynamic statistics. In these cases and also when dynamic statistics have been disabled, the optimizer uses default values for its statistics, shown in <a href="#g43961">Table 13-8</a> and <a href="#g43983">Table 13-9</a>.</p>
<div id="PFGRF94762" class="tblformal">
<p class="titleintable"><a id="sthref1203"></a><a id="g43961"></a>Table 13-8 Default Table Values When Statistics Are Missing</p>
<table class="cellalignment1686" title="Default Table Values When Statistics Are Missing" summary="This table lists the default table statistics values that Oracle assumes for remote and external tables, or when dynamic sampling is disabled." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t29">Table Statistic</th>
<th class="cellalignment1687" id="r1c2-t29">Default Value Used by Optimizer</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t29" headers="r1c1-t29">
<p><code>Cardinality</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t29 r1c2-t29">
<p>num_of_blocks * (block_size - cache_layer) / avg_row_len</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t29" headers="r1c1-t29">
<p><code>Average row length</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t29 r1c2-t29">
<p>100 bytes</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t29" headers="r1c1-t29">
<p><code>Number of blocks</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t29 r1c2-t29">
<p>100 or actual value based on the extent map</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t29" headers="r1c1-t29">
<p><code>Remote cardinality</code></p>
</td>
<td class="cellalignment1688" headers="r5c1-t29 r1c2-t29">
<p>2000 rows</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r6c1-t29" headers="r1c1-t29">
<p><code>Remote average row length</code></p>
</td>
<td class="cellalignment1688" headers="r6c1-t29 r1c2-t29">
<p>100 bytes</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="PFGRF94763" class="tblformal">
<p class="titleintable"><a id="sthref1204"></a><a id="g43983"></a>Table 13-9 Default Index Values When Statistics Are Missing</p>
<table class="cellalignment1686" title="Default Index Values When Statistics Are Missing" summary="This table lists the default index statistics values that Oracle assumes for remote and external tables, or when dynamic sampling is disabled." dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t30">Index Statistic</th>
<th class="cellalignment1687" id="r1c2-t30">Default Value Used by Optimizer</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t30" headers="r1c1-t30">
<p><code>Levels</code></p>
</td>
<td class="cellalignment1688" headers="r2c1-t30 r1c2-t30">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t30" headers="r1c1-t30">
<p><code>Leaf blocks</code></p>
</td>
<td class="cellalignment1688" headers="r3c1-t30 r1c2-t30">
<p>25</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t30" headers="r1c1-t30">
<p><code>Leaf blocks/key</code></p>
</td>
<td class="cellalignment1688" headers="r4c1-t30 r1c2-t30">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t30" headers="r1c1-t30">
<p><code>Data blocks/key</code></p>
</td>
<td class="cellalignment1688" headers="r5c1-t30 r1c2-t30">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r6c1-t30" headers="r1c1-t30">
<p><code>Distinct keys</code></p>
</td>
<td class="cellalignment1688" headers="r6c1-t30 r1c2-t30">
<p>100</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r7c1-t30" headers="r1c1-t30">
<p><code>Clustering factor</code></p>
</td>
<td class="cellalignment1688" headers="r7c1-t30 r1c2-t30">
<p>800</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i42991"></a>
<div id="PFGRF30101" class="sect1">
<h2 class="sect1"><span class="secnum">13.6</span> Controlling Dynamic Statistics</h2>
<p>By default, Oracle Database automatically gathers <a href="glossary.htm#BGBIBAHD"><span class="xreftitlebold">dynamic statistics</span></a> when optimizer statistics are missing or need augmentation. To obtain the statistics, the database uses <a id="sthref1205"></a>recursive SQL during parsing to scan a small random sample of table blocks.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Dynamic statistics were called <span class="italic">dynamic sampling</span> in previous releases.</div>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDCIACG">Purpose of Dynamic Statistics</a></p>
</li>
<li>
<p><a href="#CHDDCCBG">Dynamic Statistics Concepts</a></p>
</li>
<li>
<p><a href="#CHDBIGII">Setting Dynamic Statistics Levels Manually</a></p>
</li>
<li>
<p><a href="#BEIIGDHJ">Disabling Dynamic Statistics</a></p>
</li>
</ul>
<a id="CHDCIACG"></a>
<div id="PFGRF95254" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.6.1</span> Purpose of Dynamic Statistics</h3>
<p>By augmenting missing or insufficient optimizer statistics, the optimizer can improve plans by making better estimates for predicate selectivity. Dynamic statistics can supplement statistics such as table block counts, applicable index block counts, table cardinalities (estimated number of rows), and relevant join column statistics.</p>
</div>
<!-- class="sect2" -->
<a id="CHDDCCBG"></a>
<div id="PFGRF94759" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.6.2</span> Dynamic Statistics Concepts</h3>
<p>Dynamic statistics are enabled in the database by default. You can disable the feature by setting the initialization parameter <code>OPTIMIZER_DYNAMIC_SAMPLING=0</code>.</p>
<a id="i43032"></a>
<div id="PFGRF94760" class="sect3">
<h4 class="sect3"><span class="secnum">13.6.2.1</span> Dynamic Statistics Levels</h4>
<p><a id="sthref1206"></a>The dynamic statistics level controls both when the database gathers dynamic statistics, and the size of the sample that the optimizer uses to gather the statistics. Set the dynamic statistics level using either the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter or a statement hint.</p>
<p><a id="sthref1207"></a><a href="#BEIEIJDG">Table 13-10</a> describes the dynamic statistics levels. The default level is <code>2</code>. Starting in Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.4), level <code>11</code> enables the database to gather statistics whenever and at whichever level the optimizer deems best.</p>
<div id="PFGRF95292" class="tblruleformal">
<p class="titleintable"><a id="sthref1208"></a><a id="BEIEIJDG"></a>Table 13-10 Dynamic Statistics Levels</p>
<table class="cellalignment1691" title="Dynamic Statistics Levels" summary="Dynamic sampling levels" dir="ltr">
<thead>
<tr class="cellalignment1680">
<th class="cellalignment1687" id="r1c1-t32">Level</th>
<th class="cellalignment1687" id="r1c2-t32">When the Optimizer Uses Dynamic Statistics</th>
<th class="cellalignment1687" id="r1c3-t32">Sample Size (Blocks)</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r2c1-t32" headers="r1c1-t32">
<p>0</p>
</td>
<td class="cellalignment1688" headers="r2c1-t32 r1c2-t32">
<p>Do not use dynamic statistics</p>
</td>
<td class="cellalignment1688" headers="r2c1-t32 r1c3-t32">
<p>n/a</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r3c1-t32" headers="r1c1-t32">
<p>1</p>
</td>
<td class="cellalignment1688" headers="r3c1-t32 r1c2-t32">
<p>Use dynamic statistics for all tables that do not have statistics, but only if the following criteria are met:</p>
<ul>
<li>
<p>There is at least 1 nonpartitioned table in the query that does not have statistics.</p>
</li>
<li>
<p>This table has no indexes.</p>
</li>
<li>
<p>This table has more blocks than the number of blocks that would be used for dynamic statistics of this table.</p>
</li>
</ul>
</td>
<td class="cellalignment1688" headers="r3c1-t32 r1c3-t32">
<p>32</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r4c1-t32" headers="r1c1-t32">
<p>2</p>
</td>
<td class="cellalignment1688" headers="r4c1-t32 r1c2-t32">
<p>Use dynamic statistics if at least one table in the statement has no statistics. This is the default setting.</p>
</td>
<td class="cellalignment1688" headers="r4c1-t32 r1c3-t32">
<p>64</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r5c1-t32" headers="r1c1-t32">
<p>3</p>
</td>
<td class="cellalignment1688" headers="r5c1-t32 r1c2-t32">
<p>Use dynamic statistics if any of the following conditions is true:</p>
<ul>
<li>
<p>The statement meets level 2 criteria.</p>
</li>
<li>
<p>The statement has one or more expressions used in the <code>WHERE</code> clause predicates, for example, <code>WHERE SUBSTR(cust_last_name,1,3)</code>.</p>
</li>
</ul>
</td>
<td class="cellalignment1688" headers="r5c1-t32 r1c3-t32">
<p>64</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r6c1-t32" headers="r1c1-t32">
<p>4</p>
</td>
<td class="cellalignment1688" headers="r6c1-t32 r1c2-t32">
<p>Use dynamic statistics if any of the following conditions is true:</p>
<ul>
<li>
<p>The statement meets level 3 criteria.</p>
</li>
<li>
<p>The statement uses complex predicates (an <code>OR</code> or <code>AND</code> operator between multiple predicates on the same table).</p>
</li>
</ul>
</td>
<td class="cellalignment1688" headers="r6c1-t32 r1c3-t32">
<p>64</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r7c1-t32" headers="r1c1-t32">
<p>5</p>
</td>
<td class="cellalignment1688" headers="r7c1-t32 r1c2-t32">
<p>Use dynamic statistics if the statement meets level 4 criteria.</p>
</td>
<td class="cellalignment1688" headers="r7c1-t32 r1c3-t32">
<p>128</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r8c1-t32" headers="r1c1-t32">
<p>6</p>
</td>
<td class="cellalignment1688" headers="r8c1-t32 r1c2-t32">
<p>Use dynamic statistics if the statement meets level 4 criteria.</p>
</td>
<td class="cellalignment1688" headers="r8c1-t32 r1c3-t32">
<p>256</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r9c1-t32" headers="r1c1-t32">
<p>7</p>
</td>
<td class="cellalignment1688" headers="r9c1-t32 r1c2-t32">
<p>Use dynamic statistics if the statement meets level 4 criteria.</p>
</td>
<td class="cellalignment1688" headers="r9c1-t32 r1c3-t32">
<p>512</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r10c1-t32" headers="r1c1-t32">
<p>8</p>
</td>
<td class="cellalignment1688" headers="r10c1-t32 r1c2-t32">
<p>Use dynamic statistics if the statement meets level 4 criteria.</p>
</td>
<td class="cellalignment1688" headers="r10c1-t32 r1c3-t32">
<p>1024</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r11c1-t32" headers="r1c1-t32">
<p>9</p>
</td>
<td class="cellalignment1688" headers="r11c1-t32 r1c2-t32">
<p>Use dynamic statistics if the statement meets level 4 criteria.</p>
</td>
<td class="cellalignment1688" headers="r11c1-t32 r1c3-t32">
<p>4086</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r12c1-t32" headers="r1c1-t32">
<p>10</p>
</td>
<td class="cellalignment1688" headers="r12c1-t32 r1c2-t32">
<p>Use dynamic statistics if the statement meets level 4 criteria.</p>
</td>
<td class="cellalignment1688" headers="r12c1-t32 r1c3-t32">
<p>All blocks</p>
</td>
</tr>
<tr class="cellalignment1680">
<td class="cellalignment1688" id="r13c1-t32" headers="r1c1-t32">
<p>11</p>
</td>
<td class="cellalignment1688" headers="r13c1-t32 r1c2-t32">
<p>Use dynamic statistics automatically whenever the optimizer deems it necessary.</p>
</td>
<td class="cellalignment1688" headers="r13c1-t32 r1c3-t32">
<p>Automatically determined</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF50913" href="../../server.112/e41084/sql_elements006.htm#SQLRF50913"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about setting the statistics levels with the <code>DYNAMIC_SAMPLING</code> hint</div>
</div>
<!-- class="sect3" -->
<a id="BEIGBBCF"></a>
<div id="PFGRF94757" class="sect3">
<h4 class="sect3"><span class="secnum">13.6.2.2</span> When the Optimizer Uses Dynamic Statistics</h4>
<p>The primary factor in the decision to use dynamic statistics is whether available statistics are sufficient to generate an optimal plan. If statistics are insufficient, then the optimizer uses dynamic statistics.</p>
<p>In general, the optimizer uses default statistics rather than dynamic statistics to compute statistics needed during optimizations on tables, indexes, and columns. The optimizer decides whether to use dynamic statistics based on several factors. For example, the database uses automatic dynamic statistics when the SQL statement uses parallel execution.</p>
<p>The optimizer automatically gathers dynamic statistics in the following cases:</p>
<ul>
<li>
<p>Missing statistics</p>
<p>When tables in a query have no statistics, the optimizer gathers basic statistics on these tables before optimization. Statistics can be missing because the application creates new objects without a follow-up call to <code>DBMS_STATS</code> to gather statistics, or because statistics were locked on an object before statistics were gathered.</p>
<p>In this case, the statistics are not as high-quality or as complete as the statistics gathered using the <code>DBMS_STATS</code> package. This trade-off is made to limit the impact on the compile time of the statement.</p>
</li>
<li>
<p>Stale statistics</p>
<p>Statistics gathered by <code>DBMS_STATS</code> can become out-of-date. Typically, statistics are stale when 10% or more of the rows in the table have changed since the last time statistics were gathered.</p>
</li>
<li>
<p>Insufficient statistics</p>
<p>Statistics can be insufficient whenever the optimizer estimates the selectivity of predicates (filter or join) or the <code>GROUP BY</code> clause without taking into account correlation between columns, skew in the column data distribution, statistics on expressions, and so on.</p>
<p>Extended statistics help the optimizer obtain accurate quality cardinality estimates for complex predicate expressions. The optimizer can use dynamic statistics to compensate for the lack of extended statistics or when it cannot use extended statistics, for example, for non-equality predicates.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The database does not use dynamic statistics for queries that contain the <code>AS OF</code> clause.</div>
<p>Starting in Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.4), the optimizer can automatically decide whether dynamic statistics are useful and which statistics level to use for all SQL statements. The optimizer operates in this way only when the sampling level is explicitly set to <code>11</code> (see <a href="#BEIEIJDG">Table 13-10</a>) either through the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter or a SQL hint.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN10140" href="../../server.112/e40402/initparams167.htm#REFRN10140"><span class="italic">Oracle Database Reference</span></a> to learn about the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBIGII"></a>
<div id="PFGRF95256" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.6.3</span> Setting Dynamic Statistics Levels Manually</h3>
<p>When setting the dynamic statistics level, the best practice is to use <code>ALTER SESSION</code> to set the value for the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter. Determining a systemwide setting that would be beneficial to all SQL statements can be difficult.</p>
<p class="subhead2"><a id="PFGRF95293"></a>Assumptions</p>
<p>This tutorial assumes the following:</p>
<ul>
<li>
<p>You want correct selectivity estimates for the following query, which has <code>WHERE</code> clause predicates on two correlated columns:</p>
<pre>
  SELECT *
  FROM   sh.customers
  WHERE  cust_city='Los Angeles'
  AND    cust_state_province='CA';
</pre></li>
<li>
<p>The preceding query uses serial processing.</p>
</li>
<li>
<p>The <code>sh.customers</code> table contains 932 rows that meet the conditions in the query.</p>
</li>
<li>
<p>You have gathered statistics on the <code>sh.customers</code> table.</p>
</li>
<li>
<p>You created an index on the <code>cust_city</code> and <code>cust_state_province</code> columns.</p>
</li>
<li>
<p>The <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter is set to the default level of <code>2</code>.</p>
</li>
</ul>
<p class="orderedlisttitle">To set the dynamic statistics level manually:&nbsp;</p>
<ol>
<li>
<p>Connect SQL*Plus to the database with the appropriate privileges, and then explain the execution plan as follows:</p>
<pre>
EXPLAIN PLAN FOR
  SELECT *
  FROM   sh.customers
  WHERE  cust_city='Los Angeles'
  AND    cust_state_province='CA';
</pre></li>
<li>
<p>Query the plan as follows:</p>
<pre>
SET LINESIZE 130
SET PAGESIZE 0
SELECT * 
FROM   TABLE(DBMS_XPLAN.DISPLAY);
</pre>
<p>The output appears below (the example has been reformatted to fit on the page):</p>
<pre>
-------------------------------------------------------------------------------
|Id| Operation                   | Name             |Rows|Bytes|Cost | Time   |
-------------------------------------------------------------------------------
| 0| SELECT STATEMENT            |                   | <span class="bold">53</span>| 9593|53(0)|00:00:01|
| 1|  TABLE ACCESS BY INDEX ROWID|CUSTOMERS          | <span class="bold">53</span>| 9593|53(0)|00:00:01|
|*2|   INDEX RANGE SCAN          |CUST_CITY_STATE_IND| <span class="bold">53</span>| 9593| 3(0)|00:00:01|
-------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("CUST_CITY"='Los Angeles' AND "CUST_STATE_PROVINCE"='CA')
</pre>
<p>The columns in the <code>WHERE</code> clause have a real-world correlation, but the optimizer is not aware that Los Angeles is in California and assumes both predicates reduce the number of rows returned. Thus, the table contains 932 rows that meet the conditions, but the optimizer estimates 53, as shown in bold.</p>
<p>If the database had used dynamic statistics for this plan, then the <code>Note</code> section of the plan output would have indicated this fact. The optimizer did not use dynamic statistics because the statement executed serially, standard statistics exist, and the parameter <code>OPTIMIZER_DYNAMIC_SAMPLING</code> is set to the default of <code>2</code>.</p>
</li>
<li>
<p>Set the dynamic statistics level to <code>4</code> in the session using the following statement:</p>
<pre>
ALTER SESSION SET OPTIMIZER_DYNAMIC_SAMPLING=4;
</pre></li>
<li>
<p>Explain the plan again:</p>
<pre>
EXPLAIN PLAN FOR
  SELECT *
  FROM   sh.customers
  WHERE  cust_city='Los Angeles'
  AND    cust_state_province='CA';
</pre>
<p>The new plan shows a more accurate estimate of the number of rows, as shown by the value 932 in bold:</p>
<pre>
PLAN_TABLE_OUTPUT
-------------------------------------------------------------------------------
Plan hash value: 2008213504
 
-------------------------------------------------------------------------------
| Id  | Operation         | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |           |   <span class="bold">932</span> |   271K|   406   (1)| 00:00:05 |
|*  1 |  TABLE ACCESS FULL| CUSTOMERS |   <span class="bold">932</span> |   271K|   406   (1)| 00:00:05 |
-------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter("CUST_CITY"='Los Angeles' AND "CUST_STATE_PROVINCE"='CA')
 
Note
-----
   - <span class="bold">dynamic statistics used for this statement (level=4)</span>
</pre>
<p>The note at the bottom of the plan indicates that the sampling level is <code>4</code>. The additional dynamic statistics made the optimizer aware of the real-world relationship between the <code>cust_city</code> and <code>cust_state_province</code> columns, thereby enabling it to produce a more accurate estimate for the number of rows: 932 rather than 53.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF50913" href="../../server.112/e41084/sql_elements006.htm#SQLRF50913"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about setting sampling levels with the <code>DYNAMIC_SAMPLING</code> hint</p>
</li>
<li>
<p><a class="olink REFRN10140" href="../../server.112/e40402/initparams167.htm#REFRN10140"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn about the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BEIIGDHJ"></a>
<div id="PFGRF95294" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">13.6.4</span> Disabling Dynamic Statistics</h3>
<p><a id="sthref1210"></a>In general, the best practice is not to incur the cost of dynamic statistics for queries whose compile times must be as fast as possible, for example, unrepeated OLTP queries. You can disable the feature by setting the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter.</p>
<p class="orderedlisttitle">To disable dynamic statistics at the session level:&nbsp;</p>
<ol>
<li>
<p>Connect SQL*Plus to the database with the appropriate privileges.</p>
</li>
<li>
<p>Set the dynamic statistics level to <code>0</code>.</p>
<p>For example, run the following statement:</p>
<pre>
ALTER SESSION SET OPTIMIZER_DYNAMIC_SAMPLING=0;
</pre></li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN10140" href="../../server.112/e40402/initparams167.htm#REFRN10140"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn about the <code>OPTIMIZER_DYNAMIC_SAMPLING</code> initialization parameter</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i41506"></a>
<div id="PFGRF94764" class="sect1">
<h2 class="sect1"><span class="secnum">13.7</span> Viewing Statistics</h2>
<p>This section discusses:</p>
<ul>
<li>
<p><a href="#i41587">Statistics on Tables, Indexes and Columns</a></p>
</li>
<li>
<p><a href="#i41591">Viewing Histograms</a></p>
</li>
</ul>
<a id="i41587"></a>
<div id="PFGRF94765" class="sect2">
<h3 class="sect2"><span class="secnum">13.7.1</span> Statistics on Tables, Indexes and Columns<a id="sthref1212"></a><a id="sthref1213"></a><a id="sthref1214"></a></h3>
<p><a id="sthref1215"></a>The database stores statistics on tables, indexes, and columns in the data dictionary. To view statistics in the data dictionary, query the appropriate data dictionary view (<code>USER</code>, <code>ALL</code>, or <code>DBA</code>). These views include the following:</p>
<ul>
<li>
<p><code>DBA_TABLES</code> and <code>DBA_OBJECT_TABLES</code></p>
</li>
<li>
<p><code>DBA_TAB_STATISTICS</code> and <code>DBA_TAB_COL_STATISTICS</code></p>
</li>
<li>
<p><code>DBA_TAB_HISTOGRAMS</code></p>
</li>
<li>
<p><code>DBA_TAB_COLS</code></p>
</li>
<li>
<p><code>DBA_COL_GROUP_COLUMNS</code></p>
</li>
<li>
<p><code>DBA_INDEXES</code> and <code>DBA_IND_STATISTICS</code></p>
</li>
<li>
<p><code>DBA_CLUSTERS</code></p>
</li>
<li>
<p><code>DBA_TAB_PARTITIONS</code> and <code>DBA_TAB_SUBPARTITIONS</code></p>
</li>
<li>
<p><code>DBA_IND_PARTITIONS</code> and <code>DBA_IND_SUBPARTITIONS</code></p>
</li>
<li>
<p><code>DBA_PART_COL_STATISTICS</code></p>
</li>
<li>
<p><code>DBA_PART_HISTOGRAMS</code></p>
</li>
<li>
<p><code>DBA_SUBPART_COL_STATISTICS</code></p>
</li>
<li>
<p><code>DBA_SUBPART_HISTOGRAMS</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> to learn about the statistics in these views</div>
</div>
<!-- class="sect2" -->
<a id="i41591"></a>
<div id="PFGRF30103" class="sect2">
<h3 class="sect2"><span class="secnum">13.7.2</span> Viewing Histograms</h3>
<p>You can store column statistics as <span class="bold">histograms</span>. These histograms provide accurate estimates of the distribution of column data. Histograms provide improved selectivity estimates in the presence of data skew, resulting in optimal execution plans with nonuniform data distributions.</p>
<p>Oracle Database uses the following types of histograms for column statistics:</p>
<ul>
<li>
<p><a href="#BEIBJHBG">Height-Balanced Histograms</a></p>
</li>
<li>
<p><a href="#BEIBFBEB">Frequency Histograms</a></p>
</li>
</ul>
<p>The database stores this type of histogram in the <code>HISTOGRAM</code> column of the <code>*TAB_COL_STATISTICS</code> views (<code>USER</code> and <code>DBA</code>). This column can have values of <code>HEIGHT</code> <code>BALANCED</code>, <code>FREQUENCY</code>, or <code>NONE</code>.</p>
<a id="BEIBJHBG"></a>
<div id="PFGRF94766" class="sect3">
<h4 class="sect3"><span class="secnum">13.7.2.1</span> Height-Balanced Histograms</h4>
<p><a id="sthref1216"></a>In a <span class="bold">height-balanced histogram</span>, the column values are divided into buckets so that each bucket contains approximately the same number of rows. The histogram shows where the endpoints fall in the range of values.</p>
<p>Consider a column <code>my_col</code> with values between 1 and 100 and a histogram with 10 buckets. If the data in <code>my_col</code> is uniformly distributed, then the histogram looks similar to <a href="#i41457">Figure 13-1</a>, where the numbers are the endpoint values. For example, the 7th bucket has rows with values between 60 and 70.</p>
<div id="PFGRF94767" class="figure">
<p class="titleinfigure"><a id="i41457"></a>Figure 13-1 Height-Balanced Histogram with Uniform Distribution</p>
<img width="496" height="40" src="img/pfgrf208.gif" alt="Description of Figure 13-1 follows" /><br />
<a id="sthref1217" href="img_text/pfgrf208.htm">Description of "Figure 13-1 Height-Balanced Histogram with Uniform Distribution"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The number of rows in each bucket is 10% the total number of rows. In this example of uniform distribution, 40% of the rows have values between 60 and 100.</p>
<p>If the data is not uniformly distributed, then the histogram may look like <a href="#i41458">Figure 13-2</a>. In this case, most of the rows have the value 5 for the column. Only 10% of the rows have values between 60 and 100.</p>
<div id="PFGRF94768" class="figure">
<p class="titleinfigure"><a id="i41458"></a>Figure 13-2 Height-Balanced Histogram with Non-Uniform Distribution</p>
<img width="496" height="40" src="img/pfgrf209.gif" alt="Description of Figure 13-2 follows" /><br />
<a id="sthref1218" href="img_text/pfgrf209.htm">Description of "Figure 13-2 Height-Balanced Histogram with Non-Uniform Distribution"</a><br />
<br /></div>
<!-- class="figure" -->
<p>You can view height-balanced histograms using the <code>USER_TAB_HISTOGRAMS</code> table, as shown in <a href="#i41459">Example 13-1</a>.</p>
<div id="PFGRF94769" class="example">
<p class="titleinexample"><a id="i41459"></a>Example 13-1 Viewing Height-Balanced Histogram Statistics</p>
<pre>
BEGIN
  DBMS_STATS.GATHER_table_STATS ( 
    OWNNAME    =&gt; 'OE', 
    TABNAME    =&gt; 'INVENTORIES', 
    METHOD_OPT =&gt; 'FOR COLUMNS SIZE 10 quantity_on_hand' );
END;
/

SELECT COLUMN_NAME, NUM_DISTINCT, NUM_BUCKETS, HISTOGRAM 
FROM   USER_TAB_COL_STATISTICS
WHERE  TABLE_NAME = 'INVENTORIES' AND COLUMN_NAME = 'QUANTITY_ON_HAND';

COLUMN_NAME                    NUM_DISTINCT NUM_BUCKETS HISTOGRAM
------------------------------ ------------ ----------- ---------------
QUANTITY_ON_HAND                        237          10 HEIGHT BALANCED

SELECT ENDPOINT_NUMBER, ENDPOINT_VALUE 
FROM   USER_TAB_HISTOGRAMS
WHERE  TABLE_NAME = 'INVENTORIES' AND COLUMN_NAME = 'QUANTITY_ON_HAND'
ORDER BY ENDPOINT_NUMBER;

ENDPOINT_NUMBER ENDPOINT_VALUE
--------------- --------------
              0              0
              1             27
              2             42
              3             57
              4             74
              5             98
              6            123
              7            149
              8            175
              9            202
             10            353
</pre>
<p>In the <a href="#i41459">Example 13-1</a> query output, one row (1-10) corresponds to each bucket in the histogram. Oracle Database added a special 0th bucket to this histogram because the value in the 1st bucket (27) is not the minimum value for the <code>quantity_on_hand</code> column. The 0th bucket holds the minimum value of 0 for <code>quantity_on_hand</code>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BEIBFBEB"></a>
<div id="PFGRF94770" class="sect3">
<h4 class="sect3"><span class="secnum">13.7.2.2</span> Frequency Histograms</h4>
<p><a id="sthref1219"></a>In a <span class="bold">frequency histogram</span>, each value of the column corresponds to a single bucket of the histogram. Each bucket contains the number of occurrences of this single value. For example, suppose that 36 rows contain the value 1 for column <code>warehouse_id</code>. The endpoint value 1 has an endpoint number 36.</p>
<p>The database automatically creates frequency histograms instead of height-balanced histograms under the following conditions:</p>
<ul>
<li>
<p>The number of distinct values is less than or equal to the number of histogram buckets specified (up to 254).</p>
</li>
<li>
<p>It is <span class="italic">not</span> true that each column value repeats only once.</p>
</li>
</ul>
<p>You can view frequency histograms using the <code>USER_TAB_HISTOGRAMS</code> view, as shown in <a href="#i42645">Example 13-2</a>.</p>
<div id="PFGRF94771" class="example">
<p class="titleinexample"><a id="i42645"></a>Example 13-2 Viewing Frequency Histogram Statistics</p>
<pre>
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS ( 
    OWNNAME    =&gt; 'OE', 
    TABNAME    =&gt; 'INVENTORIES', 
    METHOD_OPT =&gt; 'FOR COLUMNS SIZE 20 warehouse_id' );
END;
/

SELECT COLUMN_NAME, NUM_DISTINCT, NUM_BUCKETS, HISTOGRAM 
FROM   USER_TAB_COL_STATISTICS
WHERE  TABLE_NAME = 'INVENTORIES' AND COLUMN_NAME = 'WAREHOUSE_ID';

COLUMN_NAME                    NUM_DISTINCT NUM_BUCKETS HISTOGRAM
------------------------------ ------------ ----------- ---------------
WAREHOUSE_ID                              9           9 FREQUENCY

SELECT   ENDPOINT_NUMBER, ENDPOINT_VALUE 
FROM     USER_TAB_HISTOGRAMS
WHERE    TABLE_NAME = 'INVENTORIES' AND COLUMN_NAME = 'WAREHOUSE_ID'
ORDER BY ENDPOINT_NUMBER;

ENDPOINT_NUMBER ENDPOINT_VALUE
--------------- --------------
             36              1
            213              2
            261              3
            370              4
            484              5
            692              6
            798              7
            984              8
           1112              9
</pre></div>
<!-- class="example" -->
<p>In <a href="#i42645">Example 13-2</a>, the first bucket is for the <code>warehouse_id</code> of 1. The value appears 36 times in the table, as confirmed by the following query:</p>
<pre>
oe@PROD&gt; SELECT COUNT(*) FROM inventories WHERE warehouse_id = 1;
 
  COUNT(*)
----------
        36
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1679">
<tr>
<td class="cellalignment1688">
<table class="cellalignment1684">
<tr>
<td class="cellalignment1683"><a href="ex_plan.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1683"><a href="data_acc.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2000, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1690">
<table class="cellalignment1682">
<tr>
<td class="cellalignment1683"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1683"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1683"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1683"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1683"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1683"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
