<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Searching Document Sections in Oracle Text</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="dcterms.created" content="2014-02-11T12:39:53Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Text Application Developer's Guide" />
<meta name="dcterms.identifier" content="E24435-03" />
<meta name="dcterms.isVersionOf" content="CCAPP" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2004, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="txtgloss.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="aoptim.htm" title="Previous" type="text/html" />
<link rel="Next" href="search.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e24435.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/21</span> <!-- End Header -->
<div id="CCAPP0800" class="chapter"><a id="g1011230"></a><a id="i1006814"></a>
<h1 class="chapter"><span class="secnum">8</span> Searching Document Sections in Oracle Text</h1>
<p>This chapter describes how to use document sections in an Oracle Text query application.</p>
<p>The following topics are discussed in this chapter:</p>
<ul>
<li>
<p><a href="#i1006204">About Oracle Text Document Section Searching</a></p>
</li>
<li>
<p><a href="#i1006480">HTML Section Searching with Oracle Text</a></p>
</li>
<li>
<p><a href="#i1006515">XML Section Searching with Oracle Text</a></p>
</li>
</ul>
<a id="i1006204"></a>
<div id="CCAPP9284" class="sect1">
<h2 class="sect1"><span class="secnum">8.1</span> About Oracle Text Document Section Searching<a id="sthref702"></a></h2>
<p>Section searching enables you to narrow text queries down to blocks of text within documents. Section searching is useful when your documents have internal structure, such as HTML and XML documents.</p>
<p>You can also search for text at the sentence and paragraph level.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1006209">Enabling Oracle Text Section Searching</a></p>
</li>
<li>
<p><a href="#i1006331">Oracle Text Section Types</a></p>
</li>
</ul>
<a id="i1006209"></a>
<div id="CCAPP9285" class="sect2">
<h3 class="sect2"><span class="secnum">8.1.1</span> Enabling Oracle Text Section Searching<a id="sthref703"></a></h3>
<p>The steps for enabling section searching for your document collection are:</p>
<ol>
<li>
<p>Create a section group</p>
</li>
<li>
<p>Define your sections</p>
</li>
<li>
<p>Index your documents</p>
</li>
<li>
<p>Section search with <code>WITHIN</code>, <code>INPATH</code>, or <code>HASPATH</code> operators</p>
</li>
</ol>
<div id="CCAPP9286" class="sect3"><a id="sthref704"></a>
<h4 class="sect3"><span class="secnum">8.1.1.1</span> Create a Section Group</h4>
<p>Section searching is enabled by defining section groups. You use one of the system-defined section groups to create an instance of a section group. Choose a section group appropriate for your document collection.</p>
<p>You use section groups to specify the type of document set you have and implicitly indicate the tag structure. For instance, to index HTML tagged documents, you use the <code>HTML_SECTION_GROUP</code>. Likewise, to index XML tagged documents, you can use the <code>XML_SECTION_GROUP</code>.</p>
<p><a href="#BABEHHID">Table 8-1</a> lists the different types of section groups you can use:</p>
<div id="CCAPP9514" class="tblformal">
<p class="titleintable"><a id="sthref705"></a><a id="BABEHHID"></a>Table 8-1 Types of Section Groups</p>
<table class="cellalignment117" title="Types of Section Groups" summary="This table shows the various types of section types you can use." dir="ltr">
<thead>
<tr class="cellalignment106">
<th class="cellalignment116" id="r1c1-t2">Section Group Preference</th>
<th class="cellalignment116" id="r1c2-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment106">
<td class="cellalignment112" id="r2c1-t2" headers="r1c1-t2">
<p><code><a id="sthref706"></a>NULL_SECTION_GROUP</code></p>
</td>
<td class="cellalignment112" headers="r2c1-t2 r1c2-t2">
<p>This is the default. Use this group type when you define no sections or when you define <span class="italic">only</span> <code>SENTENCE</code> or <code>PARAGRAPH</code> sections.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r3c1-t2" headers="r1c1-t2">
<p><code><a id="sthref707"></a>BASIC_SECTION_GROUP</code></p>
</td>
<td class="cellalignment112" headers="r3c1-t2 r1c2-t2">
<p>Use this group type for defining sections where the start and end tags are of the form <code>&lt;A&gt;</code> and <code>&lt;/A&gt;</code>.</p>
<p>Note: This group type dopes not support input such as unbalanced parentheses, comments tags, and attributes. Use <code>HTML_SECTION_GROUP</code> for this type of input.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r4c1-t2" headers="r1c1-t2">
<p><code><a id="sthref708"></a><a id="sthref709"></a>HTML_SECTION_GROUP</code></p>
</td>
<td class="cellalignment112" headers="r4c1-t2 r1c2-t2">
<p>Use this group type for indexing HTML documents and for defining sections in HTML documents.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r5c1-t2" headers="r1c1-t2">
<p><code><a id="sthref710"></a>XML_SECTION_GROUP</code></p>
</td>
<td class="cellalignment112" headers="r5c1-t2 r1c2-t2">
<p>Use this group type for indexing XML documents and for defining sections in XML documents.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r6c1-t2" headers="r1c1-t2">
<p><code><a id="sthref711"></a><a id="sthref712"></a>AUTO_SECTION_GROUP</code></p>
</td>
<td class="cellalignment112" headers="r6c1-t2 r1c2-t2">
<p>Use this group type to automatically create a zone section for each start-tag/end-tag pair in an XML document. The section names derived from XML tags are case-sensitive as in XML.</p>
<p>Attribute sections are created automatically for XML tags that have attributes. Attribute sections are named in the form <span class="italic">tag@attribute</span>.</p>
<p>Stop sections, empty tags, processing instructions, and comments are not indexed.</p>
<p>The following limitations apply to automatic section groups:</p>
<ul>
<li>
<p>You cannot add zone, field or special sections to an automatic section group.</p>
</li>
<li>
<p>Automatic sectioning does not index XML document types (root elements.) However, you can define stop-sections with document type.</p>
</li>
<li>
<p>The length of the indexed tags including prefix and namespace cannot exceed 64 bytes. Tags longer than this are not indexed.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r7c1-t2" headers="r1c1-t2">
<p><code>PATH_SECTION_GROUP</code></p>
</td>
<td class="cellalignment112" headers="r7c1-t2 r1c2-t2">
<p>Use this group type to index XML documents. Behaves like the <code>AUTO_SECTION_GROUP</code>.</p>
<p>The difference is that with this section group you can do path searching with the <code>INPATH</code> and <code>HASPATH</code> operators. Queries are also case-sensitive for tag and attribute names.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r8c1-t2" headers="r1c1-t2">
<p><code><a id="sthref713"></a>NEWS_SECTION_GROUP</code></p>
</td>
<td class="cellalignment112" headers="r8c1-t2 r1c2-t2">
<p>Use this group for defining sections in newsgroup formatted documents according to RFC 1036.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Documents sent to the <code>HTML</code>, <code>XML</code>, <code>AUTO</code> and <code>PATH</code> sectioners must begin with <code>\s*&lt;</code>, where <code>\s*</code> represents zero or more whitespace characters. Otherwise, the document is treated as a plaintext document, and no sections are recognized.</div>
<p>You use the <code>CTX_DDL</code> package to create section groups and define sections as part of section groups. For example, to index HTML documents, create a section group with <code>HTML_SECTION_GROUP</code>:</p>
<pre>
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
end;
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9287" class="sect3"><a id="sthref714"></a>
<h4 class="sect3"><span class="secnum">8.1.1.2</span> Define Your Sections</h4>
<p>You define sections as part of the section group. The following example defines an zone section called heading for all text within the HTML &lt; H1&gt; tag:</p>
<pre>
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_zone_section('htmgroup', 'heading', 'H1');
end;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are using the <code>AUTO_SECTION_GROUP</code> or <code>PATH_SECTION_GROUP</code> to index an XML document collection, then you need not explicitly define sections. The system does this for you during indexing.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1006331">"Oracle Text Section Types"</a> for more information about sections</p>
</li>
<li>
<p><a href="#i1006515">"XML Section Searching with Oracle Text"</a> for more information about section searching with XML</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="CCAPP9288" class="sect3"><a id="sthref715"></a>
<h4 class="sect3"><span class="secnum">8.1.1.3</span> Index Your Documents</h4>
<p>When you index your documents, you specify your section group in the parameter clause of <code>CREATE</code> <code>INDEX</code>.</p>
<pre>
create index myindex on docs(htmlfile) indextype is ctxsys.context 
parameters('filter ctxsys.null_filter section group htmgroup');
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9289" class="sect3"><a id="sthref716"></a>
<h4 class="sect3"><span class="secnum">8.1.1.4</span> Section Searching with the WITHIN Operator</h4>
<p>When your documents are indexed, you can query within sections using the <code>WITHIN</code> operator. For example, to find all the documents that contain the word <span class="italic">Oracle</span> within their headings, enter the following query:</p>
<pre>
'Oracle WITHIN heading'
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0330" href="../../text.112/e24436/cqoper.htm#CCREF0330"><span class="italic">Oracle Text Reference</span></a> to learn more about using the <code>WITHIN</code> operator</div>
</div>
<!-- class="sect3" -->
<div id="CCAPP9290" class="sect3"><a id="sthref717"></a>
<h4 class="sect3"><span class="secnum">8.1.1.5</span> Path Searching with INPATH and HASPATH Operators</h4>
<p>When you use the <code>PATH_SECTION_GROUP</code>, the system automatically creates XML sections for you. In addition to using the <code>WITHIN</code> operator to enter queries, you can enter path queries with the <code>INPATH</code> and <code>HASPATH</code> operators.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1006515">"XML Section Searching with Oracle Text"</a> to learn more about using these operators</p>
</li>
<li>
<p><a class="olink CCREF" href="../e24436/toc.htm"><span class="italic">Oracle Text Reference</span></a> to learn more about using the <code>INPATH</code> operator</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006331"></a>
<div id="CCAPP9291" class="sect2">
<h3 class="sect2"><span class="secnum">8.1.2</span> Oracle Text Section Types</h3>
<p>All section types are blocks of text in a document. However, sections can differ in the way that they are delimited and the way that they are recorded in the index. Sections can be one of the following types:</p>
<ul>
<li>
<p><a href="#CACBJEJD">Zone Section</a></p>
</li>
<li>
<p><a href="#CACJHHIH">Field Section</a></p>
</li>
<li>
<p><a href="#BABHHABC">Stop Section</a></p>
</li>
<li>
<p><a href="#CACICBCC">MDATA Section</a></p>
</li>
<li>
<p><a href="#CACBBAIE">SDATA Section</a></p>
</li>
<li>
<p><a href="#CACBFCBB">Attribute Section</a> (for XML documents)</p>
</li>
<li>
<p><a href="#CACEJIHE">Special Sections</a> (sentence or paragraphs)</p>
</li>
</ul>
<p><a href="#CACCGFDE">Table 8-2</a><a id="sthref718"></a><a id="sthref719"></a><a id="sthref720"></a> shows which section types may be used with each kind of section group.</p>
<div id="CCAPP9515" class="tblformalwide">
<p class="titleintable"><a id="sthref721"></a><a id="CACCGFDE"></a>Table 8-2 Section Types and Section Groups</p>
<table class="cellalignment115" title="Section Types and Section Groups" summary="Section Types and Section Groups" dir="ltr">
<thead>
<tr class="cellalignment106">
<th class="cellalignment116" id="r1c1-t8">Section Group</th>
<th class="cellalignment116" id="r1c2-t8">ZONE</th>
<th class="cellalignment116" id="r1c3-t8">FIELD</th>
<th class="cellalignment116" id="r1c4-t8">STOP</th>
<th class="cellalignment116" id="r1c5-t8">MDATA</th>
<th class="cellalignment116" id="r1c6-t8">SDATA</th>
<th class="cellalignment116" id="r1c7-t8">ATTRIBUTE</th>
<th class="cellalignment116" id="r1c8-t8">SPECIAL</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment106">
<td class="cellalignment112" id="r2c1-t8" headers="r1c1-t8">
<p>NULL</p>
</td>
<td class="cellalignment112" headers="r2c1-t8 r1c2-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r2c1-t8 r1c3-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r2c1-t8 r1c4-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r2c1-t8 r1c5-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r2c1-t8 r1c6-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r2c1-t8 r1c7-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r2c1-t8 r1c8-t8">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r3c1-t8" headers="r1c1-t8">
<p>BASIC</p>
</td>
<td class="cellalignment112" headers="r3c1-t8 r1c2-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r3c1-t8 r1c3-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r3c1-t8 r1c4-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r3c1-t8 r1c5-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r3c1-t8 r1c6-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r3c1-t8 r1c7-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r3c1-t8 r1c8-t8">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r4c1-t8" headers="r1c1-t8">
<p>HTML</p>
</td>
<td class="cellalignment112" headers="r4c1-t8 r1c2-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r4c1-t8 r1c3-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r4c1-t8 r1c4-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r4c1-t8 r1c5-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r4c1-t8 r1c6-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r4c1-t8 r1c7-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r4c1-t8 r1c8-t8">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r5c1-t8" headers="r1c1-t8">
<p>XML</p>
</td>
<td class="cellalignment112" headers="r5c1-t8 r1c2-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r5c1-t8 r1c3-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r5c1-t8 r1c4-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r5c1-t8 r1c5-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r5c1-t8 r1c6-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r5c1-t8 r1c7-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r5c1-t8 r1c8-t8">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r6c1-t8" headers="r1c1-t8">
<p>NEWS</p>
</td>
<td class="cellalignment112" headers="r6c1-t8 r1c2-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r6c1-t8 r1c3-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r6c1-t8 r1c4-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r6c1-t8 r1c5-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r6c1-t8 r1c6-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r6c1-t8 r1c7-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r6c1-t8 r1c8-t8">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r7c1-t8" headers="r1c1-t8">
<p>AUTO</p>
</td>
<td class="cellalignment112" headers="r7c1-t8 r1c2-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r7c1-t8 r1c3-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r7c1-t8 r1c4-t8">
<p>YES</p>
</td>
<td class="cellalignment112" headers="r7c1-t8 r1c5-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r7c1-t8 r1c6-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r7c1-t8 r1c7-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r7c1-t8 r1c8-t8">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r8c1-t8" headers="r1c1-t8">
<p>PATH</p>
</td>
<td class="cellalignment112" headers="r8c1-t8 r1c2-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r8c1-t8 r1c3-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r8c1-t8 r1c4-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r8c1-t8 r1c5-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r8c1-t8 r1c6-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r8c1-t8 r1c7-t8">
<p>NO</p>
</td>
<td class="cellalignment112" headers="r8c1-t8 r1c8-t8">
<p>NO</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<a id="CACBJEJD"></a>
<div id="CCAPP9292" class="sect3">
<h4 class="sect3"><span class="secnum">8.1.2.1</span> Zone Section<a id="sthref722"></a><a id="sthref723"></a></h4>
<p>A zone section is a body of text delimited by start and end tags in a document. The positions of the start and end tags are recorded in the index so that any words in between the tags are considered to be within the section. Any instance of a zone section must have a start and an end tag.</p>
<p>For example, the text between the <code>&lt;TITLE&gt;</code> and <code>&lt;/TITLE&gt;</code> tags can be defined as a zone section as follows:</p>
<pre>
&lt;TITLE&gt;Tale of Two Cities&lt;/TITLE&gt;
It was the best of times...
</pre>
<p>Zone sections can nest, overlap, and repeat within a document.</p>
<p>When querying zone sections, you use the <code>WITHIN</code> operator to search for a term across all sections. Oracle Text returns those documents that contain the term within the defined section.</p>
<p>Zone sections are well suited for defining sections in HTML and XML documents. To define a zone section, use <code>CTX_DDL</code>.<code>ADD_ZONE_SECTION</code>.</p>
<p>For example, assume you define the section <code>booktitle</code> as follows:</p>
<pre>
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_zone_section('htmgroup', 'booktitle', 'TITLE');
end;
</pre>
<p>After you index, you can search for all the documents that contain the term <span class="italic">Cities</span> within the section <code>booktitle</code> as follows:</p>
<pre>
'Cities WITHIN booktitle'
</pre>
<p>With multiple query terms such as <span class="italic">(dog and cat) WITHIN booktitle</span>, Oracle Text returns those documents that contain <span class="italic">cat</span> and <span class="italic">dog</span> within the same instance of a <code>booktitle</code> section.</p>
<div id="CCAPP9293" class="sect4"><a id="sthref724"></a>
<h5 class="sect4"><span class="secnum">8.1.2.1.1</span> Repeated Zone Sections<a id="sthref725"></a><a id="sthref726"></a></h5>
<p>Zone sections can repeat. Each occurrence is treated as a separate section. For example, if &lt;H1&gt; denotes a <code>heading</code> section, they can repeat in the same documents as follows:</p>
<pre>
&lt;H1&gt; The Brown Fox &lt;/H1&gt;
&lt;H1&gt; The Gray Wolf &lt;/H1&gt;
</pre>
<p>Assuming that these zone sections are named <code>Heading</code>, the query <span class="italic">Brown WITHIN Heading</span> returns this document. However, a query of <span class="italic">(Brown and Gray) WITHIN Heading</span> does not.</p>
</div>
<!-- class="sect4" -->
<div id="CCAPP9294" class="sect4"><a id="sthref727"></a>
<h5 class="sect4"><span class="secnum">8.1.2.1.2</span> Overlapping Zone Sections<a id="sthref728"></a><a id="sthref729"></a></h5>
<p>Zone sections can overlap each other. For example, if <code>&lt;B&gt;</code> and <code>&lt;I&gt;</code> denote two different zone sections, they can overlap in a document as follows:</p>
<pre>
plain &lt;B&gt; bold &lt;I&gt; bold and italic &lt;/B&gt; only italic &lt;/I&gt;  plain
</pre></div>
<!-- class="sect4" -->
<div id="CCAPP9295" class="sect4"><a id="sthref730"></a>
<h5 class="sect4"><span class="secnum">8.1.2.1.3</span> Nested Zone Sections<a id="sthref731"></a><a id="sthref732"></a><a id="sthref733"></a></h5>
<p>Zone sections can nest, including themselves as follows:</p>
<pre>
&lt;TD&gt; &lt;TABLE&gt;&lt;TD&gt;nested cell&lt;/TD&gt;&lt;/TABLE&gt;&lt;/TD&gt;
</pre>
<p>Using the <code>WITHIN</code> operator, you can write queries to search for text in sections within sections. For example, assume the BOOK1, BOOK2, and AUTHOR zone sections occur as follows in documents doc1 and doc2:</p>
<p>doc1:</p>
<pre>
&lt;book1&gt; &lt;author&gt;Scott Tiger&lt;/author&gt; This is a cool book to read.&lt;/book1&gt;
</pre>
<p>doc2:</p>
<pre>
&lt;book2&gt; &lt;author&gt;Scott Tiger&lt;/author&gt; This is a great book to read.&lt;/book2&gt;
</pre>
<p>Consider the nested query:</p>
<pre>
'(Scott within author) within book1'
</pre>
<p>This query returns only doc1.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CACJHHIH"></a>
<div id="CCAPP9296" class="sect3">
<h4 class="sect3"><span class="secnum">8.1.2.2</span> Field Section<a id="sthref734"></a><a id="sthref735"></a></h4>
<p>A field section is similar to a zone section in that it is a region of text delimited by start and end tags. A field section is different from a zone section in that the region is indexed separately from the rest of the document.</p>
<p>Since field sections are indexed differently, you can also get better query performance over zone sections for when you have a large number of documents indexed.</p>
<p>Field sections are more suited to when you have a single occurrence of a section in a a document such as a field in a news header. Field sections can also be made visible to the rest of the document.</p>
<p>Unlike zone sections, field sections have the following restrictions:</p>
<ul>
<li>
<p>Field sections cannot overlap</p>
</li>
<li>
<p>Field sections cannot repeat</p>
</li>
<li>
<p>Field sections cannot nest</p>
</li>
</ul>
<div id="CCAPP9297" class="sect4"><a id="sthref736"></a>
<h5 class="sect4"><span class="secnum">8.1.2.2.1</span> <a id="sthref737"></a>Visible and Invisible Field Sections</h5>
<p>By default, field sections are indexed as a sub-document separate from the rest of the document. As such, field sections are invisible to the surrounding text and can only be queried by explicitly naming the section in the <code>WITHIN</code> clause.</p>
<p>You can make field sections visible if you want the text within the field section to be indexed as part of the enclosing document. Text within a visible field section can be queried with or without the <code>WITHIN</code> operator.</p>
<p>The following example shows the difference between using invisible and visible field sections.</p>
<p>The following code defines a section group <code>basicgroup</code> of the <code>BASIC_SECTION_GROUP</code> type. It then creates a field section in <code>basicgroup</code> called <code>Author</code> for the <code>&lt;A&gt;</code> tag. It also sets the visible flag to <code>FALSE</code> to create an invisible section:</p>
<pre>
begin
ctx_ddl.create_section_group('basicgroup', 'BASIC_SECTION_GROUP');
ctx_ddl.add_field_section('basicgroup', 'Author', 'A', FALSE);
end;
</pre>
<p>Because the <code>Author</code> field section is not visible, to find text within the <code>Author</code> section, you must use the <code>WITHIN</code> operator as follows:</p>
<pre>
'(Martin Luther King) WITHIN Author'
</pre>
<p>A query of <span class="italic">Martin Luther King</span> without the <code>WITHIN</code> operator does not return instances of this term in field sections. If you want to query text within field sections without specifying <code>WITHIN</code>, you must set the visible flag to <code>TRUE</code> when you create the section as follows:</p>
<pre>
begin
ctx_ddl.add_field_section('basicgroup', 'Author', 'A', TRUE);
end;
</pre></div>
<!-- class="sect4" -->
<div id="CCAPP9298" class="sect4"><a id="sthref738"></a>
<h5 class="sect4"><span class="secnum">8.1.2.2.2</span> <a id="sthref739"></a>Nested Field Sections</h5>
<p>Field sections cannot be nested. For example, if you define a field section to start with <code>&lt;TITLE&gt;</code> and define another field section to start with <code>&lt;FOO&gt;</code>, the two sections <span class="italic">cannot</span> be nested as follows:</p>
<pre>
&lt;TITLE&gt; dog &lt;FOO&gt; cat &lt;/FOO&gt; &lt;/TITLE&gt;
</pre>
<p>To work with nested sections, define them as zone sections.</p>
</div>
<!-- class="sect4" -->
<div id="CCAPP9299" class="sect4"><a id="sthref740"></a>
<h5 class="sect4"><span class="secnum">8.1.2.2.3</span> Repeated Field Sections<a id="sthref741"></a></h5>
<p>Repeated field sections are allowed, but <code>WITHIN</code> queries treat them as a single section. The following is an example of repeated field section in a document:</p>
<pre>
&lt;TITLE&gt; cat &lt;/TITLE&gt;
&lt;TITLE&gt; dog &lt;/TITLE&gt;
</pre>
<p>The query <span class="italic">dog and cat within title</span> returns the document, even though these words occur in different sections.</p>
<p>To have <code>WITHIN</code> queries distinguish repeated sections, define them as zone sections.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABHHABC"></a>
<div id="CCAPP9300" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.1.2.3</span> <a id="sthref742"></a><a id="sthref743"></a>Stop Section</h4>
<p>A stop section may be added to an automatic section group. Adding a stop section causes the automatic section indexing operation to ignore the specified section in XML documents.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Adding a stop section causes no section information to be created in the index. However, the text within a stop section is always searchable.</div>
<p>Adding a stop section is useful when your documents contain many low-information tags. Adding stop sections also improves indexing performance with the automatic section group.</p>
<p>The number of stop sections you can add is unlimited.</p>
<p>Stop sections do not have section names and hence are not recorded in the section views.</p>
</div>
<!-- class="sect3" -->
<a id="CACICBCC"></a>
<div id="CCAPP9301" class="sect3">
<h4 class="sect3"><span class="secnum">8.1.2.4</span> MDATA <a id="sthref744"></a><a id="sthref745"></a><a id="sthref746"></a><a id="sthref747"></a><a id="sthref748"></a><a id="sthref749"></a><a id="sthref750"></a><a id="sthref751"></a><a id="sthref752"></a><a id="sthref753"></a>Section</h4>
<p>An <code>MDATA</code> section is used to reference user-defined metadata for a document. Using <code>MDATA</code> sections can speed up mixed queries.</p>
<p>Consider the case in which you want to query both according to text content and document type (magazine or newspaper or novel). You could create an index with a column for text and a column for the document type, and then perform a mixed query of this form&mdash;in this case, searching for all novels with the phrase <span class="italic">Adam Thorpe</span> (author of the novel <span class="italic">Ulverton</span>):</p>
<pre>
SELECT id FROM documents
   WHERE doctype = 'novel'
      AND CONTAINS(text, 'Adam Thorpe')&gt;0;
</pre>
<p>However, it is usually faster to incorporate the attribute (in this case, the document type) into a field section, rather than use a separate column, and then use a single <code>CONTAINS</code> query:</p>
<pre>
SELECT id FROM documents
  WHERE CONTAINS(text, 'Adam Thorpe AND novel WITHIN doctype')&gt;0;
</pre>
<p>There are two drawbacks to this approach:</p>
<ul>
<li>
<p>Each time the attribute is updated, the entire text document must be re-indexed, resulting in increased index fragmentation and slower rates of processing DML.</p>
</li>
<li>
<p>Field sections tokenize the section value. This has several effects. Special characters in metadata, such as decimal points or currency characters, are not easily searchable; value searching (searching for <span class="italic">Thurston Howell</span> but not <span class="italic">Thurston Howell, Jr.</span>) is difficult; multi-word values are queried by phrase, which is slower than single-token searching; and multi-word values do not show up in browse-words, making author browsing or subject browsing impossible.</p>
</li>
</ul>
<p>For these reasons, using <code>MDATA</code> sections instead of field sections may be worthwhile. <code>MDATA</code> sections are indexed like field sections, but metadata values can be added to and removed from documents without the need to re-index the document text. Unlike field sections, <code>MDATA</code> values are not tokenized. Additionally, <code>MDATA</code> section indexing generally takes up less disk space than field section indexing.</p>
<p>Use <code>CTX_DDL.ADD_MDATA_SECTION</code> to add an <code>MDATA</code> section to a section group. This example adds an <code>MDATA</code> section called <code>AUTHOR</code> and gives it the value <span class="italic">Soseki Natsume</span> (author of the novel <span class="italic">Kokoro</span>).</p>
<pre>
ctx_ddl.create.section.group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_mdata_section('htmgroup', 'author', 'Soseki Natsume');
</pre>
<p><code>MDATA</code> values can be changed with <code>CTX_DDL.ADD_MDATA</code> and removed with <code>CTX_DDL.REMOVE_MDATA</code>. Also, <code>MDATA</code> sections can have multiple values. Only the owner of the index is allowed to call <code>CTX_DDL.ADD_MDATA</code> and <code>CTX_DDL.REMOVE_MDATA</code>.</p>
<p>Neither <code>CTX_DDL.ADD_MDATA</code> nor <code>CTX_DDL.REMOVE_MDATA</code> are supported for <code>CTXCAT</code>, <code>CTXXPTH</code> and <code>CTXRULE</code> indexes.</p>
<p><code>MDATA</code> values are not passed through a lexer. Instead, all values undergo a simplified normalization:</p>
<ul>
<li>
<p>Leading and trailing whitespace on the value is removed.</p>
</li>
<li>
<p>The value is truncated to 64 bytes.</p>
</li>
<li>
<p>The value is indexed as a single value; if the value consists of multiple words, it is not broken up.</p>
</li>
<li>
<p>Case is preserved. If the document is dynamically generated, you can implement case-insensitivity by uppercasing <code>MDATA</code> values and making sure to search only in uppercase.</p>
</li>
</ul>
<p>After a document has had <code>MDATA</code> metadata added to it, you can query for that metadata using the <code>MDATA</code> <code>CONTAINS</code> query operator:</p>
<pre>
SELECT id FROM documents
   WHERE CONTAINS(text, 'Tokyo and MDATA(author, Soseki Natsume)')&gt;0;
</pre>
<p>This query will only be successful if an <code>AUTHOR</code> tag has the exact value <span class="italic">Soseki Natsume</span> (after simplified tokenization). <span class="italic">Soseki</span> or <span class="italic">Natsume Soseki</span> will not work.</p>
<p>Other things to note about <code>MDATA</code>:</p>
<ul>
<li>
<p><code>MDATA</code> values are not highlightable, will not appear in the output of <code>CTX_DOC.TOKENS</code>, and will not show up when <code>FILTER PLAINTEXT</code> is enabled.</p>
</li>
<li>
<p><code>MDATA</code> sections must be unique within section groups. You cannot have an <code>MDATA</code> section named <code>FOO</code> and a zone or field section of the same name in the same section group.</p>
</li>
<li>
<p>Like field sections, <code>MDATA</code> sections cannot overlap or nest. An <code>MDATA</code> section is implicitly closed by the first tag encountered. For instance, in this example:</p>
<pre>
&lt;AUTHOR&gt;Dickens &lt;B&gt;Shelley&lt;/B&gt; Keats&lt;/AUTHOR&gt;
</pre>
<p>The <code>&lt;B&gt;</code> tag closes the <code>AUTHOR</code> <code>MDATA</code> section; as a result, this document has an <code>AUTHOR</code> of 'Dickens', but not of 'Shelley' or 'Keats'.</p>
</li>
<li>
<p>To prevent race conditions, each call to <code>ADD_MDATA</code> and <code>REMOVE_MDATA</code> locks out other calls on that rowid for that index for all values and sections. However, since <code>ADD_MDATA</code> and <code>REMOVE_MDATA</code> do not commit, it is possible for an application to deadlock when calling them both. It is the application's responsibility to prevent deadlocking.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>The <code>CONTAINS</code> query operators chapter of the <a class="olink CCREF0300" href="../../text.112/e24436/cqoper.htm#CCREF0300"><span class="italic">Oracle Text Reference</span></a> for information on the <code>MDATA</code> operator</p>
</li>
<li>
<p>The <code>CTX_DDL</code> package chapter of <a class="olink CCREF0600" href="../../text.112/e24436/cddlpkg.htm#CCREF0600"><span class="italic">Oracle Text Reference</span></a> for information on adding and removing <code>MDATA</code> sections</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref754"></a>
<h4 class="sect3"><span class="secnum">8.1.2.5</span> NDATA Section</h4>
<p>Fields containing data to be indexed for name searching can be specified exclusively by adding <code>NDATA</code> sections to section groups of type: <code>BASIC_SECTION_GROUP</code>, <code>HTML_SECTION_GROUP</code>, or <code>XML_SECTION_GROUP</code>.</p>
<p>Users can synthesize textual documents, which contain name data, using two possible datastores: <code>MULTI_COLUMN_DATASTORE</code> or <code>USER_DATASTORE</code>. The following is an example of using <code>MULTI_COLUMN_DATASTORE</code> to pick up relevant columns containing the name data for indexing:</p>
<pre>
create table people(firstname varchar2(80), surname varchar2(80));
 insert into people values('John', 'Smith');
 commit;
 begin
   ctx_ddl.create_preference('nameds', 'MULTI_COLUMN_DATASTORE');
   ctx_ddl.set_attribute('nameds', 'columns', 'firstname,surname');
 end;
 / 
</pre>
<p>This produces the following virtual text for indexing:</p>
<pre>
&lt;FIRSTNAME&gt;
John
&lt;/FIRSTNAME&gt;
&lt;SURNAME&gt;
Smith
&lt;/SURNAME&gt;
</pre>
<p>You can then create <code>NDATA</code> sections for <code>FIRSTNAME</code> and <code>SURNAME</code> sections:</p>
<pre>
begin
  ctx_ddl.create_section_group('namegroup', 'BASIC_SECTION_GROUP');
  ctx_ddl.add_ndata_section('namegroup', 'FIRSTNAME', 'FIRSTNAME');
  ctx_ddl.add_ndata_section('namegroup', 'SURNAME', 'SURNAME');
end;
/
</pre>
<p>Then create the index using the datastore preference and section group preference created earlier:</p>
<pre>
create index peopleidx on people(firstname) indextype is ctxsys.context
parameters('section group namegroup datastore nameds');
</pre>
<p><code>NDATA</code> sections support both single- and multi-byte data, however, there are character- and term-based limitations. <code>NDATA</code> section data that is indexed is constrained as follows:</p>
<ul>
<li>
<p>the number of characters in a single, white space delimited term</p>
<p>511</p>
</li>
<li>
<p>the number of white space delimited terms</p>
<p>255</p>
</li>
<li>
<p>the total number of characters, including white spaces</p>
<p>511</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CACBBAIE"></a>
<div id="CCAPP9472" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.1.2.6</span> SDATA Section</h4>
<p>The <a id="sthref755"></a><a id="sthref756"></a><a id="sthref757"></a><a id="sthref758"></a><a id="sthref759"></a><a id="sthref760"></a><a id="sthref761"></a><a id="sthref762"></a><a id="sthref763"></a><a id="sthref764"></a>value of an <code>SDATA</code> section is extracted from the document text like other sections, but is indexed as structured data, also referred to as <code>SDATA</code>. Using <code>SDATA</code> sections supports operations such as projection, range searches, and ordering. It also enables <code>SDATA</code> indexing of section data such as embedded tags, and detail table or function invocations. This enables you to perform various combinations of text and structured searches in one single SQL statement.</p>
<p><code>SDATA</code> operators should be used only as descendants of <code>AND</code> operators that also have non-<code>SDATA</code> children. <code>SDATA</code> operators are meant to be used as secondary, checking or non-driving, criteria. For instance, "find documents with DOG that also have price &gt; 5", rather than "find documents with rating &gt; 4". Other uses will operate properly, but may not have optimal performance.</p>
<p>You use <code>CTX_DDL.ADD_SDATA_SECTION</code> to add an <code>SDATA</code> section to a section group. When querying within an <code>SDATA</code> section, you use the <code>CONTAINS</code> operator. The following example creates a table called <code>items</code>, and adds an <code>SDATA</code> section called <code>my_sec_group</code>, and then queries <code>SDATA</code> in the section.</p>
<p>Create the table <code>items</code>:</p>
<pre>
CREATE TABLE items 
(id  NUMBER PRIMARY KEY, 
 doc VARCHAR2(4000));
 
INSERT INTO items VALUES (1, '&lt;description&gt; Honda Pilot &lt;/description&gt;
                              &lt;category&gt; Cars &amp; Trucks &lt;/category&gt;
                              &lt;price&gt; 27000 &lt;/price&gt;');
INSERT INTO items VALUES (2, '&lt;description&gt; Toyota Sequoia &lt;/description&gt;
                              &lt;category&gt; Cars &amp; Trucks &lt;/category&gt;
                              &lt;price&gt; 35000 &lt;/price&gt;');
INSERT INTO items VALUES (3, '&lt;description&gt; Toyota Land Cruiser &lt;/description&gt;
                              &lt;category&gt; Cars &amp; Trucks &lt;/category&gt;
                              &lt;price&gt; 45000 &lt;/price&gt;');
INSERT INTO items VALUES (4, '&lt;description&gt; Palm Pilot &lt;/description&gt;
                              &lt;category&gt; Electronics &lt;/category&gt;
                              &lt;price&gt; 5 &lt;/price&gt;');
INSERT INTO items VALUES (5, '&lt;description&gt; Toyota Land Cruiser Grill &lt;/description&gt;
                              &lt;category&gt; Parts &amp; Accessories &lt;/category&gt;
                              &lt;price&gt; 100 &lt;/price&gt;');
COMMIT;
</pre>
<p>Add <code>SDATA</code> section <code>my_sec_group</code>:</p>
<pre>
BEGIN
  CTX_DDL.CREATE_SECTION_GROUP('my_sec_group', 'BASIC_SECTION_GROUP');
  CTX_DDL.ADD_SDATA_SECTION('my_sec_group', 'category', 'category', 'VARCHAR2');
  CTX_DDL.ADD_SDATA_SECTION('my_sec_group', 'price', 'price', 'NUMBER');
END;
 
</pre>
<p>Create the <code>CONTEXT</code> index:</p>
<pre>
CREATE INDEX items$doc 
  ON items(doc) 
  INDEXTYPE IS CTXSYS.CONTEXT
  PARAMETERS('SECTION GROUP my_sec_group');
 
</pre>
<p>Run a query:</p>
<pre>
SELECT id, doc
  FROM items
  WHERE contains(doc, 'Toyota 
                       AND SDATA(category = ''Cars &amp; Trucks'') 
                       AND SDATA(price &lt;= 40000 )') &gt; 0;
</pre>
<p>Return the results:</p>
<pre>
  ID DOC
---- ----------------------------------------------------------------------
   2 &lt;description&gt; Toyota Sequoia &lt;/description&gt;
                                   &lt;category&gt; Cars &amp; Trucks &lt;/category&gt;
                                   &lt;price&gt; 35000 &lt;/price&gt;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>The <code>CONTAINS</code> query operators chapter of the <a class="olink CCREF0300" href="../../text.112/e24436/cqoper.htm#CCREF0300"><span class="italic">Oracle Text Reference</span></a> for information on the <code>SDATA</code> operator</p>
</li>
<li>
<p>The <code>CTX_DDL</code> package chapter of <a class="olink CCREF0600" href="../../text.112/e24436/cddlpkg.htm#CCREF0600"><span class="italic">Oracle Text Reference</span></a> for information on adding <code>SDATA</code> sections</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CACBFCBB"></a>
<div id="CCAPP9303" class="sect3">
<h4 class="sect3"><span class="secnum">8.1.2.7</span> Attribute Section<a id="sthref765"></a><a id="sthref766"></a></h4>
<p>You can define attribute sections to query on XML attribute text. You can also have the system automatically define and index XML attributes for you.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006515">"XML Section Searching with Oracle Text"</a></div>
</div>
<!-- class="sect3" -->
<a id="CACEJIHE"></a>
<div id="CCAPP9304" class="sect3">
<h4 class="sect3"><span class="secnum">8.1.2.8</span> Special Sections<a id="sthref767"></a><a id="sthref768"></a></h4>
<p>Special sections are not recognized by tags. Currently the only special sections supported are sentence and paragraph. This enables you to search for combination of words within sentences or paragraphs.</p>
<p>The sentence and paragraph boundaries are determined by the lexer. For example, the <code>BASIC_LEXER</code> recognizes sentence and paragraph section boundaries as follows:</p>
<div id="CCAPP9516" class="tblformal">
<p class="titleintable"><a id="sthref769"></a><a id="sthref770"></a>Table 8-3 Sentence and Paragraph Section Boundaries for BASIC_LEXER</p>
<table class="cellalignment117" title="Sentence and Paragraph Section Boundaries for BASIC_LEXER" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment106">
<th class="cellalignment116" id="r1c1-t13">Special Section</th>
<th class="cellalignment116" id="r1c2-t13">Boundary</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment106">
<td class="cellalignment112" id="r2c1-t13" headers="r1c1-t13">
<p>SENTENCE</p>
</td>
<td class="cellalignment112" headers="r2c1-t13 r1c2-t13">
<p>WORD/PUNCT/WHITESPACE</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r3c1-t13" headers="r1c1-t13">&nbsp;</td>
<td class="cellalignment112" headers="r3c1-t13 r1c2-t13">
<p>WORD/PUNCT/NEWLINE</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r4c1-t13" headers="r1c1-t13">
<p>PARAGRAPH</p>
</td>
<td class="cellalignment112" headers="r4c1-t13 r1c2-t13">
<p>WORD/PUNCT/NEWLINE/WHITESPACE</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r5c1-t13" headers="r1c1-t13">&nbsp;</td>
<td class="cellalignment112" headers="r5c1-t13 r1c2-t13">
<p>WORD/PUNCT/NEWLINE/NEWLINE</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>If the lexer cannot recognize the boundaries, no sentence or paragraph sections are indexed.</p>
<p>To add a special section, use the <code>CTX_DDL</code>.<code>ADD_SPECIAL_SECTION</code> procedure. For example, the following code enables searching within sentences within HTML documents:</p>
<pre>
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_special_section('htmgroup', 'SENTENCE');
end;
</pre>
<p>You can also add zone sections to the group to enable zone searching in addition to sentence searching. The following example adds the zone section <code>Headline</code> to the section group <code>htmgroup</code>:</p>
<pre>
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_special_section('htmgroup', 'SENTENCE');
ctx_ddl.add_zone_section('htmgroup', 'Headline', 'H1');
end;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006480"></a>
<div id="CCAPP9305" class="sect1">
<h2 class="sect1"><span class="secnum">8.2</span> HTML Section Searching with Oracle Text</h2>
<p>HTML has internal structure in the form of tagged text which you can use for section searching. For example, you can define a section called headings for the <code>&lt;H1&gt;</code> tag. This enables you to search for terms only within these tags across your document set.</p>
<p>To query, you use the <code>WITHIN</code> operator. Oracle Text returns all documents that contain your query term within the headings section. Thus, if you wanted to find all documents that contain the word oracle within headings, enter the following query:</p>
<pre>
'oracle within headings'
</pre>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#CACECDGC">Creating HTML Sections</a></p>
</li>
<li>
<p><a href="#CACJHBHC">Searching HTML Meta Tags</a></p>
</li>
</ul>
<a id="CACECDGC"></a>
<div id="CCAPP9306" class="sect2">
<h3 class="sect2"><span class="secnum">8.2.1</span> Creating HTML Sections<a id="sthref771"></a><a id="sthref772"></a><a id="sthref773"></a></h3>
<p>The following code defines a section group called <code>htmgroup</code> of type <code>HTML_SECTION_GROUP</code>. It then creates a zone section in <code>htmgroup</code> called <code>heading</code> identified by the &lt;H1&gt; tag:</p>
<pre>
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_zone_section('htmgroup', 'heading', 'H1');
end;
</pre>
<p>You can then index your documents as follows:</p>
<pre>
create index myindex on docs(htmlfile) indextype is ctxsys.context
parameters('filter ctxsys.null_filter section group htmgroup');
</pre>
<p>After indexing with section group <code>htmgroup</code>, you can query within the heading section by issuing a query as follows:</p>
<pre>
'Oracle WITHIN heading'
</pre></div>
<!-- class="sect2" -->
<a id="CACJHBHC"></a>
<div id="CCAPP9307" class="sect2">
<h3 class="sect2"><span class="secnum">8.2.2</span> Searching HTML Meta Tags<a id="sthref774"></a></h3>
<p>With HTML documents you can also create sections for <code>NAME/CONTENT</code> pairs in &lt;META&gt; tags. When you do so you can limit your searches to text within <code>CONTENT</code>.</p>
<div id="CCAPP9308" class="sect3"><a id="sthref775"></a>
<h4 class="sect3"><span class="secnum">8.2.2.1</span> Example: Creating Sections for <code>&lt;META&gt;</code>Tags <a id="sthref776"></a></h4>
<p>Consider an HTML document that has a <code>META</code> tag as follows:</p>
<pre>
&lt;META NAME="author" CONTENT="ken"&gt;
</pre>
<p>To create a zone section that indexes all <code>CONTENT</code> attributes for the <code>META</code> tag whose <code>NAME</code> value is author:</p>
<pre>
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_zone_section('htmgroup', 'author', 'meta@author');
end
</pre>
<p>After indexing with section group <code>htmgroup</code>, you can query the document as follows:</p>
<pre>
'ken WITHIN author'
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006515"></a>
<div id="CCAPP9309" class="sect1">
<h2 class="sect1"><span class="secnum">8.3</span> XML Section Searching with Oracle Text<a id="sthref777"></a></h2>
<p>Like HTML documents, XML documents have tagged text which you can use to define blocks of text for section searching. The contents of a section can be searched on with the <code>WITHIN</code> or <code>INPATH</code> operators.</p>
<p>The following sections describe the different types of XML searching:</p>
<ul>
<li>
<p><a href="#CACGJCJF">Automatic Sectioning</a></p>
</li>
<li>
<p><a href="#i1006529">Attribute Searching</a></p>
</li>
<li>
<p><a href="#CACGHEEB">Creating Document Type Sensitive Sections</a></p>
</li>
<li>
<p><a href="#i1006585">Path Section Searching</a></p>
</li>
</ul>
<a id="CACGJCJF"></a>
<div id="CCAPP9310" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.1</span> Automatic Sectioning<a id="sthref778"></a><a id="sthref779"></a></h3>
<p>You can set up your indexing operation to automatically create sections from XML documents using the section group <code>AUTO_SECTION_GROUP</code>. The system creates zone sections for XML tags. Attribute sections are created for the tags that have attributes and these sections named in the form <code>tag@attribute</code>.</p>
<p>For example, the following statement creates the index <span class="italic">myindex</span> on a column containing the XML files using the <code>AUTO_SECTION_GROUP</code>:</p>
<pre>
CREATE INDEX myindex
ON xmldocs(xmlfile)
 INDEXTYPE IS ctxsys.context
PARAMETERS ('datastore ctxsys.default_datastore 
             filter ctxsys.null_filter 
             section group ctxsys.auto_section_group'
           );
</pre></div>
<!-- class="sect2" -->
<a id="i1006529"></a>
<div id="CCAPP9311" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.2</span> Attribute Searching<a id="sthref780"></a><a id="sthref781"></a></h3>
<p>You can search XML attribute text in one of two ways:</p>
<ul>
<li>
<p>Create attribute sections with <code>CTX_DDL</code>.<code>ADD_ATTR_SECTION</code> and then index with <code>XML_SECTION_GROUP</code>. If you use <code>AUTO_SECTION_GROUP</code> when you index, attribute sections are created automatically. You can query attribute sections with the <code>WITHIN</code> operator.</p>
</li>
<li>
<p>Index with the <code>PATH_SECTION_GROUP</code> and query attribute text with the <code>INPATH</code> operator.</p>
</li>
</ul>
<div id="CCAPP9312" class="sect3"><a id="sthref782"></a>
<h4 class="sect3"><span class="secnum">8.3.2.1</span> Creating Attribute Sections</h4>
<p>Consider an XML file that defines the <code>BOOK</code> tag with a <code>TITLE</code> attribute as follows:</p>
<pre>
&lt;BOOK TITLE="Tale of Two Cities"&gt; 
  It was the best of times. 
&lt;/BOOK&gt; 
</pre>
<p>To define the title attribute as an attribute section, create an <code>XML_SECTION_GROUP</code> and define the attribute section as follows:</p>
<pre>
begin
ctx_ddl.create_section_group('myxmlgroup', 'XML_SECTION_GROUP');
ctx_ddl.add_attr_section('myxmlgroup', 'booktitle', 'book@title');
end;
</pre>
<p>To index:</p>
<pre>
CREATE INDEX myindex
ON xmldocs(xmlfile)
INDEXTYPE IS ctxsys.context
PARAMETERS ('datastore ctxsys.default_datastore 
             filter ctxsys.null_filter 
             section group myxmlgroup'
           );
</pre>
<p>You can query the XML attribute section <span class="italic">booktitle</span> as follows:</p>
<pre>
'Cities within booktitle'
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9313" class="sect3"><a id="sthref783"></a>
<h4 class="sect3"><span class="secnum">8.3.2.2</span> Searching Attributes with the INPATH Operator</h4>
<p>You can search attribute text with the <code>INPATH</code> operator. To do so, you must index your XML document set with the <code>PATH_SECTION_GROUP</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006585">"Path Section Searching"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACGHEEB"></a>
<div id="CCAPP9314" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.3</span> Creating Document Type Sensitive Sections<a id="sthref784"></a></h3>
<p>For an XML document set that contains the <code>&lt;book&gt;</code> tag declared for different document types, you may want to create a distinct book section for each document type. The following scenario shows how to create book sections for each document type to improve search capability.</p>
<p>Assume that <code>mydocname1</code> is declared as an XML document type (root element) as follows:</p>
<pre>
&lt;!DOCTYPE mydocname1 ... [...
</pre>
<p>Within <code>mydocname1</code>, the element <code>&lt;book&gt;</code> is declared. For this tag, you can create a section named <code>mybooksec1</code> that is sensitive to the tag's document type as follows:</p>
<pre>
begin
</pre>
<pre>
ctx_ddl.create_section_group('myxmlgroup', 'XML_SECTION_GROUP');
ctx_ddl.add_zone_section('myxmlgroup', 'mybooksec1', 'mydocname1(book)');
</pre>
<pre>
end;
</pre>
<p>Assume that <code>mydocname2</code> is declared as another XML document type (root element) as follows:</p>
<pre>
&lt;!DOCTYPE mydocname2 ... [...
</pre>
<p>Within <code>mydocname2</code>, the element <code>&lt;book&gt;</code> is declared. For this tag, you can create a section named <code>mybooksec2</code> that is sensitive to the tag's document type as follows:</p>
<pre>
begin
</pre>
<pre>
ctx_ddl.create_section_group('myxmlgroup', 'XML_SECTION_GROUP');
ctx_ddl.add_zone_section('myxmlgroup', 'mybooksec2', 'mydocname2(book)');
</pre>
<pre>
end;
</pre>
<p>To query within the section mybooksec1, use <code>WITHIN</code> as follows:</p>
<pre>
'oracle within mybooksec1'
</pre></div>
<!-- class="sect2" -->
<a id="i1006585"></a>
<div id="CCAPP9315" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.4</span> Path Section Searching<a id="sthref785"></a><a id="sthref786"></a><a id="sthref787"></a><a id="sthref788"></a></h3>
<p>XML documents can have parent-child tag structures such as:</p>
<pre>
&lt;A&gt; &lt;B&gt; &lt;C&gt; dog &lt;/C&gt; &lt;/B&gt; &lt;/A&gt;
</pre>
<p>In this scenario, tag C is a child of tag B which is a child of tag A.</p>
<p>With Oracle Text, you can do path searching with <code>PATH_SECTION_GROUP</code>. This section group enables you to specify direct parentage in queries, such as to find all documents that contain the term <span class="italic">dog</span> in element C which is a child of element B and so on.</p>
<p>With <code>PATH_SECTION_GROUP</code>, you can also perform attribute value searching and attribute equality testing.</p>
<p>The new operators associated with this feature are</p>
<ul>
<li>
<p><code>INPATH</code></p>
</li>
<li>
<p><code>HASPATH</code></p>
</li>
</ul>
<div id="CCAPP9316" class="sect3"><a id="sthref789"></a>
<h4 class="sect3"><span class="secnum">8.3.4.1</span> Creating an Index with <a id="sthref790"></a>PATH_SECTION_GROUP</h4>
<p>To enable path section searching, index your XML document set with <code>PATH_SECTION_GROUP</code>. For example:</p>
<p>Create the preference.</p>
<pre>
begin
ctx_ddl.create_section_group('xmlpathgroup', 'PATH_SECTION_GROUP');
end;
</pre>
<p>Create the index.</p>
<pre>
CREATE INDEX myindex
ON xmldocs(xmlfile)
INDEXTYPE IS ctxsys.context
PARAMETERS ('datastore ctxsys.default_datastore 
             filter ctxsys.null_filter 
             section group xmlpathgroup'
           );
</pre>
<pre>
</pre>
<p>When you create the index, you can use the <code>INPATH</code> and <code>HASPATH</code> operators.</p>
</div>
<!-- class="sect3" -->
<div id="CCAPP9317" class="sect3"><a id="sthref791"></a>
<h4 class="sect3"><span class="secnum">8.3.4.2</span> Top-Level Tag Searching<a id="sthref792"></a></h4>
<p>To find all documents that contain the term <span class="italic">dog</span> in the top-level tag &lt;A&gt;:</p>
<pre>
dog INPATH (/A)
</pre>
<p>or</p>
<pre>
dog INPATH(A)
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9318" class="sect3"><a id="sthref793"></a>
<h4 class="sect3"><span class="secnum">8.3.4.3</span> Any-Level Tag Searching</h4>
<p>To find all documents that contain the term <span class="italic">dog</span> in the &lt;A&gt; tag at any level:</p>
<pre>
dog INPATH(//A)
</pre>
<p>This query finds the following documents:</p>
<pre>
&lt;A&gt;dog&lt;/A&gt;
</pre>
<p>and</p>
<pre>
&lt;C&gt;&lt;B&gt;&lt;A&gt;dog&lt;/A&gt;&lt;/B&gt;&lt;/C&gt;
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9319" class="sect3"><a id="sthref794"></a>
<h4 class="sect3"><span class="secnum">8.3.4.4</span> Direct Parentage Searching</h4>
<p>To find all documents that contain the term <span class="italic">dog</span> in a B element that is a direct child of a top-level A element:</p>
<pre>
dog INPATH(A/B)
</pre>
<p>This query finds the following XML document:</p>
<pre>
&lt;A&gt;&lt;B&gt;My dog is friendly.&lt;/B&gt;&lt;/A&gt;
</pre>
<p>but does not find:</p>
<pre>
&lt;C&gt;&lt;B&gt;My dog is friendly.&lt;/B&gt;&lt;/C&gt;
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9320" class="sect3"><a id="sthref795"></a>
<h4 class="sect3"><span class="secnum">8.3.4.5</span> Tag Value Testing</h4>
<p>You can test the value of tags. For example, the query:</p>
<pre>
dog INPATH(A[B="dog"])
</pre>
<p>Finds the following document:</p>
<pre>
&lt;A&gt;&lt;B&gt;dog&lt;/B&gt;&lt;/A&gt;
</pre>
<p>But does not find:</p>
<pre>
&lt;A&gt;&lt;B&gt;My dog is friendly.&lt;/B&gt;&lt;/A&gt;
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9321" class="sect3"><a id="sthref796"></a>
<h4 class="sect3"><span class="secnum">8.3.4.6</span> Attribute Searching</h4>
<p>You can search the content of attributes. For example, the query:</p>
<pre>
dog INPATH(//A/@B)
</pre>
<p>Finds the document</p>
<pre>
&lt;C&gt;&lt;A  B="snoop dog"&gt; &lt;/A&gt; &lt;/C&gt;
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9322" class="sect3"><a id="sthref797"></a>
<h4 class="sect3"><span class="secnum">8.3.4.7</span> Attribute Value Testing</h4>
<p>You can test the value of attributes. For example, the query</p>
<pre>
California INPATH (//A[@B = "home address"])
</pre>
<p>Finds the document:</p>
<pre>
&lt;A B="home address"&gt;San Francisco, California, USA&lt;/A&gt;
</pre>
<p>But does not find:</p>
<pre>
&lt;A B="work address"&gt;San Francisco, California, USA&lt;/A&gt;
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9323" class="sect3"><a id="sthref798"></a>
<h4 class="sect3"><span class="secnum">8.3.4.8</span> Path Testing<a id="sthref799"></a></h4>
<p>You can test if a path exists with the <code>HASPATH</code> operator. For example, the query:</p>
<pre>
HASPATH(A/B/C)
</pre>
<p>finds and returns a score of 100 for the document</p>
<pre>
&lt;A&gt;&lt;B&gt;&lt;C&gt;dog&lt;/C&gt;&lt;/B&gt;&lt;/A&gt;
</pre>
<p>without the query having to reference <span class="italic">dog</span> at all.</p>
</div>
<!-- class="sect3" -->
<div id="CCAPP9324" class="sect3"><a id="sthref800"></a>
<h4 class="sect3"><span class="secnum">8.3.4.9</span> Section Equality Testing with HASPATH</h4>
<p>You can use the <code>HASPATH</code> operator to do section quality tests. For example, consider the following query:</p>
<pre>
dog INPATH A
</pre>
<p>finds</p>
<pre>
&lt;A&gt;dog&lt;/A&gt;
</pre>
<p>but it also finds</p>
<pre>
&lt;A&gt;dog park&lt;/A&gt;
</pre>
<p>To limit the query to the term <span class="italic">dog</span> and nothing else, you can use a section equality test with the <code>HASPATH</code> operator. For example,</p>
<pre>
HASPATH(A="dog")
</pre>
<p>finds and returns a score of 100 only for the first document, and not the second.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0300" href="../../text.112/e24436/cqoper.htm#CCREF0300"><span class="italic">Oracle Text Reference</span></a> to learn more about using the <code>INPATH</code> and <code>HASPATH</code> operators</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment105">
<tr>
<td class="cellalignment112">
<table class="cellalignment110">
<tr>
<td class="cellalignment109"><a href="aoptim.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment109"><a href="search.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2004, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment114">
<table class="cellalignment108">
<tr>
<td class="cellalignment109"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment109"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment109"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment109"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment109"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment109"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
