<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Querying with Oracle Text</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="dcterms.created" content="2014-02-11T12:39:53Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Text Application Developer's Guide" />
<meta name="dcterms.identifier" content="E24435-03" />
<meta name="dcterms.isVersionOf" content="CCAPP" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2004, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="txtgloss.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="ind.htm" title="Previous" type="text/html" />
<link rel="Next" href="view.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e24435.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/21</span> <!-- End Header -->
<div id="CCAPP0400" class="chapter"><a id="g1016054"></a><a id="i1007836"></a>
<h1 class="chapter"><span class="secnum">4</span> Querying with Oracle Text</h1>
<p>This chapter describes Oracle Text querying and associated features. The following topics are covered:</p>
<ul>
<li>
<p><a href="#BABGAIHJ">Overview of Queries</a></p>
</li>
<li>
<p><a href="#i1006507">The CONTEXT Grammar</a></p>
</li>
<li>
<p><a href="#i1006741">The CTXCAT Grammar</a></p>
</li>
</ul>
<a id="BABGAIHJ"></a>
<div id="CCAPP9135" class="sect1">
<h2 class="sect1"><span class="secnum">4.1</span> Overview of Queries<a id="sthref358"></a></h2>
<p>The basic Oracle Text query takes a query expression, usually a word with or without operators, as input. Oracle Text returns all documents (previously indexed) that satisfy the expression along with a relevance score for each document. Scores can be used to order the documents in the result set.</p>
<p>To enter an Oracle Text query, use the SQL <code>SELECT</code> statement. Depending on the type of index you create, you use either the <code>CONTAINS</code> or <code>CATSEARCH</code> operator in the <code>WHERE</code> clause. You can use these operators programatically wherever you can use the <code>SELECT</code> statement, such as in PL/SQL cursors.</p>
<p>Use the <code>MATCHES</code> operator to classify documents with a <code>CTXRULE</code> index.</p>
<div id="CCAPP9136" class="sect2"><a id="sthref359"></a>
<h3 class="sect2"><span class="secnum">4.1.1</span> Querying with CONTAINS<a id="sthref360"></a><a id="sthref361"></a></h3>
<p>When you create an index of type <code>CONTEXT</code>, you must use the <code>CONTAINS</code> operator to enter your query. An index of type <code>CONTEXT</code> is suited for indexing collections of large coherent documents.</p>
<p>With the <code>CONTAINS</code> operator, you can use a number of operators to define your search criteria. These operators enable you to enter logical, proximity, fuzzy, stemming, thesaurus and wildcard searches. With a correctly configured index, you can also enter section searches on documents that have internal structure such as HTML and XML.</p>
<p>With <code>CONTAINS</code>, you can also use the <code>ABOUT</code> operator to search on document themes.</p>
<div id="CCAPP9137" class="sect3"><a id="sthref362"></a>
<h4 class="sect3"><span class="secnum">4.1.1.1</span> CONTAINS SQL Example<a id="sthref363"></a></h4>
<p>In the <code>SELECT</code> statement, specify the query in the <code>WHERE</code> clause with the <code>CONTAINS</code> operator. Also specify the <code>SCORE</code> operator to return the score of each hit in the hitlist. The following example shows how to enter a query:</p>
<pre>
SELECT SCORE(1), title from news WHERE CONTAINS(text, 'oracle', 1) &gt; 0;
</pre>
<p>You can order the results from the highest scoring documents to the lowest scoring documents using the <code>ORDER</code> <code>BY</code> clause as follows:</p>
<pre>
SELECT SCORE(1), title from news 
           WHERE CONTAINS(text, 'oracle', 1) &gt; 0
           ORDER BY SCORE(1) DESC;
</pre>
<p>The <code>CONTAINS</code> operator must always be followed by the &gt; 0 syntax, which specifies that the score value returned by the <code>CONTAINS</code> operator must be greater than zero for the row to be returned.</p>
<p>When the <code>SCORE</code> operator is called in the <code>SELECT</code> statement, the <code>CONTAINS</code> operator must reference the score label value in the third parameter as in the previous example.</p>
</div>
<!-- class="sect3" -->
<div id="CCAPP9138" class="sect3"><a id="sthref364"></a>
<h4 class="sect3"><span class="secnum">4.1.1.2</span> CONTAINS PL/SQL Example<a id="sthref365"></a></h4>
<p>In a PL/SQL application, you can use a cursor to fetch the results of the query.</p>
<p>The following example enters a <code>CONTAINS</code> query against the <code>NEWS</code> table to find all articles that contain the word <span class="italic">oracle</span>. The titles and scores of the first ten hits are output.</p>
<pre>
declare 
  rowno number := 0; 
begin 
  for c1 in (SELECT SCORE(1) score, title FROM news 
              WHERE CONTAINS(text, 'oracle', 1) &gt; 0
              ORDER BY SCORE(1) DESC) 
  loop 
    rowno := rowno + 1; 
    dbms_output.put_line(c1.title||': '||c1.score); 
    exit when rowno = 10; 
  end loop; 
end; 
</pre>
<p>This example uses a cursor <code>FOR</code> loop to retrieve the first ten hits. An alias <span class="italic">score</span> is declared for the return value of the <code>SCORE</code> operator. The score and title are output to standard out using cursor dot notation.</p>
</div>
<!-- class="sect3" -->
<div id="CCAPP9139" class="sect3"><a id="sthref366"></a>
<h4 class="sect3"><span class="secnum">4.1.1.3</span> Structured Query with CONTAINS<a id="sthref367"></a></h4>
<p>A structured query, also called a mixed query, is a query that has a <code>CONTAINS</code> predicate to query a text column and has another predicate to query a structured data column.</p>
<p>To enter a structured query, you specify the structured clause in the <code>WHERE</code> condition of the <code>SELECT</code> statement.</p>
<p>For example, the following <code>SELECT</code> statement returns all articles that contain the word <span class="italic">oracle</span> that were written on or after October 1, 1997:</p>
<pre>
SELECT SCORE(1), title, issue_date from news 
           WHERE CONTAINS(text, 'oracle', 1) &gt; 0
           AND issue_date &gt;= ('01-OCT-97') 
           ORDER BY SCORE(1) DESC;
</pre>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Even though you can enter structured queries with <code>CONTAINS</code>, consider creating a <code>CTXCAT</code> index and issuing the query with <code>CATSEARCH</code>, which offers better structured query performance.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CCAPP9140" class="sect2"><a id="sthref368"></a>
<h3 class="sect2"><span class="secnum">4.1.2</span> Querying with CATSEARCH<a id="sthref369"></a><a id="sthref370"></a></h3>
<p>When you create an index of type <code>CTXCAT</code>, you must use the <code>CATSEARCH</code> operator to enter your query. An index of type <code>CTXCAT</code> is best suited when your application stores short text fragments in the text column and other associated information in related columns.</p>
<p>For example, an application serving an online auction site might have a table that stores item description in a text column and associated information such as date and price in other columns. With a <code>CTXCAT</code> index, you can create b-tree indexes on one or more of these columns. The result is that when you use the <code>CATSEARCH</code> operator to search a <code>CTXCAT</code> index, query performance is generally faster for mixed queries.</p>
<p>The operators available for <code>CATSEARCH</code> queries are limited to logical operations such as <code>AND</code> or <code>OR</code>. The operators you can use to define your structured criteria are greater than, less than, equality, <code>BETWEEN</code>, and <code>IN</code>.</p>
<div id="CCAPP9141" class="sect3"><a id="sthref371"></a>
<h4 class="sect3"><span class="secnum">4.1.2.1</span> CATSEARCH SQL Query<a id="sthref372"></a><a id="sthref373"></a></h4>
<p>A typical query with <code>CATSEARCH</code> might include a structured clause as follows to find all rows that contain the word <span class="italic">camera</span> ordered by the <code>bid_close</code> date:</p>
<pre>
SELECT FROM auction WHERE CATSEARCH(title, 'camera', 'order by bid_close desc')&gt; 0;
</pre>
<p>The type of structured query you can enter depends on how you create your sub-indexes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ind.htm#i1007263">"Creating a CTXCAT Index"</a></div>
<p>As shown in the previous example, you specify the structured part of a <code>CATSEARCH</code> query with the third <code>structured_query</code> parameter. The columns you name in the structured expression must have a corresponding sub-index.</p>
<p>For example, assuming that <code>category_id</code> and <code>bid_close</code> have a sub-index in the <code>ctxcat</code> index for the <code>AUCTION</code> table, enter the following structured query:</p>
<pre>
SELECT FROM auction WHERE CATSEARCH(title, 'camera', 'category_id=99 order by bid_close desc')&gt; 0;
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9142" class="sect3"><a id="sthref374"></a>
<h4 class="sect3"><span class="secnum">4.1.2.2</span> CATSEARCH Example</h4>
<p>The following example shows a field section search against a <code>CTXCAT</code> index using <code>CONTEXT</code> grammar by means of a query template in a <code>CATSEARCH</code> query.</p>
<pre>
-- Create and populate table
create table BOOKS (ID number, INFO varchar2(200), PUBDATE DATE);
 
insert into BOOKS values(1, '&lt;author&gt;NOAM CHOMSKY&lt;/author&gt;&lt;subject&gt;CIVIL
   RIGHTS&lt;/subject&gt;&lt;language&gt;ENGLISH&lt;/language&gt;&lt;publisher&gt;MIT
   PRESS&lt;/publisher&gt;', '01-NOV-2003');
 
insert into BOOKS values(2, '&lt;author&gt;NICANOR PARRA&lt;/author&gt;&lt;subject&gt;POEMS 
  AND ANTIPOEMS&lt;/subject&gt;&lt;language&gt;SPANISH&lt;/language&gt;
  &lt;publisher&gt;VASQUEZ&lt;/publisher&gt;', '01-JAN-2001');
 
insert into BOOKS values(1, '&lt;author&gt;LUC SANTE&lt;/author&gt;&lt;subject&gt;XML
  DATABASE&lt;/subject&gt;&lt;language&gt;FRENCH&lt;/language&gt;&lt;publisher&gt;FREE
  PRESS&lt;/publisher&gt;', '15-MAY-2002');
 
commit;
 
-- Create index set and section group
exec ctx_ddl.create_index_set('BOOK_INDEX_SET');
exec ctx_ddl.add_index('BOOKSET','PUBDATE');
 
exec ctx_ddl.create_section_group('BOOK_SECTION_GROUP',
      'BASIC_SECTION_GROUP');
exec ctx_ddl.add_field_section('BOOK_SECTION_GROUP','AUTHOR','AUTHOR');
exec ctx_ddl.add_field_section('BOOK_SECTION_GROUP','SUBJECT','SUBJECT');
exec ctx_ddl.add_field_section('BOOK_SECTION_GROUP','LANGUAGE','LANGUAGE');
exec ctx_ddl.add_field_section('BOOK_SECTION_GROUP','PUBLISHER','PUBLISHER'); 
 
-- Create index
create index books_index on books(info) indextype is ctxsys.ctxcat
  parameters('index set book_index_set section group book_section_group');
 
-- Use the index
-- Note that: even though CTXCAT index can be created with field sections, it
-- cannot be accessed using CTXCAT grammar (default for CATSEARCH).
-- We need to use query template with CONTEXT grammar to access field 
-- sections with CATSEARCH
 
select  id, info from books
where catsearch(info,
'&lt;query&gt;
      &lt;textquery grammar="context"&gt;
              NOAM within author and english within language
      &lt;/textquery&gt;
 &lt;/query&gt;',
'order by pubdate')&gt;0; 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007233"></a>
<div id="CCAPP9143" class="sect2">
<h3 class="sect2"><span class="secnum">4.1.3</span> Querying with MATCHES<a id="sthref375"></a><a id="sthref376"></a></h3>
<p>When you create an index of type <code>CTXRULE</code>, you must use the <code>MATCHES</code> operator to classify your documents. The <code>CTXRULE</code> index is essentially an index on the set of queries that define your classifications.</p>
<p>For example, if you have an incoming stream of documents that need to be routed according to content, you can create a set of queries that define your categories. You create the queries as rows in a text column. It is possible to create this type of table with the <code>CTX_CLS.TRAIN</code> procedure.</p>
<p>You then index the table to create a <code>CTXRULE</code> index. When documents arrive, you use the <code>MATCHES</code> operator to classify each document</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="classify.htm#g1011013">Chapter 6, "Classifying Documents in Oracle Text"</a></div>
<div id="CCAPP9144" class="sect3"><a id="sthref377"></a>
<h4 class="sect3"><span class="secnum">4.1.3.1</span> MATCHES SQL Query<a id="sthref378"></a></h4>
<p>A <code>MATCHES</code> query finds all rows in a query table that match a given document. Assuming that a table <code>querytable</code> has a <code>CTXRULE</code> index associated with it, enter the following query:</p>
<pre>
SELECT classification FROM querytable WHERE MATCHES(query_string,:doc_text) &gt; 0;
</pre>
<p>Note the bind variable <code>:doc_text</code> which contains the document <code>CLOB</code> to be classified.</p>
<p>Combining everything into a simple example:</p>
<pre>
   create table queries (
      query_id      number,
      query_string  varchar2(80)
    );

    insert into queries values (1, 'oracle');
    insert into queries values (2, 'larry or ellison');
    insert into queries values (3, 'oracle and text');
    insert into queries values (4, 'market share');

    create index queryx on queries(query_string)
      indextype is ctxsys.ctxrule;

    select query_id from queries
     where matches(query_string, 
                   'Oracle announced that its market share in databases 
                    increased over the last year.')&gt;0
</pre>
<p>This query will return queries 1 (the word <span class="italic">oracle</span> appears in the document) and 4 (the phrase <span class="italic">market share</span> appears in the document), but not 2 (neither the word <span class="italic">larry</span> nor the word <span class="italic">ellison</span> appears, and not 3 (there is no text in the document, so it does not match the query).</p>
<p>Note that, in this example, the document was passed in as a string for simplicity. Typically, your document would be passed in a bind variable.</p>
<p>The document text used in a matches query can be <code>VARCHAR2</code> or <code>CLOB</code>. It does not accept <code>BLOB</code> input, so you cannot match filtered documents directly. Instead, you must filter the binary content to <code>CLOB</code> using the <code>AUTO_FILTER</code> filter. For the following example, we make two assumptions: one, that the document data is in the bind variable <code>:doc_blob</code>; and, two, that we have already defined a policy, <code>my_policy</code>, that <code>CTX_DOC.POLICY_FILTER</code> can use. For example:</p>
<pre>
  declare
    doc_text clob;
  begin
    -- create a temporary CLOB to hold the document text
    doc_text := dbms_lob.createtemporary(doc_text, TRUE, DBMS_LOB.SESSION);
 
    -- create a simple policy for this example
    ctx_ddl.create_preference(preference_name =&gt; 'fast_filter',
                        object_name       =&gt; 'AUTO_FILTER');
    ctx_ddl.set_attribute(preference_name =&gt; 'fast_filter',
                        attribute_name    =&gt; 'OUTPUT_FORMATTING',
                        attribute_value   =&gt; 'FALSE');
    ctx_ddl.create_policy(policy_name     =&gt; 'my_policy',
                        filter            =&gt; 'fast_filter);

    -- call ctx_doc.policy_filter to filter the BLOB to CLOB data
    ctx_doc.policy_filter('my_policy', :doc_blob, doc_text, FALSE);

    -- now do the matches query using the CLOB version
    for c1 in (select * from queries where matches(query_string, doc_text)&gt;0)
    loop
      -- do what you need to do here
    end loop;

    dbms_lob.freetemporary(doc_text);
  end;
</pre>
<p>The procedure <code>CTX_DOC.POLICY_FILTER</code> filters the <code>BLOB</code> into the <code>CLOB</code> data, because you need to get the text into a <code>CLOB</code> to enter a <code>MATCHES</code> query. It takes as one argument the name of a policy you have already created with <code>CTX_DDL.CREATE_POLICY</code>. (See <a class="olink CCREF0700" href="../../text.112/e24436/cdocpkg.htm#CCREF0700"><span class="italic">Oracle Text Reference</span></a> for information on <code>CTX_DOC.POLICY_FILTER</code>.)</p>
<p>If your file is text in the database character set, then you can create a <code>BFILE</code> and load it to a <code>CLOB</code> using the function <code>DBMS_LOB.LOADFROMFILE</code>, or you can use <code>UTL_FILE</code> to read the file into a temp <code>CLOB</code> locator.</p>
<p>If your file needs <code>AUTO_FILTER</code> filtering, then you can load the file into a <code>BLOB</code> instead, and call <code>CTX_DOC.POLICY_FILTER</code>, as previously shown.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="classify.htm#g1011013">Chapter 6, "Classifying Documents in Oracle Text"</a> for more extended classification examples</div>
</div>
<!-- class="sect3" -->
<div id="CCAPP9145" class="sect3"><a id="sthref379"></a>
<h4 class="sect3"><span class="secnum">4.1.3.2</span> MATCHES PL/SQL Example<a id="sthref380"></a></h4>
<p>The following example assumes that the table of queries <code>profiles</code> has a <code>CTXRULE</code> index associated with it. It also assumes that the table <code>newsfeed</code> contains a set of news articles to be categorized.</p>
<p>This example loops through the newsfeed table, categorizing each article using the <code>MATCHES</code> operator. The results are stored in the <code>results</code> table.</p>
<pre>
PROMPT  Populate the category table based on newsfeed articles
PROMPT
set serveroutput on;
declare
  mypk   number;
  mytitle varchar2(1000);
  myarticles clob;
  mycategory varchar2(100);
  cursor doccur is select pk,title,articles from newsfeed;
  cursor mycur is  select category from profiles where matches(rule, myarticles)&gt;0;  
  cursor rescur is select category, pk, title from results order by category,pk;

begin
  dbms_output.enable(1000000);
  open doccur;
  loop
    fetch doccur into mypk, mytitle, myarticles;
    exit when doccur%notfound;
    open mycur;
    loop
      fetch mycur into mycategory;
      exit when mycur%notfound;
      insert into results values(mycategory, mypk, mytitle);
    end loop;
    close mycur;
    commit;
  end loop;
  close doccur;
  commit;

end;
/
</pre>
<p>The following example displays the categorized articles by category.</p>
<pre>
PROMPT  display the list of articles for every category
PROMPT
set serveroutput on;

declare
  mypk   number;
  mytitle varchar2(1000);
  mycategory varchar2(100);
  cursor catcur is select category from profiles order by category;
  cursor rescur is select pk, title from results where category=mycategory order by pk;

begin
  dbms_output.enable(1000000);
  open catcur;
  loop
    fetch catcur into mycategory;
    exit when catcur%notfound;
    dbms_output.put_line('********** CATEGORY: '||mycategory||' *************');
open rescur;
    loop
      fetch rescur into mypk, mytitle;
      exit when rescur%notfound;
dbms_output.put_line('**  ('||mypk||'). '||mytitle);
    end loop;
    close rescur;
    dbms_output.put_line('**');
dbms_output.put_line('*******************************************************');
  end loop;
  close catcur; 
end;
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="classify.htm#g1011013">Chapter 6, "Classifying Documents in Oracle Text"</a> for more extended classification examples</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CCAPP9146" class="sect2"><a id="sthref381"></a>
<h3 class="sect2"><span class="secnum">4.1.4</span> Word and Phrase Queries<a id="sthref382"></a><a id="sthref383"></a></h3>
<p>A word query is a query on a word or phrase. For example, to find all the rows in your text table that contain the word <span class="italic">dog</span>, enter a query specifying <span class="italic">dog</span> as your query term.</p>
<p>You can enter word queries with both <code>CONTAINS</code> and <code>CATSEARCH</code> SQL operators. However, phrase queries are interpreted differently.</p>
<div id="CCAPP9147" class="sect3"><a id="sthref384"></a>
<h4 class="sect3"><span class="secnum">4.1.4.1</span> CONTAINS Phrase Queries</h4>
<p>If multiple words are contained in a query expression, separated only by blank spaces (no operators), the string of words is considered a phrase and Oracle Text searches for the entire string during a query.</p>
<p>For example, to find all documents that contain the phrase <span class="italic">international law</span>, enter your query with the phrase <span class="italic">international law</span>.</p>
</div>
<!-- class="sect3" -->
<div id="CCAPP9148" class="sect3"><a id="sthref385"></a>
<h4 class="sect3"><span class="secnum">4.1.4.2</span> CATSEARCH Phrase Queries</h4>
<p>With the <code>CATSEARCH</code> operator, the <code>AND</code> operator is inserted between words in phrases. For example, a query such as international law is interpreted as <span class="italic">international AND law</span>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CCAPP9149" class="sect2"><a id="sthref386"></a>
<h3 class="sect2"><span class="secnum">4.1.5</span> Querying Stopwords<a id="sthref387"></a></h3>
<p>Stopwords are words for which Oracle Text does not create an index entry. They are usually common words in your language that are unlikely to be searched on by themselves.</p>
<p>Oracle Text includes a default list of stopwords for your language. This list is called a stoplist. For example, in English, the words <span class="italic">this</span> and <span class="italic">that</span> are defined as stopwords in the default stoplist. You can modify the default stoplist or create new stoplists with the <code>CTX_DDL</code> package. You can also add stopwords after indexing with the <code>ALTER INDEX</code> statement.</p>
<p>You cannot query on a stopword by itself or on a phrase composed of only stopwords. For example, a query on the word <span class="italic">this</span> returns no hits when <span class="italic">this</span> is defined as a stopword.</p>
<p>You can query on phrases that contain stopwords as well as non-stopwords such as <span class="italic">this boy talks to that girl</span>. This is possible because the Oracle Text index records the position of stopwords even though it does not create an index entry for them.</p>
<p>When you include a stopword within your query phrase, the stopword matches any word. For example, the query:</p>
<pre>
'Jack was big'
</pre>
<p>matches phrases such as <span class="italic">Jack is big</span> and <span class="italic">Jack grew big</span> assuming <span class="italic">was</span> is a stopword. Note that this query matches grew, even though it is not a stopword.</p>
</div>
<!-- class="sect2" -->
<a id="i1006398"></a>
<div id="CCAPP9150" class="sect2">
<h3 class="sect2"><span class="secnum">4.1.6</span> ABOUT Queries and Themes<a id="sthref388"></a></h3>
<p>An <code>ABOUT</code> query is a query on a document theme. A document theme is a concept that is sufficiently developed in the text. For example, an <code>ABOUT</code> query on <span class="italic">US politics</span> might return documents containing information about US presidential elections and US foreign policy. Documents need not contain the exact phrase <span class="italic">US politics</span> to be returned.</p>
<p>During indexing, document themes are derived from the knowledge base, which is a hierarchical list of categories and concepts that represents a view of the world. Some examples of themes in the knowledge catalog are concrete concepts such as <span class="italic">jazz music</span>, <span class="italic">football</span>, or <span class="italic">Nelson Mandela</span>. Themes can also be abstract concepts such as <span class="italic">happiness</span> or <span class="italic">honesty</span>.</p>
<p>During indexing, the system can also identify and index document themes that are sufficiently developed in the document, but do not exist in the knowledge base.</p>
<p>You can augment the knowledge base to define concepts and terms specific to your industry or query application. When you do so, <code>ABOUT</code> queries are more precise for the added concepts.</p>
<p><code>ABOUT</code> queries perform best when you create a theme component in your index. Theme components are created by default for English and French.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0301" href="../../text.112/e24436/cqoper.htm#CCREF0301"><span class="italic">Oracle Text Reference</span></a></div>
<div id="CCAPP9151" class="sect3"><a id="sthref389"></a>
<h4 class="sect3"><span class="secnum">4.1.6.1</span> Querying Stopthemes<a id="sthref390"></a></h4>
<p>Oracle Text enables you to query on themes with the <code>ABOUT</code> operator. A stoptheme is a theme that is not to be indexed. You can add and remove stopthemes with the <code>CTX_DLL</code> package. You can add stopthemes after indexing with the <code>ALTER INDEX</code> statement.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CCAPP9152" class="sect2"><a id="sthref391"></a>
<h3 class="sect2"><span class="secnum">4.1.7</span> Query Expressions<a id="sthref392"></a></h3>
<p>A query expression is everything in between the single quotes in the <code>text_query</code> argument of the <code>CONTAINS</code> or <code>CATSEARCH</code> operator. What you can include in a query expression in a <code>CONTAINS</code> query is different from what you can include in a <code>CATSEARCH</code> operator.</p>
<div id="CCAPP9153" class="sect3"><a id="sthref393"></a>
<h4 class="sect3"><span class="secnum">4.1.7.1</span> CONTAINS Operators</h4>
<p>A <code>CONTAINS</code> query expression can contain query operators that enable logical, proximity, thesaural, fuzzy, and wildcard searching. Querying with stored expressions is also possible. Within the query expression, you can use grouping characters to alter operator precedence. This book refers to these operators as the <code>CONTEXT</code> grammar.</p>
<p>With <code>CONTAINS</code>, you can also use the <code>ABOUT</code> query to query document themes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006507">"The CONTEXT Grammar"</a></div>
</div>
<!-- class="sect3" -->
<div id="CCAPP9154" class="sect3"><a id="sthref394"></a>
<h4 class="sect3"><span class="secnum">4.1.7.2</span> CATSEARCH Operator</h4>
<p>With the <code>CATSEARCH</code> operator, you specify your query expression with the <code>text_query</code> argument and your optional structured criteria with the <code>structured_query</code> argument. The <code>text_query</code> argument enables you to query words and phrases. You can use logical operations, such as logical and, or, and not. This book refers to these operators as the <code>CTXCAT</code> grammar.</p>
<p>If you want to use the much richer set of operators supported by the <code>CONTEXT</code> grammar, you can use the query template feature with <code>CATSEARCH</code>.</p>
<p>With <code>structured_query</code> argument, you specify your structured criteria. You can use the following SQL operations:</p>
<ul>
<li>
<p><code>=</code></p>
</li>
<li>
<p><code>&lt;=</code></p>
</li>
<li>
<p><code>&gt;=</code></p>
</li>
<li>
<p><code>&gt;</code></p>
</li>
<li>
<p><code>&lt;</code></p>
</li>
<li>
<p><code>IN</code></p>
</li>
<li>
<p><code>BETWEEN</code></p>
</li>
</ul>
<p>You can also use <code>ORDER BY</code> clause to order your output.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006741">"The CTXCAT Grammar"</a></div>
</div>
<!-- class="sect3" -->
<div id="CCAPP9155" class="sect3"><a id="sthref395"></a>
<h4 class="sect3"><span class="secnum">4.1.7.3</span> MATCHES Operator</h4>
<p>Unlike <code>CONTAINS</code> and <code>CATSEARCH</code>, <code>MATCHES</code> does not take a query expression as input.</p>
<p>Instead, the <code>MATCHES</code> operator takes a document as input and finds all rows in a query (rule) table that match it. As such, you can use <code>MATCHES</code> to classify documents according to the rules they match.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007233">"Querying with MATCHES"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CCAPP9156" class="sect2"><a id="sthref396"></a>
<h3 class="sect2"><span class="secnum">4.1.8</span> Case-Sensitive Searching<a id="sthref397"></a><a id="sthref398"></a></h3>
<p>Oracle Text supports case-sensitivity for word and <code>ABOUT</code> queries.</p>
<div id="CCAPP9157" class="sect3"><a id="sthref399"></a>
<h4 class="sect3"><span class="secnum">4.1.8.1</span> Word Queries<a id="sthref400"></a></h4>
<p>Word queries are case-insensitive by default. This means that a query on the term <span class="italic">dog</span> returns the rows in your text table that contain the word <span class="italic">dog</span>, <span class="italic">Dog</span>, or <span class="italic">DOG</span>.</p>
<p>You can enable case-sensitive searching by enabling the <code>mixed_case</code> attribute in your <code>BASIC_LEXER</code> index preference. With a case-sensitive index, your queries must be entered in exact case. This means that a query on <span class="italic">Dog</span> matches only documents with <span class="italic">Dog</span>. Documents with dog or <span class="italic">DOG</span> are not returned as hits.</p>
<div id="CCAPP9158" class="sect4"><a id="sthref401"></a>
<h5 class="sect4"><span class="secnum">4.1.8.1.1</span> <a id="sthref402"></a>Stopwords and Case-Sensitivity</h5>
<p>If you have case-sensitivity enabled for word queries and you enter a query on a phrase containing stopwords and non-stopwords, then you must specify the correct case for the stopwords. For example, a query on <span class="italic">the dog</span> does not return text that contains <span class="italic">The Dog</span>, assuming that <span class="italic">the</span> is a stopword.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="CCAPP9159" class="sect3"><a id="sthref403"></a>
<h4 class="sect3"><span class="secnum">4.1.8.2</span> ABOUT Queries<a id="sthref404"></a><a id="sthref405"></a></h4>
<p><code>ABOUT</code> queries give the best results when your query is formulated with proper case. This is because the normalization of your query is based on the knowledge catalog which is case-sensitive. Attention to case is required especially for words that have different meanings depending on case, such as <span class="italic">turkey</span> the bird and <span class="italic">Turkey</span> the country.</p>
<p>However, you need not enter your query in exact case to obtain relevant results from an <code>ABOUT</code> query. The system does its best to interpret your query. For example, if you enter a query of <code>ORACLE</code> and the system does not find this concept in the knowledge catalog, the system might use <span class="italic">Oracle</span> as a related concept for look-up.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="CCAPP9160" class="sect2"><a id="sthref406"></a>
<h3 class="sect2"><span class="secnum">4.1.9</span> Query Feedback<a id="sthref407"></a><a id="sthref408"></a></h3>
<p>Feedback information provides broader term, narrower term, and related term information for a specified query with a context index. You obtain this information programatically with the <code>CTX_QUERY.HFEEDBACK</code> procedure.</p>
<p>Broader term, narrower term, and related term information is useful for suggesting other query terms to the user in your query application.</p>
<p>The feedback information returned is obtained from the knowledge base and contains only those terms that are also in the index. This increases the chances that terms returned from <code><a id="sthref409"></a>HFEEDBACK</code> produce hits over the currently indexed document set.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0908" href="../../text.112/e24436/cqrypkg.htm#CCREF0908"><span class="italic">Oracle Text Reference</span></a> for more information about using <code>CTX_QUERY.HFEEDBACK</code></div>
</div>
<!-- class="sect2" -->
<div id="CCAPP9161" class="sect2"><a id="sthref410"></a>
<h3 class="sect2"><span class="secnum">4.1.10</span> Query Explain Plan<a id="sthref411"></a><a id="sthref412"></a></h3>
<p>Explain plan information provides a graphical representation of the parse tree for a <code>CONTAINS</code> query expression. You can obtain this information programatically with the <code>CTX_QUERY.EXPLAIN</code> procedure.</p>
<p>Explain plan information tells you how a query is expanded and parsed without having the system execute the query. Obtaining explain information is useful for knowing the expansion for a particular stem, wildcard, thesaurus, fuzzy, soundex, or <code>ABOUT</code> query. Parse trees also show the following information:</p>
<ul>
<li>
<p>Order of execution</p>
</li>
<li>
<p><code>ABOUT</code> query normalization</p>
</li>
<li>
<p>Query expression optimization</p>
</li>
<li>
<p>Stop-word transformations</p>
</li>
<li>
<p>Breakdown of composite-word tokens for supported languages</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0906" href="../../text.112/e24436/cqrypkg.htm#CCREF0906"><span class="italic">Oracle Text Reference</span></a> for more information about using <code>CTX_QUERY.EXPLAIN</code></div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="CCAPP9162" class="sect2"><a id="sthref413"></a>
<h3 class="sect2"><span class="secnum">4.1.11</span> Using a Thesaurus in Queries<a id="sthref414"></a></h3>
<p>Oracle Text enables you to define a thesaurus for your query application.</p>
<p>Defining a custom thesaurus enables you to process queries more intelligently. Because users of your application might not know which words represent a topic, you can define synonyms or narrower terms for likely query terms. You can use the thesaurus operators to expand your query to include thesaurus terms.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cthes.htm#g1009100">Chapter 10, "Working With a Thesaurus in Oracle Text"</a></div>
</div>
<!-- class="sect2" -->
<div id="CCAPP9163" class="sect2"><a id="sthref415"></a>
<h3 class="sect2"><span class="secnum">4.1.12</span> Document Section Searching<a id="sthref416"></a></h3>
<p>Section searching enables you to narrow text queries down to sections within documents.</p>
<p>Section searching can be implemented when your documents have internal structure, such as HTML and XML documents. For example, you can define a section for the &lt;H1&gt; tag that enables you to query within this section using the <code>WITHIN</code> operator.</p>
<p>You can set the system to automatically create sections from XML documents.</p>
<p>You can also define attribute sections to search attribute text in XML documents.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Section searching is supported for only word queries with a <code>CONTEXT</code> index.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="csection.htm#g1011230">Chapter 8, "Searching Document Sections in Oracle Text"</a></div>
</div>
<!-- class="sect2" -->
<div id="CCAPP9164" class="sect2"><a id="sthref417"></a>
<h3 class="sect2"><span class="secnum">4.1.13</span> Using <a id="sthref418"></a>Query Templates</h3>
<p>Query <a id="sthref419"></a>templates are an alternative to the existing query languages. Rather than passing a query string to <code>CONTAINS</code> or <code>CATSEARCH</code>, you pass a structured document that contains the query string in a tagged element. Within this structured document, or query template, you can enable additional query features:</p>
<ul>
<li>
<p><a href="#i1007557">Query Rewrite</a></p>
</li>
<li>
<p><a href="#i1007593">Query Relaxation</a></p>
</li>
<li>
<p><a href="#BABIAHEI">Query Language</a></p>
</li>
<li>
<p><a href="#i1007605">Alternative and User-defined Scoring</a></p>
</li>
<li>
<p><a href="#i1007611">Alternative Grammar</a></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1007557"></a>
<div id="CCAPP9165" class="sect2">
<h3 class="sect2"><span class="secnum">4.1.14</span> Query Rewrite<a id="sthref420"></a><a id="sthref421"></a></h3>
<p>Query applications sometimes parse end user queries, interpreting a query string in one or more ways using different operator combinations. For example, if a user enters a query of <span class="italic">kukui nut</span>, your application might enter the queries <span class="italic">{kukui nut}</span> and <span class="italic">{kukui or nut}</span> to increase recall.</p>
<p>The <a id="sthref422"></a>query rewrite feature enables you to submit a single query that expands the original query into the rewritten versions. The results are returned with no duplication.</p>
<p>You specify your rewrite sequences with the query template feature. The rewritten versions of the query are executed efficiently with a single call to <code>CONTAINS</code> or <code>CATSEARCH</code>.</p>
<p>The following template defines a query rewrite sequence. The query of <span class="italic">{kukui nut}</span> is rewritten as follows:</p>
<p><span class="italic">{kukui} {nut}</span></p>
<p><span class="italic">{kukui} ; {nut}</span></p>
<p><span class="italic">{kukui} AND {nut}</span></p>
<p><span class="italic">{kukui} ACCUM {nut}</span></p>
<p>The <a id="sthref423"></a>query rewrite template for these transformations is as follows:</p>
<pre>
select id from docs where CONTAINS (text,
 '&lt;query&gt;
   &lt;textquery lang="ENGLISH" grammar="CONTEXT"&gt; kukui nut
     &lt;progression&gt;
       &lt;seq&gt;&lt;rewrite&gt;transform((TOKENS, "{", "}", " "))&lt;/rewrite&gt;&lt;/seq&gt;
       &lt;seq&gt;&lt;rewrite&gt;transform((TOKENS, "{", "}", " ; "))&lt;/rewrite&gt;&lt;/seq&gt;
       &lt;seq&gt;&lt;rewrite&gt;transform((TOKENS, "{", "}", "AND"))&lt;/rewrite&gt;&lt;/seq&gt;
       &lt;seq&gt;&lt;rewrite&gt;transform((TOKENS, "{", "}", "ACCUM"))&lt;/rewrite&gt;&lt;/seq&gt;
     &lt;/progression&gt;
   &lt;/textquery&gt;
  &lt;score datatype="INTEGER" algorithm="COUNT"/&gt;
&lt;/query&gt;')&gt;0;
</pre></div>
<!-- class="sect2" -->
<a id="i1007593"></a>
<div id="CCAPP9166" class="sect2">
<h3 class="sect2"><span class="secnum">4.1.15</span> Query Relaxation<a id="sthref424"></a><a id="sthref425"></a></h3>
<p>Query relaxation enables your application to execute the most restrictive version of a query first, progressively relaxing the query until the required number of hits are obtained.</p>
<p>For example, your application might search first on <span class="italic">black pen</span> and then the query is relaxed to <span class="italic">black NEAR pen</span> to obtain more hits.</p>
<p>The following query template defines a query relaxation sequence. The query of <span class="italic">black pen</span> is entered in sequence as the following:</p>
<p><span class="italic">{black} {pen}</span></p>
<p><span class="italic">{black} NEAR {pen}</span></p>
<p><span class="italic">{black} AND {pen}</span></p>
<p><span class="italic">{black} ACCUM {pen}</span></p>
<p>The <a id="sthref426"></a>query relaxation template for these transformations is as follows:</p>
<pre>
select id from docs where CONTAINS (text,
 '&lt;query&gt;
   &lt;textquery lang="ENGLISH" grammar="CONTEXT"&gt;
     &lt;progression&gt;
       &lt;seq&gt;{black} {pen}&lt;/seq&gt;
       &lt;seq&gt;{black} NEAR {pen}&lt;/seq&gt;
       &lt;seq&gt;{black} AND {pen}&lt;/seq&gt;
       &lt;seq&gt;{black} ACCUM {pen}&lt;/seq&gt;
     &lt;/progression&gt;
   &lt;/textquery&gt;
   &lt;score datatype="INTEGER" algorithm="COUNT"/&gt;
&lt;/query&gt;')&gt;0;
</pre>
<p>Query hits are returned in this sequence with no duplication as long as the application needs results.</p>
<p>Query relaxation is most effective when your application needs the top n hits to a query, which you can obtain with the <code>DOMAIN_INDEX_SORT</code> hint, or the <code>FIRST_ROWS</code> hint, which has been deprecated, or in a PL/SQL cursor.</p>
<p>Using query templating to relax a query as such is more efficient than re-executing a query.</p>
</div>
<!-- class="sect2" -->
<a id="BABIAHEI"></a>
<div id="CCAPP9167" class="sect2">
<h3 class="sect2"><span class="secnum">4.1.16</span> Query Language<a id="sthref427"></a></h3>
<p>When you use the multi-lexer to index a column containing documents in different languages, you can specify which language lexer to use during querying. You do so using the <a id="sthref428"></a><code>lang</code> parameter in the query template.</p>
<p>With the <code>MULTI_LEXER</code> in previous releases, you could only change the query language by altering the session language before executing the query.</p>
<pre>
select id from docs where CONTAINS (text,
'&lt;query&gt;&lt;textquery lang="french"&gt;bon soir&lt;/textquery&gt;&lt;/query&gt;')&gt;0;
</pre></div>
<!-- class="sect2" -->
<a id="i1007605"></a>
<div id="CCAPP9168" class="sect2">
<h3 class="sect2"><span class="secnum">4.1.17</span> Alternative and User-defined Scoring<a id="sthref429"></a><a id="sthref430"></a></h3>
<p>You can use query templating to specify <a id="sthref431"></a>alternative scoring algorithms to use, other than the default, to customize how <code>CONTAINS</code> is scored, and to enable <code>SDATA</code> to be used as part of the scoring expressions. In this way, you can mathematically define the scoring expression using not only pre-defined scoring components, but also <code>SDATA</code> components.</p>
<p>With alternative user-defined scoring, you can:</p>
<ul>
<li>
<p>Specify the scoring expressions of terms by defining arithmetic expressions that define how the query should be scored, using</p>
<ul>
<li>
<p>predefined scoring algorithms: <code>DISCRETE</code>, <code>OCCURRENCE</code>, <code>RELEVANCE</code>, and <code>COMPLETION</code>;</p>
</li>
<li>
<p>arithmetic operations: plus, minus, multiply, divide;</p>
</li>
<li>
<p>arithmetic functions: <code>ABS(n)</code>, finding the absolute value of <span class="italic">n</span> ; <code>LOG(n)</code>, finding the base-10 logarithmic value of <span class="italic">n</span>;</p>
</li>
<li>
<p>Numeric literals.</p>
</li>
</ul>
</li>
<li>
<p>Specify the scoring expressions at the term level.</p>
</li>
<li>
<p>Specify terms that should not be taken into account when calculating the score.</p>
</li>
<li>
<p>Specify how the score from child elements of <code>OR</code> and <code>AND</code> operators should be merged.</p>
</li>
<li>
<p>Use <code>SDATA</code> that stores numeric or <code>DATETIME</code> values to affect the final score of the document.</p>
</li>
</ul>
<p>The following example specifies an alternative scoring algorithm:</p>
<pre>
select id from docs where CONTAINS (text,
'&lt;query&gt;        
 &lt;textquery grammar="CONTEXT" lang="english"&gt; mustang  &lt;/textquery&gt;     
 &lt;score datatype="float" algorithm="DEFAULT"/&gt;     
&lt;/query&gt;')&gt;0
</pre>
<p>The following query templating example includes <code>SDATA</code> values as part of the final score:</p>
<pre>
select id from docs where CONTAINS (text,
'&lt;query&gt;
&lt;textquery grammar="CONTEXT" lang="english"&gt; mustang &lt;/textquery&gt;
&lt;score datatype="float" algorithm="DEFAULT" normalization_expr =&rdquo;doc_score+SDATA(price)&rdquo;/&gt;
&lt;/query&gt;')&gt;0"
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CBACAFBD">"Using DEFINESCORE and DEFINEMERGE for User-defined Scoring"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1007611"></a>
<div id="CCAPP9169" class="sect2">
<h3 class="sect2"><span class="secnum">4.1.18</span> Alternative Grammar<a id="sthref432"></a><a id="sthref433"></a></h3>
<p><a id="sthref434"></a>Query templating enables you to use the <code>CONTEXT</code> grammar with <code>CATSEARCH</code> queries and vice-versa.</p>
<pre>
select id from docs where CONTAINS (text,
'&lt;query&gt; 
  &lt;textquery grammar="CTXCAT"&gt;San Diego&lt;/textquery&gt;
  &lt;score datatype="integer"/&gt;
&lt;/query&gt;')&gt;0;
</pre></div>
<!-- class="sect2" -->
<div id="CCAPP9170" class="sect2"><a id="sthref435"></a>
<h3 class="sect2"><span class="secnum">4.1.19</span> <a id="sthref436"></a><a id="sthref437"></a><a id="sthref438"></a><a id="sthref439"></a>Query Analysis</h3>
<p>Oracle Text enables you to create a log of queries and to analyze the queries it contains. For example, suppose you have an application that searches a database of large animals, and your analysis of its queries shows that users are continually searching for the word <span class="italic">mouse</span>; this analysis might induce you to rewrite your application so that a search for <span class="italic">mouse</span> redirects the user to a database of small animals instead of simply returning an unsuccessful search.</p>
<p>With query analysis, you can find out</p>
<ul>
<li>
<p>Which queries were made</p>
</li>
<li>
<p>Which queries were successful</p>
</li>
<li>
<p>Which queries were unsuccessful</p>
</li>
<li>
<p>How many times each query was made</p>
</li>
</ul>
<p>You can combine these factors in various ways, such as determining the 50 most frequent unsuccessful queries made by your application.</p>
<p>You start query logging with <code><a id="sthref440"></a>CTX_OUTPUT.START_QUERY_LOG</code>. The query log will contain all queries made to all context indexes that the program is using until a <code><a id="sthref441"></a>CTX_OUTPUT.END_QUERY_LOG</code> procedure is entered. Use <code><a id="sthref442"></a>CTX_REPORT.QUERY_LOG_SUMMARY</code> to get a report of queries made.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0300" href="../../text.112/e24436/cqoper.htm#CCREF0300"><span class="italic">Oracle Text Reference</span></a> for syntax and examples for these procedures</div>
</div>
<!-- class="sect2" -->
<div id="CCAPP9171" class="sect2"><a id="sthref443"></a>
<h3 class="sect2"><span class="secnum">4.1.20</span> Other Query Features<a id="sthref444"></a></h3>
<p>In your query application, you can use other query features such as proximity searching. <a href="#BABGJEID">Table 4-1</a> lists some of these features.</p>
<div id="CCAPP9503" class="tblformal">
<p class="titleintable"><a id="sthref445"></a><a id="BABGJEID"></a>Table 4-1 Other Oracle Text Query Features</p>
<table class="cellalignment117" title="Other Oracle Text Query Features" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment106">
<th class="cellalignment116" id="r1c1-t18">Feature</th>
<th class="cellalignment116" id="r1c2-t18">Description</th>
<th class="cellalignment116" id="r1c3-t18">Implement With</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment106">
<td class="cellalignment112" id="r2c1-t18" headers="r1c1-t18">
<p>Case Sensitive Searching</p>
</td>
<td class="cellalignment112" headers="r2c1-t18 r1c2-t18">
<p>Enables you to search on words or phrases exactly as entered in the query. For example, a search on <span class="italic">Roman</span> returns documents that contain <span class="italic">Roman</span> and not <span class="italic">roman</span>.</p>
</td>
<td class="cellalignment112" headers="r2c1-t18 r1c3-t18">
<p><code>BASIC_LEXER</code> when you create the index</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r3c1-t18" headers="r1c1-t18">
<p>Base Letter Conversion</p>
</td>
<td class="cellalignment112" headers="r3c1-t18 r1c2-t18">
<p>Queries words with or without diacritical marks such as tildes, accents, and umlauts. For example, with a Spanish base-letter index, a query of <span class="italic">energ&iacute;a</span> matches documents containing both <span class="italic">energ&iacute;a</span> and <span class="italic">energia</span>.</p>
</td>
<td class="cellalignment112" headers="r3c1-t18 r1c3-t18">
<p><code>BASIC_LEXER</code> when you create the index</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r4c1-t18" headers="r1c1-t18">
<p>Word Decompounding</p>
<p>(German and Dutch)</p>
</td>
<td class="cellalignment112" headers="r4c1-t18 r1c2-t18">
<p>Enables searching on words that contain specified term as sub-composite.</p>
</td>
<td class="cellalignment112" headers="r4c1-t18 r1c3-t18">
<p><code>BASIC_LEXER</code> when you create the index</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r5c1-t18" headers="r1c1-t18">
<p>Alternate Spelling</p>
<p>(German, Dutch, and Swedish)</p>
</td>
<td class="cellalignment112" headers="r5c1-t18 r1c2-t18">
<p>Searches on alternate spellings of words.</p>
</td>
<td class="cellalignment112" headers="r5c1-t18 r1c3-t18">
<p><code>BASIC_LEXER</code> when you create the index</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r6c1-t18" headers="r1c1-t18">
<p>Proximity Searching</p>
</td>
<td class="cellalignment112" headers="r6c1-t18 r1c2-t18">
<p>Searches for words near one another.</p>
</td>
<td class="cellalignment112" headers="r6c1-t18 r1c3-t18">
<p><code>NEAR</code> operator when you enter the query</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r7c1-t18" headers="r1c1-t18">
<p>Stemming</p>
</td>
<td class="cellalignment112" headers="r7c1-t18 r1c2-t18">
<p>Searches for words with same root as specified term.</p>
</td>
<td class="cellalignment112" headers="r7c1-t18 r1c3-t18">
<p>$ operator at when you enter the query</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r8c1-t18" headers="r1c1-t18">
<p>Fuzzy Searching</p>
</td>
<td class="cellalignment112" headers="r8c1-t18 r1c2-t18">
<p>Searches for words that have similar spelling to specified term.</p>
</td>
<td class="cellalignment112" headers="r8c1-t18 r1c3-t18">
<p><code>FUZZY</code> operator when you enter the query</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r9c1-t18" headers="r1c1-t18">
<p>Query Explain Plan</p>
</td>
<td class="cellalignment112" headers="r9c1-t18 r1c2-t18">
<p>Generates query parse information.</p>
</td>
<td class="cellalignment112" headers="r9c1-t18 r1c3-t18">
<p><code>CTX_QUERY.EXPLAIN</code> PL/SQL procedure after you index</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r10c1-t18" headers="r1c1-t18">
<p>Hierarchical Query Feedback</p>
</td>
<td class="cellalignment112" headers="r10c1-t18 r1c2-t18">
<p>Generates broader term, narrower term and related term information for a query.</p>
</td>
<td class="cellalignment112" headers="r10c1-t18 r1c3-t18">
<p><code>CTX_QUERY.HFEEDBACK</code> PL/SQL procedure after you index.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r11c1-t18" headers="r1c1-t18">
<p>Browse index</p>
</td>
<td class="cellalignment112" headers="r11c1-t18 r1c2-t18">
<p>Browses the words around a seed word in the index.</p>
</td>
<td class="cellalignment112" headers="r11c1-t18 r1c3-t18">
<p><code>CTX_QUERY.BROWSE_WORDS</code> PL/SQL after you index.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r12c1-t18" headers="r1c1-t18">
<p>Count hits</p>
</td>
<td class="cellalignment112" headers="r12c1-t18 r1c2-t18">
<p>Counts the number of hits in a query.</p>
</td>
<td class="cellalignment112" headers="r12c1-t18 r1c3-t18">
<p><code>CTX_QUERY.COUNT_HITS</code> PL/SQL procedure after you index.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r13c1-t18" headers="r1c1-t18">
<p>Stored Query Expression</p>
</td>
<td class="cellalignment112" headers="r13c1-t18 r1c2-t18">
<p>Stores the text of a query expression for later reuse in another query.</p>
</td>
<td class="cellalignment112" headers="r13c1-t18 r1c3-t18">
<p><code>CTX_QUERY.STORE_SQE</code> PL/SQL procedure after you index.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r14c1-t18" headers="r1c1-t18">
<p>Thesaural Queries</p>
</td>
<td class="cellalignment112" headers="r14c1-t18 r1c2-t18">
<p>Uses a thesaurus to expand queries.</p>
</td>
<td class="cellalignment112" headers="r14c1-t18 r1c3-t18">
<p>Thesaurus operators such as <code>SYN</code> and <code>BT</code> as well as the <code>ABOUT</code> operator.</p>
<p>Use <code>CTX_THES</code> package to maintain thesaurus.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006507"></a>
<div id="CCAPP9172" class="sect1">
<h2 class="sect1"><span class="secnum">4.2</span> The CONTEXT Grammar<a id="sthref446"></a><a id="sthref447"></a><a id="sthref448"></a><a id="sthref449"></a></h2>
<p>The <code>CONTEXT</code> grammar is the default grammar for <code>CONTAINS</code>. With this grammar, you can add complexity to your searches with operators. You use the query operators in your query expression. For example, the logical operator <code>AND</code> enables you to search for all documents that contain two different words. The <code>ABOUT</code> operator enables you to search on concepts.</p>
<p>You can also use the <code>WITHIN</code> operator for section searching, the <code>NEAR</code> operator for proximity searches, the stem, fuzzy, and thesaural operators for expanding a query expression.</p>
<p>With <code>CONTAINS</code>, you can also use the <code>CTXCAT</code> grammar with the query template feature.</p>
<p>The following sections describe some of the Oracle Text operators.</p>
<ul>
<li>
<p><a href="#i1006528">ABOUT Query</a></p>
</li>
<li>
<p><a href="#CBABFFIB">Logical Operators</a></p>
</li>
<li>
<p><a href="#CBABDIIC">Section Searching</a></p>
</li>
<li>
<p><a href="#CBAJIBIB">Proximity Queries with NEAR and NEAR_ACCUM Operators</a></p>
</li>
<li>
<p><a href="#CBACJAFC">Fuzzy, Stem, Soundex, Wildcard and Thesaurus Expansion Operators</a></p>
</li>
<li>
<p><a href="#CBAFCIDI">Using CTXCAT Grammar</a></p>
</li>
<li>
<p><a href="#i1006676">Stored Query Expressions</a></p>
</li>
<li>
<p><a href="#i1006721">Calling PL/SQL Functions in CONTAINS</a></p>
</li>
<li>
<p><a href="#CBACGAIA">Optimizing for Response Time</a></p>
</li>
<li>
<p><a href="#CBAIBFFI">Counting Hits</a></p>
</li>
<li>
<p><a href="#CBACAFBD">Using DEFINESCORE and DEFINEMERGE for User-defined Scoring</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0300" href="../../text.112/e24436/cqoper.htm#CCREF0300"><span class="italic">Oracle Text Reference</span></a> for complete information about using query operators</div>
<a id="i1006528"></a>
<div id="CCAPP9173" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.1</span> ABOUT Query <a id="sthref450"></a><a id="sthref451"></a></h3>
<p>Use the <code>ABOUT</code> operator in English or French to query on a concept. The query string is usually a concept or theme that represents the idea to be searched on. Oracle Text returns the documents that contain the theme.</p>
<p>Word information and theme information are combined into a single index. To enter a theme query, your index must have a theme component which is created by default in English and French.</p>
<p>Enter a theme query using the <code>ABOUT</code> operator inside the query expression. For example, to retrieve all documents that are about <span class="italic">politics</span>, write your query as follows:</p>
<pre>
SELECT SCORE(1), title FROM news 
           WHERE CONTAINS(text, 'about(politics)', 1) &gt; 0
           ORDER BY SCORE(1) DESC;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0301" href="../../text.112/e24436/cqoper.htm#CCREF0301"><span class="italic">Oracle Text Reference</span></a> for more information about using the <code>ABOUT</code> operator</div>
</div>
<!-- class="sect2" -->
<a id="CBABFFIB"></a>
<div id="CCAPP9174" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.2</span> Logical Operators<a id="sthref452"></a><a id="sthref453"></a></h3>
<p>Logical operators such as <code>AND</code> or <code>OR</code> allow you to limit your search criteria in a number of ways. <a href="#BABGJGCB">Table 4-2</a> describes some of these operators.</p>
<div id="CCAPP9504" class="tblformal">
<p class="titleintable"><a id="sthref454"></a><a id="BABGJGCB"></a>Table 4-2 Logical Operators</p>
<table class="cellalignment117" title="Logical Operators" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment106">
<th class="cellalignment116" id="r1c1-t21">Operator</th>
<th class="cellalignment116" id="r1c2-t21">Symbol</th>
<th class="cellalignment116" id="r1c3-t21">Description</th>
<th class="cellalignment116" id="r1c4-t21">Example Expression</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment106">
<td class="cellalignment112" id="r2c1-t21" headers="r1c1-t21">
<p><code><a id="sthref455"></a>AND</code></p>
</td>
<td class="cellalignment112" headers="r2c1-t21 r1c2-t21">
<p>&amp;</p>
</td>
<td class="cellalignment112" headers="r2c1-t21 r1c3-t21">
<p>Use the <code>AND</code> operator to search for documents that contain at least one occurrence of <span class="italic">each</span> of the query terms.</p>
<p>Score returned is the minimum of the operands.</p>
</td>
<td class="cellalignment112" headers="r2c1-t21 r1c4-t21">
<pre>
'cats AND dogs'
'cats &amp; dogs'
</pre></td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r3c1-t21" headers="r1c1-t21">
<p><code><a id="sthref456"></a>OR</code></p>
</td>
<td class="cellalignment112" headers="r3c1-t21 r1c2-t21">
<p>|</p>
</td>
<td class="cellalignment112" headers="r3c1-t21 r1c3-t21">
<p>Use the <code>OR</code> operator to search for documents that contain at least one occurrence of <span class="italic">any</span> of the query terms.</p>
<p>Score returned is the maximum of the operands.</p>
</td>
<td class="cellalignment112" headers="r3c1-t21 r1c4-t21">
<pre>
'cats | dogs'
'cats OR dogs'
</pre></td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r4c1-t21" headers="r1c1-t21">
<p><code><a id="sthref457"></a>NOT</code></p>
</td>
<td class="cellalignment112" headers="r4c1-t21 r1c2-t21">
<p>~</p>
</td>
<td class="cellalignment112" headers="r4c1-t21 r1c3-t21">
<p>Use the <code>NOT</code> operator to search for documents that contain one query term and not another.</p>
</td>
<td class="cellalignment112" headers="r4c1-t21 r1c4-t21">
<p>To obtain the documents that contain the term <span class="italic">animals</span> but not <span class="italic">dogs</span>, use the following expression:</p>
<pre>
'animals ~ dogs'
</pre></td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r5c1-t21" headers="r1c1-t21">
<p><code><a id="sthref458"></a>ACCUM</code></p>
</td>
<td class="cellalignment112" headers="r5c1-t21 r1c2-t21">
<p>,</p>
</td>
<td class="cellalignment112" headers="r5c1-t21 r1c3-t21">
<p>Use the <code>ACCUM</code> operator to search for documents that contain at least one occurrence of any of the query terms. The accumulate operator ranks documents according to the total term weight of a document.</p>
</td>
<td class="cellalignment112" headers="r5c1-t21 r1c4-t21">
<p>The following query returns all documents that contain the terms <span class="italic">dogs, cats</span> and <span class="italic">puppies</span> giving the highest scores to the documents that contain all three terms:</p>
<pre>
'dogs, cats, puppies'
</pre></td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r6c1-t21" headers="r1c1-t21">
<p><code><a id="sthref459"></a>EQUIV</code></p>
</td>
<td class="cellalignment112" headers="r6c1-t21 r1c2-t21">
<p>=</p>
</td>
<td class="cellalignment112" headers="r6c1-t21 r1c3-t21">
<p>Use the <code>EQUIV</code> operator to specify an acceptable substitution for a word in a query.</p>
</td>
<td class="cellalignment112" headers="r6c1-t21 r1c4-t21">
<p>The following example returns all documents that contain either the phrase <span class="italic">alsatians are big dogs</span> or <span class="italic">German shepherds are big dogs</span>:</p>
<pre>
'German shepherds=alsatians are big dogs'
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CBABDIIC"></a>
<div id="CCAPP9175" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.3</span> Section Searching</h3>
<p><a id="sthref460"></a>Section searching is useful for when your document set is HTML or XML. For HTML, you can define sections using embedded tags and then use the <code>WITHIN</code> operator to search these sections.</p>
<p>For XML, you can have the system automatically create sections for you. You can query with the <code>WITHIN</code> operator or with the <code>INPATH</code> operator for path searching.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="csection.htm#g1011230">Chapter 8, "Searching Document Sections in Oracle Text"</a></div>
</div>
<!-- class="sect2" -->
<a id="CBAJIBIB"></a>
<div id="CCAPP9176" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.4</span> Proximity Queries with NEAR and NEAR_ACCUM Operators<a id="sthref461"></a><a id="sthref462"></a></h3>
<p>You can search for terms that are near to one another in a document with the <code>NEAR</code> operator.</p>
<p>For example, to find all documents where <span class="italic">dog</span> is within 6 words of <span class="italic">cat</span>, enter the following query:</p>
<pre>
'near((dog, cat), 6)'
</pre>
<p>The <code>NEAR_ACCUM</code> operator combines the functionality of the <code>NEAR</code> operator with that of the <code>ACCUM</code> operator. Like <code>NEAR</code>, it returns terms that are within a given proximity of each other; however, if one term is not found, it ranks documents according to the frequency of the occurrence of the term that is found.</p>
<p>Oracle Text also supports "mild near" within "mild not." For example:</p>
<pre>
term1 mnot near((term1,term2))
</pre>
<p>This query matches all documents containing the <code>term1</code>, unless the <code>term1</code> is contained in a minimal span defined by the semantics <code>near((term1,term2))</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0313" href="../../text.112/e24436/cqoper.htm#CCREF0313"><span class="italic">Oracle Text Reference</span></a> for more information about using the <code>NEAR</code> and <code>NEAR_ACCUM</code> operators</div>
</div>
<!-- class="sect2" -->
<a id="CBACJAFC"></a>
<div id="CCAPP9177" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.5</span> Fuzzy, Stem, Soundex, Wildcard and Thesaurus Expansion Operators<a id="sthref463"></a><a id="sthref464"></a><a id="sthref465"></a><a id="sthref466"></a></h3>
<p>You can expand your queries into longer word lists with operators such as wildcard, fuzzy, stem, soundex, and thesaurus.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CCREF0300" href="../../text.112/e24436/cqoper.htm#CCREF0300"><span class="italic">Oracle Text Reference</span></a> for more information about using these operators</p>
</li>
<li>
<p><a href="aoptim.htm#i1006663">"Is it OK to have many expansions in a query?"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CBAFCIDI"></a>
<div id="CCAPP9178" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.6</span> Using CTXCAT Grammar<a id="sthref467"></a><a id="sthref468"></a></h3>
<p>You can use the <code>CTXCAT</code> grammar in <code>CONTAINS</code> queries. To do so, use a query template specification in the <code>text_query</code> parameter of <code>CONTAINS</code>.</p>
<p>You might take advantage of the <code>CTXCAT</code> grammar when you need an alternative and simpler query grammar.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0104" href="../../text.112/e24436/csql.htm#CCREF0104"><span class="italic">Oracle Text Reference</span></a> for more information about using these operators</div>
</div>
<!-- class="sect2" -->
<a id="i1006676"></a>
<div id="CCAPP9179" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.7</span> Stored Query Expressions<a id="sthref469"></a><a id="sthref470"></a></h3>
<p>You can use the procedure <code>CTX_QUERY.<a id="sthref471"></a>STORE_SQE</code> to store the definition of a query without storing any results. Referencing the query with the <code>CONTAINS</code> SQL operator references the definition of the query. In this way, stored query expressions make it easy for defining long or frequently used query expressions.</p>
<p>Stored query expressions are not attached to an index. When you call <code>CTX_QUERY.STORE_SQE</code>, you specify only the name of the stored query expression and the query expression.</p>
<p>The query definitions are stored in the Text data dictionary. Any user can reference a stored query expression.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0912" href="../../text.112/e24436/cqrypkg.htm#CCREF0912"><span class="italic">Oracle Text Reference</span></a> to learn more about the syntax of <code>CTX_QUERY.STORE_SQE</code></div>
<div id="CCAPP9180" class="sect3"><a id="sthref472"></a>
<h4 class="sect3"><span class="secnum">4.2.7.1</span> Defining a Stored Query Expression</h4>
<p>You define and use a <a id="sthref473"></a>stored query expression as follows:</p>
<ol>
<li>
<p>Call <code>CTX_QUERY.<a id="sthref474"></a>STORE_SQE</code> to store the queries for the text column. With <code>STORE_SQE</code>, you specify a name for the stored query expression and a query expression.</p>
</li>
<li>
<p>Call the stored query expression in a query expression using the <code>SQE</code> operator. Oracle Text returns the results of the stored query expression in the same way it returns the results of a regular query. The query is evaluated at the time the stored query expression is called.</p>
<p>You can delete a stored query expression using <code><a id="sthref475"></a>REMOVE_SQE</code>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="CCAPP9181" class="sect3"><a id="sthref476"></a>
<h4 class="sect3"><span class="secnum">4.2.7.2</span> SQE Example</h4>
<p>The following example creates a stored query expression called <span class="italic">disaster</span> that searches for documents containing the words <span class="italic">tornado, hurricane</span>, or <span class="italic">earthquake</span>:</p>
<pre>
begin
ctx_query.store_sqe('disaster', 'tornado | hurricane | earthquake');
end;
</pre>
<p>To execute this query in an expression, write your query as follows:</p>
<pre>
SELECT SCORE(1), title from news 
   WHERE CONTAINS(text, 'SQE(disaster)', 1) &gt; 0
   ORDER BY SCORE(1);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0912" href="../../text.112/e24436/cqrypkg.htm#CCREF0912"><span class="italic">Oracle Text Reference</span></a> to learn more about the syntax of <code>CTX_QUERY.STORE_SQE</code></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006721"></a>
<div id="CCAPP9182" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.8</span> Calling PL/SQL Functions in CONTAINS<a id="sthref477"></a></h3>
<p>You can call user-defined functions directly in the <code>CONTAINS</code> clause as long as the function satisfies the requirements for being named in a SQL statement. The caller must also have <code>EXECUTE</code> privilege on the function.</p>
<p>For example, assuming the function <span class="italic">french</span> returns the French equivalent of an English word, you can search on the French word for <span class="italic">cat</span> by writing:</p>
<pre>
SELECT SCORE(1), title from news 
   WHERE CONTAINS(text, french('cat'), 1) &gt; 0
   ORDER BY SCORE(1);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about creating user functions and calling user functions from SQL</div>
</div>
<!-- class="sect2" -->
<a id="CBACGAIA"></a>
<div id="CCAPP9183" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.9</span> Optimizing for Response Time<a id="sthref478"></a><a id="sthref479"></a><a id="sthref480"></a><a id="sthref481"></a></h3>
<p>A <code>CONTAINS</code> query optimized for response time provides a fast solution for when you need the highest scoring documents from a hitlist.</p>
<p>The following example returns the first twenty hits to standard out. This example uses the <code>FIRST_ROWS</code>(n) hint and a cursor.</p>
<pre>
declare 
cursor c is  
  select /*+ FIRST_ROWS(20) */ title, score(1) score 
    from news where contains(txt_col, 'dog', 1) &gt; 0 order by score(1) desc; 
begin 
  for c1 in c 
  loop 
    dbms_output.put_line(c1.score||':'||substr(c1.title,1,50)); 
    exit when c%rowcount = 21; 
  end loop; 
end; 
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aoptim.htm#i1006318">"Optimizing Queries for Response Time"</a></div>
<div id="CCAPP9184" class="sect3"><a id="sthref482"></a>
<h4 class="sect3"><span class="secnum">4.2.9.1</span> Other Factors that Influence Query Response Time</h4>
<p>Besides using query hints, there are other factors that can influence query response time such as:</p>
<ul>
<li>
<p>Collection of table statistics</p>
</li>
<li>
<p>Memory allocation</p>
</li>
<li>
<p>Sorting</p>
</li>
<li>
<p>Presence of LOB columns in your base table</p>
</li>
<li>
<p>Partitioning</p>
</li>
<li>
<p>Parallelism</p>
</li>
<li>
<p>The number term expansions in your query</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aoptim.htm#CHDJCFBH">"Frequently Asked Questions About Query Performance"</a></div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CBAIBFFI"></a>
<div id="CCAPP9185" class="sect2">
<h3 class="sect2"><span class="secnum">4.2.10</span> Counting Hits<a id="sthref483"></a><a id="sthref484"></a><a id="sthref485"></a></h3>
<p>To count the number of hits returned from a query with only a <code>CONTAINS</code> predicate, you can use <code>CTX_QUERY.COUNT_HITS</code> in PL/SQL or <code>COUNT(*)</code> in a SQL <code>SELECT</code> statement.</p>
<p>If you want a rough hit count, you can use <code>CTX_QUERY.COUNT_HITS</code> in estimate mode (<code>EXACT</code> parameter set to <code>FALSE</code>). With respect to response time, this is the fastest count you can get.</p>
<p>To count the number of hits returned from a query that contains a structured predicate, use the <code>COUNT(*)</code> function in a <code>SELECT</code> statement.</p>
<div id="CCAPP9186" class="sect3"><a id="sthref486"></a>
<h4 class="sect3"><span class="secnum">4.2.10.1</span> SQL Count Hits Example</h4>
<p>To find the number of documents that contain the word <span class="italic">oracle</span>, enter the query with the <code>SQL COUNT</code> function as follows:</p>
<pre>
SELECT count(*) FROM news WHERE CONTAINS(text, 'oracle', 1) &gt; 0;
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9187" class="sect3"><a id="sthref487"></a>
<h4 class="sect3"><span class="secnum">4.2.10.2</span> Counting Hits with a Structured Predicate</h4>
<p>To find the number of documents returned by a query with a structured predicate, use <code>COUNT(*)</code> as follows:</p>
<pre>
SELECT COUNT(*) FROM news WHERE CONTAINS(text, 'oracle', 1) &gt; 0 and author = 'jones';
</pre></div>
<!-- class="sect3" -->
<div id="CCAPP9188" class="sect3"><a id="sthref488"></a>
<h4 class="sect3"><span class="secnum">4.2.10.3</span> PL/SQL Count Hits Example</h4>
<p>To find the number of documents that contain the word <span class="italic">oracle</span>, use <code>COUNT_HITS</code> as follows:</p>
<pre>
declare count number;
begin
  count := ctx_query.count_hits(index_name =&gt; my_index, text_query =&gt; 'oracle', exact =&gt; TRUE);
 dbms_output.put_line('Number of docs with oracle:');
 dbms_output.put_line(count);
end;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF" href="../e24436/toc.htm"><span class="italic">Oracle Text Reference</span></a> to learn more about the syntax of <code>CTX_QUERY.COUNT_HITS</code></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CBACAFBD"></a>
<div id="CCAPP9189" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">4.2.11</span> Using DEFINESCORE and DEFINEMERGE for User-defined Scoring</h3>
<p>The <a id="sthref489"></a><code>DEFINESCORE</code> operator enables you to define how the score for a term or phrase is to be calculated. The <a id="sthref490"></a><code>DEFINEMERGE</code> operator defines how to merge scores of child elements of <code>AND</code> and <code>OR</code> operators. You can also use the alternative scoring template with <code>SDATA</code> to affect the final scoring of the document.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1007605">"Alternative and User-defined Scoring"</a> for information about the alternative scoring template</p>
</li>
<li>
<p><a class="olink CCREF" href="../e24436/toc.htm"><span class="italic">Oracle Text Reference</span></a> to learn more about the syntax of <code>DEFINESCORE</code> and <code>DEFINEMERGE</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006741"></a>
<div id="CCAPP9190" class="sect1">
<h2 class="sect1"><span class="secnum">4.3</span> The CTXCAT Grammar<a id="sthref491"></a><a id="sthref492"></a><a id="sthref493"></a><a id="sthref494"></a></h2>
<p>The <code>CTXCAT</code> grammar is the default grammar for <code>CATSEARCH</code>. This grammar supports logical operations such as <code>AND</code> and <code>OR</code> as well as phrase queries.</p>
<p>The <code>CATSEARCH</code> query operators have the following syntax:</p>
<div id="CCAPP9505" class="tblformal">
<p class="titleintable"><a id="sthref495"></a><a id="sthref496"></a>Table 4-3 CATSEARCH Query Operator Syntax</p>
<table class="cellalignment117" title="CATSEARCH Query Operator Syntax" summary="This table shows the various CATSEARCH query operators and shows how each works." dir="ltr">
<thead>
<tr class="cellalignment106">
<th class="cellalignment116" id="r1c1-t33">Operation</th>
<th class="cellalignment116" id="r1c2-t33">Syntax</th>
<th class="cellalignment116" id="r1c3-t33">Description of Operation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment106">
<td class="cellalignment112" id="r2c1-t33" headers="r1c1-t33">
<p>Logical <code>AND</code></p>
</td>
<td class="cellalignment112" headers="r2c1-t33 r1c2-t33">
<p>a b c</p>
</td>
<td class="cellalignment112" headers="r2c1-t33 r1c3-t33">
<p>Returns rows that contain a, b and c.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r3c1-t33" headers="r1c1-t33">
<p>Logical <code>OR</code></p>
</td>
<td class="cellalignment112" headers="r3c1-t33 r1c2-t33">
<p>a | b | c</p>
</td>
<td class="cellalignment112" headers="r3c1-t33 r1c3-t33">
<p>Returns rows that contain a, b, or c.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r4c1-t33" headers="r1c1-t33">
<p>Logical <code>NOT</code></p>
</td>
<td class="cellalignment112" headers="r4c1-t33 r1c2-t33">
<p>a - b</p>
</td>
<td class="cellalignment112" headers="r4c1-t33 r1c3-t33">
<p>Returns rows that contain a and not b.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r5c1-t33" headers="r1c1-t33">
<p>hyphen with no space</p>
</td>
<td class="cellalignment112" headers="r5c1-t33 r1c2-t33">
<p>a-b</p>
</td>
<td class="cellalignment112" headers="r5c1-t33 r1c3-t33">
<p>Hyphen treated as a regular character.</p>
<p>For example, if the hyphen is defined as skipjoin, words such as <span class="italic">web-site</span> treated as the single query term <span class="italic">website</span>.</p>
<p>Likewise, if the hyphen is defined as a printjoin, words such as <span class="italic">web-site</span> treated as <span class="italic">web site</span> with the space in the <code>CTXCAT</code> query language.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r6c1-t33" headers="r1c1-t33">
<p>" "</p>
</td>
<td class="cellalignment112" headers="r6c1-t33 r1c2-t33">
<p>"a b c"</p>
</td>
<td class="cellalignment112" headers="r6c1-t33 r1c3-t33">
<p>Returns rows that contain the phrase "a b c".</p>
<p>For example, entering "Sony CD Player" means return all rows that contain this sequence of words.</p>
</td>
</tr>
<tr class="cellalignment106">
<td class="cellalignment112" id="r7c1-t33" headers="r1c1-t33">
<p>( )</p>
</td>
<td class="cellalignment112" headers="r7c1-t33 r1c2-t33">
<p>(A B) | C</p>
</td>
<td class="cellalignment112" headers="r7c1-t33 r1c3-t33">
<p>Parentheses group operations. This query is equivalent to the <code>CONTAINS</code> query (A &amp;B) | C.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="CBACAGCF"></a>
<div id="CCAPP9191" class="sect2">
<h3 class="sect2"><span class="secnum">4.3.1</span> Using CONTEXT Grammar with CATSEARCH<a id="sthref497"></a><a id="sthref498"></a></h3>
<p>In addition, you can use the <code>CONTEXT</code> grammar in <code>CATSEARCH</code> queries. To do so, use a query template specification in the text_query parameter.</p>
<p>You might use the <code>CONTAINS</code> grammar as such when you need to enter proximity, thesaurus, or <code>ABOUT</code> queries with a <code>CTXCAT</code> index.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF0103" href="../../text.112/e24436/csql.htm#CCREF0103"><span class="italic">Oracle Text Reference</span></a> for more information about using these operators</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment105">
<tr>
<td class="cellalignment112">
<table class="cellalignment110">
<tr>
<td class="cellalignment109"><a href="ind.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment109"><a href="view.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2004, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment114">
<table class="cellalignment108">
<tr>
<td class="cellalignment109"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment109"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment109"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment109"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment109"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment109"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
