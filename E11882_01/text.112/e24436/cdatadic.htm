<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Oracle Text Indexing Elements</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1071" />
<meta name="dcterms.created" content="2015-10-23T12:26:33Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Text Reference" />
<meta name="dcterms.identifier" content="E24436-05" />
<meta name="dcterms.isVersionOf" content="CCREF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1998, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="csql.htm" title="Previous" type="text/html" />
<link rel="Next" href="cqoper.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e24436.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/29</span> <!-- End Header -->
<div id="CCREF0200" class="chapter"><a id="BHCDHIAI"></a>
<h1 class="chapter"><span class="secnum">2</span> Oracle Text Indexing Elements</h1>
<p><a id="CCREF1901"></a>Oracle Text provides indexing elements for creating Oracle Text indexes and for specifying indexing preferences. This chapter describes the indexing elements that you can use to create an Oracle Text index.</p>
<p><a id="sthref270"></a>The following topics are discussed in this chapter:</p>
<ul>
<li>
<p><a href="#i1006239">Overview</a></p>
</li>
<li>
<p><a href="#i1006307">Datastore Types</a></p>
</li>
<li>
<p><a href="#i1007013">Filter Types</a></p>
</li>
<li>
<p><a href="#i1007538">Lexer Types</a></p>
</li>
<li>
<p><a href="#i1008929">Wordlist Type</a></p>
</li>
<li>
<p><a href="#i1009245">Storage Types</a></p>
</li>
<li>
<p><a href="#i1009342">Section Group Types</a></p>
</li>
<li>
<p><a href="#i1009435">Classifier Types</a></p>
</li>
<li>
<p><a href="#i1015204">Cluster Types</a></p>
</li>
<li>
<p><a href="#i1014730">Stoplists</a></p>
</li>
<li>
<p><a href="#i1017419">System-Defined Preferences</a></p>
</li>
<li>
<p><a href="#i1009827">System Parameters</a></p>
</li>
</ul>
<a id="i1006239"></a>
<div id="CCREF0202" class="sect1">
<h2 class="sect1"><span class="secnum">2.1</span> Overview</h2>
<p><a id="sthref271"></a><a id="sthref272"></a>When you use the <a href="csql.htm#i997677">CREATE INDEX</a> statement to create an index or the <a href="csql.htm#CIHBFDCE">ALTER INDEX</a> statement to manage an index, you can optionally specify indexing preferences, stoplists, and section groups in the parameter string.</p>
<p>Specifying a preference, stoplist, or section group answers one of the following questions about the way Oracle Text indexes text:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="Using Preference Classes" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t2"><span class="bold">Preference Class</span></th>
<th class="cellalignment97" id="r1c2-t2">Answers the Question</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t2" headers="r1c1-t2">Datastore</td>
<td class="cellalignment98" headers="r2c1-t2 r1c2-t2">How are your documents stored?</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t2" headers="r1c1-t2">Filter</td>
<td class="cellalignment98" headers="r3c1-t2 r1c2-t2">How can the documents be converted to plain text?</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t2" headers="r1c1-t2">Lexer</td>
<td class="cellalignment98" headers="r4c1-t2 r1c2-t2">What language is being indexed?</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t2" headers="r1c1-t2">Wordlist</td>
<td class="cellalignment98" headers="r5c1-t2 r1c2-t2">How should stem and fuzzy queries be expanded?</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t2" headers="r1c1-t2">Storage</td>
<td class="cellalignment98" headers="r6c1-t2 r1c2-t2">How should the index tables be stored?</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t2" headers="r1c1-t2">Stop List</td>
<td class="cellalignment98" headers="r7c1-t2 r1c2-t2">What words or themes are not to be indexed?</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t2" headers="r1c1-t2">Section Group</td>
<td class="cellalignment98" headers="r8c1-t2 r1c2-t2">Is querying within sections enabled, and how are the document sections defined?</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>This chapter describes how to set each preference. Enable an option by creating a preference with one of the types described in this chapter.</p>
<p>For example, to specify that your documents are stored in external files, you can create a datastore preference called <code dir="ltr">mydatastore</code> using the <a href="#i1006637">FILE_DATASTORE</a> type. Specify <code dir="ltr">mydatastore</code> as the datastore preference in the parameter clause of the <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> statement.</p>
<div id="CCREF1902" class="sect2"><a id="sthref273"></a>
<h3 class="sect2"><span class="secnum">2.1.1</span> Creating Preferences<a id="sthref274"></a></h3>
<p>To create a datastore, lexer, filter, classifier, wordlist, or storage preference, use the CTX_DDL.<a href="cddlpkg.htm#i997746">CREATE_PREFERENCE</a>procedure and specify one of the types described in this chapter. For some types, you can also set attributes with the CTX_DDL.<a href="cddlpkg.htm#i998425">SET_ATTRIBUTE</a> procedure.</p>
<p><a id="sthref275"></a><a id="sthref276"></a><a id="sthref277"></a><a id="sthref278"></a>An indexing <span class="italic">type</span> names a class of indexing objects that you can use to create an index <span class="italic">preference</span>. A type, therefore, is an abstract ID, while a preference is an entity that corresponds to a type. Many system-defined preferences have the same name as types (for example, <code dir="ltr">BASIC_LEXER</code>), but exact correspondence is not guaranteed. For example, the <code dir="ltr">DEFAULT_DATASTORE</code> preference uses the <code dir="ltr">DIRECT_DATASTORE</code> type, and there is no system preference corresponding to the <code dir="ltr">CHARSET_FILTER</code> type. Be careful in assuming the existence or nature of either indexing types or system preferences.</p>
<p>You specify indexing preferences with the <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> and <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code> statements. Indexing preferences determine how your index is created. For example, lexer preferences indicate the language of the text to be indexed. You can create and specify your own user-defined preferences, or you can use system-defined preferences.</p>
<p>To create a stoplist, use the CTX_DDL.<a href="cddlpkg.htm#i998026">CREATE_STOPLIST</a> procedure. Add stopwords to a stoplist with <code dir="ltr">CTX_DDL.ADD_STOPWORD</code>.</p>
<p>To create section groups, use CTX_DDL.<a href="cddlpkg.htm#i997893">CREATE_SECTION_GROUP</a> and specify a section group type. Add sections to section groups with the <code dir="ltr">CTX_DDL.ADD_ZONE_SECTION</code> or <code dir="ltr">CTX_DDL.ADD_FIELD_SECTION</code> procedures.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006307"></a>
<div id="CCREF0203" class="sect1">
<h2 class="sect1"><span class="secnum">2.2</span> Datastore Types<a id="sthref279"></a><a id="sthref280"></a></h2>
<p>Use the datastore types to specify how your text is stored. To create a datastore preference, you must use one of the datastore types described in <a href="#CIHHAGHA">Table 2-1</a>.</p>
<div id="CCREF23749" class="tblformal">
<p class="titleintable"><a id="sthref281"></a><a id="CIHHAGHA"></a>Table 2-1 Datastore Types</p>
<table class="cellalignment103" title="Datastore Types" summary="This table shows various datastore types." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t3">Datastore Type</th>
<th class="cellalignment97" id="r1c2-t3">Use When</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t3" headers="r1c1-t3">
<p><a href="#i1006370">DIRECT_DATASTORE</a></p>
</td>
<td class="cellalignment98" headers="r2c1-t3 r1c2-t3">
<p>Data is stored internally in the text column. Each row is indexed as a single document.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t3" headers="r1c1-t3">
<p><a href="#i1006391">MULTI_COLUMN_DATASTORE</a></p>
</td>
<td class="cellalignment98" headers="r3c1-t3 r1c2-t3">
<p>Data is stored in a text table in more than one column. Columns are concatenated to create a virtual document, one for each row.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t3" headers="r1c1-t3">
<p><a href="#i1006478">DETAIL_DATASTORE</a></p>
</td>
<td class="cellalignment98" headers="r4c1-t3 r1c2-t3">
<p>Data is stored internally in the text column. Document consists of one or more rows stored in a text column in a detail table, with header information stored in a master table.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t3" headers="r1c1-t3">
<p><a href="#i1006637">FILE_DATASTORE</a></p>
</td>
<td class="cellalignment98" headers="r5c1-t3 r1c2-t3">
<p>Data is stored externally in operating system files. File names are stored in the text column, one for each row.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t3" headers="r1c1-t3">
<p><a href="#i1006926">NESTED_DATASTORE</a></p>
</td>
<td class="cellalignment98" headers="r6c1-t3 r1c2-t3">
<p>Data is stored in a nested table.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t3" headers="r1c1-t3">
<p><a href="#i1006676">URL_DATASTORE</a></p>
</td>
<td class="cellalignment98" headers="r7c1-t3 r1c2-t3">
<p>Data is stored externally in files located on an intranet or the Internet. Uniform Resource Locators (URLs) are stored in the text column.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t3" headers="r1c1-t3">
<p><a href="#i1006810">USER_DATASTORE</a></p>
</td>
<td class="cellalignment98" headers="r8c1-t3 r1c2-t3">
<p>Documents are synthesized at index time by a user-defined stored procedure.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="i1006370"></a>
<div id="CCREF1903" class="sect2">
<h3 class="sect2"><span class="secnum">2.2.1</span> <a id="sthref282"></a><a id="sthref283"></a>DIRECT_DATASTORE</h3>
<p>Use the <code dir="ltr">DIRECT_DATASTORE</code> type for text stored directly in the text column, one document for each row. The <code dir="ltr">DIRECT_DATASTORE</code> type has no attributes.</p>
<p>The following column types are supported: <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR</code>, <code dir="ltr">VARCHAR2</code>, <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB</code>, <code dir="ltr">BFILE</code>, <code dir="ltr">XMLType</code>, and <code dir="ltr">URIType</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If your column is a <code dir="ltr">BFILE</code>, then the index owner must have <span class="italic">read</span> permission on all directories used by the <code dir="ltr">BFILEs</code>.</div>
<div id="CCREF1904" class="sect3"><a id="sthref284"></a>
<h4 class="sect3"><span class="secnum">2.2.1.1</span> DIRECT_DATASTORE CLOB Example<a id="sthref285"></a></h4>
<p>The following example creates a table with a <code dir="ltr">CLOB</code> column to store text data. It then populates two rows with text data and indexes the table using the system-defined preference <code dir="ltr">CTXSYS.DEFAULT_DATASTORE</code>.</p>
<pre dir="ltr">
create table mytable(id number primary key, docs clob); 

insert into mytable values(111555,'this text will be indexed');
insert into mytable values(111556,'this is a direct_datastore example');
commit;

create index myindex on mytable(docs) 
  indextype is ctxsys.context 
  parameters ('DATASTORE CTXSYS.DEFAULT_DATASTORE');
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006391"></a>
<div id="CCREF1905" class="sect2">
<h3 class="sect2"><span class="secnum">2.2.2</span> MULTI_COLUMN_DATASTORE</h3>
<p>Use the <code dir="ltr">MULTI_COLUMN_DATASTORE</code> datastore when your text is stored in more than one column. During indexing, the system concatenates the text columns, tags the column text, and indexes the text as a single document. The XML-like tagging is optional. You can also set the system to filter and concatenate binary columns.</p>
<p>The data store <code dir="ltr">MULTI_COLUMN_DATASTORE</code> has the attributes shown in <a href="#CIHGBHJJ">Table 2-2</a>.</p>
<div id="CCREF23750" class="tblformal">
<p class="titleintable"><a id="sthref286"></a><a id="CIHGBHJJ"></a>Table 2-2 MULTI_COLUMN_DATASTORE Attributes</p>
<table class="cellalignment103" title="MULTI_COLUMN_DATASTORE Attributes" summary="This table shows MULTI_COLUMN_DATASTORE attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t5">Attribute</th>
<th class="cellalignment97" id="r1c2-t5">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t5" headers="r1c1-t5">
<p>columns</p>
</td>
<td class="cellalignment98" headers="r2c1-t5 r1c2-t5">
<p>Specify a comma-delimited list of columns to be concatenated during indexing. You can also specify any allowed expression for the <code dir="ltr">SELECT</code> statement column list for the base table. This includes expressions, PL/SQL functions, column aliases, and so on.</p>
<p>The <code dir="ltr">NUMBER</code> and <code dir="ltr">DATE</code> column types are supported. They are converted to text before indexing using the default format mask. The <code dir="ltr">TO_CHAR</code> function can be used in the column list for formatting.</p>
<p>The <code dir="ltr">RAW</code> and <code dir="ltr">BLOB</code> columns are directly concatenated as binary data.</p>
<p>The <code dir="ltr">LONG</code>, <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, <code dir="ltr">NCHAR</code>, and <code dir="ltr">NCLOB</code> data types, nested table columns, and collections are not supported.</p>
<p>The column list is limited to 500 bytes.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t5" headers="r1c1-t5">
<p>filter</p>
</td>
<td class="cellalignment98" headers="r3c1-t5 r1c2-t5">
<p><a id="sthref287"></a><a id="sthref288"></a><a id="sthref289"></a>Specify a comma-delimited list of Y/N flags. Each flag corresponds to a column in the <code dir="ltr">COLUMNS</code> list and denotes whether to filter the column using the <code dir="ltr">AUTO_FILTER</code>.</p>
<p>Specify one of the following allowed values:</p>
<p>Y: Column is to be filtered with <code dir="ltr">AUTO_FILTER</code></p>
<p>N or no value: Column is not to be filtered (default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t5" headers="r1c1-t5">
<p>delimiter</p>
</td>
<td class="cellalignment98" headers="r4c1-t5 r1c2-t5">
<p>Specify the delimiter that separates column text as follows:</p>
<p><code dir="ltr">COLUMN_NAME_TAG</code>: Column text is set off by XML-like open and close tags (default).</p>
<p><code dir="ltr">NEWLINE</code>: Column text is separated with a newline.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="CCREF1906" class="sect3"><a id="sthref290"></a>
<h4 class="sect3"><span class="secnum">2.2.2.1</span> Indexing and DML</h4>
<p>To index, you must create a dummy column to specify in the <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> statement. This column's contents are not made part of the virtual document, unless its name is specified in the columns attribute.</p>
<p>The index is synchronized only when the dummy column is updated. You can create triggers to propagate changes if needed.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1907" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref291"></a>
<h4 class="sect3"><span class="secnum">2.2.2.2</span> <a id="sthref292"></a>MULTI_COLUMN_DATASTORE Restriction</h4>
<p>You cannot create a multicolumn datastore with <code dir="ltr">XMLType</code> columns. <code dir="ltr">MULTI_COLUMN_DATA_STORE</code> does not support <code dir="ltr">XMLType</code>. You can create a <code dir="ltr">CONTEXT</code> index with an <code dir="ltr">XMLType</code> column, as described in <a href="csql.htm#i996741">Chapter 1, "Oracle Text SQL Statements and Operators"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1908" class="sect3"><a id="sthref293"></a>
<h4 class="sect3"><span class="secnum">2.2.2.3</span> MULTI_COLUMN_DATASTORE Example</h4>
<p>The following example creates a multicolumn datastore preference called <code dir="ltr">my_multi</code> with three text columns:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.create_preference('my_multi', 'MULTI_COLUMN_DATASTORE');
ctx_ddl.set_attribute('my_multi', 'columns', 'column1, column2, column3');
</pre>
<pre dir="ltr">
end;
</pre></div>
<!-- class="sect3" -->
<div id="CCREF1909" class="sect3"><a id="sthref294"></a>
<h4 class="sect3"><span class="secnum">2.2.2.4</span> MULTI_COLUMN_DATASTORE Filter Example</h4>
<p>The following example creates a multicolumn datastore preference and denotes that the <code dir="ltr">bar</code> column is to be filtered with the <code dir="ltr">AUTO_FILTER</code>.</p>
<pre dir="ltr">
ctx_ddl.create_preference('MY_MULTI','MULTI_COLUMN_DATASTORE');
ctx_ddl.set_attribute('MY_MULTI', 'COLUMNS','foo,bar');
ctx_ddl.set_attribute('MY_MULTI','FILTER','N,Y');
</pre>
<pre dir="ltr">
</pre>
<p>The multicolumn datastore fetches the content of the <code dir="ltr">foo</code> and <code dir="ltr">bar</code> columns, filters <code dir="ltr">bar</code>, then composes the compound document as:</p>
<pre dir="ltr">
&lt;FOO&gt;
foo contents
&lt;/FOO&gt;
&lt;BAR&gt;
bar filtered contents (probably originally HTML)
&lt;/BAR&gt;
</pre>
<p>The N flags do not need not be specified, and there does not need to be a flag for every column. Only the Y flags must be need to be specified, with commas to denote to which column they apply. For instance:</p>
<pre dir="ltr">
ctx_ddl.create_preference('MY_MULTI','MULTI_COLUMN_DATASTORE');
ctx_ddl.set_attribute('MY_MULTI', 'COLUMNS','foo,bar,zoo,jar');
ctx_ddl.set_attribute('MY_MULTI','FILTER',',,Y');
</pre>
<pre dir="ltr">
</pre>
<p>This filters only the column <code dir="ltr">zoo</code>.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1910" class="sect3"><a id="sthref295"></a>
<h4 class="sect3"><span class="secnum">2.2.2.5</span> Tagging Behavior</h4>
<p>During indexing, the system creates a virtual document for each row. The virtual document is composed of the contents of the columns concatenated in the listing order with column name tags automatically added. For example:</p>
<pre dir="ltr">
create table mc(id number primary key, name varchar2(10), address varchar2(80));
insert into mc values(1, 'John Smith', '123 Main Street');

exec ctx_ddl.create_preference('mymds', 'MULTI_COLUMN_DATASTORE');
exec ctx_ddl.set_attibute('mymds', 'columns', 'name, address');
</pre>
<p>This produces the following virtual text for indexing:</p>
<pre dir="ltr">
&lt;NAME&gt;
John Smith
&lt;/NAME&gt;
&lt;ADDRESS&gt;
123 Main Street
&lt;/ADDRESS&gt;
</pre>
<p>The system indexes the text between the tags, ignoring the tags themselves.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1911" class="sect3"><a id="sthref296"></a>
<h4 class="sect3"><span class="secnum">2.2.2.6</span> Indexing Columns as Sections</h4>
<p>To index the tags as sections, you can optionally create field sections with <code dir="ltr">BASIC_SECTION_GROUP</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
No section group is created when you use the <code dir="ltr">MULTI_COLUMN_DATASTORE</code>. To create sections for these tags, you must create a section group.</div>
<p>When you use expressions or functions, the tag is composed of the first 30 characters of the expression unless a column alias is used.</p>
<p>For example, if your expression is as follows:</p>
<pre dir="ltr">
exec ctx_ddl.set_attibute('mymds', 'columns', '4 + 17');
</pre>
<p>then it produces the following virtual text:</p>
<pre dir="ltr">
&lt;4 + 17&gt;
21
&lt;/4 + 17&gt;
</pre>
<p>If your expression is as follows:</p>
<pre dir="ltr">
exec ctx_ddl.set_attibute('mymds', 'columns', '4 + 17 col1');
</pre>
<p>then it produces the following virtual text:</p>
<pre dir="ltr">
&lt;col1&gt;
21
&lt;col1&gt;
</pre>
<p>The tags are in uppercase unless the column name or column alias is in lowercase and surrounded by double quotation marks. For example:</p>
<pre dir="ltr">
exec ctx_ddl.set_attibute('mymds', 'COLUMNS', 'foo');
</pre>
<p>This produces the following virtual text:</p>
<pre dir="ltr">
&lt;FOO&gt;
content of foo
&lt;/FOO&gt;
</pre>
<p>For lowercase tags, use the following:</p>
<pre dir="ltr">
exec ctx_ddl.set_attibute('mymds', 'COLUMNS', 'foo "foo"');
</pre>
<p>This expression produces:</p>
<pre dir="ltr">
&lt;foo&gt;
content of foo
&lt;/foo&gt;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006478"></a>
<div id="CCREF1912" class="sect2">
<h3 class="sect2"><span class="secnum">2.2.3</span> DETAIL_DATASTORE <a id="sthref297"></a><a id="sthref298"></a><a id="sthref299"></a></h3>
<p>Use the <code dir="ltr">DETAIL_DATASTORE</code> type for text stored directly in the database in detail tables, with the indexed text column located in the master table.</p>
<p>The <code dir="ltr">DETAIL_DATASTORE</code> type has the attributes described in <a href="#CHDCHAGE">Table 2-3</a>.</p>
<div id="CCREF23751" class="tblformal">
<p class="titleintable"><a id="sthref300"></a><a id="CHDCHAGE"></a>Table 2-3 DETAIL_DATASTORE Attributes</p>
<table class="cellalignment103" title="DETAIL_DATASTORE Attributes" summary="This table describes DETAIL_DATASTORE attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t7">Attribute</th>
<th class="cellalignment97" id="r1c2-t7">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t7" headers="r1c1-t7">
<p>binary<span class="bold"><a id="sthref301"></a><a id="sthref302"></a></span></p>
</td>
<td class="cellalignment98" headers="r2c1-t7 r1c2-t7">
<p>Specify <code dir="ltr">TRUE</code> for Oracle Text to add <span class="italic">no</span> newline character after each detail row.</p>
<p>Specify <code dir="ltr">FALSE</code> for Oracle Text to add a newline character (\n) after each detail row automatically.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t7" headers="r1c1-t7">
<p>detail_table<span class="bold"><a id="sthref303"></a><a id="sthref304"></a></span></p>
</td>
<td class="cellalignment98" headers="r3c1-t7 r1c2-t7">
<p>Specify the name of the detail table (<code dir="ltr">OWNER.TABLE</code> if necessary).</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t7" headers="r1c1-t7">
<p>detail_key<span class="bold"><a id="sthref305"></a><a id="sthref306"></a></span></p>
</td>
<td class="cellalignment98" headers="r4c1-t7 r1c2-t7">
<p>Specify the name of the detail table foreign key column.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t7" headers="r1c1-t7">
<p>detail_lineno<span class="bold"><a id="sthref307"></a><a id="sthref308"></a></span></p>
</td>
<td class="cellalignment98" headers="r5c1-t7 r1c2-t7">
<p>Specify the name of the detail table sequence column.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t7" headers="r1c1-t7">
<p>detail_text<span class="bold"><a id="sthref309"></a><a id="sthref310"></a></span></p>
</td>
<td class="cellalignment98" headers="r6c1-t7 r1c2-t7">
<p>Specify the name of the detail table text column.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="CCREF1913" class="sect3"><a id="sthref311"></a>
<h4 class="sect3"><span class="secnum">2.2.3.1</span> Synchronizing Master/Detail Indexes</h4>
<p>Changes to the detail table do not trigger re-indexing when you synchronize the index. Only changes to the indexed column in the master table triggers a re-index when you synchronize the index.</p>
<p>You can create triggers on the detail table to propagate changes to the indexed column in the master table row.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1914" class="sect3"><a id="sthref312"></a>
<h4 class="sect3"><span class="secnum">2.2.3.2</span> Example Master/Detail Tables<a id="sthref313"></a><a id="sthref314"></a></h4>
<p>This example illustrates how master and detail tables are related to each other.</p>
<div id="CCREF1915" class="sect4"><a id="sthref315"></a>
<h5 class="sect4"><span class="secnum">2.2.3.2.1</span> Master Table Example</h5>
<p>Master tables define the documents in a master/detail relationship. Assign an identifying number to each document. The following table is an example master table, called <code dir="ltr">my_master</code>:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="Example Master Table" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t8">Column Name</th>
<th class="cellalignment97" id="r1c2-t8">Column Type</th>
<th class="cellalignment97" id="r1c3-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t8" headers="r1c1-t8"><code dir="ltr">article_id</code></td>
<td class="cellalignment98" headers="r2c1-t8 r1c2-t8"><code dir="ltr">NUMBER</code></td>
<td class="cellalignment98" headers="r2c1-t8 r1c3-t8">Document ID, unique for each document (primary key)</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t8" headers="r1c1-t8"><code dir="ltr">author</code></td>
<td class="cellalignment98" headers="r3c1-t8 r1c2-t8"><code dir="ltr">VARCHAR2(30)</code></td>
<td class="cellalignment98" headers="r3c1-t8 r1c3-t8">Author of document</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t8" headers="r1c1-t8"><code dir="ltr">title</code></td>
<td class="cellalignment98" headers="r4c1-t8 r1c2-t8"><code dir="ltr">VARCHAR2(50)</code></td>
<td class="cellalignment98" headers="r4c1-t8 r1c3-t8">Title of document</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t8" headers="r1c1-t8"><code dir="ltr">body</code></td>
<td class="cellalignment98" headers="r5c1-t8 r1c2-t8"><code dir="ltr">CHAR(1)</code></td>
<td class="cellalignment98" headers="r5c1-t8 r1c3-t8">Dummy column to specify in <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Your master table must include a primary key column when you use the <code dir="ltr">DETAIL_DATASTORE</code> type.</div>
</div>
<!-- class="sect4" -->
<div id="CCREF1916" class="sect4"><a id="sthref316"></a>
<h5 class="sect4"><span class="secnum">2.2.3.2.2</span> Detail Table Example</h5>
<p>Detail tables contain the text for a document, whose content is usually stored across a number of rows. The following detail table <code dir="ltr">my_detail</code> is related to the master table <code dir="ltr">my_master</code> with the <code dir="ltr">article_id</code> column. This column identifies the master document to which each detail row (sub-document) belongs.</p>
<div class="inftblinformal">
<table class="cellalignment96" title="Example Detail Table" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t10">Column Name</th>
<th class="cellalignment97" id="r1c2-t10">Column Type</th>
<th class="cellalignment97" id="r1c3-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t10" headers="r1c1-t10"><code dir="ltr">article_id</code></td>
<td class="cellalignment98" headers="r2c1-t10 r1c2-t10"><code dir="ltr">NUMBER</code></td>
<td class="cellalignment98" headers="r2c1-t10 r1c3-t10">Document ID that relates to master table</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t10" headers="r1c1-t10"><code dir="ltr">seq</code></td>
<td class="cellalignment98" headers="r3c1-t10 r1c2-t10"><code dir="ltr">NUMBER</code></td>
<td class="cellalignment98" headers="r3c1-t10 r1c3-t10">Sequence of document in the master document defined by <code dir="ltr">article_id</code></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t10" headers="r1c1-t10"><code dir="ltr">text</code></td>
<td class="cellalignment98" headers="r4c1-t10 r1c2-t10"><code dir="ltr">VARCHAR2</code></td>
<td class="cellalignment98" headers="r4c1-t10 r1c3-t10">Document text</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect4" -->
<div id="CCREF1917" class="sect4"><a id="sthref317"></a>
<h5 class="sect4"><span class="secnum">2.2.3.2.3</span> Detail Table Example Attributes</h5>
<p>In this example, the <code dir="ltr">DETAIL_DATASTORE</code> attributes have the following values:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="Sample Detail Table Attirbutes" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t11">Attribute</th>
<th class="cellalignment97" id="r1c2-t11">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t11" headers="r1c1-t11"><code dir="ltr">binary</code></td>
<td class="cellalignment98" headers="r2c1-t11 r1c2-t11"><code dir="ltr">TRUE</code></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t11" headers="r1c1-t11"><code dir="ltr">detail_table</code></td>
<td class="cellalignment98" headers="r3c1-t11 r1c2-t11"><code dir="ltr">my_detail</code></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t11" headers="r1c1-t11"><code dir="ltr">detail_key</code></td>
<td class="cellalignment98" headers="r4c1-t11 r1c2-t11"><code dir="ltr">article_id</code></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t11" headers="r1c1-t11"><code dir="ltr">detail_lineno</code></td>
<td class="cellalignment98" headers="r5c1-t11 r1c2-t11"><code dir="ltr">seq</code></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t11" headers="r1c1-t11"><code dir="ltr">detail_text</code></td>
<td class="cellalignment98" headers="r6c1-t11 r1c2-t11"><code dir="ltr">text</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>Use CTX_DDL.<a href="cddlpkg.htm#i997746">CREATE_PREFERENCE</a> to create a preference with <code dir="ltr">DETAIL_DATASTORE</code>. Use CTX_DDL.<a href="cddlpkg.htm#i998425">SET_ATTRIBUTE</a> to set the attributes for this preference as described earlier. The following example shows how this is done:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.create_preference('my_detail_pref', 'DETAIL_DATASTORE');
ctx_ddl.set_attribute('my_detail_pref', 'binary', 'true');
ctx_ddl.set_attribute('my_detail_pref', 'detail_table', 'my_detail');
ctx_ddl.set_attribute('my_detail_pref', 'detail_key', 'article_id');
ctx_ddl.set_attribute('my_detail_pref', 'detail_lineno', 'seq');
ctx_ddl.set_attribute('my_detail_pref', 'detail_text', 'text');
</pre>
<pre dir="ltr">
end;
</pre></div>
<!-- class="sect4" -->
<div id="CCREF1918" class="sect4"><a id="sthref318"></a>
<h5 class="sect4"><span class="secnum">2.2.3.2.4</span> Master/Detail Index Example</h5>
<p>To index<a id="sthref319"></a><a id="sthref320"></a> the document defined in this master/detail relationship, specify a column in the master table using the <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> statement. The column you specify must be one of the allowed types.</p>
<p>This example uses the <code dir="ltr">body</code> column, whose function is to enable the creation of the master/detail index and to improve readability of the code. The <code dir="ltr">my_detail_pref</code> preference is set to <code dir="ltr">DETAIL_DATASTORE</code> with the required attributes:</p>
<pre dir="ltr">
CREATE INDEX myindex on my_master(body) indextype is ctxsys.context
parameters('datastore my_detail_pref');
</pre>
<p>In this example, you can also specify the <code dir="ltr">title</code> or <code dir="ltr">author</code> column to create the index. However, if you do so, changes to these columns will trigger a re-index operation.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006637"></a>
<div id="CCREF1919" class="sect2">
<h3 class="sect2"><span class="secnum">2.2.4</span> FILE_DATASTORE<a id="sthref321"></a><a id="sthref322"></a></h3>
<p>The <code dir="ltr">FILE_DATASTORE</code> type is used for text stored in files accessed through the local file system.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">FILE_DATASTORE</code> type may not work with certain types of remote-mounted file systems.</div>
<p>The <code dir="ltr">FILE_DATASTORE</code> type has the attributes described <a href="#CHDBJDBH">Table 2-4</a>.</p>
<div id="CCREF23752" class="tblformal">
<p class="titleintable"><a id="sthref323"></a><a id="CHDBJDBH"></a>Table 2-4 FILE_DATASTORE Attributes</p>
<table class="cellalignment103" title="FILE_DATASTORE Attributes" summary="This table describes the attributes for FILE_DATASTORE." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t13">Attribute</th>
<th class="cellalignment97" id="r1c2-t13">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t13" headers="r1c1-t13">
<p><code dir="ltr">path</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t13 r1c2-t13">
<p><span class="variable">path1</span>:<span class="variable">path2</span>:<span class="variable">pathn</span></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t13" headers="r1c1-t13">
<p><code dir="ltr">filename_charset</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t13 r1c2-t13">
<p><span class="italic">name</span></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<dl>
<dt><a id="sthref324"></a><a id="sthref325"></a>path</dt>
<dd>
<p>Specifies the full directory path name of the files stored externally in a file system. When you specify the full directory path as such, you need to include only file names in your text column.</p>
<p>You can specify multiple paths for the <code dir="ltr">path</code> attribute, with each path separated by a colon (:) on UNIX and semicolon(;) on Windows. File names are stored in the text column in the text table.</p>
<p>If you do not specify a path for external files with this attribute, then Oracle Text requires that the path be included in the file names stored in the text column.</p>
</dd>
<dt>filename_charset</dt>
<dd>
<p>Specifies a valid Oracle character set name (maximum length 30 characters) to be used by the file datastore for converting file names. In general, the Oracle database can use a different character set than the operating system. This can lead to problems in finding files (which may raise DRG-11513 errors) when the indexed column contains characters that are not convertible to the operating system character set. By default, the file datastore will convert the file name to WE8ISO8859p1 for ASCII platforms or WE8EBCDIC1047 for EBCDIC platforms.</p>
<p>However, this may not be sufficient for applications with multibyte character sets for both the database and the operating system, because neither WE8ISO8859p1 nor WE8EBCDIC1047 supports multibyte characters. The attribute <code dir="ltr">filename_charset</code> rectifies this problem. If specified, then the datastore will convert from the database character set to the specified character set rather than to ISO8859 or EBCDIC.</p>
<p>If the <code dir="ltr">filename_charset</code> attribute is the same as the database character set, then the file name is used as is. If <code dir="ltr">filename_charset</code> is not a valid character set, then the error "DRG-10763: value %s is not a valid character set" is raised.</p>
</dd>
</dl>
<div id="CCREF1920" class="sect3"><a id="sthref326"></a>
<h4 class="sect3"><span class="secnum">2.2.4.1</span> PATH Attribute Limitations</h4>
<p>The <code dir="ltr">PATH</code> attribute has the following limitations:</p>
<ul>
<li>
<p>If you specify a <code dir="ltr">PATH</code> attribute, then you can only use a simple file name in the indexed column. You cannot combine the <code dir="ltr">PATH</code> attribute with a path as part of the file name. If the files exist in multiple folders or directories, you must leave the <code dir="ltr">PATH</code> attribute unset, and include the full file name, with <code dir="ltr">PATH</code>, in the indexed column.</p>
</li>
<li>
<p>On Windows systems, the files must be located on a local drive. They cannot be on a remote drive, whether the remote drive is mapped to a local drive letter.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BHCBIFEA"></a>
<div id="CCREF1921" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">2.2.4.2</span> FILE_DATASTORE and Security</h4>
<p>File and URL datastores enable access to files on the actual database disk. This may be undesirable when security is an issue since any user can browse the file system that is accessible to the Oracle user. The <code dir="ltr">FILE_ACCESS_ROLE</code> system parameter can be used to set the name of a database role that is authorized to create an index using <code dir="ltr">FILE</code> or <code dir="ltr">URL</code> datastores. If set, any user attempting to create an index using <code dir="ltr">FILE</code> or <code dir="ltr">URL</code> datastores must have this role, or the index creation will fail. Only <code dir="ltr">SYS</code> can set <code dir="ltr">FILE_ACCESS_ROLE</code>, and an error will be raised if any other user tries to modify it. If <code dir="ltr">FILE_ACCESS_ROLE</code> is left at the default of NULL, access is disallowed. Thus, by default, users are not able to create indexes that use the file or URL datastores. Users can, if desired, set <code dir="ltr">FILE_ACCESS_ROLE</code> to <code dir="ltr">PUBLIC</code> if they want to preserve the behavior from earlier releases.</p>
<p>For example, the following statement sets the name of the database role:</p>
<pre dir="ltr">
ctx_adm.set_parameter('FILE_ACCESS_ROLE','TOPCAT');
</pre>
<p>where TOPCAT is the role that is authorized to create an index on a file or URL datastore. The <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> operation will fail when a user that does not have an authorized role tries to create an index on a file or URL datastore. For example:</p>
<pre dir="ltr">
CREATE INDEX myindex ON mydocument(TEXT) INDEXTYPE IS ctxsys.context  PARAMETERS('DATASTORE ctxsys.file_datastore')
</pre>
<p>In this case, if the user does not have the role TOPCAT, then index creation will fail and return an error. For users who have the TOPCAT role, the index creation will proceed normally.</p>
<p>The authorized role name is checked any time the datastore is accessed. This includes index creation, index sync, and calls to document services, such as <code dir="ltr">CTX_DOC.HIGHLIGHT</code>.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1922" class="sect3"><a id="sthref327"></a>
<h4 class="sect3"><span class="secnum">2.2.4.3</span> FILE_DATASTORE Example<a id="sthref328"></a></h4>
<p>This example creates a file datastore preference called <code dir="ltr">COMMON_DIR</code> that has a path of <code dir="ltr">/mydocs</code>:</p>
<pre dir="ltr">
begin
 ctx_ddl.create_preference('COMMON_DIR','FILE_DATASTORE');
 ctx_ddl.set_attribute('COMMON_DIR','PATH','/mydocs');
end;
</pre>
<p>When you populate the table <code dir="ltr">mytable</code>, you need only insert file names. The <span class="syntaxinline">path</span> attribute tells the system where to look during the indexing operation.</p>
<pre dir="ltr">
create table mytable(id number primary key, docs varchar2(2000)); 
insert into mytable values(111555,'first.txt');
insert into mytable values(111556,'second.txt');
commit;
</pre>
<p>Create the index as follows:</p>
<pre dir="ltr">
create index myindex on mytable(docs)
  indextype is ctxsys.context
  parameters ('datastore COMMON_DIR'); 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006676"></a>
<div id="CCREF1923" class="sect2">
<h3 class="sect2"><span class="secnum">2.2.5</span> URL_DATASTORE <a id="sthref329"></a><a id="sthref330"></a></h3>
<p>Use the <code dir="ltr">URL_DATASTORE</code> type for text stored:</p>
<ul>
<li>
<p>In files on the World Wide Web (accessed through HTTP or FTP)</p>
</li>
<li>
<p>In files in the local file system (accessed through the file protocol)</p>
</li>
</ul>
<p>Store each URL in a single text field.</p>
<div id="CCREF1924" class="sect3"><a id="sthref331"></a>
<h4 class="sect3"><span class="secnum">2.2.5.1</span> URL Syntax<a id="sthref332"></a><a id="sthref333"></a></h4>
<p>The syntax of a URL you store in a text field is as follows (with brackets indicating optional parameters):</p>
<pre dir="ltr">
[URL:]&lt;access_scheme&gt;://&lt;host_name&gt;[:&lt;port_number&gt;]/[&lt;url_path&gt;]
</pre>
<p>The <code dir="ltr">access_scheme</code> string can be either <span class="italic">ftp, http,</span> or <span class="italic">file</span>. For example:</p>
<pre dir="ltr">
http://mymachine.example.com/home.html
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">login:password@</code> syntax within the URL is supported only for the ftp access scheme.</div>
<p>Because this syntax is partially compliant with the RFC 1738 specification, the following restriction holds for the URL syntax: The URL must contain only printable ASCII characters. Non-printable ASCII characters and multibyte characters must be escaped with the %<span class="italic">xx</span> notation, where <span class="italic">xx</span> is the hexadecimal representation of the special character.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1925" class="sect3"><a id="sthref334"></a>
<h4 class="sect3"><span class="secnum">2.2.5.2</span> URL_DATASTORE Attributes</h4>
<p><code dir="ltr">URL_DATASTORE</code> has the following attributes:</p>
<div id="CCREF23753" class="tblformal">
<p class="titleintable"><a id="sthref335"></a><a id="sthref336"></a>Table 2-5 URL_DATASTORE Attributes</p>
<table class="cellalignment103" title="URL_DATASTORE Attributes" summary="This table describes attributes for URL_DATASTORE." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t15">Attribute</th>
<th class="cellalignment97" id="r1c2-t15">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t15" headers="r1c1-t15">
<p><code dir="ltr">timeout</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t15 r1c2-t15">
<p>The value of this attribute is ignored. This is provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t15" headers="r1c1-t15">
<p><code dir="ltr">maxthreads</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t15 r1c2-t15">
<p>The value of this attribute is ignored. <code dir="ltr">URL_DATASTORE</code> is single-threaded. This is provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t15" headers="r1c1-t15">
<p><code dir="ltr">urlsize</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t15 r1c2-t15">
<p>The value of this attribute is ignored. This is provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t15" headers="r1c1-t15">
<p><code dir="ltr">maxurls</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t15 r1c2-t15">
<p>The value of this attribute is ignored. This is provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t15" headers="r1c1-t15">
<p><code dir="ltr">maxdocsize</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t15 r1c2-t15">
<p>The value of this attribute is ignored. This is provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t15" headers="r1c1-t15">
<p><code dir="ltr">http_proxy</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t15 r1c2-t15">
<p>Specify the host name of http proxy server. Optionally specify port number with a colon in the form <code dir="ltr">hostname:port</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t15" headers="r1c1-t15">
<p><code dir="ltr">ftp_proxy</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t15 r1c2-t15">
<p>Specify the host name of ftp proxy server. Optionally specify port number with a colon in the form <code dir="ltr">hostname:port</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t15" headers="r1c1-t15">
<p><code dir="ltr">no_proxy</code></p>
</td>
<td class="cellalignment98" headers="r9c1-t15 r1c2-t15">
<p>Specify the domain for no proxy server. Use a comma separated string of up to 16 domain names.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<dl>
<dt><a id="sthref337"></a><a id="sthref338"></a>timeout</dt>
<dd>
<p>The value of this attribute is ignored. This is provided for backward compatibility.</p>
</dd>
<dt><a id="sthref339"></a><a id="sthref340"></a>maxthreads</dt>
<dd>
<p>The value of this attribute is ignored. <code dir="ltr">URL_DATASTORE</code> is single-threaded. This is provided for backward compatibility.</p>
</dd>
<dt><a id="sthref341"></a><a id="sthref342"></a>urlsize</dt>
<dd>
<p>The value of this attribute is ignored. This is provided for backward compatibility.</p>
</dd>
<dt><a id="sthref343"></a><a id="sthref344"></a>maxdocsize</dt>
<dd>
<p>The value of this attribute is ignored. This is provided for backward compatibility.</p>
</dd>
<dt><a id="sthref345"></a>maxurls</dt>
<dd>
<p>The value of this attribute is ignored. This is provided for backward compatibility.</p>
</dd>
<dt><a id="sthref346"></a><a id="sthref347"></a>http_proxy</dt>
<dd>
<p>Specify the fully qualified name of the host machine that serves as the HTTP proxy (gateway) for the machine on which Oracle Text is installed. You can optionally specify port number with a colon in the form <code dir="ltr">hostname:port</code>.</p>
<p>You must set this attribute if the machine is in an intranet that requires authentication through a proxy server to access Web files located outside the firewall.</p>
</dd>
<dt><a id="sthref348"></a><a id="sthref349"></a>ftp_proxy</dt>
<dd>
<p>Specify the fully qualified name of the host machine that serves as the FTP proxy (gateway) for the server on which Oracle Text is installed. You can optionally specify a port number with a colon in the form <code dir="ltr">hostname:port</code>.</p>
<p>This attribute must be set if the machine is in an intranet that requires authentication through a proxy server to access Web files located outside the firewall.</p>
</dd>
<dt><a id="sthref350"></a><a id="sthref351"></a>no_proxy</dt>
<dd>
<p>Specify a string of domains (up to sixteen, separated by commas) that are found in most, if not all, of the machines in your intranet. When one of the domains is encountered in a host name, no request is sent to the server(s) specified for <code dir="ltr">ftp_proxy</code> and <code dir="ltr">http_proxy</code>. Instead, the request is processed directly by the host machine identified in the URL.</p>
<p>For example, if the string <span class="italic">us.example.com</span>, <span class="italic">uk.example.com</span> is entered for <code dir="ltr">no_proxy</code>, any URL requests to machines that contain either of these domains in their host names are not processed by your proxy server(s).</p>
</dd>
</dl>
</div>
<!-- class="sect3" -->
<div id="CCREF1926" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref352"></a>
<h4 class="sect3"><span class="secnum">2.2.5.3</span> URL_DATASTORE and Security</h4>
<p>For a discussion of how to control file access security for file and URL datastores, refer to <a href="#BHCBIFEA">"FILE_DATASTORE and Security"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1927" class="sect3"><a id="sthref353"></a>
<h4 class="sect3"><span class="secnum">2.2.5.4</span> URL_DATASTORE Example<a id="sthref354"></a></h4>
<p>This example creates a <code dir="ltr">URL_DATASTORE</code> preference called <code dir="ltr">URL_PREF</code> for which the <code dir="ltr">http_proxy</code>, <code dir="ltr">no_proxy</code>, and <code dir="ltr">timeout</code> attributes are set. The defaults are used for the attributes that are not set.</p>
<pre dir="ltr">
begin
 ctx_ddl.create_preference('URL_PREF','URL_DATASTORE');
 ctx_ddl.set_attribute('URL_PREF','HTTP_PROXY','www-proxy.example.com');
 ctx_ddl.set_attribute('URL_PREF','NO_PROXY','example.com');
 ctx_ddl.set_attribute('URL_PREF','Timeout','300');
end;
</pre>
<p>Create the table and insert values into it:</p>
<pre dir="ltr">
create table urls(id number primary key, docs varchar2(2000));
insert into urls values(111555,'http://context.example.com');
insert into urls values(111556,'http://www.sun.com');
commit;
 
</pre>
<p>To create the index, specify <code dir="ltr">URL_PREF</code> as the datastore:</p>
<pre dir="ltr">
create index datastores_text on urls ( docs ) 
  indextype is ctxsys.context 
  parameters ( 'Datastore URL_PREF' ); 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006810"></a>
<div id="CCREF1928" class="sect2">
<h3 class="sect2"><span class="secnum">2.2.6</span> USER_DATASTORE<a id="sthref355"></a><a id="sthref356"></a></h3>
<p>Use the <code dir="ltr">USER_DATASTORE</code> type to define stored procedures that synthesize documents during indexing. For example, a user procedure might synthesize author, date, and text columns into one document to have the author and date information be part of the indexed text.</p>
<p><code dir="ltr">USER_DATASTORE</code> has the following attributes:</p>
<div id="CCREF23754" class="tblformal">
<p class="titleintable"><a id="sthref357"></a><a id="sthref358"></a>Table 2-6 USER_DATASTORE Attributes</p>
<table class="cellalignment103" title="USER_DATASTORE Attributes" summary="This table describes the attributes for th USER_DATASTORE preference." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t16">Attribute</th>
<th class="cellalignment97" id="r1c2-t16">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t16" headers="r1c1-t16">
<p><code dir="ltr">procedure</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t16 r1c2-t16">
<p>Specify the procedure that synthesizes the document to be indexed.</p>
<p>This procedure can be owned by any user and must be executable by the index owner.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t16" headers="r1c1-t16">
<p><code dir="ltr">output_type</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t16 r1c2-t16">
<p>Specify the data type of the second argument to <span class="syntaxinline">procedure</span>. Valid values are <code dir="ltr">CLOB</code>, <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB_LOC</code>, <code dir="ltr">BLOB_LOC</code>, or <code dir="ltr">VARCHAR2</code>. The default is <code dir="ltr">CLOB</code>.</p>
<p>When you specify <code dir="ltr">CLOB_LOC</code>, <code dir="ltr">BLOB_LOC</code>, you indicate that no temporary <code dir="ltr">CLOB</code> or <code dir="ltr">BLOB</code> is needed, because your procedure copies a locator to the <code dir="ltr">IN</code>/<code dir="ltr">OUT</code> second parameter.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<dl>
<dt><a id="sthref359"></a><a id="sthref360"></a>procedure</dt>
<dd>
<p>Specify the name of the procedure that synthesizes the document to be indexed. This specification must be in the form <code dir="ltr">PROCEDURENAME</code> or <code dir="ltr">PACKAGENAME.PROCEDURENAME</code>. You can also specify the schema owner name.</p>
<p>The procedure you specify must have two arguments defined as follows:</p>
<pre dir="ltr">
procedure (r IN ROWID, c IN OUT NOCOPY <span class="italic">output_type</span>)
</pre>
<p>The first argument <span class="syntaxinline">r</span> must be of type <code dir="ltr">ROWID</code>. The second argument <span class="syntaxinline">c</span> must be of type <code dir="ltr">output_type. NOCOPY</code> is a compiler hint that instructs Oracle Text to pass parameter c by reference if possible.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The procedure name and its arguments can be named anything. The arguments r and c are used in this example for simplicity.</div>
<p>The stored procedure is called once for each row indexed. Given the rowid of the current row, <code dir="ltr">procedure</code> must write the text of the document into its second argument, whose type you specify with <code dir="ltr">output_type</code>.</p>
</dd>
</dl>
<div id="CCREF1929" class="sect3"><a id="sthref361"></a>
<h4 class="sect3"><span class="secnum">2.2.6.1</span> Constraints</h4>
<p>The following constraints apply to <code dir="ltr">procedure</code>:</p>
<ul>
<li>
<p>It can be owned by any user, but the user must have database permissions to execute <code dir="ltr">procedure</code> correctly</p>
</li>
<li>
<p>It must be executable by the index owner</p>
</li>
<li>
<p>It must not enter DDL or transaction control statements, like <code dir="ltr">COMMIT</code></p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="CCREF1930" class="sect3"><a id="sthref362"></a>
<h4 class="sect3"><span class="secnum">2.2.6.2</span> Editing Procedure after Indexing</h4>
<p>When you change or edit the stored procedure, indexes based on it will not be notified, so you must manually re-create such indexes. So if the stored procedure makes use of other columns, and those column values change, the row will not be re-indexed. The row is re-indexed only when the indexed column changes.</p>
<dl>
<dt>output_type<a id="sthref363"></a><a id="sthref364"></a></dt>
<dd>
<p>Specify the datatype of the second argument to <code dir="ltr">procedure</code>. You can use either <code dir="ltr">CLOB</code>, <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB_LOC</code>, <code dir="ltr">BLOB_LOC</code>, or <code dir="ltr">VARCHAR2</code>.</p>
</dd>
</dl>
</div>
<!-- class="sect3" -->
<div id="CCREF1931" class="sect3"><a id="sthref365"></a>
<h4 class="sect3"><span class="secnum">2.2.6.3</span> USER_DATASTORE with CLOB Example<a id="sthref366"></a></h4>
<p>Consider a table in which the author, title, and text fields are separate, as in the <code dir="ltr">articles</code> table defined as follows:</p>
<pre dir="ltr">
create table articles( 
    id       number, 
    author   varchar2(80), 
    title    varchar2(120), 
    text     clob );
</pre>
<p>The author and title fields are to be part of the indexed document text. Assume user <code dir="ltr">appowner</code> writes a stored procedure with the user datastore interface that synthesizes a document from the text, author, and title fields:</p>
<pre dir="ltr">
create procedure myproc(rid in rowid, tlob in out clob nocopy) is 
  begin 
      for c1 in (select author, title, text from articles 
                  where rowid = rid) 
      loop 
</pre>
<pre dir="ltr">
   dbms_lob.writeappend(tlob, length(c1.title), c1.title);
   dbms_lob.writeappend(tlob, length(c1.author), c1.author);
   dbms_lob.writeappend(tlob, length(c1.text), c1.text);
</pre>
<pre dir="ltr">
       end loop; 
    end; 
 
</pre>
<p>This procedure takes in a rowid and a temporary <code dir="ltr">CLOB</code> locator, and concatenates all the article's columns into the temporary <code dir="ltr">CLOB</code>. The for loop executes only once.</p>
<p>The user <code dir="ltr">appowner</code> creates the preference as follows:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.create_preference('myud', 'user_datastore'); 
ctx_ddl.set_attribute('myud', 'procedure', 'myproc'); 
ctx_ddl.set_attribute('myud', 'output_type', 'CLOB'); 
</pre>
<pre dir="ltr">
end;
</pre>
<p>When <code dir="ltr">appowner</code> creates the index on <code dir="ltr">articles(text)</code> using this preference, the indexing operation sees author and title in the document text.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1932" class="sect3"><a id="sthref367"></a>
<h4 class="sect3"><span class="secnum">2.2.6.4</span> USER_DATASTORE with BLOB_LOC Example</h4>
<p>The following procedure might be used with <code dir="ltr">OUTPUT_TYPE</code> <code dir="ltr">BLOB_LOC</code>:</p>
<pre dir="ltr">
procedure myds(rid in rowid, dataout in out nocopy blob)
is
  l_dtype varchar2(10);
  l_pk    number;
begin
  select dtype, pk into l_dtype, l_pk from mytable where rowid = rid;
  if (l_dtype = 'MOVIE') then
    select movie_data into dataout from movietab where fk = l_pk;
  elsif (l_dtype = 'SOUND') then
    select sound_data into dataout from soundtab where fk = l_pk;
  end if;
end;
</pre>
<p>The user <code dir="ltr">appowner</code> creates the preference as follows:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.create_preference('myud', 'user_datastore'); 
ctx_ddl.set_attribute('myud', 'procedure', 'myproc'); 
ctx_ddl.set_attribute('myud', 'output_type', 'blob_loc'); 
</pre>
<pre dir="ltr">
end;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006926"></a>
<div id="CCREF1933" class="sect2">
<h3 class="sect2"><span class="secnum">2.2.7</span> <a id="sthref368"></a>NESTED_DATASTORE</h3>
<p>Use the nested datastore type to index documents stored as rows in a nested table.</p>
<div id="CCREF23755" class="tblformal">
<p class="titleintable"><a id="sthref369"></a><a id="sthref370"></a>Table 2-7 NESTED_DATASTORE Attributes</p>
<table class="cellalignment103" title="NESTED_DATASTORE Attributes" summary="This table describes NESTED_DATASTORE attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t18">Attribute</th>
<th class="cellalignment97" id="r1c2-t18">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t18" headers="r1c1-t18">
<p><a id="sthref371"></a><code dir="ltr">nested_column</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t18 r1c2-t18">
<p>Specify the name of the nested table column.This attribute is required. Specify only the column name. Do not specify schema owner or containing table name.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t18" headers="r1c1-t18">
<p><a id="sthref372"></a><code dir="ltr">nested_type</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t18 r1c2-t18">
<p>Specify the type of nested table. This attribute is required. You must provide owner name and type.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t18" headers="r1c1-t18">
<p><a id="sthref373"></a><code dir="ltr">nested_lineno</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t18 r1c2-t18">
<p>Specify the name of the attribute in the nested table that orders the lines. This is like <code dir="ltr">DETAIL_LINENO</code> in detail datastore. This attribute is required.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t18" headers="r1c1-t18">
<p><a id="sthref374"></a><code dir="ltr">nested_text</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t18 r1c2-t18">
<p>Specify the name of the column in the nested table type that contains the text of the line. This is like <code dir="ltr">DETAIL_TEXT</code> in detail datastore. This attribute is required. <code dir="ltr">LONG</code> column types are not supported as nested table text columns.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t18" headers="r1c1-t18">
<p><a id="sthref375"></a><code dir="ltr">binary</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t18 r1c2-t18">
<p>Specify <code dir="ltr">FALSE</code> for Oracle Text to automatically insert a newline character when synthesizing the document text. If you specify <code dir="ltr">TRUE</code>, Oracle Text does not do this. This attribute is not required. The default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>When using the nested table datastore, you must index a dummy column, because the extensible indexing framework disallows indexing the nested table column. See the example.</p>
<p>DML on the nested table is not automatically propagated to the dummy column used for indexing. For DML on the nested table to be propagated to the dummy column, your application code or trigger must explicitly update the dummy column.</p>
<p>Filter defaults for the index are based on the type of the <code dir="ltr">nested_text</code> column.</p>
<p>During validation, Oracle Text checks that the type exists and that the attributes you specify for <code dir="ltr">nested_lineno</code> and <code dir="ltr">nested_text</code> exist in the nested table type. Oracle Text does not check that the named nested table column exists in the indexed table.</p>
<div id="CCREF1934" class="sect3"><a id="sthref376"></a>
<h4 class="sect3"><span class="secnum">2.2.7.1</span> NESTED_DATASTORE Example<a id="sthref377"></a></h4>
<p>This section shows an example of using the <code dir="ltr">NESTED_DATASTORE</code> type to index documents stored as rows in a nested table.</p>
<div id="CCREF1935" class="sect4"><a id="sthref378"></a>
<h5 class="sect4"><span class="secnum">2.2.7.1.1</span> Create the Nested Table</h5>
<p>The following code creates a nested table and a storage table mytab for the nested table:</p>
<pre dir="ltr">
create type nt_rec as object (
  lno number, -- line number
  ltxt varchar2(80) -- text of line
);

create type nt_tab as table of nt_rec;
create table mytab (
   id number primary key, -- primary key
   dummy char(1), -- dummy column for indexing
   doc nt_tab -- nested table
)
nested table doc store as myntab;
</pre></div>
<!-- class="sect4" -->
<div id="CCREF1936" class="sect4"><a id="sthref379"></a>
<h5 class="sect4"><span class="secnum">2.2.7.1.2</span> Insert Values into Nested Table</h5>
<p>The following code inserts values into the nested table for the parent row with ID equal to 1.</p>
<pre dir="ltr">
insert into mytab values (1, null, nt_tab());
insert into table(select doc from mytab where id=1) values (1, 'the dog');
insert into table(select doc from mytab where id=1) values (2, 'sat on mat ');
commit;
</pre></div>
<!-- class="sect4" -->
<div id="CCREF1937" class="sect4"><a id="sthref380"></a>
<h5 class="sect4"><span class="secnum">2.2.7.1.3</span> Create Nested Table Preferences</h5>
<p>The following code sets the preferences and attributes for the <code dir="ltr">NESTED_DATASTORE</code> according to the definitions of the nested table type <code dir="ltr">nt_tab</code> and the parent table <code dir="ltr">mytab</code>:</p>
<pre dir="ltr">
begin
-- create nested datastore pref
ctx_ddl.create_preference('ntds','nested_datastore'); 

-- nest tab column in main table
ctx_ddl.set_attribute('ntds','nested_column', 'doc'); 

-- nested table type
ctx_ddl.set_attribute('ntds','nested_type', 'scott.nt_tab');

-- lineno column in nested table
ctx_ddl.set_attribute('ntds','nested_lineno','lno');

--text column in nested table
ctx_ddl.set_attribute('ntds','nested_text', 'ltxt');
end;
</pre></div>
<!-- class="sect4" -->
<div id="CCREF1938" class="sect4"><a id="sthref381"></a>
<h5 class="sect4"><span class="secnum">2.2.7.1.4</span> Create Index on Nested Table</h5>
<p>The following code creates the index using the nested table datastore:</p>
<pre dir="ltr">
create index myidx on mytab(dummy) -- index dummy column, not nest table
indextype is ctxsys.context parameters ('datastore ntds');
</pre></div>
<!-- class="sect4" -->
<div id="CCREF1939" class="sect4"><a id="sthref382"></a>
<h5 class="sect4"><span class="secnum">2.2.7.1.5</span> Query Nested Datastore</h5>
<p>The following select statement queries the index built from a nested table:</p>
<pre dir="ltr">
select * from mytab where contains(dummy, 'dog and mat')&gt;0;
-- returns document 1, because it has dog in line 1 and mat in line 2.
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007013"></a>
<div id="CCREF0210" class="sect1">
<h2 class="sect1"><span class="secnum">2.3</span> Filter Types<a id="sthref383"></a><a id="sthref384"></a></h2>
<p>Use the filter types to create preferences that determine how text is filtered for indexing. Filters enable word processor documents, formatted documents, plain text, HTML, and XML documents to be indexed.</p>
<p>For formatted documents, Oracle Text stores documents in their native format and uses filters to build interim plain text or HTML versions of the documents. Oracle Text indexes the words derived from the plain text or HTML version of the formatted document.</p>
<p>To create a filter preference, you must use one of the following types:</p>
<div id="CCREF23756" class="tblformal">
<p class="titleintable"><a id="sthref385"></a><a id="sthref386"></a>Table 2-8 Filter Types</p>
<table class="cellalignment103" title="Filter Types" summary="This table shows the various filter types available." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t19">Filter</th>
<th class="cellalignment97" id="r1c2-t19">When Used</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t19" headers="r1c1-t19">
<p><a href="#i1007067">CHARSET_FILTER</a></p>
</td>
<td class="cellalignment98" headers="r2c1-t19 r1c2-t19">
<p>Character set converting filter.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t19" headers="r1c1-t19">
<p><a href="#i1007132">AUTO_FILTER</a></p>
</td>
<td class="cellalignment98" headers="r3c1-t19 r1c2-t19">
<p>Auto filter for filtering formatted documents.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t19" headers="r1c1-t19">
<p><a href="#i1007244">NULL_FILTER</a></p>
</td>
<td class="cellalignment98" headers="r4c1-t19 r1c2-t19">
<p>No filtering required. Use for indexing plain text, HTML, or XML documents.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t19" headers="r1c1-t19">
<p><a href="#i1010601">MAIL_FILTER</a></p>
</td>
<td class="cellalignment98" headers="r5c1-t19 r1c2-t19">
<p>Use the <code dir="ltr">MAIL_FILTER</code> to transform RFC-822, RFC-2045 messages in to text that can be indexed.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t19" headers="r1c1-t19">
<p><a href="#i1007328">USER_FILTER</a></p>
</td>
<td class="cellalignment98" headers="r6c1-t19 r1c2-t19">
<p>User-defined external filter to be used for custom filtering.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t19" headers="r1c1-t19">
<p><a href="#i1007380">PROCEDURE_FILTER</a></p>
</td>
<td class="cellalignment98" headers="r7c1-t19 r1c2-t19">
<p>User-defined stored procedure filter to be used for custom filtering.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="i1007067"></a>
<div id="CCREF1940" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.1</span> CHARSET_FILTER <a id="sthref387"></a><a id="sthref388"></a></h3>
<p>Use the <code dir="ltr">CHARSET_FILTER</code> to convert documents from a non-database character set to the character set used by the database.</p>
<p><code dir="ltr">CHARSET_FILTER</code> has the attribute described in <a href="#BHCJEIGB">Table 2-9</a>.</p>
<div id="CCREF23757" class="tblformal">
<p class="titleintable"><a id="sthref389"></a><a id="BHCJEIGB"></a>Table 2-9 CHARSET_FILTER Attributes</p>
<table class="cellalignment103" title="CHARSET_FILTER Attributes" summary="This table shows CHARSET_FILTER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t20">Attribute</th>
<th class="cellalignment97" id="r1c2-t20">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t20" headers="r1c1-t20">
<p><a id="sthref390"></a><a id="sthref391"></a>charset</p>
</td>
<td class="cellalignment98" headers="r2c1-t20 r1c2-t20">
<p>Specify the Globalization Support name of source character set.</p>
<p>If you specify UTF16AUTO, then this filter automatically detects the if the character set is UTF16 big- or little-endian.</p>
<p>Specify JAAUTO for Japanese character set auto-detection. This filter automatically detects the custom character specification in JA16EUC or JA16SJIS and converts to the database character set. This filter is useful in Japanese when your data files have mixed character sets.</p>
<p>JAAUTO can only be specified on a database whose character set is JA16EUC, JA16SJIS, or UTF8.</p>
<p>Specify <code dir="ltr">AUTO</code> to have <code dir="ltr">CHARSET_FILTER</code> automatically detect and convert character sets that Oracle Database supports, as shown in <a href="#BHCJBIAA">Table 2-10</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>When the <code dir="ltr">charset</code> column or attribute is set to <code dir="ltr">AUTO</code>, the <code dir="ltr">CHARSET_FILTER</code> automatically detects the document character set and converts the document from the detected character set to the database character set. <code dir="ltr">CHARSET_FILTER</code> can detect the supported character sets shown in <a href="#BHCJBIAA">Table 2-10</a>.</p>
<div id="CCREF23758" class="tblformal">
<p class="titleintable"><a id="sthref392"></a><a id="BHCJBIAA"></a>Table 2-10 Character Sets Supported for CHARSET_FILTER Auto-detection</p>
<table class="cellalignment103" title="Character Sets Supported for CHARSET_FILTER Auto-detection" summary="Oracle-supported character sets for charset_filter auto-detection" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t21">Character Set</th>
<th class="cellalignment97" id="r1c2-t21"><br /></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t21" headers="r1c1-t21">
<p>AL16UTF16</p>
</td>
<td class="cellalignment98" headers="r2c1-t21 r1c2-t21">
<p>JA16EUC</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t21" headers="r1c1-t21">
<p>AL32UTF8</p>
</td>
<td class="cellalignment98" headers="r3c1-t21 r1c2-t21">
<p>JA16SJIS</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t21" headers="r1c1-t21">
<p>AR8ISO8859P6</p>
</td>
<td class="cellalignment98" headers="r4c1-t21 r1c2-t21">
<p>KO16KSC5601</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t21" headers="r1c1-t21">
<p>AR8MSWIN1256</p>
</td>
<td class="cellalignment98" headers="r5c1-t21 r1c2-t21">
<p>TH8TISASCII</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t21" headers="r1c1-t21">
<p>CL8ISO8859P5</p>
</td>
<td class="cellalignment98" headers="r6c1-t21 r1c2-t21">
<p>WE8ISO8859P1</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t21" headers="r1c1-t21">
<p>CL8KOI8R</p>
</td>
<td class="cellalignment98" headers="r7c1-t21 r1c2-t21">
<p>WE8ISO8859P9</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t21" headers="r1c1-t21">
<p>CL8MSWIN1251</p>
</td>
<td class="cellalignment98" headers="r8c1-t21 r1c2-t21">
<p>WE8MSWIN1252</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t21" headers="r1c1-t21">
<p>EE8ISO8859P2</p>
</td>
<td class="cellalignment98" headers="r9c1-t21 r1c2-t21">
<p>ZHS16CGB231280</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r10c1-t21" headers="r1c1-t21">
<p>EE8MSWIN1250</p>
</td>
<td class="cellalignment98" headers="r10c1-t21 r1c2-t21">
<p>ZHS32GB18030</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r11c1-t21" headers="r1c1-t21">
<p>EL8ISO8859P7</p>
</td>
<td class="cellalignment98" headers="r11c1-t21 r1c2-t21">
<p>ZHT16BIG5</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r12c1-t21" headers="r1c1-t21">
<p>EL8MSWIN1253</p>
</td>
<td class="cellalignment98" headers="r12c1-t21 r1c2-t21">
<p>WE8MSWIN1252</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG" href="../../server.112/e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information about the supported globalization character sets</div>
<div id="CCREF1941" class="sect3"><a id="sthref393"></a>
<h4 class="sect3"><span class="secnum">2.3.1.1</span> UTF-16 Big- and Little-Endian Detection<a id="sthref394"></a></h4>
<p>If your character set is UTF-16, then you can specify UTF16AUTO to automatically detect big- or little-endian data. Oracle Text does so by examining the first two bytes of the document row.</p>
<p>If the first two bytes are 0xFE, 0xFF, the document is recognized as big-endian and the remainder of the document minus those two bytes is passed on for indexing.</p>
<p>If the first two bytes are 0xFF, 0xFE, the document is recognized as little-endian and the remainder of the document minus those two bytes is passed on for indexing.</p>
<p>If the first two bytes are anything else, the document is assumed to be big-endian and the whole document including the first two bytes is passed on for indexing.</p>
</div>
<!-- class="sect3" -->
<a id="BHCIFFHE"></a>
<div id="CCREF1942" class="sect3">
<h4 class="sect3"><span class="secnum">2.3.1.2</span> Indexing Mixed-Character Set Columns<a id="sthref395"></a><a id="sthref396"></a></h4>
<p>A mixed character set column is one that stores documents of different character sets. For example, a text table might store some documents in WE8ISO8859P1 and others in UTF8.</p>
<p>To index a table of documents in different character sets, you must create your base table with a character set column. In this column, specify the document character set on a per-row basis. To index the documents, Oracle Text converts the documents into the database character set.</p>
<p>Character set conversion works with the <code dir="ltr">CHARSET_FILTER</code>. When the charset column is <code dir="ltr">NULL</code> or not recognized, Oracle Text assumes the source character set is the one specified in the <span class="syntaxinline">charset</span> attribute.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Character set conversion also works with the <code dir="ltr">AUTO_FILTER</code> when the document format column is set to <code dir="ltr">TEXT</code>.</div>
<div id="CCREF1943" class="sect4"><a id="sthref397"></a>
<h5 class="sect4"><span class="secnum">2.3.1.2.1</span> Indexing Mixed-Character Set Example<a id="sthref398"></a></h5>
<p>For example, create the table with a charset column:</p>
<pre dir="ltr">
create table hdocs (
     id number primary key,
     fmt varchar2(10),
     cset varchar2(20),
     text varchar2(80)
);
</pre>
<p>Create a preference for this filter:</p>
<pre dir="ltr">
begin
cxt_ddl.create_preference('cs_filter', 'CHARSET_FILTER');
ctx_ddl.set_attribute('cs_filter', 'charset', 'UTF8');
end;
/
</pre>
<p>Insert plain-text documents and name the character set:</p>
<pre dir="ltr">
insert into hdocs values(1, 'text', 'WE8ISO8859P1', '/docs/iso.txt');
insert into hdocs values (2, 'text', 'UTF8', '/docs/utf8.txt');
commit;
</pre>
<p>Create the index and name the charset column:</p>
<pre dir="ltr">
create index hdocsx on hdocs(text) indextype is ctxsys.context
  parameters ('datastore ctxsys.file_datastore 
  filter cs_filter 
  format column fmt
  charset column cset');
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007132"></a>
<div id="CCREF9902" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.2</span> AUTO_FILTER<a id="sthref399"></a><a id="sthref400"></a><a id="sthref401"></a><a id="sthref402"></a><a id="sthref403"></a></h3>
<p>The <code dir="ltr">AUTO_FILTER</code> is a universal filter that filters most document formats, including PDF and Microsoft Word documents. Use it for indexing both single-format and mixed-format columns. This filter automatically bypasses plain text, HTML, XHTML, SGML, and XML documents.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="afilsupt.htm#g639477">Appendix B, "Oracle Text Supported Document Formats"</a>, for a list of the formats supported by <code dir="ltr">AUTO_FILTER</code>, and to learn more about how to set up your environment</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <a id="sthref404"></a><a id="sthref405"></a><code dir="ltr">AUTO_FILTER</code> replaces the <code dir="ltr">INSO_FILTER</code>, which has been deprecated. While every effort has been made to ensure maximal backward compatibility between the two filters, so that applications using <code dir="ltr">INSO_FILTER</code> will continue to work without modification, some differences may arise. Users should therefore use <code dir="ltr">AUTO_FILTER</code> in their new programs and, when possible, replace instances of <code dir="ltr">INSO_FILTER</code>, and any system preferences or constants that make use of it, in older applications.</div>
<p>The <code dir="ltr">AUTO_FILTER</code> preference has the following attributes:</p>
<div id="CCREF23759" class="tblformal">
<p class="titleintable"><a id="sthref406"></a><a id="sthref407"></a>Table 2-11 AUTO_FILTER Attributes</p>
<table class="cellalignment103" title="AUTO_FILTER Attributes" summary="This table describes the AUTO_FILTER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t26">Attribute</th>
<th class="cellalignment97" id="r1c2-t26">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t26" headers="r1c1-t26">
<p><code dir="ltr">timeout</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t26 r1c2-t26">
<p>Specify the <code dir="ltr">AUTO_FILTER</code> timeout in seconds. Use a number between 0 and 42,949,672. Default is 120. Setting this value to 0 disables the feature.</p>
<p>How this wait period is used depends on how you set <code dir="ltr">timeout_type</code>.</p>
<p>This feature is disabled for rows for which the corresponding charset and format column cause the <code dir="ltr">AUTO_FILTER</code> to bypass the row, such as when format is marked <code dir="ltr">TEXT</code>.</p>
<p>Use this feature to prevent the Oracle Text indexing operation from waiting indefinitely on a hanging filter operation.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t26" headers="r1c1-t26">
<p><code dir="ltr">timeout_type</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t26 r1c2-t26">
<p>Specify either <code dir="ltr">HEURISTIC</code> or <code dir="ltr">FIXED</code>. Default is <code dir="ltr">HEURISTIC</code>.</p>
<p>Specify <code dir="ltr">HEURISTIC</code> for Oracle Text to check every <code dir="ltr">TIMEOUT</code> seconds if output from Outside In HTML Export has increased. The operation terminates for the document if output has not increased. An error is recorded in the <code dir="ltr">CTX_USER_INDEX_ERRORS</code> view and Oracle Text moves to the next document row to be indexed.</p>
<p>Specify <code dir="ltr">FIXED</code> to terminate the Outside In HTML Export processing after <code dir="ltr">TIMEOUT</code> seconds regardless of whether filtering was progressing normally or just hanging. This value is useful when indexing throughput is more important than taking the time to successfully filter large documents.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t26" headers="r1c1-t26">
<p><code dir="ltr">output_formatting</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t26 r1c2-t26">
<p>Setting this attribute has no effect on filter performance or filter output. It is maintained for backward compatibility.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="CCREF9903" class="sect3"><a id="sthref408"></a>
<h4 class="sect3"><span class="secnum">2.3.2.1</span> Indexing Formatted Documents</h4>
<p>To index a text column containing formatted documents such as Microsoft Word, use the <code dir="ltr">AUTO_FILTER</code>. This filter automatically detects the document format. Use the <a id="sthref409"></a><a id="sthref410"></a><code dir="ltr">CTXSYS</code>.<code dir="ltr">AUTO_FILTER</code> system-defined preference in the parameter clause as follows:</p>
<pre dir="ltr">
create index hdocsx on hdocs(text) indextype is ctxsys.context
  parameters ('datastore ctxsys.file_datastore 
  filter ctxsys.auto_filter');
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">CTXSYS.AUTO_FILTER</code> replaces <a id="sthref411"></a><code dir="ltr">CTXSYS.INSO_FILTER</code>, which has been deprecated. Programs making use of <code dir="ltr">CTXSYS.INSO_FILTER</code> should still work. New programs should use <code dir="ltr">CTXSYS.AUTO_FILTER</code>.</div>
</div>
<!-- class="sect3" -->
<div id="CCREF9904" class="sect3"><a id="sthref412"></a>
<h4 class="sect3"><span class="secnum">2.3.2.2</span> Explicitly Bypassing Plain Text or HTML in Mixed Format Columns<a id="sthref413"></a><a id="sthref414"></a><a id="sthref415"></a></h4>
<p>A mixed-format column is a text column containing more than one document format, such as a column that contains Microsoft Word, PDF, plain text, and HTML documents.</p>
<p>The <code dir="ltr">AUTO_FILTER</code> can index mixed-format columns, automatically bypassing plain text, HTML, and XML documents. However, if you prefer not to depend on the built-in bypass mechanism, you can explicitly tag your rows as text and cause the <code dir="ltr">AUTO_FILTER</code> to ignore the row and not process the document in any way.</p>
<p>The format column in the base table enables you to specify the type of document contained in the text column. You can specify the following document types: <code dir="ltr">TEXT</code>, <code dir="ltr">BINARY</code>, and <code dir="ltr">IGNORE</code>. During indexing, the <code dir="ltr">AUTO_FILTER</code> ignores any document typed <code dir="ltr">TEXT</code>, assuming the charset column is not specified. (The difference between a document with a <code dir="ltr">TEXT</code> format column type and one with an <code dir="ltr">IGNORE</code> type is that the <code dir="ltr">TEXT</code> document is indexed, but ignored by the filter, while the <code dir="ltr">IGNORE</code> document is not indexed at all. Use <code dir="ltr">IGNORE</code> to overlook documents such as image files, or documents in a language that you do not want to index. <code dir="ltr">IGNORE</code> can be used with any filter type.)</p>
<p>To set up the <code dir="ltr">AUTO_FILTER</code> bypass mechanism, you must create a format column in your base table.</p>
<p>For example:</p>
<pre dir="ltr">
create table hdocs (
     id number primary key,
     fmt varchar2(10),
     text varchar2(80)
);
</pre>
<p>Assuming you are indexing mostly Word documents, you specify <code dir="ltr">BINARY</code> in the format column to filter the Word documents. Alternatively, to have the <code dir="ltr">AUTO_FILTER</code> ignore an HTML document, specify <code dir="ltr">TEXT</code> in the format column.</p>
<p>For example, the following statements add two documents to the text table, assigning one format as <code dir="ltr">BINARY</code> and the other <code dir="ltr">TEXT</code>:</p>
<pre dir="ltr">
insert into hdocs values(1, 'binary', '/docs/myword.doc');
insert in hdocs values (2, 'text', '/docs/index.html');
commit;
</pre>
<p>To create the index, use <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> and specify the format column name in the parameter string:</p>
<pre dir="ltr">
create index hdocsx on hdocs(text) indextype is ctxsys.context
  parameters ('datastore ctxsys.file_datastore 
  filter ctxsys.auto_filter 
  format column fmt');
</pre>
<p>If you do not specify <code dir="ltr">TEXT</code> or <code dir="ltr">BINARY</code> for the format column, <code dir="ltr">BINARY</code> is used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You need not specify the format column in <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> when using the <code dir="ltr">AUTO_FILTER</code>.</div>
</div>
<!-- class="sect3" -->
<div id="CCREF9905" class="sect3"><a id="sthref416"></a>
<h4 class="sect3"><span class="secnum">2.3.2.3</span> Character Set Conversion With AUTO_FILTER<a id="sthref417"></a><a id="sthref418"></a></h4>
<p>The <code dir="ltr">AUTO_FILTER</code> converts documents to the database character set when the document format column is set to <code dir="ltr">TEXT</code>. In this case, the <code dir="ltr">AUTO_FILTER</code> looks at the charset column to determine the document character set.</p>
<p>If the charset column value is not an Oracle Text character set name, the document is passed through without any character set conversion.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You need not specify the charset column when using the <code dir="ltr">AUTO_FILTER</code>.</div>
<p>If you do specify the charset column and do not specify the format column, the <code dir="ltr">AUTO_FILTER</code> works like the <a href="#i1007067">CHARSET_FILTER</a>, except that in this case there is no Japanese character set auto-detection.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007067">"CHARSET_FILTER"</a>.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007244"></a>
<div id="CCREF1948" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.3</span> NULL_FILTER <a id="sthref419"></a></h3>
<p>Use the <code dir="ltr">NULL_FILTER</code> type when plain text or HTML is to be indexed and no filtering needs to be performed. <code dir="ltr">NULL_FILTER</code> has no attributes.</p>
<div id="CCREF1949" class="sect3"><a id="sthref420"></a>
<h4 class="sect3"><span class="secnum">2.3.3.1</span> Indexing HTML Documents<a id="sthref421"></a><a id="sthref422"></a><a id="sthref423"></a></h4>
<p>If your document set is entirely HTML, Oracle recommends that you use the <code dir="ltr">NULL_FILTER</code> in your filter preference.</p>
<p>For example, to index an HTML document set, specify the system-defined preferences for <code dir="ltr">NULL_FILTER</code> and <code dir="ltr">HTML_SECTION_GROUP</code> as follows:</p>
<pre dir="ltr">
create index myindex on docs(htmlfile) indextype is ctxsys.context 
  parameters('filter ctxsys.null_filter
  section group ctxsys.html_section_group');
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information on section groups and indexing HTML documents, see <a href="#i1009342">"Section Group Types"</a>.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1010601"></a>
<div id="CCREF1950" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.4</span> MAIL_FILTER<a id="sthref424"></a><a id="sthref425"></a><a id="sthref426"></a><a id="sthref427"></a><a id="sthref428"></a></h3>
<p>Use <code dir="ltr">MAIL_FILTER</code> to transform RFC-822, RFC-2045 messages into indexable text. The following limitations apply to the input:</p>
<ul>
<li>
<p>Documents must be US-ASCII</p>
</li>
<li>
<p>Lines must not be longer than 1024 bytes</p>
</li>
<li>
<p>Documents must be syntactically valid with regard to RFC-822.</p>
</li>
</ul>
<p>Behavior for invalid input is not defined. Some deviations may be robustly handled by the filter without error. Others may result in a fetch-time or filter-time error.</p>
<p>The <code dir="ltr">MAIL_FILTER</code> has the following attributes:</p>
<div id="CCREF23760" class="tblformal">
<p class="titleintable"><a id="sthref429"></a><a id="sthref430"></a>Table 2-12 MAIL_FILTER Attributes</p>
<table class="cellalignment103" title="MAIL_FILTER Attributes" summary="This table describes the MAIL_FILTER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t32">Attribute</th>
<th class="cellalignment97" id="r1c2-t32">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t32" headers="r1c1-t32">
<p><code dir="ltr">INDEX_FIELDS</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t32 r1c2-t32">
<p>Specify a colon-separated list of fields to preserve in the output. These fields are transformed to tag markup. For example, if <code dir="ltr">INDEX_FIELDS</code> is set to "FROM":</p>
<p><code dir="ltr">From: Scott Tiger</code></p>
<p>becomes:</p>
<p><code dir="ltr">&lt;FROM&gt;Scott Tiger&lt;/FROM&gt;</code></p>
<p>Only top-level fields are transformed in this way.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t32" headers="r1c1-t32">
<p><code dir="ltr">AUTO_FILTER_TIMEOUT</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t32 r1c2-t32">
<p>Specify a timeout value for the <code dir="ltr">AUTO_FILTER</code> filtering invoked by the mail filter. Default is 60. (Replaces the <code dir="ltr">INSO_TIMEOUT</code> attribute and is backward compatible with <code dir="ltr">INSO_TIMEOUT</code>.)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t32" headers="r1c1-t32">
<p><code dir="ltr">AUTO_FILTER_OUTPUT_FORMATTING</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t32 r1c2-t32">
<p><a id="sthref431"></a><a id="sthref432"></a><a id="sthref433"></a><a id="sthref434"></a>Specify either <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code>. Default is <code dir="ltr">TRUE</code>.</p>
<p>This attribute replaces the previous <code dir="ltr">INSO_OUTPUT_FORMATTING</code> attribute. However, it has no effect in the current release.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t32" headers="r1c1-t32">
<p><code dir="ltr">PART_FIELD_STYLE</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t32 r1c2-t32">
<p>Specify how fields occurring in lower-level parts and identified by the <code dir="ltr">INDEX_FIELDS</code> attribute should be transformed. The fields of the top-level message part identified by <code dir="ltr">INDEX_FIELDS</code> are always transformed to tag markup (see the previous description of <code dir="ltr">INDEX_FIELDS</code>); <code dir="ltr">PART_FIELD_STYLE</code> controls the transformation of subsequent parts; for example, attached e-mails.</p>
<p>Possible values include <code dir="ltr">IGNORE</code> (the default), in which the part fields are not included for indexing; <code dir="ltr">TAG</code>, in which the part field names are transformed to tags, as occurs with top-level part fields; <code dir="ltr">FIELD</code>, in which the part field names are preserved as fields, not as tags; and <code dir="ltr">TEXT</code>, in which the part field names are eliminated and only the field content is preserved for indexing. See <a href="#BHCJFFBB">"Mail_Filter Example"</a> for an example of how <code dir="ltr">PART_FIELD_STYLE</code> works.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="BHCFIAHF"></a>
<div id="CCREF1951" class="sect3">
<h4 class="sect3"><span class="secnum">2.3.4.1</span> Filter Behavior</h4>
<p>This filter behaves in the following way for each document:</p>
<ul>
<li>
<p>Read and remove header fields</p>
</li>
<li>
<p>Decode message body if needed, depending on Content-transfer-encoding field</p>
</li>
<li>
<p>Take action depending on the Content-Type field value and the user-specified behavior specified in a mail filter configuration file. (See <a href="#BHCJIBCD">"About the Mail Filter Configuration File"</a>.) The possible actions are:</p>
<ul>
<li>
<p>produce the body in the output text (<code dir="ltr">INCLUDE</code>). If no character set is encountered in the <code dir="ltr">INCLUDE</code> parts in the Content-Type header field, then Oracle defaults to the value specified in the character set column in the base table. Name your populated character set column in the parameter string of the <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> command.</p>
</li>
<li>
<p><code dir="ltr">AUTO_FILTER</code> the body contents (<code dir="ltr">AUTO_FILTER</code> directive).</p>
</li>
<li>
<p>remove the body contents from the output text (<code dir="ltr">IGNORE</code>)</p>
</li>
</ul>
</li>
<li>
<p>If no behavior is specified for the type in the configuration file, then the defaults are as follows:</p>
<ul>
<li>
<p>text/*: produce body in the output text</p>
</li>
<li>
<p>application/*: <code dir="ltr">AUTO_FILTER</code> the body contents</p>
</li>
<li>
<p>image/*, audio/*, video/*, model/*: ignore</p>
</li>
</ul>
</li>
<li>
<p>Multipart messages are parsed, and the mail filter applied recursively to each part. Each part is appended to the output.</p>
</li>
<li>
<p>All text produced will be charset-converted to the database character set, if needed.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BHCJIBCD"></a>
<div id="CCREF1952" class="sect3">
<h4 class="sect3"><span class="secnum">2.3.4.2</span> About the Mail Filter Configuration File<a id="sthref435"></a></h4>
<p>The <code dir="ltr">MAIL_FILTER</code> filter makes use of a mail filter configuration file, which contains directives specifying how a mail document should be filtered. The mail filter configuration file is a editable text file. Here you can override default behavior for each Content-Type. The configuration file also contains IANA-to-Oracle Globalization Support character set name mappings.</p>
<p>The location of the file must be in <code dir="ltr">ORACLE_HOME</code>/ctx/config. The name of the file to use is stored in the new system parameter <a id="sthref436"></a><code dir="ltr">MAIL_FILTER_CONFIG_FILE</code>. On install, this is set to drmailfl.txt, which has useful default contents.</p>
<p>Oracle recommends that you create your own mail filter configuration files to avoid overwrite by the installation of a new version or patch set. The mail filter configuration file should be in the database character set.</p>
<div id="CCREF1953" class="sect4"><a id="sthref437"></a>
<h5 class="sect4"><span class="secnum">2.3.4.2.1</span> Mail File Configuration File Structure</h5>
<p>The file has two sections, <code dir="ltr">BEHAVIOR</code> and <code dir="ltr">CHARSETS</code>. Indicate the start of the behavior section as follows:</p>
<pre dir="ltr">
[behavior]
</pre>
<p>Each line following starts with a mime type, then whitespace, then behavior specification. The <code dir="ltr">MIME</code> type can be a full <code dir="ltr">TYPE</code>/<code dir="ltr">SUBTYPE</code> or just <code dir="ltr">TYPE</code>, which will apply to all subtypes of that type. <code dir="ltr">TYPE</code>/<code dir="ltr">SUBTYPE</code> specification overrides <code dir="ltr">TYPE</code> specification, which overrides default behavior. Behavior can be <code dir="ltr">INCLUDE</code>, <code dir="ltr">AUTO_FILTER</code>, or <code dir="ltr">IGNORE</code> (see <a href="#BHCFIAHF">"Filter Behavior"</a> for definitions). For instance:</p>
<pre dir="ltr">
application/zip     IGNORE
application/msword  AUTO_FILTER
model               IGNORE
</pre>
<p>You cannot specify behavior for "multipart" or "message" types. If you do, such lines are ignored. Duplicate specification for a type replaces earlier specifications.</p>
<p>Comments can be included in the mail configuration file by starting lines with the # symbol.</p>
<p>The charset mapping section begins with</p>
<pre dir="ltr">
[charsets]
</pre>
<p>Lines consist of an IANA name, then whitespace, then an Oracle Globalization Support charset name, like:</p>
<pre dir="ltr">
US-ASCII     US7ASCI
ISO-8859-1   WE8ISO8859P1
</pre>
<p>This file is the only way the mail filter gets the mappings. There are no defaults.</p>
<p>When you change the configuration file, the changes affect only the documents indexed after that point. You must flush the shared pool after changing the file.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BHCJFFBB"></a>
<div id="CCREF1954" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">2.3.4.3</span> Mail_Filter Example</h4>
<p>Suppose there is an e-mail with the following form, in which other e-mails with different subject lines are attached to this e-mail:</p>
<pre dir="ltr">
To:  somebody@someplace
Subject:  mainheader
Content-Type:  multipart/mixed
. . .
Content-Type: text/plain
X-Ref:  some_value
Subject:  subheader 1
. . .
Content-Type:  text/plain
X-Control:  blah blah blah 
Subject:  subheader 2
. . .
</pre>
<p>Set <code dir="ltr">INDEX_FIELDS</code> to be "Subject" and, initially, <code dir="ltr">PART_FIELD_STYLE</code> to <code dir="ltr">IGNORE</code>.</p>
<pre dir="ltr">
CTX_DDL.CREATE_PREFERENCE('my_mail_filt', 'mail_filter');
CTX_DDL_SET_ATTRIBUTE(my_mail_filt', 'INDEX_FILES', 'subject');
CTX_DDL.SET ATTRIBUTE ('my_mail_filt', 'PART_FIELD_STYLE', 'ignore');
</pre>
<p>Now when the index is created, the file will be indexed as follows:</p>
<pre dir="ltr">
&lt;SUBJECT&gt;mainheader&lt;/SUBJECT&gt;
</pre>
<p>If <code dir="ltr">PART_FIELD_STYLE</code> is instead set to <code dir="ltr">TAG</code>, this becomes:</p>
<pre dir="ltr">
&lt;SUBJECT&gt;mainheader&lt;/SUBJECT&gt;
&lt;SUBJECT&gt;subheader1&lt;/SUBJECT&gt;
&lt;SUBJECT&gt;subheader2&lt;/SUBJECT&gt;
</pre>
<p>If <code dir="ltr">PART_FIELD_STYLE</code> is set to <code dir="ltr">FIELD</code> instead, this is the result:</p>
<pre dir="ltr">
&lt;SUBJECT&gt;mainheader&lt;SUBJECT&gt;
SUBJECT:subheader1
SUBJECT:subheader2
</pre>
<p>Finally, if <code dir="ltr">PART_FIELD_STYLE</code> is instead set to <code dir="ltr">TEXT</code>, then the result is:</p>
<pre dir="ltr">
&lt;SUBJECT&gt;mainheader&lt;/SUBJECT&gt;
subheader1
subheader2
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007328"></a>
<div id="CCREF1955" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.5</span> USER_FILTER<a id="sthref438"></a><a id="sthref439"></a></h3>
<p>Use the <code dir="ltr">USER_FILTER</code> type to specify an external filter for filtering documents in a column. <code dir="ltr">USER_FILTER</code> has the following attribute:</p>
<div id="CCREF23761" class="tblformal">
<p class="titleintable"><a id="sthref440"></a><a id="sthref441"></a>Table 2-13 USER_FILTER Attribute</p>
<table class="cellalignment103" title="USER_FILTER Attribute" summary="This table describes the USER_FILTER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t33">Attribute</th>
<th class="cellalignment97" id="r1c2-t33">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t33" headers="r1c1-t33">
<p><code dir="ltr">command</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t33 r1c2-t33">
<p>Specify the name of the filter executable.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotewarn">
<p class="notep1">CAUTION:</p>
<p class="warnsp">The <code dir="ltr">USER_FILTER</code> type introduces the potential for security threats. A database user granted the CTXAPP role could potentially use <code dir="ltr">USER_FILTER</code> to load a malicious application. Therefore, the DBA must safeguard against any combination of input and output file parameters that would enable the named filter executable to compromise system security.</p>
</div>
<dl>
<dt><a id="sthref442"></a><a id="sthref443"></a>command</dt>
<dd>
<p>Specify the executable for the single <a id="sthref444"></a>external filter that is used to filter all text stored in a column. If more than one document format is stored in the column, then the external filter specified for <code dir="ltr">command</code> must recognize and handle all such formats.</p>
<p>The executable that you specify must exist in the <code dir="ltr">$ORACLE_HOME/ctx/bin</code> directory on UNIX, and in the <code dir="ltr">%ORACLE_HOME%/ctx/bin</code> directory on Windows.</p>
<p>You must create your user-filter command with two parameters:</p>
<ul>
<li>
<p>The first parameter is the name of the input file to be read.</p>
</li>
<li>
<p>The second parameter is the name of the output file to be written to.</p>
</li>
</ul>
<p>If all the document formats are supported by <code dir="ltr">AUTO_FILTER</code>, then use <code dir="ltr">AUTO_FILTER</code> instead of <code dir="ltr">USER_FILTER</code>, unless additional tasks besides filtering are required for the documents.</p>
</dd>
</dl>
<div id="CCREF23762" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref445"></a>
<h4 class="sect3"><span class="secnum">2.3.5.1</span> Using USER_FILTER with Charset and Format Columns</h4>
<p><code dir="ltr">USER_FILTER</code> bypasses documents that do not need to be filtered. Its behavior is sensitive to the values of the format and charset columns. In addition, <code dir="ltr">USER_FILTER</code> performs character set conversion according to the charset column values.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF23763" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref446"></a>
<h4 class="sect3"><span class="secnum">2.3.5.2</span> Explicitly Bypassing Plain Text or HTML in Mixed Format Columns</h4>
<p>A mixed-format column is a text column containing more than one document format, such as a column that contains Microsoft Word, PDF, plain text, and HTML documents.</p>
<p>The <code dir="ltr">USER_FILTER</code> executable can index mixed-format columns, automatically bypassing textual documents. However, if you prefer not to depend on the built-in bypass mechanism, you can explicitly tag your rows as text and cause the <code dir="ltr">USER_FILTER</code> executable to ignore the row and not process the document in any way.</p>
<p>The format column in the base table enables you to specify the type of document contained in the text column. You can specify the following document types: <code dir="ltr">TEXT</code>, <code dir="ltr">BINARY</code>, and <code dir="ltr">IGNORE</code>. During indexing, the <code dir="ltr">USER_FILTER</code> executable ignores any document typed <code dir="ltr">TEXT</code>, assuming the charset column is not specified. (The difference between a document with a <code dir="ltr">TEXT</code> format column type and one with an <code dir="ltr">IGNORE</code> type is that the <code dir="ltr">TEXT</code> document is indexed, but ignored by the filter, while the <code dir="ltr">IGNORE</code> document is not indexed at all. Use <code dir="ltr">IGNORE</code> to overlook documents such as image files, or documents in a language that you do not want to index. <code dir="ltr">IGNORE</code> can be used with any filter type.</p>
<p>To set up the <code dir="ltr">USER_FILTER</code> bypass mechanism, you must create a format column in your base table. For example:</p>
<pre dir="ltr">
create table hdocs (
   id number primary key,
   fmt varchar2(10),
   text varchar2(80)
);
</pre>
<p>Assuming you are indexing mostly Word documents, you specify <code dir="ltr">BINARY</code> in the format column to filter the Word documents. Alternatively, to have the <code dir="ltr">USER_FILTER</code> executable ignore an HTML document, specify <code dir="ltr">TEXT</code> in the format column.</p>
<p>For example, the following statements add two documents to the text table, assigning one format as <code dir="ltr">BINARY</code> and the other <code dir="ltr">TEXT</code>:</p>
<pre dir="ltr">
insert into hdocs values(1, 'binary', '/docs/myword.doc');
insert into hdocs values(2, 'text', '/docs/index.html');
commit;
</pre>
<p>Assuming that this file is named <code dir="ltr">upcase.pl</code>, create the filter preference as follows:</p>
<pre dir="ltr">
ctx_ddl.create_preference
   (
    preference_name =&gt; 'USER_FILTER_PREF',
    object_name     =&gt; 'USER_FILTER'
    );

ctx_ddl.set_attribute ('USER_FILTER_PREF', 'COMMAND', 'upcase.pl');
</pre>
<p>To create the index, use <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> and specify the format column name in the parameter string:</p>
<pre dir="ltr">
create index hdocsx on hdocs(text) indextype is ctxsys.context
   parameters ('datastore ctxsys.file_datastore
   filter 'USER_FILTER_PREF'
   format column fmt');
</pre>
<p>If you do not specify <code dir="ltr">TEXT</code> or <code dir="ltr">BINARY</code> for the format column, <code dir="ltr">BINARY</code> is used.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF23764" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref447"></a>
<h4 class="sect3"><span class="secnum">2.3.5.3</span> Character Set Conversion with USER_FILTER</h4>
<p>The <code dir="ltr">USER_FILTER</code> executable converts documents to the database character set when the document format column is set to <code dir="ltr">TEXT</code>. In this case, the <code dir="ltr">USER_FILTER</code> executable looks at the charset column to determine the document character set.</p>
<p>If the charset column value is not an Oracle Text character set name, the document is passed through without any character set conversion.</p>
<p>If you do specify the charset column and do not specify the format column, the <code dir="ltr">USER_FILTER</code> executable works like the <code dir="ltr">CHARSET_FILTER</code>, except that in this case, there is no Japanese character set auto-detection. See <a href="#i1007067">"CHARSET_FILTER"</a> for more information regarding <code dir="ltr">CHARSET_FILTER</code>.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1956" class="sect3"><a id="sthref448"></a>
<h4 class="sect3"><span class="secnum">2.3.5.4</span> User Filter Example<a id="sthref449"></a></h4>
<p>The following example shows a Perl script to be used as the user filter. This script converts the input text file specified in the first argument to uppercase and writes the output to the location specified in the second argument.</p>
<pre dir="ltr">
#!/usr/local/bin/perl

open(IN, $ARGV[0]);
open(OUT, "&gt;".$ARGV[1]);

while (&lt;IN&gt;)
{
  tr/a-z/A-Z/;
  print OUT;
}

close (IN);
close (OUT);
</pre>
<p>Assuming that this file is named <code dir="ltr">upcase.pl</code>, create the filter preference as follows:</p>
<pre dir="ltr">
begin 
  ctx_ddl.create_preference 
    ( 
      preference_name =&gt; 'USER_FILTER_PREF', 
      object_name     =&gt; 'USER_FILTER' 
    ); 
  ctx_ddl.set_attribute
    ('USER_FILTER_PREF','COMMAND','upcase.pl');
end; 
</pre>
<p>Create the index in SQL*Plus as follows:</p>
<pre dir="ltr">
create index user_filter_idx on user_filter ( docs ) 
  indextype is ctxsys.context 
  parameters ('FILTER USER_FILTER_PREF'); 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007380"></a>
<div id="CCREF1957" class="sect2">
<h3 class="sect2"><span class="secnum">2.3.6</span> PROCEDURE_FILTER<a id="sthref450"></a><a id="sthref451"></a></h3>
<p>Use the <code dir="ltr">PROCEDURE_FILTER</code> type to filter your documents with a stored procedure. The stored procedure is called each time a document needs to be filtered.</p>
<p><a href="#BHCGJDDJ">Table 2-14</a> lists the attributes for <code dir="ltr">PROCEDURE_FILTER</code>.</p>
<div id="CCREF23765" class="tblformal">
<p class="titleintable"><a id="sthref452"></a><a id="BHCGJDDJ"></a>Table 2-14 PROCEDURE_FILTER Attributes</p>
<table class="cellalignment103" title="PROCEDURE_FILTER Attributes" summary="This table describes the PROCEDURE_FILTER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t35">Attribute</th>
<th class="cellalignment97" id="r1c2-t35">Purpose</th>
<th class="cellalignment97" id="r1c3-t35">Allowable Values</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t35" headers="r1c1-t35">
<p><code dir="ltr">procedure</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t35 r1c2-t35">
<p>Name of the filter stored procedure.</p>
</td>
<td class="cellalignment98" headers="r2c1-t35 r1c3-t35">
<p>Any procedure. The procedure can be a PL/SQL stored procedure.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t35" headers="r1c1-t35">
<p><code dir="ltr">input_type</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t35 r1c2-t35">
<p>Type of input argument for stored procedure.</p>
</td>
<td class="cellalignment98" headers="r3c1-t35 r1c3-t35">
<p><code dir="ltr">VARCHAR2, BLOB, CLOB, FILE</code></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t35" headers="r1c1-t35">
<p><code dir="ltr">output_type</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t35 r1c2-t35">
<p>Type of output argument for stored procedure.</p>
</td>
<td class="cellalignment98" headers="r4c1-t35 r1c3-t35">
<p><code dir="ltr">VARCHAR2, CLOB, FILE</code></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t35" headers="r1c1-t35">
<p><code dir="ltr">rowid_parameter</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t35 r1c2-t35">
<p>Include rowid parameter?</p>
</td>
<td class="cellalignment98" headers="r5c1-t35 r1c3-t35">
<p><code dir="ltr">TRUE/FALSE</code></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t35" headers="r1c1-t35">
<p><code dir="ltr">format_parameter</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t35 r1c2-t35">
<p>Include format parameter?</p>
</td>
<td class="cellalignment98" headers="r6c1-t35 r1c3-t35">
<p><code dir="ltr">TRUE/FALSE</code></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t35" headers="r1c1-t35">
<p><code dir="ltr">charset_parameter</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t35 r1c2-t35">
<p>Include charset parameter?</p>
</td>
<td class="cellalignment98" headers="r7c1-t35 r1c3-t35">
<p><code dir="ltr">TRUE/FALSE</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<dl>
<dt>procedure</dt>
<dd>
<p>Specify the name of the stored procedure to use for filtering. The procedure can be a PL/SQL stored procedure. The procedure can be a safe callout, or call a safe callout.</p>
<p>With the <code dir="ltr">rowid_parameter</code>, <code dir="ltr">format_parameter</code>, and <code dir="ltr">charset_parameter</code> set to FALSE, the procedure can have one of the following signatures:</p>
<pre dir="ltr">
PROCEDURE(IN BLOB, IN OUT NOCOPY CLOB)
PROCEDURE(IN CLOB, IN OUT NOCOPY CLOB)
PROCEDURE(IN VARCHAR, IN OUT NOCOPY CLOB)
PROCEDURE(IN BLOB, IN OUT NOCOPY VARCHAR2)
PROCEDURE(IN CLOB, IN OUT NOCOPY VARCHAR2)
PROCEDURE(IN VARCHAR2, IN OUT NOCOPY VARCHAR2)
PROCEDURE(IN BLOB, IN VARCHAR2)
PROCEDURE(IN CLOB, IN VARCHAR2)
PROCEDURE(IN VARCHAR2, IN VARCHAR2)
</pre>
<p>The first argument is the content of the unfiltered row, output by the datastore. The second argument is for the procedure to pass back the filtered document text.</p>
<p>The procedure attribute is mandatory and has no default.</p>
</dd>
<dt>input_type</dt>
<dd>
<p>Specify the type of the input argument of the filter procedure. You can specify one of the following types:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="PROCEDURE_FILTER input_type types" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t36">Type</th>
<th class="cellalignment97" id="r1c2-t36">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t36" headers="r1c1-t36"><code dir="ltr">procedure</code></td>
<td class="cellalignment98" headers="r2c1-t36 r1c2-t36">Name of the filter stored procedure.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t36" headers="r1c1-t36"><code dir="ltr">input_type</code></td>
<td class="cellalignment98" headers="r3c1-t36 r1c2-t36">Type of input argument for stored procedure.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t36" headers="r1c1-t36"><code dir="ltr">output_type</code></td>
<td class="cellalignment98" headers="r4c1-t36 r1c2-t36">Type of output argument for stored procedure.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t36" headers="r1c1-t36"><code dir="ltr">rowid_parameter</code></td>
<td class="cellalignment98" headers="r5c1-t36 r1c2-t36">Include rowid parameter?</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>The <code dir="ltr">input_type</code> attribute is not mandatory. If not specified, then <code dir="ltr">BLOB</code> is the default.</p>
</dd>
<dt>output_type</dt>
<dd>
<p>Specify the type of output argument of the filter procedure. You can specify one of the following types:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="PROCEDURE_FILTER output_type types" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t37">Type</th>
<th class="cellalignment97" id="r1c2-t37">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t37" headers="r1c1-t37"><code dir="ltr">CLOB</code></td>
<td class="cellalignment98" headers="r2c1-t37 r1c2-t37">The output argument is <code dir="ltr">IN</code> <code dir="ltr">OUT</code> <code dir="ltr">NOCOPY</code> <code dir="ltr">CLOB</code>. Your procedure must write the filtered content to the <code dir="ltr">CLOB</code> passed in.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t37" headers="r1c1-t37"><code dir="ltr">VARCHAR2</code></td>
<td class="cellalignment98" headers="r3c1-t37 r1c2-t37">The output argument is <code dir="ltr">IN</code> <code dir="ltr">OUT</code> <code dir="ltr">NOCOPY</code> <code dir="ltr">VARCHAR2</code>. Your procedure must write the filtered content to the <code dir="ltr">VARCHAR2</code> variable passed in.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t37" headers="r1c1-t37"><code dir="ltr">FILE</code></td>
<td class="cellalignment98" headers="r4c1-t37 r1c2-t37">The output argument must be <code dir="ltr">IN</code> <code dir="ltr">VARCHAR2</code>. On entering the filter procedure, the output argument is the name of a temporary file. The filter procedure must write the filtered contents to this named file.
<p>Using a FILE output type is useful only when the procedure is a safe callout, which can write to the file.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>The <code dir="ltr">output_type</code> attribute is not mandatory. If not specified, then <code dir="ltr">CLOB</code> is the default.</p>
</dd>
<dt>rowid_ parameter</dt>
<dd>
<p>When you specify TRUE, the rowid of the document to be filtered is passed as the first parameter, before the input and output parameters.</p>
<p>For example, with <code dir="ltr">INPUT_TYPE</code> <code dir="ltr">BLOB</code>, <code dir="ltr">OUTPUT_TYPE</code> <code dir="ltr">CLOB</code>, and <code dir="ltr">ROWID_PARAMETER</code> <code dir="ltr">TRUE</code>, the filter procedure must have the signature as follows:</p>
<pre dir="ltr">
procedure(in rowid, in blob, in out nocopy clob)
</pre>
<p>This attribute is useful for when your procedure requires data from other columns or tables. This attribute is not mandatory. The default is <code dir="ltr">FALSE</code>.</p>
</dd>
<dt>format_parameter</dt>
<dd>
<p>When you specify <code dir="ltr">TRUE</code>, the value of the format column of the document being filtered is passed to the filter procedure before input and output parameters, but after the rowid parameter, if enabled.</p>
<p>Specify the name of the format column at index time in the parameters string, using the keyword <code dir="ltr">'format column &lt;columnname&gt;'</code>. The parameter type must be <code dir="ltr">IN</code> <code dir="ltr">VARCHAR2</code>.</p>
<p>The format column value can be read by means of the rowid parameter, but this attribute enables a single filter to work on multiple table structures, because the format attribute is abstracted and does not require the knowledge of the name of the table or format column.</p>
<p><code dir="ltr">FORMAT_PARAMETER</code>is not mandatory. The default is <code dir="ltr">FALSE</code>.</p>
</dd>
<dt>charset_parameter</dt>
<dd>
<p>When you specify <code dir="ltr">TRUE</code>, the value of the charset column of the document being filtered is passed to the filter procedure before input and output parameters, but after the rowid and format parameter, if enabled.</p>
<p>Specify the name of the charset column at index time in the parameters string, using the keyword <code dir="ltr">'charset column &lt;columnname&gt;'</code>. The parameter type must be <code dir="ltr">IN</code> <code dir="ltr">VARCHAR2</code>.</p>
<p><code dir="ltr">CHARSET_PARAMETER</code>attribute is not mandatory. The default is FALSE.</p>
</dd>
</dl>
<div id="CCREF1958" class="sect3"><a id="sthref453"></a>
<h4 class="sect3"><span class="secnum">2.3.6.1</span> Parameter Order</h4>
<p><code dir="ltr">ROWID_PARAMETER</code>, <code dir="ltr">FORMAT_PARAMETER</code>, and <code dir="ltr">CHARSET_PARAMETER</code>are all independent. The order is rowid, the format, then charset. However, the filter procedure is passed only the minimum parameters required.</p>
<p>For example, assume that <code dir="ltr">INPUT_TYPE</code> is <code dir="ltr">BLOB</code> and <code dir="ltr">OUTPUT_TYPE</code> is <code dir="ltr">CLOB</code>. If your filter procedure requires all parameters, then the procedure signature must be:</p>
<pre dir="ltr">
(id IN ROWID, format IN VARCHAR2, charset IN VARCHAR2, input IN BLOB, output IN
OUT NOCOPY CLOB)
</pre>
<p>If your procedure requires only the <code dir="ltr">ROWID</code>, then the procedure signature must be:</p>
<pre dir="ltr">
(id IN ROWID,input IN BLOB, ouput IN OUT NOCOPY CLOB)
</pre></div>
<!-- class="sect3" -->
<div id="CCREF1959" class="sect3"><a id="sthref454"></a>
<h4 class="sect3"><span class="secnum">2.3.6.2</span> Procedure Filter Execute Requirements</h4>
<p>To create an index using a <code dir="ltr">PROCEDURE_FILTER</code> preference, the index owner must have <span class="italic">execute</span> permission on the procedure.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1960" class="sect3"><a id="sthref455"></a>
<h4 class="sect3"><span class="secnum">2.3.6.3</span> Error Handling</h4>
<p>The filter procedure can raise any errors needed through the normal PL/SQL <code dir="ltr">raise_application_error</code> facility. These errors are propagated to the <a href="aviews.htm#i13049">CTX_USER_INDEX_ERRORS</a> view or reported to the user, depending on how the filter is invoked.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1961" class="sect3"><a id="sthref456"></a>
<h4 class="sect3"><span class="secnum">2.3.6.4</span> Procedure Filter Preference Example</h4>
<p>Consider a filter procedure <code dir="ltr">CTXSYS.NORMALIZE</code> that you define with the following signature:</p>
<pre dir="ltr">
PROCEDURE NORMALIZE(id IN ROWID, charset IN VARCHAR2, input IN CLOB, 
output IN OUT NOCOPY VARCHAR2);
</pre>
<p>To use this procedure as your filter, set up your filter preference as follows:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('myfilt', 'procedure_filter');
ctx_ddl.set_attribute('myfilt', 'procedure', 'normalize');
ctx_ddl.set_attribute('myfilt', 'input_type', 'clob');
ctx_ddl.set_attribute('myfilt', 'output_type', 'varchar2');
ctx_ddl.set_attribute('myfilt', 'rowid_parameter', 'TRUE');
ctx_ddl.set_attribute('myfilt', 'charset_parameter', 'TRUE');
end;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007538"></a>
<div id="CCREF0217" class="sect1">
<h2 class="sect1"><span class="secnum">2.4</span> Lexer Types<a id="sthref457"></a><a id="sthref458"></a><a id="sthref459"></a></h2>
<p>Use the lexer preference to specify the language of the text to be indexed. To create a lexer preference, you must use one of the lexer types described in <a href="#BHCIFHFF">Table 2-15</a>.</p>
<div id="CCREF23766" class="tblformal">
<p class="titleintable"><a id="sthref460"></a><a id="BHCIFHFF"></a>Table 2-15 Lexer Types</p>
<table class="cellalignment103" title="Lexer Types" summary="This table shows the various lexer types." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t38">Type</th>
<th class="cellalignment97" id="r1c2-t38">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t38" headers="r1c1-t38">
<p><a href="#i1007615">BASIC_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r2c1-t38 r1c2-t38">
<p>Lexer for extracting tokens from text in languages, such as English and most western European languages that use white space delimited words.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t38" headers="r1c1-t38">
<p><a href="#i1007955">MULTI_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r3c1-t38 r1c2-t38">
<p>Lexer for indexing tables containing documents of different languages such as English, German, and Japanese.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t38" headers="r1c1-t38">
<p><a href="#i1008019">CHINESE_VGRAM_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r4c1-t38 r1c2-t38">
<p>Lexer for extracting tokens from Chinese text.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t38" headers="r1c1-t38">
<p><a href="#i1008040">CHINESE_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r5c1-t38 r1c2-t38">
<p>Lexer for extracting tokens from Chinese text. This lexer offers benefits over the <code dir="ltr">CHINESE_VGRAM</code> lexer:</p>
<ul>
<li>
<p>Generates a smaller index</p>
</li>
<li>
<p>Better query response time</p>
</li>
<li>
<p>Generates real world tokens resulting in better query precision</p>
</li>
<li>
<p>Supports stop words</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t38" headers="r1c1-t38">
<p><a href="#i1017169">JAPANESE_VGRAM_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r6c1-t38 r1c2-t38">
<p>Lexer for extracting tokens from Japanese text.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t38" headers="r1c1-t38">
<p><a href="#i1008067">JAPANESE_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r7c1-t38 r1c2-t38">
<p>Lexer for extracting tokens from Japanese text. This lexer offers the following advantages over the <code dir="ltr">JAPANESE_VGRAM</code> lexer:</p>
<ul>
<li>
<p>Generates smaller index</p>
</li>
<li>
<p>Better query response time</p>
</li>
<li>
<p>Generates real world tokens resulting in better precision</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t38" headers="r1c1-t38">
<p><a href="#i1008175">KOREAN_MORPH_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r8c1-t38 r1c2-t38">
<p>Lexer for extracting tokens from Korean text.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t38" headers="r1c1-t38">
<p><a href="#i1008347">USER_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r9c1-t38 r1c2-t38">
<p>Lexer you create to index a particular language.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r10c1-t38" headers="r1c1-t38">
<p><a href="#BHCJEGFJ">WORLD_LEXER</a></p>
</td>
<td class="cellalignment98" headers="r10c1-t38 r1c2-t38">
<p>Lexer for indexing tables containing documents of different languages; autodetects languages in a document.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="i1007615"></a>
<div id="CCREF0218" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.1</span> <a id="sthref461"></a><a id="sthref462"></a>BASIC_LEXER</h3>
<p>Use the <code dir="ltr">BASIC_LEXER</code> type to identify tokens for creating Text indexes for English and all other supported whitespace-delimited languages.</p>
<p>The <code dir="ltr">BASIC_LEXER</code> also enables base-letter conversion, composite word indexing, case-sensitive indexing and alternate spelling for whitespace-delimited languages that have extended character sets.</p>
<p>In English and French, you can use the <code dir="ltr">BASIC_LEXER</code> to enable theme indexing.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Any processing that the lexer does to tokens before indexing (for example, removal of characters, and base-letter conversion) are also performed on query terms at query time. This ensures that the query terms match the form of the tokens in the Text index.</div>
<p><code dir="ltr"><a id="sthref463"></a><a id="sthref464"></a>BASIC_LEXER</code> supports any database character set.</p>
<p><code dir="ltr">BASIC_LEXER</code> has the attributes shown in <a href="#CIHHBAAD">Table 2-16</a>.</p>
<div id="CCREF23785" class="tblformal">
<p class="titleintable"><a id="sthref465"></a><a id="CIHHBAAD"></a>Table 2-16 BASIC_LEXER Attributes</p>
<table class="cellalignment103" title="BASIC_LEXER Attributes" summary="This table shows BASIC_LEXER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t40">Attribute</th>
<th class="cellalignment97" id="r1c2-t40">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t40" headers="r1c1-t40">
<p><code dir="ltr">continuation</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t40 r1c2-t40">
<p><span class="variable">characters</span></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t40" headers="r1c1-t40">
<p><code dir="ltr">numgroup</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t40 r1c2-t40">
<p><span class="variable">characters</span></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t40" headers="r1c1-t40">
<p><code dir="ltr">numjoin</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t40 r1c2-t40">
<p><span class="variable">characters</span></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t40" headers="r1c1-t40">
<p><code dir="ltr">printjoins</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t40 r1c2-t40">
<p><span class="variable">characters</span></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t40" headers="r1c1-t40">
<p><code dir="ltr">punctuations</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t40 r1c2-t40">
<p><span class="variable">characters</span></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t40" headers="r1c1-t40">
<p><code dir="ltr">skipjoins</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t40 r1c2-t40">
<p><span class="variable">characters</span></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t40" headers="r1c1-t40">
<p><code dir="ltr">startjoins</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t40 r1c2-t40">
<p><span class="variable">non alphanumeric characters that occur at the beginning of a token</span> (string)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t40" headers="r1c1-t40">
<p><code dir="ltr">endjoins</code></p>
</td>
<td class="cellalignment98" headers="r9c1-t40 r1c2-t40">
<p><span class="variable">non alphanumeric characters that occur at the end of a token</span> (string)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r10c1-t40" headers="r1c1-t40">
<p><code dir="ltr">whitespace</code></p>
</td>
<td class="cellalignment98" headers="r10c1-t40 r1c2-t40">
<p><span class="italic">characters</span> (string)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r11c1-t40" headers="r1c1-t40">
<p><code dir="ltr">newline</code></p>
</td>
<td class="cellalignment98" headers="r11c1-t40 r1c2-t40">
<p><span class="italic">NEWLINE (\n)</span></p>
<p><span class="italic">CARRIAGE_RETURN (\r)</span></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r12c1-t40" headers="r1c1-t40">
<p><code dir="ltr">base_letter</code></p>
</td>
<td class="cellalignment98" headers="r12c1-t40 r1c2-t40">
<p>NO (disabled)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r13c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r13c1-t40 r1c2-t40">
<p>YES (enabled)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r14c1-t40" headers="r1c1-t40">
<p><code dir="ltr">base_letter_type</code></p>
</td>
<td class="cellalignment98" headers="r14c1-t40 r1c2-t40">
<p>GENERIC (default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r15c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r15c1-t40 r1c2-t40">
<p>SPECIFIC</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r16c1-t40" headers="r1c1-t40">
<p><code dir="ltr">override_base_letter</code></p>
</td>
<td class="cellalignment98" headers="r16c1-t40 r1c2-t40">
<p>TRUE</p>
<p>FALSE (default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r17c1-t40" headers="r1c1-t40">
<p><code dir="ltr">mixed_case</code></p>
</td>
<td class="cellalignment98" headers="r17c1-t40 r1c2-t40">
<p>NO (disabled)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r18c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r18c1-t40 r1c2-t40">
<p>YES (enabled)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r19c1-t40" headers="r1c1-t40">
<p><code dir="ltr">composite</code></p>
</td>
<td class="cellalignment98" headers="r19c1-t40 r1c2-t40">
<p>DEFAULT (no composite word indexing, default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r20c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r20c1-t40 r1c2-t40">
<p>GERMAN (German composite word indexing)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r21c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r21c1-t40 r1c2-t40">
<p>DUTCH (Dutch composite word indexing)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r22c1-t40" headers="r1c1-t40">
<p><code dir="ltr"><a id="sthref466"></a>index_stems</code></p>
</td>
<td class="cellalignment98" headers="r22c1-t40 r1c2-t40">
<p>0 NONE</p>
<p>1 ENGLISH</p>
<p>2 DERIVATIONAL</p>
<p>3 DUTCH</p>
<p>4 FRENCH</p>
<p>5 GERMAN</p>
<p>6 ITALIAN</p>
<p>7 SPANISH</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r23c1-t40" headers="r1c1-t40">
<p><code dir="ltr">index_themes</code></p>
</td>
<td class="cellalignment98" headers="r23c1-t40 r1c2-t40">
<p>YES (enabled)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r24c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r24c1-t40 r1c2-t40">
<p>NO (disabled, default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r25c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r25c1-t40 r1c2-t40">
<p>NO (disabled, default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r26c1-t40" headers="r1c1-t40">
<p><code dir="ltr">index_text</code></p>
</td>
<td class="cellalignment98" headers="r26c1-t40 r1c2-t40">
<p>YES (enabled, default</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r27c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r27c1-t40 r1c2-t40">
<p>NO (disabled)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r28c1-t40" headers="r1c1-t40">
<p><code dir="ltr">prove_themes</code></p>
</td>
<td class="cellalignment98" headers="r28c1-t40 r1c2-t40">
<p>YES (enabled, default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r29c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r29c1-t40 r1c2-t40">
<p>NO (disabled)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r30c1-t40" headers="r1c1-t40">
<p><code dir="ltr">theme_language</code></p>
</td>
<td class="cellalignment98" headers="r30c1-t40 r1c2-t40">
<p>AUTO (default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r31c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r31c1-t40 r1c2-t40">
<p>(any Globalization Support language)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r32c1-t40" headers="r1c1-t40">
<p><code dir="ltr">alternate_spelling</code></p>
</td>
<td class="cellalignment98" headers="r32c1-t40 r1c2-t40">
<p>GERMAN (German alternate spelling)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r33c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r33c1-t40 r1c2-t40">
<p>DANISH (Danish alternate spelling)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r34c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r34c1-t40 r1c2-t40">
<p>SWEDISH (Swedish alternate spelling)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r35c1-t40" headers="r1c1-t40">&nbsp;</td>
<td class="cellalignment98" headers="r35c1-t40 r1c2-t40">
<p>NONE (No alternate spelling, default)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r36c1-t40" headers="r1c1-t40">
<p><code dir="ltr">new_german_spelling</code></p>
</td>
<td class="cellalignment98" headers="r36c1-t40 r1c2-t40">
<p>YES</p>
<p>NO (default)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<dl>
<dt><a id="sthref467"></a><a id="sthref468"></a><a id="sthref469"></a>continuation</dt>
<dd>
<p><span class="variable">S</span>pecify the characters that indicate a word continues on the next line and should be indexed as a single token. The most common continuation characters are hyphen '-' and backslash '\'.</p>
</dd>
<dt><a id="sthref470"></a><a id="sthref471"></a><a id="sthref472"></a>numgroup</dt>
<dd>
<p><span class="variable">S</span>pecify a single character that, when it appears in a string of digits, indicates that the digits are groupings within a larger single unit.</p>
<p>For example, comma ',' might be defined as a <code dir="ltr">numgroup</code> character because it often indicates a grouping of thousands when it appears in a string of digits.</p>
</dd>
<dt><a id="sthref473"></a><a id="sthref474"></a><a id="sthref475"></a>numjoin</dt>
<dd>
<p><span class="variable">S</span>pecify the characters that, when they appear in a string of digits, cause Oracle Text to index the string of digits as a single unit or word.</p>
<p>For example, period '.' can be defined as numjoin characters because it often serves as decimal points when it appears in a string of digits.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The default values for <code dir="ltr">numjoin</code> and <code dir="ltr">numgroup</code> are determined by the globalization support initialization parameters that are specified for the database.
<p>In general, a value need not be specified for either <code dir="ltr">numjoin</code> or <code dir="ltr">numgroup</code> when creating a lexer preference for <code dir="ltr">BASIC_LEXER</code>.</p>
</div>
</dd>
<dt><a id="sthref476"></a><a id="sthref477"></a><a id="sthref478"></a>printjoins</dt>
<dd>
<p><span class="variable">S</span>pecify the non alphanumeric characters that, when they appear anywhere in a word (beginning, middle, or end), are processed as alphanumeric and included with the token in the Text index. This includes <code dir="ltr">printjoins</code> that occur consecutively.</p>
<p>For example, if the hyphen '-' and underscore '_' characters are defined as <code dir="ltr">printjoins</code>, terms such as <span class="italic">pseudo-intellectual</span> and <span class="variable">_file_</span> are stored in the Text index as <span class="variable">pseudo-intellectual</span> and <span class="variable">_file_</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a <code dir="ltr">printjoins</code> character is also defined as a <code dir="ltr">punctuations</code> character, the character is only processed as an alphanumeric character if the character immediately following it is a standard alphanumeric character or has been defined as a <code dir="ltr">printjoins</code> or <code dir="ltr">skipjoins</code> character.</div>
</dd>
<dt><a id="sthref479"></a><a id="sthref480"></a><a id="sthref481"></a>punctuations</dt>
<dd>
<p>Specify a list of non-alphanumeric characters that, when they appear at the end of a word, indicate the end of a sentence. The defaults are period '.', question mark '?', and exclamation point '!'.</p>
<p>Characters that are defined as <code dir="ltr">punctuations</code> are removed from a token before text indexing. However, if a <code dir="ltr">punctuations</code> character is also defined as a <code dir="ltr">printjoins</code> character, then the character is removed only when it is the last character in the token.</p>
<p>For example, if the period (.) is defined as both a <code dir="ltr">printjoins</code> and a <code dir="ltr">punctuations</code> character, then the following transformations take place during indexing and querying as well:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="Sample Punctuation Transformation" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t43">Token</th>
<th class="cellalignment97" id="r1c2-t43">Indexed Token</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t43" headers="r1c1-t43">.doc</td>
<td class="cellalignment98" headers="r2c1-t43 r1c2-t43">.doc</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t43" headers="r1c1-t43">dog.doc</td>
<td class="cellalignment98" headers="r3c1-t43 r1c2-t43">dog.doc</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t43" headers="r1c1-t43">dog..doc</td>
<td class="cellalignment98" headers="r4c1-t43 r1c2-t43">dog..doc</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t43" headers="r1c1-t43">dog.</td>
<td class="cellalignment98" headers="r5c1-t43 r1c2-t43">dog</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t43" headers="r1c1-t43">dog...</td>
<td class="cellalignment98" headers="r6c1-t43 r1c2-t43">dog..</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>In addition, <code dir="ltr">BASIC_LEXER</code> use <code dir="ltr">punctuations</code> characters in conjunction with <code dir="ltr">newline</code> and <code dir="ltr">whitespace</code> characters to determine sentence and paragraph delimiters for sentence/paragraph searching.</p>
</dd>
<dt><a id="sthref482"></a><a id="sthref483"></a><a id="sthref484"></a>skipjoins</dt>
<dd>
<p>Specify the non-alphanumeric characters that, when they appear within a word, identify the word as a single token; however, the characters are not stored with the token in the Text index.</p>
<p>For example, if the hyphen character '-' is defined as a <code dir="ltr">skipjoins</code>, then the word <span class="italic">pseudo-intellectual</span> is stored in the Text index as <span class="italic">pseudointellectual</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">Printjoins</code> and <code dir="ltr">skipjoins</code> are mutually exclusive. The same characters cannot be specified for both attributes.</div>
</dd>
<dt><a id="sthref485"></a><a id="sthref486"></a><a id="sthref487"></a><a id="sthref488"></a><a id="sthref489"></a>startjoins/endjoins</dt>
<dd>
<p>For <code dir="ltr">startjoins</code>, specify the characters that when encountered as the first character in a token explicitly identify the start of the token. The character, as well as any other <code dir="ltr">startjoins</code> characters that immediately follow it, is included in the Text index entry for the token. In addition, the first <code dir="ltr">startjoins</code> character in a string of <code dir="ltr">startjoins</code> characters implicitly ends the previous token.</p>
<p>For <code dir="ltr">endjoins</code>, specify the characters that when encountered as the last character in a token explicitly identify the end of the token. The character, as well as any other <code dir="ltr">startjoins</code> characters that immediately follow it, is included in the Text index entry for the token.</p>
<p>The following rules apply to both <code dir="ltr">startjoins</code> and <code dir="ltr">endjoins</code>:</p>
</dd>
</dl>
<ul>
<li>
<p>The characters specified for <code dir="ltr">startjoins</code>/<code dir="ltr">endjoins</code> cannot occur in any of the other attributes for <code dir="ltr">BASIC_LEXER</code>.</p>
</li>
<li>
<p><code dir="ltr">startjoins</code>/<code dir="ltr">endjoins</code> characters can occur only at the beginning or end of tokens</p>
</li>
</ul>
<p>Printjoins differ from endjoins and startjoins in that position does not matter. For example, <span class="italic">$35</span> will be indexed as one token if <span class="italic">$</span> is a <code dir="ltr">startjoin</code> or a <code dir="ltr">printjoin</code>, but as two tokens if it is defined as an <code dir="ltr">endjoin</code>.</p>
<dl>
<dt><a id="sthref490"></a><a id="sthref491"></a><a id="sthref492"></a>whitespace</dt>
<dd>
<p><span class="italic">S</span>pecify the characters that are treated as blank spaces between tokens. <code dir="ltr">BASIC_LEXER</code> uses <code dir="ltr">whitespace</code> characters in conjunction with <code dir="ltr">punctuations</code> and <code dir="ltr">newline</code> characters to identify character strings that serve as sentence delimiters for sentence and paragraph searching.</p>
<p>The predefined default values for <code dir="ltr">whitespace</code> are <code dir="ltr">space</code> and <code dir="ltr">tab</code>. These values cannot be changed. Specifying characters as <code dir="ltr">whitespace</code> characters adds to these defaults.</p>
</dd>
<dt><a id="sthref493"></a><a id="sthref494"></a><a id="sthref495"></a>newline</dt>
<dd>
<p><span class="italic">S</span>pecify the characters that indicate the end of a line of text. <code dir="ltr">BASIC_LEXER</code> uses <code dir="ltr">newline</code> characters in conjunction with punctuations and whitespace characters to identify character strings that serve as paragraph delimiters for sentence and paragraph searching.</p>
<p>The only valid values for <code dir="ltr">newline</code> are <code dir="ltr">NEWLINE</code> and <code dir="ltr">CARRIAGE_RETURN</code> (for carriage returns). The default is <code dir="ltr">NEWLINE</code>.</p>
</dd>
<dt><a id="sthref496"></a><a id="sthref497"></a>base_letter</dt>
<dd>
<p>Specify whether characters that have diacritical marks (umlauts, cedillas, acute accents, and so on) are converted to their base form before being stored in the Text index. The default is NO (base-letter conversion disabled). For more information on base-letter conversions and <code dir="ltr">base_letter_type</code>, see <a href="cspell.htm#CIHHECGC">Base-Letter Conversion</a>.</p>
</dd>
<dt><a id="sthref498"></a><a id="sthref499"></a>base_letter_type</dt>
<dd>
<p>Specify <code dir="ltr">GENERIC</code> or <code dir="ltr">SPECIFIC</code>.</p>
<p>The <code dir="ltr">GENERIC</code> value is the default and means that base letter transformation uses one transformation table that applies to all languages. For more information on base-letter conversions and <code dir="ltr">base_letter_type</code>, see <a href="cspell.htm#CIHHECGC">"Base-Letter Conversion"</a>.</p>
</dd>
<dt>override_base_letter</dt>
<dd>
<p>When <code dir="ltr">base_letter</code> is enabled at the same time as <code dir="ltr">alternate_spelling</code>, it is sometimes necessary to override <code dir="ltr">base_letter</code> to prevent unexpected results from serial transformations. See <a href="cspell.htm#CIHEFHFF">"Overriding Base-Letter Transformations with Alternate Spelling"</a>. Default is <code dir="ltr">FALSE</code>.</p>
</dd>
<dt><a id="sthref500"></a><a id="sthref501"></a><a id="sthref502"></a>mixed_case</dt>
<dd>
<p>Specify whether the lexer leaves the tokens exactly as they appear in the text or converts the tokens to all uppercase. The default is NO (tokens are converted to all uppercase).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Text ensures that word queries match the case sensitivity of the index being queried. As a result, if you enable case sensitivity for your Text index, queries against the index are always case sensitive.</div>
</dd>
<dt><a id="sthref503"></a><a id="sthref504"></a><a id="sthref505"></a><a id="sthref506"></a><a id="sthref507"></a>composite</dt>
<dd>
<p>Specify whether composite word indexing is disabled or enabled for either <code dir="ltr">GERMAN</code> or <code dir="ltr">DUTCH</code> text. The default is <code dir="ltr">DEFAULT</code> (composite word indexing disabled).</p>
<p>Words that are usually one entry in a German dictionary are not split into composite stems, while words that aren't dictionary entries are split into composite stems.</p>
<p>To retrieve the indexed composite stems, you must enter a stem query, such as <span class="italic">$bahnhof</span>. The language of the wordlist stemmer must match the language of the composite stems.</p>
</dd>
</dl>
<a id="BHCHCFHI"></a>
<div id="CCREF1966" class="sect3">
<h4 class="sect3"><span class="secnum">2.4.1.1</span> <a id="sthref508"></a><a id="sthref509"></a>Stemming User-Dictionaries</h4>
<p>You can create a user-dictionary for your own language to customize how words are decomposed. These dictionaries are shown in <a href="#BHCHJFEB">Table 2-17</a>.</p>
<div id="CCREF23786" class="tblformal">
<p class="titleintable"><a id="sthref510"></a><a id="BHCHJFEB"></a>Table 2-17 Stemming User-Dictionaries</p>
<table class="cellalignment103" title="Stemming User-Dictionaries" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t46">Dictionary</th>
<th class="cellalignment97" id="r1c2-t46">Stemmer</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t46" headers="r1c1-t46">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/frlx/drfr.dct</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t46 r1c2-t46">
<p>French</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t46" headers="r1c1-t46">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/delx/drde.dct</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t46 r1c2-t46">
<p>German</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t46" headers="r1c1-t46">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/nllx/drnl.dct</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t46 r1c2-t46">
<p>Dutch</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t46" headers="r1c1-t46">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/itlx/drit.dct</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t46 r1c2-t46">
<p>Italian</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t46" headers="r1c1-t46">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/eslx/dres.dct</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t46 r1c2-t46">
<p>Spanish</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t46" headers="r1c1-t46">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/enlx/dren.dct</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t46 r1c2-t46">
<p>English and Derivational</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Stemming user-dictionaries are not supported for languages other than those listed in <a href="#BHCHJFEB">Table 2-17</a>.</p>
<p>The format for the user dictionary is as follows:</p>
<pre dir="ltr">
output term &lt;tab&gt; input term
</pre>
<p>The individual parts of the decomposed word must be separated by the # character. The following example entries are for the German word <span class="italic">Hauptbahnhof</span>:</p>
<pre dir="ltr">
Hauptbahnhof&lt;tab&gt;Haupt#Bahnhof
Hauptbahnhofes&lt;tab&gt;Haupt#Bahnhof
Hauptbahnhof&lt;tab&gt;Haupt#Bahnhof
Hauptbahnhoefe&lt;tab&gt;Haupt#Bahnhof
</pre>
<dl>
<dt><a id="sthref511"></a><a id="sthref512"></a><a id="sthref513"></a><a id="sthref514"></a><a id="sthref515"></a>index_themes</dt>
<dd>
<p>Specify <code dir="ltr">YES</code> to index theme information in English or French. This makes <code dir="ltr">ABOUT</code> queries more precise. The <code dir="ltr">index_themes</code> and <code dir="ltr">index_text</code> attributes cannot both be <code dir="ltr">NO</code>. The default is <code dir="ltr">YES</code>.</p>
<p>You can set this parameter to <code dir="ltr">TRUE</code> for any index type, including <code dir="ltr">CTXCAT</code>. To enter an <code dir="ltr">ABOUT</code> query with <code dir="ltr">CATSEARCH</code>, use the query template with <code dir="ltr">CONTEXT</code> grammar.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">index_themes</code> requires an installed knowledge base. A knowledge base may or may not have been installed with Oracle Text. For more information on knowledge bases, see <a class="olink CCAPP0900" href="../../text.112/e24435/cthes.htm#CCAPP0900"><span class="italic">Oracle Text Application Developer's Guide</span></a>.</div>
</dd>
<dt><a id="sthref516"></a><a id="sthref517"></a>prove_themes</dt>
<dd>
<p>Specify <code dir="ltr">YES</code> to prove themes. Theme proving attempts to find related themes in a document. When no related themes are found, parent themes are eliminated from the document.</p>
<p>While theme proving is acceptable for large documents, short text descriptions with a few words rarely prove parent themes, resulting in poor recall performance with <code dir="ltr">ABOUT</code> queries.</p>
<p>Theme proving results in higher precision and less recall (less rows returned) for <code dir="ltr">ABOUT</code> queries. For higher recall in <code dir="ltr">ABOUT</code> queries and possibly less precision, you can disable theme proving. Default is <code dir="ltr">YES</code>.</p>
<p>The <code dir="ltr">prove_themes</code> attribute is supported for <code dir="ltr">CONTEXT</code> and <code dir="ltr">CTXRULE</code> indexes.</p>
</dd>
<dt><a id="sthref518"></a>theme_language</dt>
<dd>
<p>Specify which knowledge base to use for theme generation when <code dir="ltr">index_themes</code> is set to <code dir="ltr">YES</code>. When <code dir="ltr">index_themes</code> is <code dir="ltr">NO</code>, setting this parameter has no effect on anything.</p>
<p>Specify any globalization support language or <code dir="ltr">AUTO</code>. You must have a knowledge base for the language you specify. This release provides a knowledge base in only English and French. In other languages, you can create your own knowledge base.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cexec.htm#i1006464">"Adding a Language-Specific Knowledge Base"</a> in <a href="cexec.htm#BABCABHG">Chapter 14, "Oracle Text Utilities"</a>.</div>
<p>The default is <code dir="ltr">AUTO</code>, which instructs the system to set this parameter according to the language of the environment.</p>
</dd>
<dt><a id="sthref519"></a><a id="sthref520"></a>index_stems</dt>
<dd>
<p>Specify the stemmer to use for stem indexing. Choose one of the following stemmers:</p>
<div class="inftblsimple">
<table class="cellalignment104" title="List of stemmers" summary="List of languages that have a stemmer." dir="ltr">
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98">
<ul>
<li>NONE</li>
<li>
<p>DERIVATIONAL</p>
</li>
<li>
<p>DUTCH</p>
</li>
<li>
<p>ENGLISH</p>
</li>
<li>
<p>FRENCH</p>
</li>
</ul>
</td>
<td class="cellalignment98">
<ul>
<li>GERMAN</li>
<li>
<p>ITALIAN</p>
</li>
<li>
<p>NORWEGIAN</p>
</li>
<li>
<p>SPANISH</p>
</li>
<li>
<p>SWEDISH</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblsimple" --></dd>
</dl>
<p>Tokens are stemmed to a single base form at index time in addition to the normal forms. Indexing stems enables better query performance for stem ($) queries, such as <span class="italic">$computed</span>.</p>
<dl>
<dt><a id="sthref521"></a><a id="sthref522"></a><a id="sthref523"></a>index_text</dt>
<dd>
<p>Specify <code dir="ltr">YES</code> to index word information. The <span class="syntaxinline">index_themes</span> and <span class="syntaxinline">index_text</span> attributes cannot both be <code dir="ltr">NO</code>.</p>
<p>The default is <code dir="ltr">NO</code>.</p>
</dd>
<dt><a id="sthref524"></a><a id="sthref525"></a><a id="sthref526"></a>alternate_spelling</dt>
<dd>
<p>Specify either <code dir="ltr">GERMAN</code>, <code dir="ltr">DANISH</code>, or <code dir="ltr">SWEDISH</code> to enable the alternate spelling in one of these languages. Enabling alternate spelling enables you to query a word in any of its alternate forms.</p>
<p>Alternate spelling is off by default; however, in the language-specific scripts that Oracle provides in <code dir="ltr">admin/defaults</code> (<code dir="ltr">drdefd.sql</code> for German, <code dir="ltr">drdefdk.sql</code> for Danish, and <code dir="ltr">drdefs.sql</code> for Swedish), alternate spelling is turned on. If your installation uses these scripts, then alternate spelling is on. However, you can specify <code dir="ltr">NONE</code> for no alternate spelling. For more information about the alternate spelling conventions Oracle Text uses, see <a href="cspell.htm#CIHBECGH">Alternate Spelling</a>.</p>
</dd>
<dt><a id="sthref527"></a><a id="sthref528"></a><a id="sthref529"></a><a id="sthref530"></a>new_german_spelling</dt>
<dd>
<p>Specify whether the queries using the <code dir="ltr">BASIC_LEXER</code> return both traditional and reformed (new) spellings of German words. If <code dir="ltr">new_german_spelling</code> is set to <code dir="ltr">YES</code>, then both traditional and new forms of words are indexed. If it is set to <code dir="ltr">NO</code>, then the word will be indexed only as it as provided in the query. The default is <code dir="ltr">NO</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cspell.htm#i634661">"New German Spelling"</a></div>
</dd>
</dl>
</div>
<!-- class="sect3" -->
<div id="CCREF1967" class="sect3"><a id="sthref531"></a>
<h4 class="sect3"><span class="secnum">2.4.1.2</span> <a id="sthref532"></a>BASIC_LEXER Example</h4>
<p>The following example sets printjoin characters and disables theme indexing with the <code dir="ltr">BASIC_LEXER</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('mylex', 'BASIC_LEXER');
ctx_ddl.set_attribute('mylex', 'printjoins', '_-');
ctx_ddl.set_attribute ( 'mylex', 'index_themes', 'NO');
ctx_ddl.set_attribute ( 'mylex', 'index_text', 'YES'); 
end;
</pre>
<p>To create the index with no theme indexing and with printjoin characters set as described, enter the following statement:</p>
<pre dir="ltr">
create index myindex on mytable ( docs ) 
  indextype is ctxsys.context 
  parameters ( 'LEXER mylex' ); 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007955"></a>
<div id="CCREF0219" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.2</span> <a id="sthref533"></a><a id="sthref534"></a><a id="sthref535"></a><a id="sthref536"></a>MULTI_LEXER</h3>
<p>Use <code dir="ltr">MULTI_LEXER</code> to index text columns that contain documents of different languages. For example, use this lexer to index a text column that stores English, German, and Japanese documents.</p>
<p>This lexer has no attributes.</p>
<p>You must have a language column in your base table. To index multi-language tables, specify the language column when you create the index.</p>
<p>Create a multi-lexer preference with <code dir="ltr">CTX_DDL.CREATE_PREFERENCE</code>. Add language-specific lexers to the multi-lexer preference with the <code dir="ltr">CTX_DDL.ADD_SUB_LEXER</code> procedure.</p>
<p>During indexing, the <code dir="ltr">MULTI_LEXER</code> examines each row's language column value and switches in the language-specific lexer to process the document.</p>
<p>The <code dir="ltr">WORLD_LEXER</code> lexer also performs multi-language indexing, but without the need for separate language columns (that is, it has automatic language detection). For more on <code dir="ltr">WORLD_LEXER</code>, see <a href="#BHCJEGFJ">"WORLD_LEXER"</a>.</p>
<div id="CCREF1968" class="sect3"><a id="sthref537"></a>
<h4 class="sect3"><span class="secnum">2.4.2.1</span> Multi-language Stoplists<a id="sthref538"></a><a id="sthref539"></a></h4>
<p>When you use the <code dir="ltr">MULTI_LEXER</code>, you can also use a multi-language stoplist for indexing.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1009534">"Multi-Language Stoplists"</a>.</div>
</div>
<!-- class="sect3" -->
<div id="CCREF1969" class="sect3"><a id="sthref540"></a>
<h4 class="sect3"><span class="secnum">2.4.2.2</span> MULTI_LEXER Example<a id="sthref541"></a><a id="sthref542"></a></h4>
<p>Create the multi-language table with a primary key, a text column, and a language column as follows:</p>
<pre dir="ltr">
create table globaldoc (
   doc_id number primary key,
   lang varchar2(3),
   text clob
);
</pre>
<p>Assume that the table holds mostly English documents, with the occasional German or Japanese document. To handle the three languages, you must create three sub-lexers, one for English, one for German, and one for Japanese:</p>
<pre dir="ltr">
ctx_ddl.create_preference('english_lexer','basic_lexer');
ctx_ddl.set_attribute('english_lexer','index_themes','yes');
ctx_ddl.set_attribute('english_lexer','theme_language','english');

ctx_ddl.create_preference('german_lexer','basic_lexer');
ctx_ddl.set_attribute('german_lexer','composite','german');
ctx_ddl.set_attribute('german_lexer','mixed_case','yes');
ctx_ddl.set_attribute('german_lexer','alternate_spelling','german');

ctx_ddl.create_preference('japanese_lexer','japanese_vgram_lexer');
</pre>
<p>Create the multi-lexer preference:</p>
<pre dir="ltr">
ctx_ddl.create_preference('global_lexer', 'multi_lexer');
</pre>
<p>Because the stored documents are mostly English, make the English lexer the default using CTX_DDL.<a href="cddlpkg.htm#i997457">ADD_SUB_LEXER</a>:</p>
<pre dir="ltr">
ctx_ddl.add_sub_lexer('global_lexer','default','english_lexer');
</pre>
<p>Now add the German and Japanese lexers in their respective languages with CTX_DDL.<a href="cddlpkg.htm#i997457">ADD_SUB_LEXER</a> procedure. Also assume that the language column is expressed in the standard ISO 639-2 language codes, so add those as alternative values.</p>
<pre dir="ltr">
ctx_ddl.add_sub_lexer('global_lexer','german','german_lexer','ger');
ctx_ddl.add_sub_lexer('global_lexer','japanese','japanese_lexer','jpn');
</pre>
<p>Now create the index <code dir="ltr">globalx</code>, specifying the multi-lexer preference and the language column in the parameter clause as follows:</p>
<pre dir="ltr">
create index globalx on globaldoc(text) indextype is ctxsys.context
parameters ('lexer global_lexer language column lang');
</pre></div>
<!-- class="sect3" -->
<div id="CCREF1970" class="sect3"><a id="sthref543"></a>
<h4 class="sect3"><span class="secnum">2.4.2.3</span> Querying Multi-Language Tables<a id="sthref544"></a></h4>
<p>At query time, the multi-lexer examines the language setting and uses the sub-lexer preference for that language to parse the query.</p>
<p>If the language is not set, then the default lexer is used. Otherwise, the query is parsed and run as usual. The index contains tokens from multiple languages, so such a query can return documents in several languages. To limit your query to a given language, use a structured clause on the language column.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008019"></a>
<div id="CCREF1971" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.3</span> <a id="sthref545"></a><a id="sthref546"></a>CHINESE_VGRAM_LEXER</h3>
<p>The <code dir="ltr">CHINESE_VGRAM_LEXER</code> type identifies tokens in Chinese text for creating Text indexes.</p>
<div id="CCREF1972" class="sect3"><a id="sthref547"></a>
<h4 class="sect3"><span class="secnum">2.4.3.1</span> CHINESE_VGRAM_LEXER Attribute</h4>
<p>The <code dir="ltr">CHINESE_VGRAM_LEXER</code> has the following attribute:</p>
<div id="CCREF23788" class="tblformal">
<p class="titleintable"><a id="sthref548"></a><a id="sthref549"></a>Table 2-18 CHINESE_VGRAM_LEXER Attributes</p>
<table class="cellalignment103" title="CHINESE_VGRAM_LEXER Attributes" summary="This table describes the CHINESE_VGRAM_LEXER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t52">Attribute</th>
<th class="cellalignment97" id="r1c2-t52">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t52" headers="r1c1-t52">
<p><code dir="ltr">mixed_case_ASCII7</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t52 r1c2-t52">
<p>Enable mixed-case (upper- and lower-case) searches of ASCII7 text (for example, <span class="italic">cat</span> and <span class="italic">Cat</span>). Allowable values are <code dir="ltr">YES</code> and <code dir="ltr">NO</code> (default).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF1973" class="sect3"><a id="sthref550"></a>
<h4 class="sect3"><span class="secnum">2.4.3.2</span> Character Sets</h4>
<p>You can use this lexer if your database uses one of the following character sets:<a id="sthref551"></a><a id="sthref552"></a></p>
<ul>
<li>
<p><a id="sthref553"></a>AL32UTF8</p>
</li>
<li>
<p><a id="sthref554"></a>ZHS16CGB231280</p>
</li>
<li>
<p><a id="sthref555"></a>ZHS16GBK</p>
</li>
<li>
<p><a id="sthref556"></a>ZHS32GB18030</p>
</li>
<li>
<p><a id="sthref557"></a>ZHT32EUC</p>
</li>
<li>
<p><a id="sthref558"></a>ZHT16BIG5</p>
</li>
<li>
<p><a id="sthref559"></a>ZHT32TRIS</p>
</li>
<li>
<p><a id="sthref560"></a>ZHT16HKSCS</p>
</li>
<li>
<p><a id="sthref561"></a>ZHT16MSWIN950</p>
</li>
<li>
<p>UTF8<a id="sthref562"></a></p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008040"></a>
<div id="CCREF1974" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.4</span> CHINESE_LEXER</h3>
<p>The <code dir="ltr">CHINESE_LEXER</code> type identifies tokens in traditional and simplified Chinese text for creating Oracle Text indexes.</p>
<p>This lexer offers the following benefits over the <code dir="ltr">CHINESE_VGRAM_LEXER</code>:</p>
<ul>
<li>
<p>generates a smaller index</p>
</li>
<li>
<p>better query response time</p>
</li>
<li>
<p>generates real word tokens resulting in better query precision</p>
</li>
<li>
<p>supports stop words</p>
</li>
</ul>
<p>Because the <code dir="ltr">CHINESE_LEXER</code> uses a different algorithm to generate tokens, indexing time is longer than with <code dir="ltr">CHINESE_VGRAM_LEXER</code>.</p>
<p>You can use this lexer if your database character is one of the Chinese or Unicode character sets supported by Oracle.</p>
<div id="CCREF1975" class="sect3"><a id="sthref563"></a>
<h4 class="sect3"><span class="secnum">2.4.4.1</span> <a id="sthref564"></a>CHINESE_LEXER Attribute</h4>
<p>The <code dir="ltr">CHINESE_LEXER</code> has the following attribute:</p>
<div id="CCREF23789" class="tblformal">
<p class="titleintable"><a id="sthref565"></a><a id="sthref566"></a>Table 2-19 CHINESE_LEXER Attributes</p>
<table class="cellalignment103" title="CHINESE_LEXER Attributes" summary="This table describes the CHINESE_VGRAM_LEXER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t53">Attribute</th>
<th class="cellalignment97" id="r1c2-t53">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t53" headers="r1c1-t53">
<p><code dir="ltr">mixed_case_ASCII7</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t53 r1c2-t53">
<p>Enable mixed-case (upper- and lower-case) searches of ASCII7 text (for example, <span class="italic">cat</span> and <span class="italic">Cat</span>). Allowable values are <code dir="ltr">YES</code> and <code dir="ltr">NO</code> (default).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF1976" class="sect3"><a id="sthref567"></a>
<h4 class="sect3"><span class="secnum">2.4.4.2</span> Customizing the Chinese Lexicon</h4>
<p>You can modify the existing lexicon (dictionary) used by the Chinese lexer, or create your own Chinese lexicon, with the <code dir="ltr">ctxlc</code> command.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cexec.htm#i1006575">"Lexical Compiler (ctxlc)"</a> in <a href="cexec.htm#BABCABHG">Chapter 14, "Oracle Text Utilities"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1017169"></a>
<div id="CCREF1977" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.5</span> <a id="sthref568"></a><a id="sthref569"></a>JAPANESE_VGRAM_LEXER</h3>
<p>The <code dir="ltr">JAPANESE_VGRAM_LEXER</code> type identifies tokens in Japanese for creating Text indexes. This lexer supports the stem ($) operator.</p>
<div id="CCREF1978" class="sect3"><a id="sthref570"></a>
<h4 class="sect3"><span class="secnum">2.4.5.1</span> <a id="sthref571"></a>JAPANESE_VGRAM_LEXER Attributes</h4>
<p>This lexer has the following attributes:</p>
<div id="CCREF23790" class="tblformal">
<p class="titleintable"><a id="sthref572"></a><a id="sthref573"></a>Table 2-20 JAPANESE_VGRAM_LEXER Attributes</p>
<table class="cellalignment103" title="JAPANESE_VGRAM_LEXER Attributes" summary="This table describes the JAPANESE_VGRAM_LEXER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t55">Attribute</th>
<th class="cellalignment97" id="r1c2-t55">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t55" headers="r1c1-t55">
<p><code dir="ltr">delimiter</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t55 r1c2-t55">
<p>Specify whether to consider certain Japanese blank characters, such as a full-width forward slash or a full-width middle dot. <code dir="ltr">ALL</code> considers these characters, while <code dir="ltr">NONE</code> ignores them. Default is <code dir="ltr">NONE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t55" headers="r1c1-t55">
<p><code dir="ltr">mixed_case_ASCII7</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t55 r1c2-t55">
<p>Enable mixed-case (upper- and lower-case) searches of ASCII7 text (for example, <span class="italic">cat</span> and <span class="italic">Cat</span>). Allowable values are <code dir="ltr">YES</code> and <code dir="ltr">NO</code> (default).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF1979" class="sect3"><a id="sthref574"></a>
<h4 class="sect3"><span class="secnum">2.4.5.2</span> JAPANESE_VGRAM_LEXER Character Sets</h4>
<p>You can use this lexer if your database uses one of the following character sets:<a id="sthref575"></a><a id="sthref576"></a></p>
<ul>
<li>
<p><a id="sthref577"></a>JA16SJIS</p>
</li>
<li>
<p><a id="sthref578"></a>JA16EUC</p>
</li>
<li>
<p>UTF8<a id="sthref579"></a></p>
</li>
<li>
<p><a id="sthref580"></a>AL32UTF8</p>
</li>
<li>
<p><a id="sthref581"></a>JA16EUCTILDE</p>
</li>
<li>
<p><a id="sthref582"></a>JA16EUCYEN</p>
</li>
<li>
<p><a id="sthref583"></a>JA16SJISTILDE</p>
</li>
<li>
<p><a id="sthref584"></a>JA16SJISYEN</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008067"></a>
<div id="CCREF1980" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.6</span> JAPANESE_LEXER<a id="sthref585"></a><a id="sthref586"></a><a id="sthref587"></a></h3>
<p>The <code dir="ltr">JAPANESE_LEXER</code> type identifies tokens in Japanese for creating Text indexes. This lexer supports the stem ($) operator.</p>
<p>This lexer offers the following benefits over the <code dir="ltr">JAPANESE_VGRAM_LEXER</code>:</p>
<ul>
<li>
<p>generates a smaller index</p>
</li>
<li>
<p>better query response time</p>
</li>
<li>
<p>generates real word tokens resulting in better query precision</p>
</li>
</ul>
<p>Because the <code dir="ltr">JAPANESE_LEXER</code> uses a new algorithm to generate tokens, indexing time is longer than with <code dir="ltr">JAPANESE_VGRAM_LEXER</code>.</p>
<div id="CCREF1981" class="sect3"><a id="sthref588"></a>
<h4 class="sect3"><span class="secnum">2.4.6.1</span> Customizing the Japanese Lexicon</h4>
<p>You can modify the existing lexicon (dictionary) used by the Japanese lexer, or create your own Japanese lexicon, with the <code dir="ltr">ctxlc</code> command.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cexec.htm#i1006575">"Lexical Compiler (ctxlc)"</a> in <a href="cexec.htm#BABCABHG">Chapter 14, "Oracle Text Utilities"</a></div>
</div>
<!-- class="sect3" -->
<div id="CCREF1982" class="sect3"><a id="sthref589"></a>
<h4 class="sect3"><span class="secnum">2.4.6.2</span> <a id="sthref590"></a>JAPANESE_LEXER Attributes</h4>
<p>This lexer has the following attributes:</p>
<div id="CCREF23791" class="tblformal">
<p class="titleintable"><a id="sthref591"></a><a id="sthref592"></a>Table 2-21 JAPANESE_LEXER Attributes</p>
<table class="cellalignment103" title="JAPANESE_LEXER Attributes" summary="This table describes the JAPANESE_LEXER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t57">Attribute</th>
<th class="cellalignment97" id="r1c2-t57">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t57" headers="r1c1-t57">
<p><code dir="ltr">delimiter</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t57 r1c2-t57">
<p>Specify <code dir="ltr">NONE</code> or <code dir="ltr">ALL</code> to ignore certain Japanese blank characters, such as a full-width forward slash or a full-width middle dot. Default is <code dir="ltr">NONE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t57" headers="r1c1-t57">
<p><code dir="ltr">mixed_case_ASCII7</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t57 r1c2-t57">
<p>Enable mixed-case (upper- and lower-case) searches of ASCII7 text (for example, <span class="italic">cat</span> and <span class="italic">Cat</span>). Allowable values are <code dir="ltr">YES</code> and <code dir="ltr">NO</code> (default).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF1983" class="sect3"><a id="sthref593"></a>
<h4 class="sect3"><span class="secnum">2.4.6.3</span> JAPANESE LEXER Character Sets</h4>
<p>The <code dir="ltr">JAPANESE_LEXER</code> supports the following character sets:</p>
<ul>
<li>
<p><a id="sthref594"></a>JA16SJIS</p>
</li>
<li>
<p><a id="sthref595"></a>JA16EUC</p>
</li>
<li>
<p>UTF8<a id="sthref596"></a></p>
</li>
<li>
<p><a id="sthref597"></a>AL32UTF8</p>
</li>
<li>
<p><a id="sthref598"></a>JA16EUCTILDE</p>
</li>
<li>
<p><a id="sthref599"></a>JA16EUCYEN</p>
</li>
<li>
<p><a id="sthref600"></a>JA16SJISTILDE</p>
</li>
<li>
<p><a id="sthref601"></a>JA16SJISYEN</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="CCREF1984" class="sect3"><a id="sthref602"></a>
<h4 class="sect3"><span class="secnum">2.4.6.4</span> Japanese Lexer Example</h4>
<p>When you specify <code dir="ltr">JAPANESE_LEXER</code> for creating text index, the <code dir="ltr">JAPANESE_LEXER</code> resolves a sentence into words.</p>
<p>For example, the following compound word (<span class="italic">natural language institute</span>)</p>
<img width="216" height="51" src="img/nihongo1.gif" alt="Description of nihongo1.gif follows" /><br />
<a id="sthref603" href="img_text/nihongo1.htm">Description of the illustration ''nihongo1.gif''</a><br />
<br />
<p>is indexed as three tokens:</p>
<img width="290" height="43" src="img/nihongo2.gif" alt="Description of nihongo2.gif follows" /><br />
<a id="sthref604" href="img_text/nihongo2.htm">Description of the illustration ''nihongo2.gif''</a><br />
<br />
<p>To resolve a sentence into words, the internal dictionary is referenced. When a word cannot be found in the internal dictionary, Oracle Text uses the <code dir="ltr">JAPANESE_VGRAM_LEXER</code> to resolve it.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008175"></a>
<div id="CCREF1985" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.7</span> KOREAN_MORPH_LEXER<a id="sthref605"></a><a id="sthref606"></a></h3>
<p>The <code dir="ltr">KOREAN_MORPH_LEXER</code> type identifies tokens in Korean text for creating Oracle Text indexes.</p>
<div id="CCREF1986" class="sect3"><a id="sthref607"></a>
<h4 class="sect3"><span class="secnum">2.4.7.1</span> Supplied Dictionaries<a id="sthref608"></a><a id="sthref609"></a></h4>
<p>The <code dir="ltr">KOREAN_MORPH_LEXER</code> uses four dictionaries:</p>
<div id="CCREF23792" class="tblformal">
<p class="titleintable"><a id="sthref610"></a><a id="sthref611"></a>Table 2-22 KOREAN_MORPH_LEXER Dictionaries</p>
<table class="cellalignment103" title="KOREAN_MORPH_LEXER Dictionaries" summary="This table describes the KOREAN_MORPH_LEXER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t58">Dictionary</th>
<th class="cellalignment97" id="r1c2-t58">File</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t58" headers="r1c1-t58">
<p>System</p>
</td>
<td class="cellalignment98" headers="r2c1-t58 r1c2-t58">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/kolx/drk2sdic.dat</code></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t58" headers="r1c1-t58">
<p>Grammar</p>
</td>
<td class="cellalignment98" headers="r3c1-t58 r1c2-t58">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/kolx/drk2gram.dat</code></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t58" headers="r1c1-t58">
<p>Stopword</p>
</td>
<td class="cellalignment98" headers="r4c1-t58 r1c2-t58">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/kolx/drk2xdic.dat</code></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t58" headers="r1c1-t58">
<p>User-defined</p>
</td>
<td class="cellalignment98" headers="r5c1-t58 r1c2-t58">
<p><code dir="ltr">$ORACLE_HOME/ctx/data/kolx/drk2udic.dat</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The grammar, user-defined, and stopword dictionaries should be written using the KSC 5601 or MSWIN949 character sets. You can modify these dictionaries using the defined rules. The system dictionary must not be modified.</p>
<p>You can add unregistered words to the user-defined dictionary file. The rules for specifying new words are in the file.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1987" class="sect3"><a id="sthref612"></a>
<h4 class="sect3"><span class="secnum">2.4.7.2</span> Supported Character Sets</h4>
<p>You can use <code dir="ltr">KOREAN_MORPH_LEXER</code> if your database uses one of the following character sets:<a id="sthref613"></a><a id="sthref614"></a></p>
<ul>
<li>
<p><a id="sthref615"></a>KO16KSC5601</p>
</li>
<li>
<p><a id="sthref616"></a>KO16MSWIN949</p>
</li>
<li>
<p>UTF8<a id="sthref617"></a></p>
</li>
<li>
<p><a id="sthref618"></a>AL32UTF8</p>
</li>
</ul>
<p>The <code dir="ltr">KOREAN_MORPH_LEXER</code> enables mixed-case searches.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1988" class="sect3"><a id="sthref619"></a>
<h4 class="sect3"><span class="secnum">2.4.7.3</span> <a id="sthref620"></a><a id="sthref621"></a><a id="sthref622"></a>Unicode Support</h4>
<p>The <code dir="ltr">KOREAN_MORPH_LEXER</code> supports:</p>
<ul>
<li>
<p>Words in non-KSC5601 Korean characters defined in Unicode</p>
</li>
<li>
<p>Supplementary characters</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For information on supplementary characters, see the <a class="olink NLSPG" href="../../server.112/e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a></div>
<p>Some Korean documents may have non-KSC5601 characters in them. As the <code dir="ltr">KOREAN_MORPH_LEXER</code> can recognize all possible 11,172 Korean (Hangul) characters, such documents can also be interpreted by using the UTF8 or AL32UTF8 character sets.</p>
<p>Use the AL32UTF8 character set for your database to extract surrogate characters. By default, the <code dir="ltr">KOREAN_MORPH_LEXER</code> extracts all series of surrogate characters in a document as one token for each series.</p>
<div id="CCREF1989" class="sect4"><a id="sthref623"></a>
<h5 class="sect4"><span class="secnum">2.4.7.3.1</span> Limitations on Korean Unicode Support</h5>
<p>For conversion Hanja to Hangul (Korean), the <code dir="ltr">KOREAN_MORPH_LEXER</code> supports only the 4888 Hanja characters defined in KSC5601.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="CCREF1990" class="sect3"><a id="sthref624"></a>
<h4 class="sect3"><span class="secnum">2.4.7.4</span> <a id="sthref625"></a>KOREAN_MORPH_LEXER Attributes</h4>
<p>When you use the <code dir="ltr">KOREAN_MORPH_LEXER</code>, you can specify the following attributes:</p>
<div id="CCREF23793" class="tblformal">
<p class="titleintable"><a id="sthref626"></a><a id="sthref627"></a>Table 2-23 KOREAN_MORPH_LEXER Attributes</p>
<table class="cellalignment103" title="KOREAN_MORPH_LEXER Attributes" summary="This table shows the KOREAN_MORPH_LEXER attributes" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t60">Attribute</th>
<th class="cellalignment97" id="r1c2-t60">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t60" headers="r1c1-t60">
<p><a id="sthref628"></a><code dir="ltr">verb_adjective</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code> to index verbs, adjectives, and adverbs. Default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t60" headers="r1c1-t60">
<p><a id="sthref629"></a><code dir="ltr">one_char_word</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code> to index one syllable. Default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t60" headers="r1c1-t60">
<p><a id="sthref630"></a><code dir="ltr">number</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code> to index number. Default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t60" headers="r1c1-t60">
<p><a id="sthref631"></a><code dir="ltr">user_dic</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code> to index user dictionary. Default is <code dir="ltr">TRUE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t60" headers="r1c1-t60">
<p><a id="sthref632"></a><code dir="ltr">stop_dic</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> of <code dir="ltr">FALSE</code> to use stop-word dictionary. Default is <code dir="ltr">TRUE</code>. The stop-word dictionary belongs to <code dir="ltr">KOREAN_MORPH_LEXER</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t60" headers="r1c1-t60">
<p><a id="sthref633"></a><code dir="ltr">composite</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t60 r1c2-t60">
<p>Specify indexing style of composite noun.</p>
<p>Specify <code dir="ltr">COMPOSITE_ONLY</code> to index only composite nouns.</p>
<p>Specify <code dir="ltr">NGRAM</code> to index all noun components of a composite noun.</p>
<p>Specify <code dir="ltr">COMPONENT_WORD</code> to index single noun components of composite nouns as well as the composite noun itself. Default is <code dir="ltr">COMPONENT_WORD</code>.</p>
<p>The following example describes the difference between <code dir="ltr">NGRAM</code> and <code dir="ltr">COMPONENT_WORD</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t60" headers="r1c1-t60">
<p><a id="sthref634"></a><code dir="ltr">morpheme</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code> for morphological analysis. If set to <code dir="ltr">FALSE</code>, tokens are created from the words that are divided by delimiters such as white space in the document. Default is <code dir="ltr">TRUE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t60" headers="r1c1-t60">
<p><a id="sthref635"></a><code dir="ltr">to_upper</code></p>
</td>
<td class="cellalignment98" headers="r9c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code> to convert English to uppercase. Default is <code dir="ltr">TRUE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r10c1-t60" headers="r1c1-t60">
<p><a id="sthref636"></a><code dir="ltr">hanja</code></p>
</td>
<td class="cellalignment98" headers="r10c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> to index hanja characters. If set to <code dir="ltr">FALSE</code>, hanja characters are converted to hangul characters. Default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r11c1-t60" headers="r1c1-t60">
<p><a id="sthref637"></a><code dir="ltr">long_word</code></p>
</td>
<td class="cellalignment98" headers="r11c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> to index long words that have more than 16 syllables in Korean. Default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r12c1-t60" headers="r1c1-t60">
<p><a id="sthref638"></a><code dir="ltr">japanese</code></p>
</td>
<td class="cellalignment98" headers="r12c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> to index Japanese characters in Unicode (only in the 2-byte area). Default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r13c1-t60" headers="r1c1-t60">
<p><a id="sthref639"></a><code dir="ltr">english</code></p>
</td>
<td class="cellalignment98" headers="r13c1-t60 r1c2-t60">
<p>Specify <code dir="ltr">TRUE</code> to index alphanumeric strings. Default is <code dir="ltr">TRUE</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF1991" class="sect3"><a id="sthref640"></a>
<h4 class="sect3"><span class="secnum">2.4.7.5</span> Limitations</h4>
<p>Sentence and paragraph sections are not supported with the <code dir="ltr">KOREAN_MORPH_LEXER</code>.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF1992" class="sect3"><a id="sthref641"></a>
<h4 class="sect3"><span class="secnum">2.4.7.6</span> <a id="sthref642"></a>KOREAN_MORPH_LEXER Example: Setting Composite Attribute</h4>
<p>Use the composite attribute to control how composite nouns are indexed.</p>
<div id="CCREF1993" class="sect4"><a id="sthref643"></a>
<h5 class="sect4"><span class="secnum">2.4.7.6.1</span> NGRAM Example</h5>
<p>When you specify <code dir="ltr">NGRAM</code> for the composite attribute, composite nouns are indexed with all possible component tokens. For example, the following composite noun (<span class="italic">information processing institute</span>)</p>
<img width="111" height="19" src="img/a1.gif" alt="Description of a1.gif follows" /><br />
<a id="sthref644" href="img_text/a1.htm">Description of the illustration ''a1.gif''</a><br />
<br />
<p>is indexed as six tokens:</p>
<img width="242" height="26" src="img/a2.gif" alt="Description of a2.gif follows" /><br />
<a id="sthref645" href="img_text/a2.htm">Description of the illustration ''a2.gif''</a><br />
<br />
<img width="194" height="28" src="img/a3.gif" alt="Description of a3.gif follows" /><br />
<a id="sthref646" href="img_text/a3.htm">Description of the illustration ''a3.gif''</a><br />
<br />
<p>Specify <code dir="ltr">NGRAM</code> indexing as follows:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('my_lexer','KOREAN_MORPH_LEXER');
ctx_ddl.set_attribute('my_lexer','COMPOSITE','NGRAM');
end
</pre>
<p>To create the index:</p>
<pre dir="ltr">
create index koreanx on korean(text) indextype is ctxsys.context
parameters ('lexer my_lexer');
</pre></div>
<!-- class="sect4" -->
<div id="CCREF1994" class="sect4"><a id="sthref647"></a>
<h5 class="sect4"><span class="secnum">2.4.7.6.2</span> COMPONENT_WORD Example</h5>
<p>When you specify <code dir="ltr">COMPONENT_WORD</code> for the composite attribute, composite nouns and their components are indexed. For example, the following composite noun (<span class="italic">information processing institute</span>)</p>
<img width="111" height="19" src="img/a1.gif" alt="Description of a1.gif follows" /><br />
<a id="sthref648" href="img_text/a1.htm">Description of the illustration ''a1.gif''</a><br />
<br />
<p>is indexed as four tokens:</p>
<img width="242" height="26" src="img/a2.gif" alt="Description of a2.gif follows" /><br />
<a id="sthref649" href="img_text/a2.htm">Description of the illustration ''a2.gif''</a><br />
<br />
<img width="125" height="19" src="img/comp.gif" alt="Description of comp.gif follows" /><br />
<a id="sthref650" href="img_text/comp.htm">Description of the illustration ''comp.gif''</a><br />
<br />
<p>Specify <code dir="ltr">COMPONENT_WORD</code> indexing as follows:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('my_lexer','KOREAN_MORPH_LEXER');
ctx_ddl.set_attribute('my_lexer','COMPOSITE','COMPONENT_WORD');
end
</pre>
<p>To create the index:</p>
<pre dir="ltr">
create index koreanx on korean(text) indextype is ctxsys.context
parameters ('lexer my_lexer');
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008347"></a>
<div id="CCREF1995" class="sect2">
<h3 class="sect2"><span class="secnum">2.4.8</span> USER_LEXER<a id="sthref651"></a></h3>
<p>Use <code dir="ltr">USER_LEXER</code> to plug in your own language-specific lexing solution. This enables you to define lexers for languages that are not supported by Oracle Text. It also enables you to define a new lexer for a language that is supported but whose lexer is inappropriate for your application.</p>
<p>The user-defined lexer you register with Oracle Text is composed of two routines that you must supply:</p>
<div id="CCREF23794" class="tblformal">
<p class="titleintable"><a id="sthref652"></a><a id="sthref653"></a>Table 2-24 User-Defined Routines for USER_LEXER</p>
<table class="cellalignment103" title="User-Defined Routines for USER_LEXER" summary="This table describes the User-defined routines for the USER_LEXER." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t61">User-Defined Routine</th>
<th class="cellalignment97" id="r1c2-t61">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t61" headers="r1c1-t61">
<p>Indexing Procedure</p>
</td>
<td class="cellalignment98" headers="r2c1-t61 r1c2-t61">
<p>Stored procedure (PL/SQL) which implements the tokenization of documents and stop words. Output must be an XML document as specified in this section.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t61" headers="r1c1-t61">
<p>Query Procedure</p>
</td>
<td class="cellalignment98" headers="r3c1-t61 r1c2-t61">
<p>Stored procedure (PL/SQL) which implements the tokenization of query words. Output must be an XML document as specified in this section.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="CCREF1996" class="sect3"><a id="sthref654"></a>
<h4 class="sect3"><span class="secnum">2.4.8.1</span> Limitations</h4>
<p>The following features are not supported with the <code dir="ltr">USER_LEXER</code>:</p>
<ul>
<li>
<p><code dir="ltr">CTX_DOC.GIST</code> and <code dir="ltr">CTX_DOC.THEMES</code></p>
</li>
<li>
<p><code dir="ltr">CTX_QUERY.HFEEDBACK</code></p>
</li>
<li>
<p><code dir="ltr">ABOUT</code> query operator</p>
</li>
<li>
<p><code dir="ltr"><a id="sthref655"></a><a id="sthref656"></a>CTXRULE</code> index type</p>
</li>
<li>
<p><code dir="ltr">VGRAM</code> indexing algorithm</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="CCREF1997" class="sect3"><a id="sthref657"></a>
<h4 class="sect3"><span class="secnum">2.4.8.2</span> USER_LEXER Attributes</h4>
<p><code dir="ltr">USER_LEXER</code> has the following attributes:</p>
<div id="CCREF23795" class="tblformal">
<p class="titleintable"><a id="sthref658"></a><a id="sthref659"></a>Table 2-25 USER_LEXER Attributes</p>
<table class="cellalignment103" title="USER_LEXER Attributes" summary="This table describes the USER_LEXER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t62">Attribute</th>
<th class="cellalignment97" id="r1c2-t62">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t62" headers="r1c1-t62">
<p><code dir="ltr">INDEX_PROCEDURE</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t62 r1c2-t62">
<p>Name of a stored procedure. No default provided.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t62" headers="r1c1-t62">
<p><code dir="ltr">INPUT_TYPE</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t62 r1c2-t62">
<p><code dir="ltr">VARCHAR2</code>, <code dir="ltr">CLOB</code>. Default is <code dir="ltr">CLOB</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t62" headers="r1c1-t62">
<p><code dir="ltr">QUERY_PROCEDURE</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t62 r1c2-t62">
<p>Name of a stored procedure. No default provided.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF1998" class="sect3"><a id="sthref660"></a>
<h4 class="sect3"><span class="secnum">2.4.8.3</span> <a id="sthref661"></a>INDEX_PROCEDURE</h4>
<p>This callback stored procedure is called by Oracle Text as needed to tokenize a document or a stop word found in the stoplist object.</p>
<div id="CCREF1999" class="sect4"><a id="sthref662"></a>
<h5 class="sect4"><span class="secnum">2.4.8.3.1</span> Requirements</h5>
<p>This procedure can be a PL/SQL stored procedure.</p>
<p>The index owner must have <code dir="ltr">EXECUTE</code> privilege on this stored procedure.</p>
<p>This stored procedure must not be replaced or dropped after the index is created. You can replace or drop this stored procedure after the index is dropped.</p>
</div>
<!-- class="sect4" -->
<div id="CCREF2000" class="sect4"><a id="sthref663"></a>
<h5 class="sect4"><span class="secnum">2.4.8.3.2</span> Parameters</h5>
<p>Two different interfaces are supported for the user-defined lexer indexing procedure:</p>
<ul>
<li>
<p><a href="#i1008419">VARCHAR2 Interface</a></p>
</li>
<li>
<p><a href="#i1016448">CLOB Interface</a></p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="CCREF2001" class="sect4"><a id="sthref664"></a>
<h5 class="sect4"><span class="secnum">2.4.8.3.3</span> Restrictions</h5>
<p>This procedure must not perform any of the following operations:</p>
<ul>
<li>
<p>Rollback</p>
</li>
<li>
<p>Explicitly or implicitly commit the current transaction</p>
</li>
<li>
<p>Enter any other transaction control statement</p>
</li>
<li>
<p>Alter the session language or territory</p>
</li>
</ul>
<p>The child elements of the root element tokens of the XML document returned must be in the same order as the tokens occur in the document or stop word being tokenized.</p>
<p>The behavior of this stored procedure must be deterministic with respect to all parameters.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="CCREF2002" class="sect3"><a id="sthref665"></a>
<h4 class="sect3"><span class="secnum">2.4.8.4</span> <a id="sthref666"></a>INPUT_TYPE</h4>
<p>Two different interfaces are supported for the User-defined lexer indexing procedure. One interface enables the document or stop word and the corresponding tokens encoded as XML to be passed as <code dir="ltr">VARCHAR2</code> datatype whereas the other interface uses the <code dir="ltr">CLOB</code> datatype. This attribute indicates the interface implemented by the stored procedure specified by the <code dir="ltr">INDEX_PROCEDURE</code> attribute.</p>
<a id="i1008419"></a>
<div id="CCREF2003" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.8.4.1</span> VARCHAR2 Interface</h5>
<p><a href="#g1019326">BASIC_WORDLIST Attributes</a> <a href="#g1019326">Table 2-33</a> describes the interface that enables the document or stop word from stoplist object to be tokenized to be passed as <code dir="ltr">VARCHAR2</code> from Oracle Text to the stored procedure and for the tokens to be passed as <code dir="ltr">VARCHAR2</code> as well from the stored procedure back to Oracle Text.</p>
<p>Your user-defined lexer indexing procedure should use this interface when all documents in the column to be indexed are smaller than or equal to 32512 bytes and the tokens can be represented by less than or equal to 32512 bytes. In this case the <code dir="ltr">CLOB</code> interface given in <a href="#g1019249">Table 2-27</a> can also be used, although the <code dir="ltr">VARCHAR2</code> interface will generally perform faster than the <code dir="ltr">CLOB</code> interface.</p>
<p>This procedure must be defined with the following parameters:</p>
<div id="CCREF23796" class="tblformalwide">
<p class="titleintable"><a id="sthref667"></a><a id="g1019225"></a>Table 2-26 VARCHAR2 Interface for INDEX_PROCEDURES</p>
<table class="cellalignment96" title="VARCHAR2 Interface for INDEX_PROCEDURES" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t63">Parameter Position</th>
<th class="cellalignment97" id="r1c2-t63">Parameter Mode</th>
<th class="cellalignment97" id="r1c3-t63">Parameter Datatype</th>
<th class="cellalignment97" id="r1c4-t63">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t63" headers="r1c1-t63">
<p>1</p>
</td>
<td class="cellalignment98" headers="r2c1-t63 r1c2-t63">
<p><code dir="ltr">IN</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t63 r1c3-t63">
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t63 r1c4-t63">
<p>Document or stop <span class="italic">word</span> from stoplist object to be tokenized.</p>
<p>If the document is larger than 32512 bytes then Oracle Text will report a document level indexing error.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t63" headers="r1c1-t63">
<p>2</p>
</td>
<td class="cellalignment98" headers="r3c1-t63 r1c2-t63">
<p><code dir="ltr">IN</code> <code dir="ltr">OUT</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t63 r1c3-t63">
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t63 r1c4-t63">
<p>Tokens encoded as XML.</p>
<p>If the document contains no tokens, then either NULL must be returned or the tokens element in the XML document returned must contain no child elements.</p>
<p>Byte length of the data must be less than or equal to 32512.</p>
<p>To improve performance, use the <code dir="ltr">NOCOPY</code> hint when declaring this parameter. This passes the data by reference, rather than passing data by value.</p>
<p>The XML document returned by this procedure should not include unnecessary whitespace characters (typically used to improve readability). This reduces the size of the XML document which in turn minimizes the transfer time.</p>
<p>To improve performance, index_procedure should not validate the XML document with the corresponding XML schema at run-time.</p>
<p>Note that this parameter is <code dir="ltr">IN</code> <code dir="ltr">OUT</code> for performance purposes. The stored procedure has no need to use the <code dir="ltr">IN</code> value.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t63" headers="r1c1-t63">
<p>3</p>
</td>
<td class="cellalignment98" headers="r4c1-t63 r1c2-t63">
<p><code dir="ltr">IN</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t63 r1c3-t63">
<p><code dir="ltr">BOOLEAN</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t63 r1c4-t63">
<p>Oracle Text sets this parameter to <code dir="ltr">TRUE</code> when Oracle Text needs the character offset and character length of the tokens as found in the document being tokenized.</p>
<p>Oracle Text sets this parameter to <code dir="ltr">FALSE</code> when Text is not interested in the character offset and character length of the tokens as found in the document being tokenized. This implies that the XML attributes off and len must not be used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect4" -->
<a id="i1016448"></a>
<div id="CCREF2004" class="sect4">
<h5 class="sect4"><span class="secnum">2.4.8.4.2</span> CLOB Interface</h5>
<p><a href="#g1019249">Table 2-27</a> describes the <code dir="ltr">CLOB</code> interface that enables the document or stop word from stoplist object to be tokenized to be passed as <code dir="ltr">CLOB</code> from Oracle Text to the stored procedure and for the tokens to be passed as <code dir="ltr">CLOB</code> as well from the stored procedure back to Oracle Text.</p>
<p>The user-defined lexer indexing procedure should use this interface when at least one of the documents in the column to be indexed is larger than 32512 bytes or the corresponding tokens are represented by more than 32512 bytes.</p>
<div id="CCREF23797" class="tblformalwide">
<p class="titleintable"><a id="sthref668"></a><a id="g1019249"></a>Table 2-27 CLOB Interface for INDEX_PROCEDURE</p>
<table class="cellalignment96" title="CLOB Interface for INDEX_PROCEDURE" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t64">Parameter Position</th>
<th class="cellalignment97" id="r1c2-t64">Parameter Mode</th>
<th class="cellalignment97" id="r1c3-t64">Parameter Datatype</th>
<th class="cellalignment97" id="r1c4-t64">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t64" headers="r1c1-t64">
<p>1</p>
</td>
<td class="cellalignment98" headers="r2c1-t64 r1c2-t64">
<p><code dir="ltr">IN</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t64 r1c3-t64">
<p><code dir="ltr">CLOB</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t64 r1c4-t64">
<p>Document or stop <span class="italic">word</span> from stoplist object to be tokenized.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t64" headers="r1c1-t64">
<p>2</p>
</td>
<td class="cellalignment98" headers="r3c1-t64 r1c2-t64">
<p><code dir="ltr">IN</code> <code dir="ltr">OUT</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t64 r1c3-t64">
<p><code dir="ltr">CLOB</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t64 r1c4-t64">
<p>Tokens encoded as XML.</p>
<p>If the document contains no tokens, then either NULL must be returned or the tokens element in the XML document returned must contain no child elements.</p>
<p>To improve performance, use the <code dir="ltr">NOCOPY</code> hint when declaring this parameter. This passes the data by reference, rather than passing data by value.</p>
<p>The XML document returned by this procedure should not include unnecessary whitespace characters (typically used to improve readability). This reduces the size of the XML document which in turn minimizes the transfer time.</p>
<p>To improve performance, index_procedure should not validate the XML document with the corresponding XML schema at run-time.</p>
<p>Note that this parameter is <code dir="ltr">IN</code> <code dir="ltr">OUT</code> for performance purposes. The stored procedure has no need to use the IN value. The <code dir="ltr">IN</code> value will always be a truncated <code dir="ltr">CLOB</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t64" headers="r1c1-t64">
<p>3</p>
</td>
<td class="cellalignment98" headers="r4c1-t64 r1c2-t64">
<p><code dir="ltr">IN</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t64 r1c3-t64">
<p><code dir="ltr">BOOLEAN</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t64 r1c4-t64">
<p>Oracle Text sets this parameter to <code dir="ltr">TRUE</code> when Oracle Text needs the character offset and character length of the tokens as found in the document being tokenized.</p>
<p>Oracle Text sets this parameter to <code dir="ltr">FALSE</code> when Text is not interested in the character offset and character length of the tokens as found in the document being tokenized. This implies that the XML attributes off and len must not be used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p>The first and second parameters are temporary <code dir="ltr">CLOBS</code>. Avoid assigning these <code dir="ltr">CLOB</code> locators to other locator variables. Assigning the formal parameter <code dir="ltr">CLOB</code> locator to another locator variable causes a new copy of the temporary <code dir="ltr">CLOB</code> to be created resulting in a performance hit.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="CCREF2005" class="sect3"><a id="sthref669"></a>
<h4 class="sect3"><span class="secnum">2.4.8.5</span> <a id="sthref670"></a>QUERY_PROCEDURE</h4>
<p>This callback stored procedure is called by Oracle Text as needed to tokenize <span class="italic">word</span>s in the query. A space-delimited group of characters (excluding the query operators) in the query will be identified by Oracle Text as a <span class="italic">word</span>.</p>
<div id="CCREF2006" class="sect4"><a id="sthref671"></a>
<h5 class="sect4"><span class="secnum">2.4.8.5.1</span> Requirements</h5>
<p>This procedure can be a PL/SQL stored procedure.</p>
<p>The index owner must have <code dir="ltr">EXECUTE</code> privilege on this stored procedure.</p>
<p>This stored procedure must not be replaced or be dropped after the index is created. You can replace or drop this stored procedure after the index is dropped.</p>
</div>
<!-- class="sect4" -->
<div id="CCREF2007" class="sect4"><a id="sthref672"></a>
<h5 class="sect4"><span class="secnum">2.4.8.5.2</span> Restrictions</h5>
<p>This procedure must not perform any of the following operations:</p>
<ul>
<li>
<p>Rollback</p>
</li>
<li>
<p>Explicitly or implicitly commit the current transaction</p>
</li>
<li>
<p>Enter any other transaction control statement</p>
</li>
<li>
<p>Alter the session language or territory</p>
</li>
</ul>
<p>The child elements of the root element tokens of the XML document returned must be in the same order as the tokens occur in the query <span class="italic">word</span> being tokenized.</p>
<p>The behavior of this stored procedure must be deterministic with respect to all parameters.</p>
</div>
<!-- class="sect4" -->
<div id="CCREF2008" class="sect4"><a id="sthref673"></a>
<h5 class="sect4"><span class="secnum">2.4.8.5.3</span> Parameters</h5>
<p><a href="#g1019998">Table 2-28</a> describes the interface for the user-defined lexer query procedure:</p>
<div id="CCREF23798" class="tblformalwide">
<p class="titleintable"><a id="sthref674"></a><a id="g1019998"></a>Table 2-28 User-defined Lexer Query Procedure XML Schema Attributes</p>
<table class="cellalignment96" title="User-defined Lexer Query Procedure XML Schema Attributes" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t65">Parameter Position</th>
<th class="cellalignment97" id="r1c2-t65">Parameter Mode</th>
<th class="cellalignment97" id="r1c3-t65">Parameter Datatype</th>
<th class="cellalignment97" id="r1c4-t65">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t65" headers="r1c1-t65">
<p>1</p>
</td>
<td class="cellalignment98" headers="r2c1-t65 r1c2-t65">
<p><code dir="ltr">IN</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t65 r1c3-t65">
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t65 r1c4-t65">
<p>Query <span class="italic">word</span> to be tokenized.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t65" headers="r1c1-t65">
<p>2</p>
</td>
<td class="cellalignment98" headers="r3c1-t65 r1c2-t65">
<p><code dir="ltr">IN</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t65 r1c3-t65">
<p><code dir="ltr">CTX_ULEXER.WILDCARD_TAB</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t65 r1c4-t65">
<p>Character offsets of wildcard characters (% and _) in the query <span class="italic">word</span>. If the query <span class="italic">word</span> passed in by Oracle Text does not contain any wildcard characters then this index-by table will be empty.</p>
<p>The wildcard characters in the query <span class="italic">word</span> must be preserved in the tokens returned in order for the wildcard query feature to work properly.</p>
<p>The character offset is 0 (zero) based. Offset information follows USC-2 codepoint semantics.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t65" headers="r1c1-t65">
<p>3</p>
</td>
<td class="cellalignment98" headers="r4c1-t65 r1c2-t65">
<p><code dir="ltr">IN</code> <code dir="ltr">OUT</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t65 r1c3-t65">
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t65 r1c4-t65">
<p>Tokens encoded as XML.</p>
<p>If the query <span class="italic">word</span> contains no tokens then either NULL must be returned or the tokens element in the XML document returned must contain no child elements.</p>
<p>The length of the data must be less-than or equal to 32512 bytes.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="CCREF2009" class="sect3"><a id="sthref675"></a>
<h4 class="sect3"><span class="secnum">2.4.8.6</span> Encoding Tokens as XML</h4>
<p>The sequence of tokens returned by your stored procedure must be represented as an XML 1.0 document. The XML document must be valid with respect to the XML Schemas given in the following sections.</p>
<ul>
<li>
<p><a href="#i1008615">XML Schema for No-Location, User-defined Indexing Procedure</a></p>
</li>
<li>
<p><a href="#i1008731">XML Schema for User-defined Indexing Procedure with Location</a></p>
</li>
<li>
<p><a href="#i1008831">XML Schema for User-defined Lexer Query Procedure</a></p>
</li>
</ul>
<div id="CCREF2010" class="sect4"><a id="sthref676"></a>
<h5 class="sect4"><span class="secnum">2.4.8.6.1</span> Limitations</h5>
<p>To boost performance of this feature, the XML parser in Oracle Text will not perform validation and will not be a full-featured XML compliant parser. This implies that only minimal XML features will be supported. The following XML features are not supported:</p>
<ul>
<li>
<p>Document Type Declaration (for example, <code dir="ltr">&lt;!DOCTYPE [...]&gt;</code>) and therefore entity declarations. Only the following built-in entities can be referenced: lt, gt, amp, quot, and apos.</p>
</li>
<li>
<p>CDATA sections.</p>
</li>
<li>
<p>Comments.</p>
</li>
<li>
<p>Processing Instructions.</p>
</li>
<li>
<p>XML declaration (for example, <code dir="ltr">&lt;?xml version="1.0" ...?&gt;</code>).</p>
</li>
<li>
<p>Namespaces.</p>
</li>
<li>
<p>Use of elements and attributes other than those defined by the corresponding XML Schema.</p>
</li>
<li>
<p>Character references (for example &amp;#x099F;).</p>
</li>
<li>
<p>xml:space attribute.</p>
</li>
<li>
<p>xml:lang attribute</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1008615"></a>
<div id="CCREF2011" class="sect3">
<h4 class="sect3"><span class="secnum">2.4.8.7</span> XML Schema for No-Location, User-defined Indexing Procedure</h4>
<p>This section describes additional constraints imposed on the XML document returned by the user-defined lexer indexing procedure when the third parameter is <code dir="ltr">FALSE</code>. The XML document returned must be valid with respect to the following XML Schema:</p>
<pre dir="ltr">
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xsd:element name="tokens"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt; 
          &lt;xsd:element name="eos" type="EmptyTokenType"/&gt;
          &lt;xsd:element name="eop" type="EmptyTokenType"/&gt;
          &lt;xsd:element name="num" type="xsd:token"/&gt; 
          &lt;xsd:group ref="IndexCompositeGroup"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- 
  Enforce constraint that compMem element must be preceeded by word element
  or compMem element for indexing 
  --&gt;
  &lt;xsd:group name="IndexCompositeGroup"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="word" type="xsd:token"/&gt;
      &lt;xsd:element name="compMem" type="xsd:token" minOccurs="0"
maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:group&gt;

  &lt;!-- EmptyTokenType defines an empty element without attributes --&gt;
  &lt;xsd:complexType name="EmptyTokenType"/&gt;

&lt;/xsd:schema&gt;
</pre>
<p>Here are some of the constraints imposed by this XML Schema:</p>
<ul>
<li>
<p>The root element is tokens. This is mandatory. It has no attributes.</p>
</li>
<li>
<p>The root element can have zero or more child elements. The child elements can be one of the following elements: eos, eop, num, word, and compMem. Each of these represent a specific type of token.</p>
</li>
<li>
<p>The compMem element must be preceded by a word element or a compMem element.</p>
</li>
<li>
<p>The eos and eop elements have no attributes and must be empty elements.</p>
</li>
<li>
<p>The num, word, and compMem elements have no attributes. Oracle Text will normalize the content of these elements as follows: convert whitespace characters to space characters, collapse adjacent space characters to a single space character, remove leading and trailing spaces, perform entity reference replacement, and truncate to 64 bytes.</p>
</li>
</ul>
<p><a href="#g1019283">Table 2-29</a> describes the element names defined in the preceding XML Schema.</p>
<div id="CCREF23799" class="tblformal">
<p class="titleintable"><a id="sthref677"></a><a id="g1019283"></a>Table 2-29 User-defined Lexer Indexing Procedure XML Schema Element Names</p>
<table class="cellalignment103" title="User-defined Lexer Indexing Procedure XML Schema Element Names" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t66">Element</th>
<th class="cellalignment97" id="r1c2-t66">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t66" headers="r1c1-t66">
<p>word</p>
</td>
<td class="cellalignment98" headers="r2c1-t66 r1c2-t66">
<p>This element represents a simple word token. The content of the element is the word itself. Oracle Text does the work of identifying this token as being a stop word or non-stop word and processing it appropriately.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t66" headers="r1c1-t66">
<p>num</p>
</td>
<td class="cellalignment98" headers="r3c1-t66 r1c2-t66">
<p>This element represents an arithmetic number token. The content of the element is the arithmetic number itself. Oracle Text treats this token as a stop word if the stoplist preference has <code dir="ltr">NUMBERS</code> added as the stopclass. Otherwise this token is treated the same way as the word token.</p>
<p>Supporting this token type is optional. Without support for this token type, adding the <code dir="ltr">NUMERBS</code> stopclass will have no effect.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t66" headers="r1c1-t66">
<p>eos</p>
</td>
<td class="cellalignment98" headers="r4c1-t66 r1c2-t66">
<p>This element represents end-of-sentence token. Oracle Text uses this information so that it can support <code dir="ltr">WITHIN</code> <code dir="ltr">SENTENCE</code> queries.</p>
<p>Supporting this token type is optional. Without support for this token type, queries against the <code dir="ltr">SENTENCE</code> section will not work as expected.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t66" headers="r1c1-t66">
<p>eop</p>
</td>
<td class="cellalignment98" headers="r5c1-t66 r1c2-t66">
<p>This element represents end-of-paragraph token. Oracle Text uses this information so that it can support <code dir="ltr">WITHIN</code> <code dir="ltr">PARAGRAPH</code> queries.</p>
<p>Supporting this token type is optional. Without support for this token type, queries against the <code dir="ltr">PARAGRAPH</code> section will not work as expected.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t66" headers="r1c1-t66">
<p>compMem</p>
</td>
<td class="cellalignment98" headers="r6c1-t66 r1c2-t66">
<p>Same as the word element, except that the implicit word offset is the same as the previous word token.</p>
<p>Support for this token type is optional.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="CCREF2012" class="sect4"><a id="sthref678"></a>
<h5 class="sect4"><span class="secnum">2.4.8.7.1</span> Example</h5>
<p>Document: Vom Nordhauptbahnhof und aus der Innenstadt zum Messegel&auml;nde.</p>
<p>Tokens:</p>
<pre dir="ltr">
&lt;tokens&gt;
  &lt;word&gt; VOM &lt;/word&gt;
  &lt;word&gt; NORDHAUPTBAHNHOF &lt;/word&gt;
  &lt;compMem&gt;NORD&lt;/compMem&gt;
  &lt;compMem&gt;HAUPT &lt;/compMem&gt;
  &lt;compMem&gt;BAHNHOF &lt;/compMem&gt;
  &lt;compMem&gt;HAUPTBAHNHOF &lt;/compMem&gt;
  &lt;word&gt; UND &lt;/word&gt;
  &lt;word&gt; AUS &lt;/word&gt;
  &lt;word&gt; DER &lt;/word&gt;
  &lt;word&gt; INNENSTADT &lt;/word&gt;
  &lt;word&gt; ZUM &lt;/word&gt;
  &lt;word&gt; MESSEGEL&Auml;NDE &lt;/word&gt;
  &lt;eos/&gt;
&lt;/tokens&gt;
</pre></div>
<!-- class="sect4" -->
<div id="CCREF2013" class="sect4"><a id="sthref679"></a>
<h5 class="sect4"><span class="secnum">2.4.8.7.2</span> Example</h5>
<p>Document: Oracle Database 11<span class="italic">g</span> Release 1</p>
<p>Tokens:</p>
<pre dir="ltr">
&lt;tokens&gt;
  &lt;word&gt; ORACLE11G&lt;/word&gt;
  &lt;word&gt; RELEASE &lt;/word&gt;
  &lt;num&gt; 1 &lt;/num&gt;
&lt;/tokens&gt;
</pre></div>
<!-- class="sect4" -->
<div id="CCREF2014" class="sect4"><a id="sthref680"></a>
<h5 class="sect4"><span class="secnum">2.4.8.7.3</span> Example</h5>
<p>Document: WHERE salary&lt;25000.00 AND job = 'F&amp;B Manager'</p>
<p>Tokens:</p>
<pre dir="ltr">
&lt;tokens&gt;
  &lt;word&gt; WHERE &lt;/word&gt;
  &lt;word&gt; salary&amp;lt;2500.00 &lt;/word&gt;
  &lt;word&gt; AND &lt;/word&gt;
  &lt;word&gt; job &lt;/word&gt;
  &lt;word&gt; F&amp;amp;B &lt;/word&gt;
  &lt;word&gt; Manager &lt;/word&gt;
&lt;/tokens&gt;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1008731"></a>
<div id="CCREF2015" class="sect3">
<h4 class="sect3"><span class="secnum">2.4.8.8</span> XML Schema for User-defined Indexing Procedure with Location</h4>
<p>This section describes additional constraints imposed on the XML document returned by the user-defined lexer indexing procedure when the third parameter is <code dir="ltr">TRUE</code>. The XML document returned must be valid according to the following XML schema:</p>
<pre dir="ltr">
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xsd:element name="tokens"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xsd:element name="eos" type="EmptyTokenType"/&gt;
          &lt;xsd:element name="eop" type="EmptyTokenType"/&gt;
          &lt;xsd:element name="num" type="DocServiceTokenType"/&gt;
          &lt;xsd:group ref="DocServiceCompositeGroup"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- 
  Enforce constraint that compMem element must be preceeded by word element
  or compMem element for document service
  --&gt;
  &lt;xsd:group name="DocServiceCompositeGroup"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="word" type="DocServiceTokenType"/&gt;
      &lt;xsd:element name="compMem" type="DocServiceTokenType" minOccurs="0"
           maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:group&gt;

  &lt;!-- EmptyTokenType defines an empty element without attributes --&gt;
  &lt;xsd:complexType name="EmptyTokenType"/&gt;

  &lt;!-- 
  DocServiceTokenType defines an element with content and mandatory attributes 
  --&gt;
  &lt;xsd:complexType name="DocServiceTokenType"&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:token"&gt;
        &lt;xsd:attribute name="off" type="OffsetType" use="required"/&gt;
        &lt;xsd:attribute name="len" type="xsd:unsignedShort" use="required"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:simpleType name="OffsetType"&gt;
    &lt;xsd:restriction base="xsd:unsignedInt"&gt;
      &lt;xsd:maxInclusive value="2147483647"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

&lt;/xsd:schema&gt;
</pre>
<p>Some of the constraints imposed by this XML Schema are as follows:</p>
<ul>
<li>
<p>The root element is tokens. This is mandatory. It has no attributes.</p>
</li>
<li>
<p>The root element can have zero or more child elements. The child elements can be one of the following elements: eos, eop, num, word, and compMem. Each of these represent a specific type of token.</p>
</li>
<li>
<p>The compMem element must be preceded by a word element or a compMem element.</p>
</li>
<li>
<p>The eos and eop elements have no attributes and must be empty elements.</p>
</li>
<li>
<p>The num, word, and compMem elements have two mandatory attributes: <code dir="ltr">off</code> and len. Oracle Text will normalize the content of these elements as follows: convert whitespace characters to space characters, collapse adjacent space characters to a single space character, remove leading and trailing spaces, perform entity reference replacement, and truncate to 64 bytes.</p>
</li>
<li>
<p>The <code dir="ltr">off</code> attribute value must be an integer between 0 and 2147483647 inclusive.</p>
</li>
<li>
<p>The <code dir="ltr">len</code> attribute value must be an integer between 0 and 65535 inclusive.</p>
</li>
</ul>
<p><a href="#g1019283">Table 2-29</a> describes the element types defined in the preceding XML Schema.</p>
<p><a href="#g1019305">Table 2-30</a> describes the attributes defined in the preceding XML Schema.</p>
<div id="CCREF23800" class="tblformal">
<p class="titleintable"><a id="sthref681"></a><a id="g1019305"></a>Table 2-30 User-defined Lexer Indexing Procedure XML Schema Attributes</p>
<table class="cellalignment103" title="User-defined Lexer Indexing Procedure XML Schema Attributes" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t67">Attribute</th>
<th class="cellalignment97" id="r1c2-t67">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t67" headers="r1c1-t67">
<p>off</p>
</td>
<td class="cellalignment98" headers="r2c1-t67 r1c2-t67">
<p>This attribute represents the character offset of the token as it appears in the document being tokenized.</p>
<p>The offset is with respect to the character document passed to the user-defined lexer indexing procedure, not the document fetched by the datastore. The document fetched by the datastore may be pre-processed by the filter object or the section group object, or both, before being passed to the user-defined lexer indexing procedure.</p>
<p>The offset of the first character in the document being tokenized is 0 (zero). Offset information follows USC-2 codepoint semantics.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t67" headers="r1c1-t67">
<p>len</p>
</td>
<td class="cellalignment98" headers="r3c1-t67 r1c2-t67">
<p>This attribute represents the character length (same semantics as SQL function <code dir="ltr">LENGTH</code>) of the token as it appears in the document being tokenized.</p>
<p>The length is with respect to the character document passed to the user-defined lexer indexing procedure, not the document fetched by the datastore. The document fetched by the datastore may be pre-processed by the filter object or the section group object before being passed to the user-defined lexer indexing procedure.</p>
<p>Length information follows USC-2 codepoint semantics.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Sum of <code dir="ltr">off</code> attribute value and <code dir="ltr">len</code> attribute value must be less than or equal to the total number of characters in the document being tokenized. This is to ensure that the document offset and characters being referenced are within the document boundary.</p>
<div id="CCREF2016" class="sect4"><a id="sthref682"></a>
<h5 class="sect4"><span class="secnum">2.4.8.8.1</span> Example</h5>
<p>Document: User-defined Lexer.</p>
<p>Tokens:</p>
<pre dir="ltr">
&lt;tokens&gt;
  &lt;word off="0" len="4"&gt; USE &lt;/word&gt;
  &lt;word off="5" len="7"&gt; DEF &lt;/word&gt;
  &lt;word off="13" len="5"&gt; LEX &lt;/word&gt;
  &lt;eos/&gt;
&lt;/tokens&gt;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1008831"></a>
<div id="CCREF2017" class="sect3">
<h4 class="sect3"><span class="secnum">2.4.8.9</span> XML Schema for User-defined Lexer Query Procedure</h4>
<p>This section describes additional constraints imposed on the XML document returned by the user-defined lexer query procedure. The XML document returned must be valid with respect to the following XML Schema:</p>
<pre dir="ltr">
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xsd:element name="tokens"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xsd:element name="num" type="QueryTokenType"/&gt;
          &lt;xsd:group ref="QueryCompositeGroup"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

&lt;!--
Enforce constraint that compMem element must be preceeded by word element
or compMem element for query
--&gt;
  &lt;xsd:group name="QueryCompositeGroup"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="word" type="QueryTokenType"/&gt;
      &lt;xsd:element name="compMem" type="QueryTokenType" minOccurs="0"
                                              maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:group&gt;

  &lt;!-- 
  QueryTokenType defines an element with content and with an optional attribute
  --&gt;
  &lt;xsd:complexType name="QueryTokenType"&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:token"&gt;
        &lt;xsd:attribute name="wildcard" type="WildcardType" use="optional"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:simpleType name="WildcardType"&gt;
    &lt;xsd:restriction base="WildcardBaseType"&gt;
      &lt;xsd:minLength value="1"/&gt;
      &lt;xsd:maxLength value="64"/&gt;
    &lt;/xsd:restriction&gt;     
  &lt;/xsd:simpleType&gt;

  &lt;xsd:simpleType name="WildcardBaseType"&gt;
    &lt;xsd:list&gt;
      &lt;xsd:simpleType&gt;
        &lt;xsd:restriction base="xsd:unsignedShort"&gt;
          &lt;xsd:maxInclusive value="378"/&gt;
        &lt;/xsd:restriction&gt;
      &lt;/xsd:simpleType&gt;
    &lt;/xsd:list&gt;
  &lt;/xsd:simpleType&gt;

&lt;/xsd:schema&gt;
</pre>
<p>Here are some of the constraints imposed by this XML Schema:</p>
<ul>
<li>
<p>The <code dir="ltr">root</code> element is tokens. This is mandatory. It has no attributes.</p>
</li>
<li>
<p>The <code dir="ltr">root</code> element can have zero or more child elements. The child elements can be one of the following elements: <code dir="ltr">num</code> and <code dir="ltr">word</code>. Each of these represent a specific type of token.</p>
</li>
<li>
<p><a id="sthref683"></a>The <code dir="ltr">compMem</code> element must be preceded by a <code dir="ltr">word</code> element or a <code dir="ltr">compMem</code> element.</p>
<p>The purpose of <code dir="ltr">compMem</code> is to enable <code dir="ltr">USER_LEXER</code> queries to return multiple forms for a single query. For example, if a user-defined lexer indexes the word bank as <code dir="ltr">BANK(FINANCIAL)</code> and <code dir="ltr">BANK(RIVER)</code>, the query procedure can return the first term as a <code dir="ltr">word</code> and the second as a <code dir="ltr">compMem</code> element:</p>
<pre dir="ltr">
&lt;tokens&gt;
  &lt;word&gt;BANK(RIVER)&lt;/word&gt;
  &lt;compMem&gt;BANK(FINANCIAL)&lt;/compMem&gt;
&lt;/tokens&gt;
</pre>
<p>See <a href="#g1019273">Table 2-31</a>, <a href="#g1019273">"User-defined Lexer Query Procedure XML Schema Attributes"</a> for more on the <code dir="ltr">compMem</code> element.</p>
</li>
<li>
<p>The num and word elements have a single optional attribute: wildcard. Oracle Text will normalize the content of these elements as follows: convert whitespace characters to space characters, collapse adjacent space characters to a single space character, remove leading and trailing spaces, perform entity reference replacement, and truncate to 64 bytes.</p>
</li>
<li>
<p>The wildcard attribute value is a white-space separated list of integers. The minimum number of integers is 1 and the maximum number of integers is 64. The value of the integers must be between 0 and 378 inclusive. The intriguers in the list can be in any order.</p>
</li>
</ul>
<p><a href="#g1019283">Table 2-29</a> describes the element types defined in the preceding XML Schema.</p>
<p><a href="#g1019273">Table 2-31</a> describes the attribute defined in the preceding XML Schema.</p>
<div id="CCREF23801" class="tblformal">
<p class="titleintable"><a id="sthref684"></a><a id="g1019273"></a>Table 2-31 User-defined Lexer Query Procedure XML Schema Attributes</p>
<table class="cellalignment103" title="User-defined Lexer Query Procedure XML Schema Attributes" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t68">Attribute</th>
<th class="cellalignment97" id="r1c2-t68">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t68" headers="r1c1-t68">
<p><code dir="ltr">compMem</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t68 r1c2-t68">
<p>Same as the <code dir="ltr">word</code> element, but its implicit word offset is the same as the previous <code dir="ltr">word</code> token. Oracle Text will equate this token with the previous <code dir="ltr">word</code> token and with subsequent <code dir="ltr">compMem</code> tokens using the query <code dir="ltr">EQUIV</code> operator.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t68" headers="r1c1-t68">
<p><code dir="ltr">wildcard</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t68 r1c2-t68">
<p>Any% or _ characters in the query which are not escaped by the user are considered wildcard characters because they are replaced by other characters. These wildcard characters in the query must be preserved during tokenization in order for the wildcard query feature to work properly. This attribute represents the character offsets (same semantics as SQL function <code dir="ltr">LENGTH</code>) of wildcard characters in the content of the element. Oracle Text will adjust these offsets for any normalization performed on the content of the element. The characters pointed to by the offsets must either be% or _ characters.</p>
<p>The offset of the first character in the content of the element is 0. Offset information follows USC-2 codepoint semantics.</p>
<p>If the token does not contain any wildcard characters then this attribute must not be specified.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="CCREF2018" class="sect4"><a id="sthref685"></a>
<h5 class="sect4"><span class="secnum">2.4.8.9.1</span> Example</h5>
<p>Query <span class="italic">word</span>: pseudo-%morph%</p>
<p>Tokens:</p>
<pre dir="ltr">
&lt;tokens&gt;
  &lt;word&gt; PSEUDO &lt;/word&gt;
  &lt;word wildcard="1 7"&gt; %MORPH% &lt;/word&gt;
&lt;/tokens&gt;
</pre></div>
<!-- class="sect4" -->
<div id="CCREF2019" class="sect4"><a id="sthref686"></a>
<h5 class="sect4"><span class="secnum">2.4.8.9.2</span> Example</h5>
<pre dir="ltr">
Query <span class="italic">word</span>: &lt;%&gt;
Tokens:
&lt;tokens&gt;
  &lt;word wildcard="5"&gt; &amp;lt;%&amp;gt; &lt;/word&gt;
&lt;/tokens&gt;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BHCJEGFJ"></a>
<div id="CCREF2020" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.4.9</span> WORLD_LEXER<a id="sthref687"></a><a id="sthref688"></a><a id="sthref689"></a><a id="sthref690"></a></h3>
<p>Use the <code dir="ltr">WORLD_LEXER</code> to index text columns that contain documents of different languages. For example, use this lexer to index a text column that stores English, Japanese, and German documents.</p>
<p><code dir="ltr">WORLD_LEXER</code> differs from <code dir="ltr">MULTI_LEXER</code> in that <code dir="ltr">WORLD_LEXER</code> automatically detects the language(s) of a document. Unlike <code dir="ltr">MULTI_LEXER</code>, <code dir="ltr">WORLD_LEXER</code> does not require you to have a language column in your base table nor to specify the language column when you create the index. Moreover, it is not necessary to use sub-lexers, as with <code dir="ltr">MULTI_LEXER</code>. (See <a href="#i1007955">"MULTI_LEXER"</a>.)</p>
<p><code dir="ltr">WORLD_LEXER</code> supports all database character sets, and for languages whose character sets are Unicode-based, it supports the Unicode 5.0 standard. For a list of languages that <code dir="ltr">WORLD_LEXER</code> can work with, see <a href="amultlng.htm#CEGBAFHC">"World Lexer Features"</a>.</p>
<div id="CCREF2021" class="sect3"><a id="sthref691"></a>
<h4 class="sect3"><span class="secnum">2.4.9.1</span> WORLD_LEXER Attribute</h4>
<p>The <code dir="ltr">WORLD_VGRAM_LEXER</code> has the following attribute:</p>
<div id="CCREF23802" class="tblformal">
<p class="titleintable"><a id="sthref692"></a><a id="sthref693"></a>Table 2-32 WORLD_LEXER Attribute</p>
<table class="cellalignment103" title="WORLD_LEXER Attribute" summary="This table describes the CHINESE_VGRAM_LEXER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t69">Attribute</th>
<th class="cellalignment97" id="r1c2-t69">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t69" headers="r1c1-t69">
<p><code dir="ltr">mixed_case</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t69 r1c2-t69">
<p>Enable mixed-case (upper- and lower-case) searches of text (for example, <span class="italic">cat</span> and <span class="italic">Cat</span>). Allowable values are <code dir="ltr">YES</code> and <code dir="ltr">NO</code> (default).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF2022" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref694"></a>
<h4 class="sect3"><span class="secnum">2.4.9.2</span> WORLD_LEXER Example</h4>
<p>Here is an example of creating an index using <code dir="ltr">WORLD_LEXER</code>.</p>
<pre dir="ltr">
exec ctx_ddl.create_preference('MYLEXER', 'world_lexer');
create index doc_idx on doc(data)
  indextype is CONTEXT
  parameters ('lexer MYLEXER
               stoplist CTXSYS.EMPTY_STOPLIST');
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008929"></a>
<div id="CCREF0225" class="sect1">
<h2 class="sect1"><span class="secnum">2.5</span> Wordlist <a id="sthref695"></a>Type</h2>
<p>Use the wordlist preference to enable the query options such as stemming, fuzzy matching for your language. You can also use the wordlist preference to enable substring and prefix indexing, which improves performance for wildcard queries with <code dir="ltr">CONTAINS</code> and <code dir="ltr">CATSEARCH</code>.</p>
<p>To create a wordlist preference, you must use <code dir="ltr">BASIC_WORDLIST</code>, which is the only type available.</p>
<a id="i1008935"></a>
<div id="CCREF2023" class="sect2">
<h3 class="sect2"><span class="secnum">2.5.1</span> <a id="sthref696"></a>BASIC_WORDLIST</h3>
<p>Use <code dir="ltr">BASIC_WORDLIST</code> type to enable stemming and fuzzy matching or to create prefix indexes with Text indexes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cqoper.htm#CHDEGDDF">Chapter 3, "Oracle Text CONTAINS Query Operators"</a></div>
<p><a href="#g1019326">Table 2-33</a> lists the attributes for <code dir="ltr">BASIC_WORDLIST</code>.</p>
<div id="CCREF23803" class="tblformal">
<p class="titleintable"><a id="sthref697"></a><a id="g1019326"></a>Table 2-33 BASIC_WORDLIST Attributes</p>
<table class="cellalignment103" title="BASIC_WORDLIST Attributes" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t71">Attribute</th>
<th class="cellalignment97" id="r1c2-t71">Attribute Values</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t71" headers="r1c1-t71">
<p><code dir="ltr">stemmer</code><a id="sthref698"></a><a id="sthref699"></a></p>
</td>
<td class="cellalignment98" headers="r2c1-t71 r1c2-t71">
<p>Specify which language stemmer to use. You can specify one of the following stemmers:</p>
<p>NULL (no stemming)</p>
<p>ENGLISH (English inflectional)</p>
<p>DERIVATIONAL (English derivational)</p>
<p>DUTCH<a id="sthref700"></a></p>
<p><a id="sthref701"></a>FRENCH</p>
<p><a id="sthref702"></a>GERMAN</p>
<p><a id="sthref703"></a>ITALIAN</p>
<p><a id="sthref704"></a>SPANISH</p>
<p><a id="sthref705"></a><a id="sthref706"></a>AUTO (Automatic language-detection for stemming, derived from the database session language. If the database session language is AMERICAN or ENGLISH, then the ENGLISH stemmer is used. Does not auto-detect JAPANESE.)</p>
<p>JAPANESE<a id="sthref707"></a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t71" headers="r1c1-t71">
<p><code dir="ltr">fuzzy_match</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t71 r1c2-t71">
<p>Specify which fuzzy matching cluster to use. You can specify one of the following types:</p>
<p><a id="sthref708"></a>AUTO (Automatic language detection for stemming.)</p>
<p>CHINESE_VGRAM<a id="sthref709"></a></p>
<p><a id="sthref710"></a>DUTCH</p>
<p>ENGLISH<a id="sthref711"></a></p>
<p><a id="sthref712"></a>FRENCH</p>
<p>GENERIC</p>
<p><a id="sthref713"></a>GERMAN</p>
<p><a id="sthref714"></a>ITALIAN</p>
<p><a id="sthref715"></a>JAPANESE_VGRAM</p>
<p>KOREAN<a id="sthref716"></a></p>
<p>OCR</p>
<p><a id="sthref717"></a>SPANISH</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t71" headers="r1c1-t71">
<p><code dir="ltr">fuzzy_score</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t71 r1c2-t71">
<p>Specify a default lower limit of fuzzy score. Specify a number between 0 and 80. Text with scores below this number is not returned. Default is 60.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t71" headers="r1c1-t71">
<p><code dir="ltr">fuzzy_numresults</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t71 r1c2-t71">
<p>Specify the maximum number of fuzzy expansions. Use a number between 0 and 5,000. Default is 100.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t71" headers="r1c1-t71">
<p><code dir="ltr">substring_index</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t71 r1c2-t71">
<p>Specify <code dir="ltr">TRUE</code> for Oracle Text to create a substring index. A substring index improves left-truncated and double-truncated wildcard queries such as <span class="italic">%ing</span> or <span class="italic">%benz%</span>. Default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t71" headers="r1c1-t71">
<p><code dir="ltr">prefix_index</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t71 r1c2-t71">
<p>Specify <code dir="ltr">TRUE</code> to enable prefix indexing. Prefix indexing improves performance for right truncated wildcard searches such as TO%. Default is <code dir="ltr">FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t71" headers="r1c1-t71">
<p><code dir="ltr">prefix_min_length</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t71 r1c2-t71">
<p>Specify the minimum length of indexed prefixes. Default is 1. Length information must follow USC-2 codepoint semantics.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t71" headers="r1c1-t71">
<p><code dir="ltr">prefix_max_length</code></p>
</td>
<td class="cellalignment98" headers="r9c1-t71 r1c2-t71">
<p>Specify the maximum length of indexed prefixes. Default is 64. Length information must follow USC-2 codepoint semantics.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r10c1-t71" headers="r1c1-t71">
<p><code dir="ltr">wildcard_maxterms</code></p>
</td>
<td class="cellalignment98" headers="r10c1-t71 r1c2-t71">
<p>Specify the maximum number of terms in a wildcard expansion. The maximum value is 50000 and the default value is 20000. If you specify a value of 0, then the number of wildcard expansions will be unbounded.Note that when set to 0, the system may run out of memory due to the high number of wildcard expansions.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r11c1-t71" headers="r1c1-t71">
<p><code dir="ltr">ndata_base_letter</code></p>
</td>
<td class="cellalignment98" headers="r11c1-t71 r1c2-t71">
<p>Specify whether characters that have diacritical marks are converted to their base form before being stored in the Text index or queried by the <code dir="ltr">NDATA</code> operator.</p>
<p><code dir="ltr">FALSE</code> (default) or <code dir="ltr">TRUE</code></p>
<p>When set to <code dir="ltr">FALSE</code>, no base lettering is used.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r12c1-t71" headers="r1c1-t71">
<p><code dir="ltr">ndata_alternate_spelling</code></p>
</td>
<td class="cellalignment98" headers="r12c1-t71 r1c2-t71">
<p>Specify whether to enable alternate spelling for German, Danish, and Swedish. Enabling alternate spelling allows you to index <code dir="ltr">NDATA</code> section data and query using the <code dir="ltr">NDATA</code> operator in alternate form.</p>
<p><code dir="ltr">FALSE</code> (default) or <code dir="ltr">TRUE</code></p>
<p>When set to <code dir="ltr">FALSE</code>, no alternate spelling is used.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r13c1-t71" headers="r1c1-t71">
<p><code dir="ltr">ndata_thesaurus</code></p>
</td>
<td class="cellalignment98" headers="r13c1-t71 r1c2-t71">
<p>Name of the thesaurus used for alternate name expansion.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r14c1-t71" headers="r1c1-t71">
<p><code dir="ltr">ndata_join_particles</code></p>
</td>
<td class="cellalignment98" headers="r14c1-t71 r1c2-t71">
<p>A list of colon-separated name particles that can be joined with a name that follows them.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<dl>
<dt><a id="sthref718"></a><a id="sthref719"></a><a id="sthref720"></a><a id="sthref721"></a><a id="sthref722"></a>stemmer</dt>
<dd>
<p>Specify the stemmer used for word stemming in Text queries. When you do not specify a value for <code dir="ltr">STEMMER</code>, the default is <code dir="ltr">ENGLISH</code>.</p>
<p>Specify <code dir="ltr">AUTO</code> for the system to automatically set the stemming language according to the language setting of the database session. If the database language is <code dir="ltr">AMERICAN</code> or <code dir="ltr">ENGLISH</code>, then the <code dir="ltr">ENGLISH</code> stemmer is automatically used. Otherwise, the stemmer that maps to the database session language is used.</p>
<p>When there is no stemmer for a language, the default is <code dir="ltr">NULL</code>. With the <code dir="ltr">NULL</code> stemmer, the stem operator is ignored in queries.</p>
<p>You can create your own stemming user-dictionary. See <a href="#BHCHCFHI">"Stemming User-Dictionaries"</a> for more information.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">STEMMER</code> attribute of <code dir="ltr">BASIC_WORDLIST</code> preference will be ignored if the database session language causes <code dir="ltr">MULTI_LEXER</code> to choose a <code dir="ltr">SUB_LEXER</code> with the same setting as <code dir="ltr">wildcard_maxterms</code> or <code dir="ltr">ndata_base_letter</code>.
<p>In this case, the same stemmer that is used by the <code dir="ltr">BASIC_LEXER</code> during indexing will be used to determine the stem of the query term during query.</p>
</div>
</dd>
<dt><a id="sthref723"></a><a id="sthref724"></a>fuzzy_match</dt>
<dd>
<p>S<a id="sthref725"></a>pecify which fuzzy matching routines are used for the column. Fuzzy matching is currently supported for English, Japanese, and, to a lesser extent, the Western European languages.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">fuzzy_match</code> attributes value for Chinese and Korean are dummy attribute values that prevent the English and Japanese fuzzy matching routines from being used on Chinese and Korean text.</div>
<p>The default for <code dir="ltr">fuzzy_match</code> is <code dir="ltr">GENERIC</code>.</p>
<p>Specify <code dir="ltr">AUTO</code> for the system to automatically set the fuzzy matching language according to language setting of the session.</p>
</dd>
</dl>
<dl>
<dt><a id="sthref726"></a><a id="sthref727"></a>fuzzy_score</dt>
<dd>
<p>Specify a default lower limit of fuzzy score. Specify a number between 0 and 80. Text with scores below this number are not returned. The default is 60.</p>
<p>Fuzzy score is a measure of how close the expanded word is to the query word. The higher the score the better the match. Use this parameter to limit fuzzy expansions to the best matches.</p>
</dd>
<dt><a id="sthref728"></a><a id="sthref729"></a>fuzzy_numresults</dt>
<dd>
<p>Specify the maximum number of fuzzy expansions. Use a number between 0 and 5000. The default is 100.</p>
<p>Setting a fuzzy expansion limits the expansion to a specified number of the best matching words.</p>
</dd>
<dt><a id="sthref730"></a><a id="sthref731"></a><a id="sthref732"></a>substring_index</dt>
<dd>
<p>Specify <code dir="ltr">TRUE</code> for Oracle Text to create a substring index. A substring index improves performance for left-truncated or double-truncated wildcard queries such as <span class="italic">%ing</span> or <span class="italic">%benz%</span>. The default is false.</p>
<p>Substring indexing has the following impact on indexing and disk resources:</p>
</dd>
</dl>
<ul>
<li>
<p>Index creation and DML processing is up to 4 times slower</p>
</li>
<li>
<p>Index creation with <code dir="ltr">substring_index</code> enabled requires more rollback segments during index flushes than with substring index off. Oracle recommends that you do either of the following when creating a substring index:</p>
<ul>
<li>
<p>Make available double the usual rollback or</p>
</li>
<li>
<p>Decrease the index memory to reduce the size of the index flushes to disk</p>
</li>
</ul>
</li>
</ul>
<dl>
<dt><a id="sthref733"></a><a id="sthref734"></a>prefix_index</dt>
<dd>
<p>Specify <code dir="ltr">yes</code> to enable prefix indexing. Prefix indexing improves performance for right truncated wildcard searches such as <span class="italic">TO%</span>. Default is <code dir="ltr">NO</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Enabling prefix indexing increases index size.</div>
<p>Prefix indexing chops up tokens into multiple prefixes to store in the $I table. For example, words <code dir="ltr">TOKEN</code> and <code dir="ltr">TOY</code> are normally indexed as follows in the $I table:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="Sample prefix_index Tokens" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t75">Token</th>
<th class="cellalignment97" id="r1c2-t75">Type</th>
<th class="cellalignment97" id="r1c3-t75">Information</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t75" headers="r1c1-t75">TOKEN</td>
<td class="cellalignment98" headers="r2c1-t75 r1c2-t75">0</td>
<td class="cellalignment98" headers="r2c1-t75 r1c3-t75">DOCID 1 POS 1</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t75" headers="r1c1-t75">TOY</td>
<td class="cellalignment98" headers="r3c1-t75 r1c2-t75">0</td>
<td class="cellalignment98" headers="r3c1-t75 r1c3-t75">DOCID 1 POS 3</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>With prefix indexing, Oracle Text indexes the prefix substrings of these tokens as follows with a new token type of 6:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="Sample prefix_index Tokens" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t76">Token</th>
<th class="cellalignment97" id="r1c2-t76">Type</th>
<th class="cellalignment97" id="r1c3-t76">Information</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t76" headers="r1c1-t76">TOKEN</td>
<td class="cellalignment98" headers="r2c1-t76 r1c2-t76">0</td>
<td class="cellalignment98" headers="r2c1-t76 r1c3-t76">DOCID 1 POS 1</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t76" headers="r1c1-t76">TOY</td>
<td class="cellalignment98" headers="r3c1-t76 r1c2-t76">0</td>
<td class="cellalignment98" headers="r3c1-t76 r1c3-t76">DOCID 1 POS 3</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t76" headers="r1c1-t76">T</td>
<td class="cellalignment98" headers="r4c1-t76 r1c2-t76">6</td>
<td class="cellalignment98" headers="r4c1-t76 r1c3-t76">DOCID 1 POS 1 POS 3</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t76" headers="r1c1-t76">TO</td>
<td class="cellalignment98" headers="r5c1-t76 r1c2-t76">6</td>
<td class="cellalignment98" headers="r5c1-t76 r1c3-t76">DOCID 1 POS 1 POS 3</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t76" headers="r1c1-t76">TOK</td>
<td class="cellalignment98" headers="r6c1-t76 r1c2-t76">6</td>
<td class="cellalignment98" headers="r6c1-t76 r1c3-t76">DOCID 1 POS 1</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t76" headers="r1c1-t76">TOKE</td>
<td class="cellalignment98" headers="r7c1-t76 r1c2-t76">6</td>
<td class="cellalignment98" headers="r7c1-t76 r1c3-t76">DOCID 1 POS 1</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t76" headers="r1c1-t76">TOKEN</td>
<td class="cellalignment98" headers="r8c1-t76 r1c2-t76">6</td>
<td class="cellalignment98" headers="r8c1-t76 r1c3-t76">DOCID 1 POS 1</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t76" headers="r1c1-t76">TOY</td>
<td class="cellalignment98" headers="r9c1-t76 r1c2-t76">6</td>
<td class="cellalignment98" headers="r9c1-t76 r1c3-t76">DOCID 1 POS 3</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>Wildcard searches such as <code dir="ltr">TO%</code> are now faster because Oracle Text does no expansion of terms and merging of result sets. To obtain the result, Oracle Text need only examine the (TO,6) row.</p>
</dd>
<dt><a id="sthref735"></a>prefix_min_length</dt>
<dd>
<p>Specify the minimum length of indexed prefixes. Default is 1.</p>
<p>For example, setting <code dir="ltr">prefix_min_length</code> to 3 and <code dir="ltr">prefix_max_length</code> to 5 indexes all prefixes between 3 and 5 characters long.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A wildcard search whose pattern is below the minimum length or above the maximum length is searched using the slower method of equivalence expansion and merging.</div>
</dd>
<dt><a id="sthref736"></a>prefix_max_length</dt>
<dd>
<p>Specify the maximum length of indexed prefixes. Default is 64.</p>
<p>For example, setting <code dir="ltr">prefix_min_length</code> to 3 and <code dir="ltr">prefix_max_length</code> to 5 indexes all prefixes between 3 and 5 characters long.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A wildcard search whose pattern is below the minimum length or above the maximum length is searched using the slower method of equivalence expansion and merging.</div>
</dd>
<dt><a id="sthref737"></a>wildcard_maxterms</dt>
<dd>
<p>Specify the maximum number of terms in a wildcard (%) expansion. Use this parameter to keep wildcard query performance within an acceptable limit. Oracle Text returns an error when the wildcard query expansion exceeds this number.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Search terms with wild card queries having only the wildcard character, for example: <code dir="ltr">%</code>, <code dir="ltr">%_%</code>, and <code dir="ltr">%_</code>, are threaded as stopwords.</div>
</dd>
<dt>ndata_base_letter</dt>
<dd>
<p>Specify whether characters that have diacritical marks (umlauts, cedillas, acute accents, and so on) are converted to their base form before being stored in the Text index or queried by the <code dir="ltr">NDATA</code> operator. The default is <code dir="ltr">FALSE</code> (base-letter conversion disabled). For more information on base-letter conversions, see <a href="cspell.htm#CIHHECGC">"Base-Letter Conversion"</a>.</p>
</dd>
<dt>ndata_alternate_spelling</dt>
<dd>
<p>Specify whether to enable alternate spelling for German, Danish, and Swedish. Enabling alternate spelling allows you to index <code dir="ltr">NDATA</code> section data and query using the <code dir="ltr">NDATA</code> operator in alternate form.</p>
<p>When <code dir="ltr">ndata_base_letter</code> is enabled at the same time as <code dir="ltr">ndata_alternate_spelling</code>, <code dir="ltr">NDATA</code> section data is serially transformed first by alternate spelling and then by base lettering. For more information about the alternate spelling conventions Oracle Text uses, see <a href="cspell.htm#CIHBECGH">"Alternate Spelling"</a>.</p>
</dd>
<dt>ndata_thesaurus</dt>
<dd>
<p>Specify a name of the thesaurus used for alternate name expansion. The indexing engine expands names in documents using synonym rings in the thesaurus. A user should make use of homographic disambiguating feature of the thesaurus to distinguish common nicknames.</p>
<p>An example is:</p>
<pre dir="ltr">
Albert
  SYN Al
  SYN Bert
Alfred
  SYN Al
  SYN Fred
</pre>
<p>A simple definition such as the above will put Albert, Alfred, Al, Bert, and Fred into the same synonym ring. This will cause an unexpected expansion such that the expansion of Bert includes Fred. To prevent this, you can use homographic disambiguation as in:</p>
<pre dir="ltr">
Albert
  SYN Al (Albert)
  SYN Bert (Albert)
Alfred
  SYN Al (Alfred)
  SYN Fred (Alfred)
</pre>
<p>This forms two synonym rings, Albert-Al-Bert and Alfred-Al-Fred. Thus, the expansion of Bert no longer includes Fred. A more detailed example is:</p>
<pre dir="ltr">
begin
  ctx_ddl.create_preference('NDAT_PREF', 'BASIC_WORDLIST');
  ctx_ddl.set_attribute('NDATA_PREF', 'NDATA_ALTERNATE_SPELLING', 'FALSE');
  ctx_ddl.set_attribute('NDATA_PREF', 'NDATA_BASE_LETTER', 'TRUE');
  ctx_ddl.set_attribute('NDATA_PREF', 'NDATA_THESAURUS', 'NICKNAMES');
end;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
A sample thesaurus for names can be found in the <code dir="ltr">$ORACLE_HOME/ctx/sample/thes</code> directory. This file is <code dir="ltr">dr0thsnames.txt</code>.</div>
</dd>
<dt>ndata_join_particles</dt>
<dd>
<p>Specify a list of colon-separated name particles that can be joined with a name that follows them. A name particle, such as da, is written separately from or joined with its following name like da Vinci or daVinci. The indexing engine generates index data for both separated and join versions of a name when it finds a name particle specified in this prefence. The same happens in the query processing for better recall.</p>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<div id="CCREF2024" class="sect2"><a id="sthref738"></a>
<h3 class="sect2"><span class="secnum">2.5.2</span> BASIC_WORDLIST Example<a id="sthref739"></a><a id="sthref740"></a><a id="sthref741"></a><a id="sthref742"></a></h3>
<p>The following example shows the use of the <code dir="ltr">BASIC_WORDLIST</code> type.</p>
<div id="CCREF2025" class="sect3"><a id="sthref743"></a>
<h4 class="sect3"><span class="secnum">2.5.2.1</span> Enabling Fuzzy Matching and Stemming</h4>
<p>The following example enables stemming and fuzzy matching for English. The preference <code dir="ltr">STEM_FUZZY_PREF</code> sets the number of expansions to the maximum allowed. This preference also instructs the system to create a substring index to improve the performance of double-truncated searches.</p>
<pre dir="ltr">
begin 
  ctx_ddl.create_preference('STEM_FUZZY_PREF', 'BASIC_WORDLIST'); 
  ctx_ddl.set_attribute('STEM_FUZZY_PREF','FUZZY_MATCH','ENGLISH');
  ctx_ddl.set_attribute('STEM_FUZZY_PREF','FUZZY_SCORE','0');
  ctx_ddl.set_attribute('STEM_FUZZY_PREF','FUZZY_NUMRESULTS','5000');
  ctx_ddl.set_attribute('STEM_FUZZY_PREF','SUBSTRING_INDEX','TRUE');
  ctx_ddl.set_attribute('STEM_FUZZY_PREF','STEMMER','ENGLISH');
end; 
</pre>
<p>To create the index in SQL, enter the following statement:</p>
<pre dir="ltr">
create index fuzzy_stem_subst_idx on mytable ( docs ) 
  indextype is ctxsys.context parameters ('Wordlist STEM_FUZZY_PREF');
</pre></div>
<!-- class="sect3" -->
<div id="CCREF2026" class="sect3"><a id="sthref744"></a>
<h4 class="sect3"><span class="secnum">2.5.2.2</span> Enabling Sub-string and Prefix Indexing</h4>
<p>The following example sets the wordlist preference for prefix and sub-string indexing. For prefix indexing, it specifies that Oracle Text create token prefixes between 3 and 4 characters long:</p>
<pre dir="ltr">
begin 
</pre>
<pre dir="ltr">
ctx_ddl.create_preference('mywordlist', 'BASIC_WORDLIST'); 
ctx_ddl.set_attribute('mywordlist','PREFIX_INDEX','TRUE');
ctx_ddl.set_attribute('mywordlist','PREFIX_MIN_LENGTH',3);
ctx_ddl.set_attribute('mywordlist','PREFIX_MAX_LENGTH', 4);
ctx_ddl.set_attribute('mywordlist','SUBSTRING_INDEX', 'YES');
</pre>
<pre dir="ltr">
end
</pre></div>
<!-- class="sect3" -->
<div id="CCREF2027" class="sect3"><a id="sthref745"></a>
<h4 class="sect3"><span class="secnum">2.5.2.3</span> Setting Wildcard Expansion Limit</h4>
<p>Use the wildcard_maxterms attribute to set the maximum allowed terms in a wildcard expansion.</p>
<pre dir="ltr">
--- create a sample table
drop table quick ;
create table quick 
  ( 
    quick_id number primary key, 
    text      varchar(80) 
  ); 

--- insert a row with 10 expansions for 'tire%'
insert into quick ( quick_id, text ) 
  values ( 1, 'tire tirea tireb tirec tired tiree tiref tireg tireh tirei tirej');
commit;

--- create an index using wildcard_maxterms=100
begin 
    Ctx_Ddl.Create_Preference('wildcard_pref', 'BASIC_WORDLIST'); 
    ctx_ddl.set_attribute('wildcard_pref', 'wildcard_maxterms', 100) ;
end; 
/
create index wildcard_idx on quick(text)
    indextype is ctxsys.context 
    parameters ('Wordlist wildcard_pref') ;

--- query on 'tire%' - should work fine
select quick_id from quick
  where contains ( text, 'tire%' ) &gt; 0;

--- now re-create the index with wildcard_maxterms=5

drop index wildcard_idx ;

begin 
    Ctx_Ddl.Drop_Preference('wildcard_pref'); 
    Ctx_Ddl.Create_Preference('wildcard_pref', 'BASIC_WORDLIST'); 
    ctx_ddl.set_attribute('wildcard_pref', 'wildcard_maxterms', 5) ;
end; 
/

create index wildcard_idx on quick(text)
    indextype is ctxsys.context 
    parameters ('Wordlist wildcard_pref') ;

--- query on 'tire%' gives "wildcard query expansion resulted in too many terms"
select quick_id from quick
  where contains ( text, 'tire%' ) &gt; 0;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009245"></a>
<div id="CCREF0230" class="sect1">
<h2 class="sect1"><span class="secnum">2.6</span> Storage Types<a id="sthref746"></a><a id="sthref747"></a><a id="sthref748"></a></h2>
<p>Use the storage preference to specify tablespace and creation parameters for tables associated with a Text index. The system provides a single storage type called <code dir="ltr">BASIC_STORAGE</code>:</p>
<div id="CCREF23804" class="tblformal">
<p class="titleintable"><a id="sthref749"></a><a id="sthref750"></a>Table 2-34 Storage Types</p>
<table class="cellalignment103" title="Storage Types" summary="This table describes storage types." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t81">Type</th>
<th class="cellalignment97" id="r1c2-t81">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t81" headers="r1c1-t81">
<p><code dir="ltr">BASIC_STORAGE</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t81 r1c2-t81">
<p>Indexing type used to specify the tablespace and creation parameters for the database tables and indexes that constitute a Text index.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="i1009262"></a>
<div id="CCREF2028" class="sect2">
<h3 class="sect2"><span class="secnum">2.6.1</span> <a id="sthref751"></a>BASIC_STORAGE</h3>
<p>The <code dir="ltr">BASIC_STORAGE</code> type specifies the tablespace and creation parameters for the database tables and indexes that constitute a Text index.</p>
<p>The clause you specify is added to the internal <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> (<code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> for the <code dir="ltr">i_index_clause</code>) statement at index creation. You can specify most allowable clauses, such as storage, LOB storage, or partitioning. However, you cannot specify an index organized table clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about how to specify <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> and <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> statements, see <a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span>.</a></div>
<p><code dir="ltr">BASIC_STORAGE</code> has the following attributes:</p>
<div id="CCREF23805" class="tblformal">
<p class="titleintable"><a id="sthref752"></a><a id="BHCGFIJI"></a>Table 2-35 BASIC_STORAGE Attributes</p>
<table class="cellalignment103" title="BASIC_STORAGE Attributes" summary="This table describes the BASIC_STORAGE attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t83">Attribute</th>
<th class="cellalignment97" id="r1c2-t83">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t83" headers="r1c1-t83">
<p><a id="sthref753"></a><a id="sthref754"></a><code dir="ltr">i_index_clause</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t83 r1c2-t83">
<p>Parameter clause for dr$<span class="italic">indexname</span>$X index creation. Specify&nbsp;storage and tablespace clauses to add to the end of the internal <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> statement. The default clause is: <code dir="ltr">'COMPRESS 2'</code> which instructs Oracle Text to compress this index table.</p>
<p>If you choose to override the default, Oracle recommends including <code dir="ltr">COMPRESS 2</code> in your parameter clause to compress this table, because such compression saves disk space and helps query performance.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t83" headers="r1c1-t83">
<p><code dir="ltr"><a id="sthref755"></a>i_rowid_index_clause</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t83 r1c2-t83">
<p>Parameter clause to specify the storage clause for the $R index on dr$<span class="italic">rowid</span> column of the $I table. Specify storage and tablespace clauses to add to the end of the internal <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> statement.</p>
<p>This clause is only used by the <code dir="ltr">CTXCAT</code> index type.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t83" headers="r1c1-t83">
<p><a id="sthref756"></a><a id="sthref757"></a><code dir="ltr">i_table_clause</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t83 r1c2-t83">
<p>Parameter clause for dr$<span class="italic">indexname</span>$I table creation. Specify storage and tablespace clauses to add to the end of the internal <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement.</p>
<p>The I table is the index data table.</p>
<p><span class="bold">Note:</span> Oracle strongly recommends that you do not specify "disable storage in row" for $I LOBs, as this will greatly degrade the query performance.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t83" headers="r1c1-t83">
<p><a id="sthref758"></a><a id="sthref759"></a><code dir="ltr">k_table_clause</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t83 r1c2-t83">
<p>Parameter clause for dr$<span class="italic">indexname</span>$K table creation. Specify storage and tablespace clauses to add to the end of the internal <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement.</p>
<p>The K table is the keymap table.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t83" headers="r1c1-t83">
<p><a id="sthref760"></a><a id="sthref761"></a><code dir="ltr">r_table_clause</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t83 r1c2-t83">
<p>Parameter clause for dr$<span class="italic">indexname</span>$R table creation. Specify storage and tablespace clauses to add to the end of the internal <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement.</p>
<p>The R table is the rowid table.</p>
<p>The default clause is: <code dir="ltr">'LOB(DATA) STORE AS (CACHE)'.</code></p>
<p>If you modify this attribute, always include this clause for good performance.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t83" headers="r1c1-t83">
<p><a id="sthref762"></a><a id="sthref763"></a><code dir="ltr">n_table_clause</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t83 r1c2-t83">
<p>Parameter clause for dr$<span class="italic">indexname</span>$N table creation. Specify storage and tablespace clauses to add to the end of the internal <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement.</p>
<p>The N table is the negative list table.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t83" headers="r1c1-t83">
<p><a id="sthref764"></a><a id="sthref765"></a><code dir="ltr">p_table_clause</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t83 r1c2-t83">
<p>Parameter clause for the substring index if you have enabled <code dir="ltr">SUBSTRING_INDEX</code> in the <code dir="ltr">BASIC_WORDLIST</code>.</p>
<p>Specify storage and tablespace clauses to add to the end of the internal <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> statement. The P table is an index-organized table so the storage clause you specify must be appropriate to this type of table.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t83" headers="r1c1-t83">
<p><code dir="ltr">s_table_clause</code></p>
</td>
<td class="cellalignment98" headers="r9c1-t83 r1c2-t83">
<p>Parameter clause for dr$<span class="italic">indexname</span>$S table creation*. Specify storage and tablespace clauses to add to the end of the internal <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement. The default clause is <code dir="ltr">nocompress</code>.</p>
<p>* For performance reasons, $S table must be created on a tablespace with db block size &gt;= 4K without overflow segment and without a <code dir="ltr">PCTTHRESHOLD</code> clause. If $S is created on a tablespace with db block size &lt; 4K, or is created with an overflow segment or with <code dir="ltr">PCTTHRESHOLD</code> clause, then appropriate errors will be raised during <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
<p>The S table is the table that stores <code dir="ltr">SDATA</code> section values.</p>
<p>If this clause is specified for a storage preference in an index without <code dir="ltr">SDATA</code>, then it will have no effect on the index, and index creation will still succeed.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="CCREF2029" class="sect3"><a id="sthref766"></a>
<h4 class="sect3"><span class="secnum">2.6.1.1</span> Storage Default Behavior<a id="sthref767"></a><a id="sthref768"></a></h4>
<p>By default, <code dir="ltr">BASIC_STORAGE</code> attributes are not set. In such cases, the Text index tables are created in the index owner's default tablespace. Consider the following statement, entered by user <code dir="ltr">IUSER</code>, with no <code dir="ltr">BASIC_STORAGE</code> attributes set:</p>
<pre dir="ltr">
create index IOWNER.idx on TOWNER.tab(b) indextype is ctxsys.context;
</pre>
<p>In this example, the text index is created in <code dir="ltr">IOWNER's</code> default tablespace.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF2030" class="sect3"><a id="sthref769"></a>
<h4 class="sect3"><span class="secnum">2.6.1.2</span> Storage Example<a id="sthref770"></a><a id="sthref771"></a>s</h4>
<p>The following examples specify that the index tables are to be created in the <code dir="ltr">foo</code> tablespace with an initial extent of 1K:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('mystore', 'BASIC_STORAGE');
ctx_ddl.set_attribute('mystore', 'I_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'K_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'R_TABLE_CLAUSE',
                        'tablespace users storage (initial 1K) lob
                         (data) store as (disable storage in row cache)');
ctx_ddl.set_attribute('mystore', 'N_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'I_INDEX_CLAUSE',
                        'tablespace foo storage (initial 1K) compress 2');
ctx_ddl.set_attribute('mystore', 'P_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'S_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)');
end;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009342"></a>
<div id="CCREF0234" class="sect1">
<h2 class="sect1"><span class="secnum">2.7</span> Section Group Types<a id="sthref772"></a><a id="sthref773"></a></h2>
<p>To enter <code dir="ltr">WITHIN</code> queries on document sections, you must create a section group before you define your sections. Specify your section group in the parameter clause of <a href="csql.htm#i997677">CREATE INDEX</a>.</p>
<p>To create a section group, you can specify one of the following group types with the CTX_DDL.<a href="cddlpkg.htm#i997893">CREATE_SECTION_GROUP</a> procedure:</p>
<div id="CCREF23806" class="tblformal">
<p class="titleintable"><a id="sthref774"></a><a id="sthref775"></a>Table 2-36 Section Group Types</p>
<table class="cellalignment103" title="Section Group Types" summary="This table describes section group types." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t84">Type</th>
<th class="cellalignment97" id="r1c2-t84">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t84" headers="r1c1-t84">
<p><code dir="ltr"><a id="sthref776"></a>NULL_SECTION_GROUP</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t84 r1c2-t84">
<p>Use this group type when you define no sections or when you define <span class="italic">only</span> <code dir="ltr">SENTENCE</code> or <code dir="ltr">PARAGRAPH</code> sections. This is the default.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t84" headers="r1c1-t84">
<p><code dir="ltr"><a id="sthref777"></a>BASIC_SECTION_GROUP</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t84 r1c2-t84">
<p>Use this group type for defining sections where the start and end tags are of the form <code dir="ltr">&lt;A&gt;</code> and <code dir="ltr">&lt;/A&gt;</code>.</p>
<p>Note: This group type does not support input such as unbalanced parentheses, comments tags, and attributes. Use <code dir="ltr">HTML_SECTION_GROUP</code> for this type of input.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t84" headers="r1c1-t84">
<p><code dir="ltr"><a id="sthref778"></a><a id="sthref779"></a>HTML_SECTION_GROUP</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t84 r1c2-t84">
<p>Use this group type for indexing HTML documents and for defining sections in HTML documents.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t84" headers="r1c1-t84">
<p><code dir="ltr"><a id="sthref780"></a>XML_SECTION_GROUP</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t84 r1c2-t84">
<p>Use this group type for indexing XML documents and for defining sections in XML documents. All sections to be indexed must be manually defined for this group.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t84" headers="r1c1-t84">
<p><code dir="ltr"><a id="sthref781"></a><a id="sthref782"></a>AUTO_SECTION_GROUP</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t84 r1c2-t84">
<p>Use this group type to automatically create a zone section for each start-tag/end-tag pair in an XML document. The section names derived from XML tags are case sensitive as in XML.</p>
<p>Attribute sections are created automatically for XML tags that have attributes. Attribute sections are named in the form tag@attribute.</p>
<p>Special sections can be added to <code dir="ltr">AUTO_SECTION_GROUP</code> for <code dir="ltr">WITHIN</code> <code dir="ltr">SENTENCE</code> and <code dir="ltr">WITHIN</code> <code dir="ltr">PARAGRAPH</code> searches. Once a sentence or paragraph section is added to the <code dir="ltr">AUTO_SECTION_GROUP</code>, sections with corresponding tag names '<code dir="ltr">sentence</code>' or '<code dir="ltr">paragraph</code>' (case insensitive) are treated as stop sections.</p>
<p>Stop sections, empty tags, processing instructions, and comments are not indexed.</p>
<p>The following limitations apply to automatic section groups:</p>
<ul>
<li>
<p>You cannot add zone, field, sdata, or special sections to an automatic section group.</p>
</li>
<li>
<p>You can define a stop section that applies only to one particular type; that is, if you have two different XML DTDs, both of which use a tag called <code dir="ltr">FOO</code>, you can define <code dir="ltr">(TYPE1)FOO</code> to be stopped, but<code dir="ltr">(TYPE2)FOO</code> to not be stopped.</p>
</li>
<li>
<p>The length of the indexed tags, including prefix and namespace, cannot exceed 64 bytes. Tags longer than this are not indexed.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t84" headers="r1c1-t84">
<p><code dir="ltr"><a id="sthref783"></a>PATH_SECTION_GROUP</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t84 r1c2-t84">
<p>Use this group type to index XML documents. Behaves like the <code dir="ltr">AUTO_SECTION_GROUP</code>.</p>
<p>The difference is that with this section group you can do path searching with the <code dir="ltr">INPATH</code> and <code dir="ltr">HASPATH</code> operators. Queries are also case-sensitive for tag and attribute names. Stop sections are not allowed.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t84" headers="r1c1-t84">
<p><code dir="ltr"><a id="sthref784"></a>NEWS_SECTION_GROUP</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t84 r1c2-t84">
<p>Use this group for defining sections in newsgroup formatted documents according to RFC 1036.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="CCREF2031" class="sect2"><a id="sthref785"></a>
<h3 class="sect2"><span class="secnum">2.7.1</span> Section Group Examples<a id="sthref786"></a></h3>
<p>This example shows the use of section groups in both HTML and XML documents.</p>
<div id="CCREF2032" class="sect3"><a id="sthref787"></a>
<h4 class="sect3"><span class="secnum">2.7.1.1</span> Creating Section Groups in HTML Documents<a id="sthref788"></a></h4>
<p>The following statement creates a section group called <code dir="ltr">htmgroup</code> with the HTML group type.</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
end;
</pre>
<p>You can optionally add sections to this group using the procedures in the <code dir="ltr">CTX_DDL</code> package, such as <code dir="ltr">CTX_DDL.ADD_SPECIAL_SECTION</code> or <code dir="ltr">CTX_DDL.ADD_ZONE_SECTION</code>. To index your documents, enter a statement such as:</p>
<pre dir="ltr">
create index myindex on docs(htmlfile) indextype is ctxsys.context 
parameters('filter ctxsys.null_filter section group htmgroup');
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information on section groups, see <a href="cddlpkg.htm#g1014415">Chapter 7, "CTX_DDL Package"</a></div>
</div>
<!-- class="sect3" -->
<div id="CCREF2033" class="sect3"><a id="sthref789"></a>
<h4 class="sect3"><span class="secnum">2.7.1.2</span> Creating Sections Groups in XML Documents<a id="sthref790"></a></h4>
<p>The following statement creates a section group called <code dir="ltr">xmlgroup</code> with the <code dir="ltr">XML_SECTION_GROUP</code> group type.</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('xmlgroup', 'XML_SECTION_GROUP');
end;
</pre>
<p>You can optionally add sections to this group using the procedures in the <code dir="ltr">CTX_DDL</code> package, such as <code dir="ltr">CTX_DDL.ADD_ATTR_SECTION</code> or <code dir="ltr">CTX_DDL.ADD_STOP_SECTION</code>. To index your documents, enter a statement such as:</p>
<pre dir="ltr">
create index myindex on docs(htmlfile) indextype is ctxsys.context 
parameters('filter ctxsys.null_filter section group xmlgroup');
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information on section groups, see <a href="cddlpkg.htm#g1014415">Chapter 7, "CTX_DDL Package"</a></div>
</div>
<!-- class="sect3" -->
<div id="CCREF2034" class="sect3"><a id="sthref791"></a>
<h4 class="sect3"><span class="secnum">2.7.1.3</span> Automatic Sectioning in XML Documents<a id="sthref792"></a><a id="sthref793"></a></h4>
<p>The following statement creates a section group called <code dir="ltr">auto</code> with the <code dir="ltr">AUTO_SECTION_GROUP</code> group type. This section group automatically creates sections from tags in XML documents.</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.create_section_group('auto', 'AUTO_SECTION_GROUP');
</pre>
<pre dir="ltr">
end;

CREATE INDEX myindex on docs(htmlfile) INDEXTYPE IS ctxsys.context 
PARAMETERS('filter ctxsys.null_filter section group auto');
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009435"></a>
<div id="CCREF2035" class="sect1">
<h2 class="sect1"><span class="secnum">2.8</span> Classifier Types</h2>
<p>This section describes the classifier types used to create a preference for <code dir="ltr">CTX_CLS.TRAIN</code> and <code dir="ltr">CTXRULE</code> index creation. The following two classifier types are supported:</p>
<ul>
<li>
<p><a href="#i1010632">RULE_CLASSIFIER</a></p>
</li>
<li>
<p><a href="#i1018114">SVM_CLASSIFIER</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
In Oracle Database XE Edition, <code dir="ltr">RULE_CLASSIFIER</code> and <code dir="ltr">SVM_CLASSIFIER</code> are not supported because the Data Mining option is not available. This is also true for <code dir="ltr">KMEAN_CLUSTERING</code>.</div>
<a id="i1010632"></a>
<div id="CCREF2036" class="sect2">
<h3 class="sect2"><span class="secnum">2.8.1</span> RULE_CLASSIFIER<a id="sthref794"></a><a id="sthref795"></a></h3>
<p>Use the <code dir="ltr">RULE_CLASSIFIER</code> type for creating preferences for the query rule generating procedure, <code dir="ltr">CTX_CLS.TRAIN</code> and for <code dir="ltr">CTXRULE</code> creation. The rules generated with this type are essentially query strings and can be easily examined. The queries generated by this classifier can use the <code dir="ltr">AND</code>, <code dir="ltr">NOT</code>, or <code dir="ltr">ABOUT</code> operators. The <code dir="ltr">WITHIN</code> operator is supported for queries on field sections only.</p>
<p>This type has the following attributes:</p>
<div id="CCREF23807" class="tblformal">
<p class="titleintable"><a id="sthref796"></a><a id="sthref797"></a>Table 2-37 RULE_CLASSIFIER Attributes</p>
<table class="cellalignment103" title="RULE_CLASSIFIER Attributes" summary="This table describes the RULE_CLASSIFIER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t88">Attribute</th>
<th class="cellalignment97" id="r1c2-t88">Data Type</th>
<th class="cellalignment97" id="r1c3-t88">Default</th>
<th class="cellalignment97" id="r1c4-t88">Min Value</th>
<th class="cellalignment97" id="r1c5-t88">Max Value</th>
<th class="cellalignment97" id="r1c6-t88">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t88" headers="r1c1-t88">
<p><code dir="ltr">THRESHOLD</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t88 r1c2-t88">
<p>I</p>
</td>
<td class="cellalignment98" headers="r2c1-t88 r1c3-t88">
<p>50</p>
</td>
<td class="cellalignment98" headers="r2c1-t88 r1c4-t88">
<p>1</p>
</td>
<td class="cellalignment98" headers="r2c1-t88 r1c5-t88">
<p>99</p>
</td>
<td class="cellalignment98" headers="r2c1-t88 r1c6-t88">
<p>Specify threshold (in percentage) for rule generation. One rule is output only when its confidence level is larger than threshold.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t88" headers="r1c1-t88">
<p><code dir="ltr">MAX_TERMS</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t88 r1c2-t88">
<p>I</p>
</td>
<td class="cellalignment98" headers="r3c1-t88 r1c3-t88">
<p>100</p>
</td>
<td class="cellalignment98" headers="r3c1-t88 r1c4-t88">
<p>20</p>
</td>
<td class="cellalignment98" headers="r3c1-t88 r1c5-t88">
<p>2000</p>
</td>
<td class="cellalignment98" headers="r3c1-t88 r1c6-t88">
<p>For each class, a list of relevant terms is selected to form rules. Specify the maximum number of terms that can be selected for each class.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t88" headers="r1c1-t88">
<p><code dir="ltr">MEMORY_SIZE</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t88 r1c2-t88">
<p>I</p>
</td>
<td class="cellalignment98" headers="r4c1-t88 r1c3-t88">
<p>500</p>
</td>
<td class="cellalignment98" headers="r4c1-t88 r1c4-t88">
<p>10</p>
</td>
<td class="cellalignment98" headers="r4c1-t88 r1c5-t88">
<p>4000</p>
</td>
<td class="cellalignment98" headers="r4c1-t88 r1c6-t88">
<p>Specify memory usage for training in MB. Larger values improve performance.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t88" headers="r1c1-t88">
<p><code dir="ltr">NT_THRESHOLD</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t88 r1c2-t88">
<p>F</p>
</td>
<td class="cellalignment98" headers="r5c1-t88 r1c3-t88">
<p>0.001</p>
</td>
<td class="cellalignment98" headers="r5c1-t88 r1c4-t88">
<p>0</p>
</td>
<td class="cellalignment98" headers="r5c1-t88 r1c5-t88">
<p>0.90</p>
</td>
<td class="cellalignment98" headers="r5c1-t88 r1c6-t88">
<p>Specify a threshold for term selection. There are two thresholds guiding two steps in selecting relevant terms. This threshold controls the behavior of the first step. At this step, terms are selected as candidate terms for the further consideration in the second step. The term is chosen when the ratio of the occurrence frequency over the number of documents in the training set is larger than this threshold.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t88" headers="r1c1-t88">
<p><code dir="ltr">TERM_THRESHOLD</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t88 r1c2-t88">
<p>I</p>
</td>
<td class="cellalignment98" headers="r6c1-t88 r1c3-t88">
<p>10</p>
</td>
<td class="cellalignment98" headers="r6c1-t88 r1c4-t88">
<p>0</p>
</td>
<td class="cellalignment98" headers="r6c1-t88 r1c5-t88">
<p>100</p>
</td>
<td class="cellalignment98" headers="r6c1-t88 r1c6-t88">
<p>Specify a threshold as a percentage for term selection. This threshold controls the second step term selection. Each candidate term has a numerical quantity calculated to imply its correlation with a given class. The candidate term will be selected for this class only when the ratio of its quantity value over the maximum value for all candidate terms in the class is larger than this threshold.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t88" headers="r1c1-t88">
<p><code dir="ltr">PRUNE_LEVEL</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t88 r1c2-t88">
<p>I</p>
</td>
<td class="cellalignment98" headers="r7c1-t88 r1c3-t88">
<p>75</p>
</td>
<td class="cellalignment98" headers="r7c1-t88 r1c4-t88">
<p>0</p>
</td>
<td class="cellalignment98" headers="r7c1-t88 r1c5-t88">
<p>100</p>
</td>
<td class="cellalignment98" headers="r7c1-t88 r1c6-t88">
<p>Specify how much to prune a built decision tree for better coverage. Higher values mean more aggressive pruning and the generated rules will have larger coverage but less accuracy.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="i1018114"></a>
<div id="CCREF2037" class="sect2">
<h3 class="sect2"><span class="secnum">2.8.2</span> SVM_CLASSIFIER</h3>
<p>Use the <code dir="ltr">SVM_CLASSIFIER</code> type for creating preferences for the rule generating procedure, <code dir="ltr">CTX_CLS.TRAIN</code>, and for <code dir="ltr">CTXRULE</code> creation. This classifier type represents the Support Vector Machine method of classification and generates rules in binary format. Use this classifier type when you need high classification accuracy.</p>
<p>This type has the following attributes:</p>
<div id="CCREF23808" class="tblformal">
<p class="titleintable"><a id="sthref798"></a><a id="sthref799"></a>Table 2-38 SVM_CLASSIFIER Attributes</p>
<table class="cellalignment103" title="SVM_CLASSIFIER Attributes" summary="This table summarizes the SVM_CLASSIFIER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t89">Attribute Name</th>
<th class="cellalignment97" id="r1c2-t89">Data Type</th>
<th class="cellalignment97" id="r1c3-t89">Default</th>
<th class="cellalignment97" id="r1c4-t89">Min Value</th>
<th class="cellalignment97" id="r1c5-t89">Max Value</th>
<th class="cellalignment97" id="r1c6-t89">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t89" headers="r1c1-t89">
<p><code dir="ltr">MAX_DOCTERMS</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t89 r1c2-t89">
<p>I</p>
</td>
<td class="cellalignment98" headers="r2c1-t89 r1c3-t89">
<p>50</p>
</td>
<td class="cellalignment98" headers="r2c1-t89 r1c4-t89">
<p>10</p>
</td>
<td class="cellalignment98" headers="r2c1-t89 r1c5-t89">
<p>8192</p>
</td>
<td class="cellalignment98" headers="r2c1-t89 r1c6-t89">
<p>Specify the maximum number of terms representing one document.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t89" headers="r1c1-t89">
<p><code dir="ltr">MAX_FEATURES</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t89 r1c2-t89">
<p>I</p>
</td>
<td class="cellalignment98" headers="r3c1-t89 r1c3-t89">
<p>3,000</p>
</td>
<td class="cellalignment98" headers="r3c1-t89 r1c4-t89">
<p>1</p>
</td>
<td class="cellalignment98" headers="r3c1-t89 r1c5-t89">
<p>100,000</p>
</td>
<td class="cellalignment98" headers="r3c1-t89 r1c6-t89">
<p>Specify the maximum number of distinct features.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t89" headers="r1c1-t89">
<p><code dir="ltr">THEME_ON</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t89 r1c2-t89">
<p>B</p>
</td>
<td class="cellalignment98" headers="r4c1-t89 r1c3-t89">
<p>FALSE</p>
</td>
<td class="cellalignment98" headers="r4c1-t89 r1c4-t89">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r4c1-t89 r1c5-t89">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r4c1-t89 r1c6-t89">
<p>Specify <code dir="ltr">TRUE</code> to use themes as features.</p>
<p>Classification with themes requires an installed knowledge base. A knowledge base may or may not have been installed with Oracle Text. For more information on knowledge bases, see the <a class="olink CCAPP0900" href="../../text.112/e24435/cthes.htm#CCAPP0900"><span class="italic">Oracle Text Application Developer's Guide</span></a>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t89" headers="r1c1-t89">
<p><code dir="ltr">TOKEN_ON</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t89 r1c2-t89">
<p>B</p>
</td>
<td class="cellalignment98" headers="r5c1-t89 r1c3-t89">
<p>TRUE</p>
</td>
<td class="cellalignment98" headers="r5c1-t89 r1c4-t89">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r5c1-t89 r1c5-t89">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r5c1-t89 r1c6-t89">
<p>Specify <code dir="ltr">TRUE</code> to use regular tokens as features.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t89" headers="r1c1-t89">
<p><code dir="ltr">STEM_ON</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t89 r1c2-t89">
<p>B</p>
</td>
<td class="cellalignment98" headers="r6c1-t89 r1c3-t89">
<p>FALSE</p>
</td>
<td class="cellalignment98" headers="r6c1-t89 r1c4-t89">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r6c1-t89 r1c5-t89">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r6c1-t89 r1c6-t89">
<p>Specify <code dir="ltr">TRUE</code> to use stemmed tokens as features. This only works when turning <code dir="ltr">INDEX_STEM</code> on for the lexer.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t89" headers="r1c1-t89">
<p><code dir="ltr">MEMORY_SIZE</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t89 r1c2-t89">
<p>I</p>
</td>
<td class="cellalignment98" headers="r7c1-t89 r1c3-t89">
<p>500</p>
</td>
<td class="cellalignment98" headers="r7c1-t89 r1c4-t89">
<p>10</p>
</td>
<td class="cellalignment98" headers="r7c1-t89 r1c5-t89">
<p>4000</p>
</td>
<td class="cellalignment98" headers="r7c1-t89 r1c6-t89">
<p>Specify approximate memory size in MB.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t89" headers="r1c1-t89">
<p><code dir="ltr">SECTION_WEIGHT</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t89 r1c2-t89">
<p>1</p>
</td>
<td class="cellalignment98" headers="r8c1-t89 r1c3-t89">
<p>2</p>
</td>
<td class="cellalignment98" headers="r8c1-t89 r1c4-t89">
<p>0</p>
</td>
<td class="cellalignment98" headers="r8c1-t89 r1c5-t89">
<p>100</p>
</td>
<td class="cellalignment98" headers="r8c1-t89 r1c6-t89">
<p>Specify the occurrence multiplier for adding a term in a field section as a normal term. For example, by default, the term <span class="italic">cat</span> in "&lt;A&gt;cat&lt;/A&gt;" is a field section term and is treated as a normal term with occurrence equal to 2, but you can specify that it be treated as a normal term with a weight up to 100. <code dir="ltr">SECTION_WEIGHT</code> is only meaningful when the index policy specifies a field section.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1015204"></a>
<div id="CCREF2038" class="sect1">
<h2 class="sect1"><span class="secnum">2.9</span> Cluster Types<a id="sthref800"></a><a id="sthref801"></a><a id="sthref802"></a><a id="sthref803"></a><a id="sthref804"></a></h2>
<p>This section describes the cluster types used for creating preferences for the <code dir="ltr">CTX_CLS.CLUSTERING</code> procedure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In Oracle Database XE Edition, <code dir="ltr">KMEAN_CLUSTERING</code> is not supported because the Data Mining option is not available. This is also true for <code dir="ltr">RULE_CLASSIFIER</code> and <code dir="ltr">SVM_CLASSIFIER</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about clustering, see <a href="cclspkg.htm#i996892">"CLUSTERING"</a> in <a href="cclspkg.htm#g1000169">Chapter 6, "CTX_CLS Package"</a> as well as the <a class="olink CCAPP0600" href="../../text.112/e24435/classify.htm#CCAPP0600"><span class="italic">Oracle Text Application Developer's Guide</span></a></div>
<div id="CCREF2039" class="sect2"><a id="sthref805"></a>
<h3 class="sect2"><span class="secnum">2.9.1</span> <a id="sthref806"></a><a id="sthref807"></a>KMEAN_CLUSTERING</h3>
<p>This clustering type has the following attributes:</p>
<div id="CCREF23809" class="tblformal">
<p class="titleintable"><a id="sthref808"></a><a id="sthref809"></a>Table 2-39 KMEAN_CLUSTERING Attributes</p>
<table class="cellalignment103" title="KMEAN_CLUSTERING Attributes" summary="This table describes the KMEAN_CLUSTER attributes." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t92">Attribute Name</th>
<th class="cellalignment97" id="r1c2-t92">Data Type</th>
<th class="cellalignment97" id="r1c3-t92">Default</th>
<th class="cellalignment97" id="r1c4-t92">Min Value</th>
<th class="cellalignment97" id="r1c5-t92">Max Value</th>
<th class="cellalignment97" id="r1c6-t92">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t92" headers="r1c1-t92">
<p><code dir="ltr">MAX_DOCTERMS</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t92 r1c2-t92">
<p>I</p>
</td>
<td class="cellalignment98" headers="r2c1-t92 r1c3-t92">
<p>50</p>
</td>
<td class="cellalignment98" headers="r2c1-t92 r1c4-t92">
<p>10</p>
</td>
<td class="cellalignment98" headers="r2c1-t92 r1c5-t92">
<p>8192</p>
</td>
<td class="cellalignment98" headers="r2c1-t92 r1c6-t92">
<p>Specify the maximum number of distinct terms representing one document.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t92" headers="r1c1-t92">
<p><code dir="ltr">MAX_FEATURES</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t92 r1c2-t92">
<p>I</p>
</td>
<td class="cellalignment98" headers="r3c1-t92 r1c3-t92">
<p>3,000</p>
</td>
<td class="cellalignment98" headers="r3c1-t92 r1c4-t92">
<p>1</p>
</td>
<td class="cellalignment98" headers="r3c1-t92 r1c5-t92">
<p>500,000</p>
</td>
<td class="cellalignment98" headers="r3c1-t92 r1c6-t92">
<p>Specify the maximum number of distinct features.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t92" headers="r1c1-t92">
<p><code dir="ltr">THEME_ON</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t92 r1c2-t92">
<p>B</p>
</td>
<td class="cellalignment98" headers="r4c1-t92 r1c3-t92">
<p>FALSE</p>
</td>
<td class="cellalignment98" headers="r4c1-t92 r1c4-t92">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r4c1-t92 r1c5-t92">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r4c1-t92 r1c6-t92">
<p>Specify <code dir="ltr">TRUE</code> to use themes as features.</p>
<p>Clustering with themes requires an installed knowledge base. A knowledge base may or may not have been installed with Oracle Text. For more information on knowledge bases, see <a class="olink CCAPP0900" href="../../text.112/e24435/cthes.htm#CCAPP0900"><span class="italic">Oracle Text Application Developer's Guide</span></a>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t92" headers="r1c1-t92">
<p><code dir="ltr">TOKEN_ON</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t92 r1c2-t92">
<p>B</p>
</td>
<td class="cellalignment98" headers="r5c1-t92 r1c3-t92">
<p>TRUE</p>
</td>
<td class="cellalignment98" headers="r5c1-t92 r1c4-t92">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r5c1-t92 r1c5-t92">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r5c1-t92 r1c6-t92">
<p>Specify <code dir="ltr">TRUE</code> to use regular tokens as features.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t92" headers="r1c1-t92">
<p><code dir="ltr">STEM_ON</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t92 r1c2-t92">
<p>B</p>
</td>
<td class="cellalignment98" headers="r6c1-t92 r1c3-t92">
<p>FALSE</p>
</td>
<td class="cellalignment98" headers="r6c1-t92 r1c4-t92">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r6c1-t92 r1c5-t92">
<p>NULL</p>
</td>
<td class="cellalignment98" headers="r6c1-t92 r1c6-t92">
<p>Specify <code dir="ltr">TRUE</code> to use stemmed tokens as features. This only works when turning <code dir="ltr">INDEX_STEM</code> on for the lexer.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t92" headers="r1c1-t92">
<p><code dir="ltr">MEMORY_SIZE</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t92 r1c2-t92">
<p>I</p>
</td>
<td class="cellalignment98" headers="r7c1-t92 r1c3-t92">
<p>500</p>
</td>
<td class="cellalignment98" headers="r7c1-t92 r1c4-t92">
<p>10</p>
</td>
<td class="cellalignment98" headers="r7c1-t92 r1c5-t92">
<p>4000</p>
</td>
<td class="cellalignment98" headers="r7c1-t92 r1c6-t92">
<p>Specify approximate memory size in MB.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t92" headers="r1c1-t92">
<p><code dir="ltr">SECTION_WEIGHT</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t92 r1c2-t92">
<p>1</p>
</td>
<td class="cellalignment98" headers="r8c1-t92 r1c3-t92">
<p>2</p>
</td>
<td class="cellalignment98" headers="r8c1-t92 r1c4-t92">
<p>0</p>
</td>
<td class="cellalignment98" headers="r8c1-t92 r1c5-t92">
<p>100</p>
</td>
<td class="cellalignment98" headers="r8c1-t92 r1c6-t92">
<p>Specify the occurrence multiplier for adding a term in a field section as a normal term. For example, by default, the term <span class="italic">cat</span> in "&lt;A&gt;cat&lt;/A&gt;" is a field section term and is treated as a normal term with occurrence equal to 2, but you can specify that it be treated as a normal term with a weight up to 100. <code dir="ltr">SECTION_WEIGHT</code> is only meaningful when the index policy specifies a field section.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t92" headers="r1c1-t92">
<p><code dir="ltr">CLUSTER_NUM</code></p>
</td>
<td class="cellalignment98" headers="r9c1-t92 r1c2-t92">
<p>I</p>
</td>
<td class="cellalignment98" headers="r9c1-t92 r1c3-t92">
<p>200</p>
</td>
<td class="cellalignment98" headers="r9c1-t92 r1c4-t92">
<p>2</p>
</td>
<td class="cellalignment98" headers="r9c1-t92 r1c5-t92">
<p>20000</p>
</td>
<td class="cellalignment98" headers="r9c1-t92 r1c6-t92">
<p>Specify the total number of leaf clusters to be generated.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1014730"></a>
<div id="CCREF0238" class="sect1">
<h2 class="sect1"><span class="secnum">2.10</span> Stoplists<a id="sthref810"></a></h2>
<p>Stoplists identify the words in your language that are not to be indexed. In English, you can also identify stopthemes that are not to be indexed. By default, the system indexes text using the system-supplied stoplist that corresponds to your database language.</p>
<p>Oracle Text provides default stoplists for most common languages including English, French, German, Spanish, Chinese, Dutch, and Danish. These default stoplists contain only stopwords.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about the supplied default stoplists, see <a href="astopsup.htm#CEGBGCDF">Appendix E, "Oracle Text Supplied Stoplists"</a></div>
<a id="i1009534"></a>
<div id="CCREF2040" class="sect2">
<h3 class="sect2"><span class="secnum">2.10.1</span> Multi-Language Stoplists<a id="sthref811"></a><a id="sthref812"></a></h3>
<p>You can create multi-language stoplists to hold language-specific stopwords. A multi-language stoplist is useful when you use the <code dir="ltr">MULTI_LEXER</code> to index a table that contains documents in different languages, such as English, German.</p>
<p>To create a multi-language stoplist, use the CTX_DLL.<a href="cddlpkg.htm#i998026">CREATE_STOPLIST</a> procedure and specify a stoplist type of <code dir="ltr">MULTI_STOPLIST</code>. Add language specific stopwords with CTX_DDL.<a href="cddlpkg.htm#i997383">ADD_STOPWORD</a>.</p>
<p>At indexing time, the language column of each document is examined, and only the stopwords for that language are eliminated. At query time, the session language setting determines the active stopwords, like it determines the active lexer when using the multi-lexer.</p>
</div>
<!-- class="sect2" -->
<div id="CCREF2041" class="sect2"><a id="sthref813"></a>
<h3 class="sect2"><span class="secnum">2.10.2</span> Creating Stoplists<a id="sthref814"></a></h3>
<p>Create your own stoplists using the CTX_DLL.<a href="cddlpkg.htm#i998026">CREATE_STOPLIST</a> procedure. With this procedure you can create a <code dir="ltr">BASIC_STOPLIST</code> for single language stoplist, or you can create a <code dir="ltr">MULTI_STOPLIST</code> for a multi-language stoplist.</p>
<p>When you create your own stoplist, you must specify it in the parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
<p>To create stoplists for Chinese or Japanese languages, use the <code dir="ltr">CHINESE_LEXER</code> or <code dir="ltr">JAPANESE_LEXER</code> respectively, and update the appropriate lexicon to be <span class="italic">@contained_such_stopwords</span>.</p>
</div>
<!-- class="sect2" -->
<div id="CCREF2042" class="sect2"><a id="sthref815"></a>
<h3 class="sect2"><span class="secnum">2.10.3</span> Modifying the Default Stoplist<a id="sthref816"></a></h3>
<p>The default stoplist is always named <a href="#i1009790">CTXSYS.DEFAULT_STOPLIST</a>. Use the following procedures to modify this stoplist:</p>
<ul>
<li>
<p>CTX_DDL.<a href="cddlpkg.htm#i997383">ADD_STOPWORD</a></p>
</li>
<li>
<p>CTX_DDL.<a href="cddlpkg.htm#i998395">REMOVE_STOPWORD</a></p>
</li>
<li>
<p>CTX_DDL.<a href="cddlpkg.htm#i997338">ADD_STOPTHEME</a></p>
</li>
<li>
<p>CTX_DDL.<a href="cddlpkg.htm#i997253">ADD_STOPCLASS</a></p>
</li>
</ul>
<p>When you modify <code dir="ltr">CTXSYS.DEFAULT_STOPLIST</code> with the <code dir="ltr">CTX_DDL</code> package, you must re-create your index for the changes to take effect.</p>
<div id="CCREF2043" class="sect3"><a id="sthref817"></a>
<h4 class="sect3"><span class="secnum">2.10.3.1</span> Dynamic Addition of Stopwords<a id="sthref818"></a></h4>
<p>You can <span class="italic">add</span> stopwords dynamically to a default or custom stoplist with <a href="csql.htm#CIHBFDCE">ALTER INDEX</a>. When you add a stopword dynamically, you need not re-index, because the word immediately becomes a stopword and is removed from the index.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Even though you can dynamically add stopwords to an index, you cannot dynamically remove stopwords. <a id="sthref819"></a>To remove a stopword, you must use CTX_DDL.<a href="cddlpkg.htm#i998395">REMOVE_STOPWORD</a>, drop your index and re-create it.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="csql.htm#CIHBFDCE">"ALTER INDEX"</a> in <a href="csql.htm#i996741">Chapter 1, "Oracle Text SQL Statements and Operators"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1017419"></a>
<div id="CCREF0242" class="sect1">
<h2 class="sect1"><span class="secnum">2.11</span> System-Defined Preferences<a id="sthref820"></a><a id="sthref821"></a></h2>
<p>When you install Oracle Text, some indexing preferences are created. You can use these preferences in the parameter clause of <a href="csql.htm#i997677">CREATE INDEX</a> or define your own.</p>
<p>The default index parameters are mapped to some of the system-defined preferences described in this section.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about default index parameters, see <a href="#i1009891">"Default Index Parameters"</a></div>
<p>System-defined preferences are divided into the following categories:</p>
<ul>
<li>
<p><a href="#i1009656">Data Storage</a></p>
</li>
<li>
<p><a href="#i1009677">Filter</a></p>
</li>
<li>
<p><a href="#i1009693">Lexer</a></p>
</li>
<li>
<p><a href="#i1009772">Section Group</a></p>
</li>
<li>
<p><a href="#i1009788">Stoplist</a></p>
</li>
<li>
<p><a href="#i1009806">Storage</a></p>
</li>
<li>
<p><a href="#i1009815">Wordlist</a></p>
</li>
</ul>
<a id="i1009656"></a>
<div id="CCREF2044" class="sect2">
<h3 class="sect2"><span class="secnum">2.11.1</span> Data Storage</h3>
<p>This section discusses the types associated with data storage preferences.</p>
<a id="i1009659"></a>
<div id="CCREF2045" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.1.1</span> <a id="sthref822"></a>CTXSYS.DEFAULT_DATASTORE</h4>
<p>This preference uses the <a href="#i1006370">DIRECT_DATASTORE</a> type. Use this preference to create indexes for text columns in which the text is stored directly in the column.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF2046" class="sect3"><a id="sthref823"></a>
<h4 class="sect3"><span class="secnum">2.11.1.2</span> CTXSYS.<a id="sthref824"></a>FILE_DATASTORE</h4>
<p>This preference uses the <a href="#i1006637">FILE_DATASTORE</a> type.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF2047" class="sect3"><a id="sthref825"></a>
<h4 class="sect3"><span class="secnum">2.11.1.3</span> CTXSYS.<a id="sthref826"></a>URL_DATASTORE</h4>
<p>This preference uses the <a href="#i1006676">URL_DATASTORE</a> type.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009677"></a>
<div id="CCREF2048" class="sect2">
<h3 class="sect2"><span class="secnum">2.11.2</span> Filter</h3>
<p>This section discusses the types associated with filtering preferences.</p>
<a id="i1009679"></a>
<div id="CCREF2049" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.2.1</span> CTXSYS.<a id="sthref827"></a>NULL_FILTER</h4>
<p>This preference uses the <a href="#i1007244">NULL_FILTER</a> type.</p>
</div>
<!-- class="sect3" -->
<a id="i1009686"></a>
<div id="CCREF2050" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.2.2</span> CTXSYS.<a id="sthref828"></a>AUTO_FILTER</h4>
<p>This preference uses the <a href="#i1007132">AUTO_FILTER</a> type.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009693"></a>
<div id="CCREF2051" class="sect2">
<h3 class="sect2"><span class="secnum">2.11.3</span> Lexer</h3>
<p>This section discusses the types associated with lexer preferences.</p>
<a id="i1009696"></a>
<div id="CCREF2052" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.3.1</span> <a id="sthref829"></a>CTXSYS.DEFAULT_LEXER</h4>
<p>The default lexer depends on the language used at install time. The following sections describe the default settings for <code dir="ltr">CTXSYS.DEFAULT_LEXER</code> for each language.</p>
<div id="CCREF2053" class="sect4"><a id="sthref830"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.1</span> American and English Language Settings<a id="sthref831"></a><a id="sthref832"></a><a id="sthref833"></a></h5>
<p>If your language is English, this preference uses the <a href="#i1007615">BASIC_LEXER</a> with the <code dir="ltr">index_themes</code> attribute disabled.</p>
</div>
<!-- class="sect4" -->
<div id="CCREF2054" class="sect4"><a id="sthref834"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.2</span> Danish Language Settings<a id="sthref835"></a></h5>
<p>If your language is Danish, this preference uses the <a href="#i1007615">BASIC_LEXER</a> with the following option enabled:</p>
<ul>
<li>
<p>Alternate spelling (alternate_spelling attribute set to <code dir="ltr">DANISH</code>)</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="CCREF2055" class="sect4"><a id="sthref836"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.3</span> Dutch Language Settings<a id="sthref837"></a></h5>
<p>If your language is Dutch, this preference uses the <a href="#i1007615">BASIC_LEXER</a> with the following options enabled:</p>
<ul>
<li>
<p>composite indexing (<code dir="ltr">composite</code> attribute set to <code dir="ltr">DUTCH</code>)</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="CCREF2056" class="sect4"><a id="sthref838"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.4</span> German and German DIN <a id="sthref839"></a>Language Settings</h5>
<p>If your language is German, then this preference uses the <a href="#i1007615">BASIC_LEXER</a> with the following options enabled:</p>
<ul>
<li>
<p>Case-sensitive indexing (<code dir="ltr">mixed_case</code> attribute enabled)</p>
</li>
<li>
<p>Composite indexing (<code dir="ltr">composite</code> attribute set to <code dir="ltr">GERMAN</code>)</p>
</li>
<li>
<p>Alternate spelling (<code dir="ltr">alternate_spelling</code> attribute set to <code dir="ltr">GERMAN</code>)</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="CCREF2057" class="sect4"><a id="sthref840"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.5</span> Finnish, Norwegian, and Swedish Language Settings<a id="sthref841"></a><a id="sthref842"></a><a id="sthref843"></a></h5>
<p>If your language is Finnish, Norwegian, or Swedish, this preference uses the <a href="#i1007615">BASIC_LEXER</a> with the following option enabled:</p>
<ul>
<li>
<p>Alternate spelling (alternate_spelling attribute set to <code dir="ltr">SWEDISH</code>)</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="CCREF2058" class="sect4"><a id="sthref844"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.6</span> Japanese Language Settings<a id="sthref845"></a></h5>
<p>If you language is Japanese, this preference uses the <a href="#i1017169">JAPANESE_VGRAM_LEXER</a>.</p>
</div>
<!-- class="sect4" -->
<div id="CCREF2059" class="sect4"><a id="sthref846"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.7</span> Korean Language Settings<a id="sthref847"></a></h5>
<p>If your language is Korean, this preference uses the <a href="#i1008175">KOREAN_MORPH_LEXER</a>. All attributes for the <code dir="ltr">KOREAN_MORPH_LEXER</code> are enabled.</p>
</div>
<!-- class="sect4" -->
<div id="CCREF2060" class="sect4"><a id="sthref848"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.8</span> Chinese Language Settings<a id="sthref849"></a></h5>
<p>If your language is Simplified or Traditional Chinese, this preference uses the <a href="#i1008019">CHINESE_VGRAM_LEXER</a>.</p>
</div>
<!-- class="sect4" -->
<div id="CCREF2061" class="sect4"><a id="sthref850"></a>
<h5 class="sect4"><span class="secnum">2.11.3.1.9</span> Other Languages</h5>
<p>For all other languages not listed in this section, this preference uses the <a href="#i1007615">BASIC_LEXER</a> with no attributes set.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
To learn more about these options, see <a href="#i1007615">"BASIC_LEXER"</a></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="CCREF2062" class="sect3"><a id="sthref851"></a>
<h4 class="sect3"><span class="secnum">2.11.3.2</span> CTXSYS.BASIC_LEXER<a id="sthref852"></a></h4>
<p>This preference uses the <code dir="ltr">BASIC_LEXER</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009772"></a>
<div id="CCREF2063" class="sect2">
<h3 class="sect2"><span class="secnum">2.11.4</span> Section Group</h3>
<p>This section discusses the types associated with section group preferences.</p>
<a id="i1009774"></a>
<div id="CCREF2064" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.4.1</span> CTXSYS.<a id="sthref853"></a>NULL_SECTION_GROUP</h4>
<p>This preference uses the <code dir="ltr">NULL_SECTION_GROUP</code> type.</p>
</div>
<!-- class="sect3" -->
<a id="i1009778"></a>
<div id="CCREF2065" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.4.2</span> CTXSYS.<a id="sthref854"></a>HTML_SECTION_GROUP</h4>
<p>This preference uses the <code dir="ltr">HTML_SECTION_GROUP</code> type.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF2066" class="sect3"><a id="sthref855"></a>
<h4 class="sect3"><span class="secnum">2.11.4.3</span> CTXSYS.AUTO_SECTION_GROUP<a id="sthref856"></a></h4>
<p>This preference uses the <code dir="ltr">AUTO_SECTION_GROUP</code> type.</p>
</div>
<!-- class="sect3" -->
<div id="CCREF2067" class="sect3"><a id="sthref857"></a>
<h4 class="sect3"><span class="secnum">2.11.4.4</span> CTXSYS.PATH_SECTION_GROUP<a id="sthref858"></a></h4>
<p>This preference uses the <code dir="ltr">PATH_SECTION_GROUP</code> type.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009788"></a>
<div id="CCREF2068" class="sect2">
<h3 class="sect2"><span class="secnum">2.11.5</span> Stoplist</h3>
<p>This section discusses the types associated with stoplist preferences.</p>
<a id="i1009790"></a>
<div id="CCREF2069" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.5.1</span> CTXSYS.<a id="sthref859"></a>DEFAULT_STOPLIST</h4>
<p>This stoplist preference defaults to the stoplist of your database language.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For a complete list of the stop words in the supplied stoplists, see <a href="astopsup.htm#CEGBGCDF">Appendix E, "Oracle Text Supplied Stoplists"</a></div>
</div>
<!-- class="sect3" -->
<div id="CCREF2070" class="sect3"><a id="sthref860"></a>
<h4 class="sect3"><span class="secnum">2.11.5.2</span> CTXSYS.EMPTY_STOPLIST<a id="sthref861"></a></h4>
<p>This stoplist has no words.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009806"></a>
<div id="CCREF2071" class="sect2">
<h3 class="sect2"><span class="secnum">2.11.6</span> Storage</h3>
<p>This section discusses the types associated with storage preferences.</p>
<a id="i1009808"></a>
<div id="CCREF2072" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.6.1</span> CTXSYS.DEFAULT_STORAGE<a id="sthref862"></a></h4>
<p>This storage preference uses the <a href="#i1009262">BASIC_STORAGE</a> type.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009815"></a>
<div id="CCREF2073" class="sect2">
<h3 class="sect2"><span class="secnum">2.11.7</span> Wordlist</h3>
<p>This section discusses the types associated with wordlist preferences.</p>
<a id="i1009817"></a>
<div id="CCREF2074" class="sect3">
<h4 class="sect3"><span class="secnum">2.11.7.1</span> CTXSYS.DEFAULT_WORDLIST<a id="sthref863"></a></h4>
<p>This preference uses the language stemmer for your database language. If your language is not listed in <a href="#g1019326">Table 2-33</a>, then this preference defaults to the <code dir="ltr">NULL</code> stemmer and the <code dir="ltr">GENERIC</code> fuzzy matching attribute.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009827"></a>
<div id="CCREF0245" class="sect1">
<h2 class="sect1"><span class="secnum">2.12</span> System Parameters<a id="sthref864"></a><a id="sthref865"></a><a id="sthref866"></a></h2>
<p>This section describes the Oracle Text system parameters, which are divided into the following categories:</p>
<ul>
<li>
<p><a href="#i1009844">General System Parameters</a></p>
</li>
<li>
<p><a href="#i1009891">Default Index Parameters</a></p>
</li>
</ul>
<a id="i1009844"></a>
<div id="CCREF2075" class="sect2">
<h3 class="sect2"><span class="secnum">2.12.1</span> General System Parameters</h3>
<p>When you install Oracle Text, in addition to the system-defined preferences, the following system parameters are set:</p>
<div id="CCREF23810" class="tblformal">
<p class="titleintable"><a id="sthref867"></a><a id="sthref868"></a>Table 2-40 General System Parameters</p>
<table class="cellalignment103" title="General System Parameters" summary="This table shows the Oracle Text general system parameters." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t99">System Parameter</th>
<th class="cellalignment97" id="r1c2-t99">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t99" headers="r1c1-t99">
<p><code dir="ltr"><a id="sthref869"></a>MAX_INDEX_MEMORY</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t99 r1c2-t99">
<p>This is the maximum indexing memory that can be specified in the parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> and <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code>. The maximum value for this parameter is 2 GB -1.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t99" headers="r1c1-t99">
<p><code dir="ltr"><a id="sthref870"></a>DEFAULT_INDEX_MEMORY</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t99 r1c2-t99">
<p>This is the default indexing memory used with <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> and <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code>.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t99" headers="r1c1-t99">
<p><code dir="ltr"><a id="sthref871"></a>LOG_DIRECTORY</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t99 r1c2-t99">
<p>This is the directory for <code dir="ltr">CTX_OUTPUT</code> log files.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t99" headers="r1c1-t99">
<p><code dir="ltr"><a id="sthref872"></a>CTX_DOC_KEY_TYPE</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t99 r1c2-t99">
<p>This is the default input key type, either <code dir="ltr">ROWID</code> or <code dir="ltr">PRIMARY_KEY</code>, for the <code dir="ltr">CTX_DOC</code> procedures. Set to <code dir="ltr">ROWID</code> at install time.</p>
<p><span class="bold">See Also:</span> CTX_DOC.<a href="cdocpkg.htm#i997423">SET_KEY_TYPE</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>View system defaults by querying the <a href="aviews.htm#i12685">CTX_PARAMETERS</a> view. Change defaults using the CTX_ADM.<a href="cadmpkg.htm#i996788">SET_PARAMETER</a> procedure.</p>
</div>
<!-- class="sect2" -->
<a id="i1009891"></a>
<div id="CCREF2076" class="sect2">
<h3 class="sect2"><span class="secnum">2.12.2</span> Default Index Parameters<a id="sthref873"></a><a id="sthref874"></a></h3>
<p>This section describes the index parameters that you can use when you create <code dir="ltr">CONTEXT</code> and <code dir="ltr">CTXCAT</code> indexes.</p>
<div id="CCREF2077" class="sect3"><a id="sthref875"></a>
<h4 class="sect3"><span class="secnum">2.12.2.1</span> CONTEXT Index Parameters<a id="sthref876"></a><a id="sthref877"></a></h4>
<p>The following default parameters are used when you create a <code dir="ltr">CONTEXT</code> index and do not specify preferences in the parameter clause of <a href="csql.htm#i997677">CREATE INDEX</a>. Each default parameter names a system-defined preference to use for data storage, filtering, lexing, and so on.</p>
<div id="CCREF23811" class="tblformal">
<p class="titleintable"><a id="sthref878"></a><a id="sthref879"></a>Table 2-41 Default CONTEXT Index Parameters</p>
<table class="cellalignment103" title="Default CONTEXT Index Parameters" summary="This table shows the default CONTEXT index parameters." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t100">Parameter</th>
<th class="cellalignment97" id="r1c2-t100">Used When</th>
<th class="cellalignment97" id="r1c3-t100">Default Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref880"></a>DEFAULT_DATASTORE</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t100 r1c2-t100">
<p>No datastore preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r2c1-t100 r1c3-t100">
<p><a href="#i1009659">CTXSYS.DEFAULT_DATASTORE</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref881"></a>DEFAULT_FILTER_FILE</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t100 r1c2-t100">
<p>No filter preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>, and either of the following conditions is true:</p>
<ul>
<li>
<p>Your files are stored in external files (BFILES) or</p>
</li>
<li>
<p>Specify a datastore preference that uses <code dir="ltr">FILE_DATASTORE</code></p>
</li>
</ul>
</td>
<td class="cellalignment98" headers="r3c1-t100 r1c3-t100">
<p><a href="#i1009686">CTXSYS.AUTO_FILTER</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref882"></a>DEFAULT_FILTER_BINARY</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t100 r1c2-t100">
<p>No filter preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>, and Oracle Text detects that the text column datatype is <code dir="ltr">RAW</code>, <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, or <code dir="ltr">BLOB</code>.</p>
</td>
<td class="cellalignment98" headers="r4c1-t100 r1c3-t100">
<p><a href="#i1009686">CTXSYS.AUTO_FILTER</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref883"></a>DEFAULT_FILTER_TEXT</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t100 r1c2-t100">
<p>No filter preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>, and Oracle Text detects that the text column datatype is either <code dir="ltr">LONG</code>, <code dir="ltr">VARCHAR2</code>, <code dir="ltr">VARCHAR</code>, <code dir="ltr">CHAR</code>, or <code dir="ltr">CLOB</code>.</p>
</td>
<td class="cellalignment98" headers="r5c1-t100 r1c3-t100">
<p><a href="#i1009679">CTXSYS.NULL_FILTER</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref884"></a>DEFAULT_SECTION_HTML</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t100 r1c2-t100">
<p>No section group specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>, and when either of the following conditions is true:</p>
<ul>
<li>
<p>Your datastore preference uses <code dir="ltr">URL_DATASTORE</code> or</p>
</li>
<li>
<p>Your filter preference uses <code dir="ltr">AUTO_FILTER</code>.</p>
</li>
</ul>
</td>
<td class="cellalignment98" headers="r6c1-t100 r1c3-t100">
<p><a href="#i1009778">CTXSYS.HTML_SECTION_GROUP</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref885"></a>DEFAULT_SECTION_TEXT</code></p>
</td>
<td class="cellalignment98" headers="r7c1-t100 r1c2-t100">
<p>No section group specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>, and when you do <span class="italic">not</span> use either <code dir="ltr">URL_DATASTORE</code> or <code dir="ltr">AUTO_FILTER</code>.</p>
</td>
<td class="cellalignment98" headers="r7c1-t100 r1c3-t100">
<p><a href="#i1009774">CTXSYS.NULL_SECTION_GROUP</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref886"></a>DEFAULT_STORAGE</code></p>
</td>
<td class="cellalignment98" headers="r8c1-t100 r1c2-t100">
<p>No storage preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r8c1-t100 r1c3-t100">
<p><a href="#i1009808">CTXSYS.DEFAULT_STORAGE</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref887"></a>DEFAULT_LEXER</code></p>
</td>
<td class="cellalignment98" headers="r9c1-t100 r1c2-t100">
<p>No lexer preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r9c1-t100 r1c3-t100">
<p><a href="#i1009696">CTXSYS.DEFAULT_LEXER</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r10c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref888"></a>DEFAULT_STOPLIST</code></p>
</td>
<td class="cellalignment98" headers="r10c1-t100 r1c2-t100">
<p>No stoplist specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r10c1-t100 r1c3-t100">
<p><a href="#i1009790">CTXSYS.DEFAULT_STOPLIST</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r11c1-t100" headers="r1c1-t100">
<p><code dir="ltr"><a id="sthref889"></a>DEFAULT_WORDLIST</code></p>
</td>
<td class="cellalignment98" headers="r11c1-t100 r1c2-t100">
<p>No wordlist preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r11c1-t100 r1c3-t100">
<p><a href="#i1009817">CTXSYS.DEFAULT_WORDLIST</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF2078" class="sect3"><a id="sthref890"></a>
<h4 class="sect3"><span class="secnum">2.12.2.2</span> CTXCAT Index Parameters<a id="sthref891"></a><a id="sthref892"></a></h4>
<p>The following default parameters are used when you create a <code dir="ltr">CTXCAT</code> index with <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> and do not specify any parameters in the parameter string. The <code dir="ltr">CTXCAT</code> index supports only the index set, lexer, storage, stoplist, and wordlist parameters. Each default parameter names a system-defined preference.</p>
<div id="CCREF23812" class="tblformal">
<p class="titleintable"><a id="sthref893"></a><a id="sthref894"></a>Table 2-42 Default CTXCAT Index Parameters</p>
<table class="cellalignment103" title="Default CTXCAT Index Parameters" summary="This table shows the default CTXCAT index parameters." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t101">Parameter</th>
<th class="cellalignment97" id="r1c2-t101">Used When</th>
<th class="cellalignment97" id="r1c3-t101">Default Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t101" headers="r1c1-t101">
<p><code dir="ltr"><a id="sthref895"></a>DEFAULT_CTXCAT_INDEX_SET</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t101 r1c2-t101">
<p>No index set specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r2c1-t101 r1c3-t101">
<p>n/a</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t101" headers="r1c1-t101">
<p><code dir="ltr"><a id="sthref896"></a>DEFAULT_CTXCAT_STORAGE</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t101 r1c2-t101">
<p>No storage preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r3c1-t101 r1c3-t101">
<p><a href="#i1009808">CTXSYS.DEFAULT_STORAGE</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t101" headers="r1c1-t101">
<p><code dir="ltr"><a id="sthref897"></a>DEFAULT_CTXCAT_LEXER</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t101 r1c2-t101">
<p>No lexer preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r4c1-t101 r1c3-t101">
<p><a href="#i1009696">CTXSYS.DEFAULT_LEXER</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t101" headers="r1c1-t101">
<p><code dir="ltr"><a id="sthref898"></a>DEFAULT_CTXCAT_STOPLIST</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t101 r1c2-t101">
<p>No stoplist specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r5c1-t101 r1c3-t101">
<p><a href="#i1009790">CTXSYS.DEFAULT_STOPLIST</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t101" headers="r1c1-t101">
<p><code dir="ltr"><a id="sthref899"></a>DEFAULT_CTXCAT_WORDLIST</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t101 r1c2-t101">
<p>No wordlist preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
<p>Note that while you can specify a wordlist preference for <code dir="ltr">CTXCAT</code> indexes, most of the attributes do not apply, because the catsearch query language does not support wildcarding, fuzzy, and stemming. The only attribute that is useful is <code dir="ltr">PREFIX_INDEX</code> for Japanese data.</p>
</td>
<td class="cellalignment98" headers="r6c1-t101 r1c3-t101">
<p><a href="#i1009817">CTXSYS.DEFAULT_WORDLIST</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="CCREF2079" class="sect3"><a id="sthref900"></a>
<h4 class="sect3"><span class="secnum">2.12.2.3</span> CTXRULE Index Parameters<a id="sthref901"></a><a id="sthref902"></a></h4>
<p><a href="#CIHEGCFF">Table 2-43</a> lists the default parameters that are used when you create a <code dir="ltr">CTXRULE</code> index with <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> and do not specify any parameters in the parameter string. The <code dir="ltr">CTXRULE</code> index supports only the lexer, storage, stoplist, and wordlist parameters. Each default parameter names a system-defined preference.</p>
<div id="CCREF23813" class="tblformal">
<p class="titleintable"><a id="sthref903"></a><a id="CIHEGCFF"></a>Table 2-43 Default CTXRULE Index Parameters</p>
<table class="cellalignment103" title="Default CTXRULE Index Parameters" summary="This table shows the default CTXRULE index parameters." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t102">Parameter</th>
<th class="cellalignment97" id="r1c2-t102">Used When</th>
<th class="cellalignment97" id="r1c3-t102">Default Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t102" headers="r1c1-t102">
<p><a id="sthref904"></a><code dir="ltr">DEFAULT_CTXRULE_LEXER</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t102 r1c2-t102">
<p>No lexer preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r2c1-t102 r1c3-t102">
<p><a href="#i1009696">CTXSYS.DEFAULT_LEXER</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t102" headers="r1c1-t102">
<p><a id="sthref905"></a><code dir="ltr">DEFAULT_CTXRULE_STORAGE</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t102 r1c2-t102">
<p>No storage preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r3c1-t102 r1c3-t102">
<p><a href="#i1009808">CTXSYS.DEFAULT_STORAGE</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t102" headers="r1c1-t102">
<p><a id="sthref906"></a><code dir="ltr">DEFAULT_CTXRULE_STOPLIST</code></p>
</td>
<td class="cellalignment98" headers="r4c1-t102 r1c2-t102">
<p>No stoplist specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r4c1-t102 r1c3-t102">
<p><a href="#i1009790">CTXSYS.DEFAULT_STOPLIST</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t102" headers="r1c1-t102">
<p><a id="sthref907"></a><code dir="ltr">DEFAULT_CTXRULE_WORDLIST</code></p>
</td>
<td class="cellalignment98" headers="r5c1-t102 r1c2-t102">
<p>No wordlist preference specified in parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code>.</p>
</td>
<td class="cellalignment98" headers="r5c1-t102 r1c3-t102">
<p><a href="#i1009817">CTXSYS.DEFAULT_WORDLIST</a></p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t102" headers="r1c1-t102">
<p><a id="sthref908"></a><code dir="ltr">DEFAULT_CLASSIFIER</code></p>
</td>
<td class="cellalignment98" headers="r6c1-t102 r1c2-t102">
<p>No classifier preference is specified in parameter clause.</p>
</td>
<td class="cellalignment98" headers="r6c1-t102 r1c3-t102">
<p><code dir="ltr">RULE_CLASSIFIER</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="CCREF23814"></a><a id="sthref909"></a>CTXRULE Index Limitations</p>
<p>The <code dir="ltr">CTXRULE</code> index does not support the following query operators:</p>
<ul>
<li>
<p>Fuzzy</p>
</li>
<li>
<p>Soundex</p>
</li>
</ul>
<p>It also does not support the following <code dir="ltr">BASIC_WORDLIST</code> attributes:</p>
<ul>
<li>
<p><code dir="ltr">SUBSTRING_INDEX</code></p>
</li>
<li>
<p><code dir="ltr">PREFIX_INDEX</code></p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="CCREF2080" class="sect3"><a id="sthref910"></a>
<h4 class="sect3"><span class="secnum">2.12.2.4</span> Viewing Default Values<a id="sthref911"></a></h4>
<p>View system defaults by querying the <a href="aviews.htm#i12685">CTX_PARAMETERS</a> view. For example, to see all parameters and values, enter the following statement:</p>
<pre dir="ltr">
SQL&gt; SELECT par_name, par_value from ctx_parameters;
</pre></div>
<!-- class="sect3" -->
<div id="CCREF2081" class="sect3"><a id="sthref912"></a>
<h4 class="sect3"><span class="secnum">2.12.2.5</span> Changing Default Values<a id="sthref913"></a></h4>
<p>Change a default value using the CTX_ADM.<a href="cadmpkg.htm#i996788">SET_PARAMETER</a> procedure to name another custom or system-defined preference to use as default.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment89">
<tr>
<td class="cellalignment98">
<table class="cellalignment94">
<tr>
<td class="cellalignment93"><a href="csql.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment93"><a href="cqoper.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1998, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment100">
<table class="cellalignment92">
<tr>
<td class="cellalignment93"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment93"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment93"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment93"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment93"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment93"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
