<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>CTX_DDL Package</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1071" />
<meta name="dcterms.created" content="2015-10-23T12:26:35Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Text Reference" />
<meta name="dcterms.identifier" content="E24436-05" />
<meta name="dcterms.isVersionOf" content="CCREF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1998, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="cclspkg.htm" title="Previous" type="text/html" />
<link rel="Next" href="cdocpkg.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e24436.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/29</span> <!-- End Header -->
<div id="CCREF0600" class="chapter"><a id="g1014415"></a> <a id="i996734"></a>
<h1 class="chapter"><span class="secnum">7</span> CTX_DDL Package</h1>
<p>This chapter provides reference information for using the <code dir="ltr">CTX_DDL</code> PL/SQL package to create and manage the preferences, section groups, and stoplists required for Text indexes.</p>
<p><code dir="ltr">CTX_DDL</code> contains the following stored procedures and functions:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="ctx_ddl procedures" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t2"><span class="bold">Name</span></th>
<th class="cellalignment97" id="r1c2-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t2" headers="r1c1-t2"><a href="#CHDFIAHI">ADD_ATTR_SECTION</a></td>
<td class="cellalignment98" headers="r2c1-t2 r1c2-t2">Adds an attribute section to an XML section group.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t2" headers="r1c1-t2"><a href="#i999153">ADD_FIELD_SECTION</a></td>
<td class="cellalignment98" headers="r3c1-t2 r1c2-t2">Creates a field section and assigns it to the specified section group.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t2" headers="r1c1-t2"><a href="#i997112">ADD_INDEX</a></td>
<td class="cellalignment98" headers="r4c1-t2 r1c2-t2">Adds an index to a catalog index preference.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t2" headers="r1c1-t2"><a href="#BJFHJFIJ">ADD_MDATA</a></td>
<td class="cellalignment98" headers="r5c1-t2 r1c2-t2">Changes the <code dir="ltr">MDATA</code> value of a document.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t2" headers="r1c1-t2"><a href="#CEGCABJJ">ADD_MDATA_COLUMN</a></td>
<td class="cellalignment98" headers="r6c1-t2 r1c2-t2">Maps a <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column to the specified <code dir="ltr">MDATA</code> section.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t2" headers="r1c1-t2"><a href="#BJFFGAAA">ADD_MDATA_SECTION</a></td>
<td class="cellalignment98" headers="r7c1-t2 r1c2-t2">Adds an <code dir="ltr">MDATA</code> metadata section to a document.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t2" headers="r1c1-t2"><a href="#BABCBFCB">ADD_NDATA_SECTION</a></td>
<td class="cellalignment98" headers="r8c1-t2 r1c2-t2">Adds an <code dir="ltr">NDATA</code> section to a document.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t2" headers="r1c1-t2"><a href="#CEGFAEJJ">ADD_SDATA_COLUMN</a></td>
<td class="cellalignment98" headers="r9c1-t2 r1c2-t2">Maps a <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column to the specified <code dir="ltr">SDATA</code> section.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r10c1-t2" headers="r1c1-t2"><a href="#CEGGBEIC">ADD_SDATA_SECTION</a></td>
<td class="cellalignment98" headers="r10c1-t2 r1c2-t2">Adds an <code dir="ltr">SDATA</code> structured data section to a document.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r11c1-t2" headers="r1c1-t2"><a href="#i997153">ADD_SPECIAL_SECTION</a></td>
<td class="cellalignment98" headers="r11c1-t2 r1c2-t2">Adds a special section to a section group.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r12c1-t2" headers="r1c1-t2"><a href="#i997253">ADD_STOPCLASS</a></td>
<td class="cellalignment98" headers="r12c1-t2 r1c2-t2">Adds a stopclass to a stoplist.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r13c1-t2" headers="r1c1-t2"><a href="#i997287">ADD_STOP_SECTION</a></td>
<td class="cellalignment98" headers="r13c1-t2 r1c2-t2">Adds a stop section to an automatic section group.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r14c1-t2" headers="r1c1-t2"><a href="#i997338">ADD_STOPTHEME</a></td>
<td class="cellalignment98" headers="r14c1-t2 r1c2-t2">Adds a stoptheme to a stoplist.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r15c1-t2" headers="r1c1-t2"><a href="#i997383">ADD_STOPWORD</a></td>
<td class="cellalignment98" headers="r15c1-t2 r1c2-t2">Adds a stopword to a stoplist.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r16c1-t2" headers="r1c1-t2"><a href="#i997457">ADD_SUB_LEXER</a></td>
<td class="cellalignment98" headers="r16c1-t2 r1c2-t2">Adds a sub-lexer to a multi-lexer preference.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r17c1-t2" headers="r1c1-t2"><a href="#i997526">ADD_ZONE_SECTION</a></td>
<td class="cellalignment98" headers="r17c1-t2 r1c2-t2">Creates a zone section and adds it to the specified section group.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r18c1-t2" headers="r1c1-t2"><a href="#CHDDGDDA">COPY_POLICY</a></td>
<td class="cellalignment98" headers="r18c1-t2 r1c2-t2">Creates a copy of a policy.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r19c1-t2" headers="r1c1-t2"><a href="#i997653">CREATE_INDEX_SET</a></td>
<td class="cellalignment98" headers="r19c1-t2 r1c2-t2">Creates an index set for <code dir="ltr">CTXCAT</code> index types.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r20c1-t2" headers="r1c1-t2"><a href="#i997662">CREATE_POLICY</a></td>
<td class="cellalignment98" headers="r20c1-t2 r1c2-t2">Creates a policy to use with <code dir="ltr">ORA:CONTAINS()</code>.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r21c1-t2" headers="r1c1-t2"><a href="#i997746">CREATE_PREFERENCE</a></td>
<td class="cellalignment98" headers="r21c1-t2 r1c2-t2">Creates a preference in the Text data dictionary.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r22c1-t2" headers="r1c1-t2"><a href="#i997893">CREATE_SECTION_GROUP</a></td>
<td class="cellalignment98" headers="r22c1-t2 r1c2-t2">Creates a section group in the Text data dictionary.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r23c1-t2" headers="r1c1-t2"><a href="#CEGCJHAF">CREATE_SHADOW_INDEX</a></td>
<td class="cellalignment98" headers="r23c1-t2 r1c2-t2">Creates a policy for the passed-in index. For non-partitioned index, also creates an index table.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r24c1-t2" headers="r1c1-t2"><a href="#i998026">CREATE_STOPLIST</a></td>
<td class="cellalignment98" headers="r24c1-t2 r1c2-t2">Creates a stoplist.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r25c1-t2" headers="r1c1-t2"><a href="#i998118">DROP_INDEX_SET</a></td>
<td class="cellalignment98" headers="r25c1-t2 r1c2-t2">Drops an index set.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r26c1-t2" headers="r1c1-t2"><a href="#i998128">DROP_POLICY</a></td>
<td class="cellalignment98" headers="r26c1-t2 r1c2-t2">Drops a policy.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r27c1-t2" headers="r1c1-t2"><a href="#i998137">DROP_PREFERENCE</a></td>
<td class="cellalignment98" headers="r27c1-t2 r1c2-t2">Deletes a preference from the Text data dictionary.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r28c1-t2" headers="r1c1-t2"><a href="#i998158">DROP_SECTION_GROUP</a></td>
<td class="cellalignment98" headers="r28c1-t2 r1c2-t2">Deletes a section group from the Text data dictionary.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r29c1-t2" headers="r1c1-t2"><a href="#CHDGAEFB">DROP_SHADOW_INDEX</a></td>
<td class="cellalignment98" headers="r29c1-t2 r1c2-t2">Drops a shadow index.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r30c1-t2" headers="r1c1-t2"><a href="#i998178">DROP_STOPLIST</a></td>
<td class="cellalignment98" headers="r30c1-t2 r1c2-t2">Drops a stoplist.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r31c1-t2" headers="r1c1-t2"><a href="#CHDJAGBJ">EXCHANGE_SHADOW_INDEX</a></td>
<td class="cellalignment98" headers="r31c1-t2 r1c2-t2">Swaps the shadow index metadata and data.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r32c1-t2" headers="r1c1-t2"><a href="#i998200">OPTIMIZE_INDEX</a></td>
<td class="cellalignment98" headers="r32c1-t2 r1c2-t2">Optimizes the index.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r33c1-t2" headers="r1c1-t2"><a href="#CHDJHEJB">POPULATE_PENDING</a></td>
<td class="cellalignment98" headers="r33c1-t2 r1c2-t2">Populates the pending queue with every rowid in the base table or table partition.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r34c1-t2" headers="r1c1-t2"><a href="#CEGJDGDD">RECREATE_INDEX_ONLINE</a></td>
<td class="cellalignment98" headers="r34c1-t2 r1c2-t2">Recreates the passed-in index.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r35c1-t2" headers="r1c1-t2"><a href="#i998279">REMOVE_INDEX</a></td>
<td class="cellalignment98" headers="r35c1-t2 r1c2-t2">Removes an index from a <code dir="ltr">CTXCAT</code> index preference.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r36c1-t2" headers="r1c1-t2"><a href="#BJFGGBCJ">REMOVE_MDATA</a></td>
<td class="cellalignment98" headers="r36c1-t2 r1c2-t2">Removes <code dir="ltr">MDATA</code> values from a document.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r37c1-t2" headers="r1c1-t2"><a href="#i998299">REMOVE_SECTION</a></td>
<td class="cellalignment98" headers="r37c1-t2 r1c2-t2">Deletes a section from a section group.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r38c1-t2" headers="r1c1-t2"><a href="#i998343">REMOVE_STOPCLASS</a></td>
<td class="cellalignment98" headers="r38c1-t2 r1c2-t2">Deletes a stopclass from a stoplist.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r39c1-t2" headers="r1c1-t2"><a href="#i998369">REMOVE_STOPTHEME</a></td>
<td class="cellalignment98" headers="r39c1-t2 r1c2-t2">Deletes a stoptheme from a stoplist.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r40c1-t2" headers="r1c1-t2"><a href="#i998395">REMOVE_STOPWORD</a></td>
<td class="cellalignment98" headers="r40c1-t2 r1c2-t2">Deletes a stopword from a stoplist.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r41c1-t2" headers="r1c1-t2"><a href="#CEGIHFBA">REMOVE_SUB_LEXER</a></td>
<td class="cellalignment98" headers="r41c1-t2 r1c2-t2">Deletes a sub-lexer from a multi-lexer preference.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r42c1-t2" headers="r1c1-t2"><a href="#CEGHCHIC">REPLACE_INDEX_METADATA</a></td>
<td class="cellalignment98" headers="r42c1-t2 r1c2-t2">Replaces metadata for local domain indexes.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r43c1-t2" headers="r1c1-t2"><a href="#i998425">SET_ATTRIBUTE</a></td>
<td class="cellalignment98" headers="r43c1-t2 r1c2-t2">Sets a preference attribute.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r44c1-t2" headers="r1c1-t2"><a href="#i998469">SYNC_INDEX</a></td>
<td class="cellalignment98" headers="r44c1-t2 r1c2-t2">Synchronizes the index.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r45c1-t2" headers="r1c1-t2"><a href="#i998511">UNSET_ATTRIBUTE</a></td>
<td class="cellalignment98" headers="r45c1-t2 r1c2-t2">Removes a set attribute from a preference.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r46c1-t2" headers="r1c1-t2"><a href="#i998543">UPDATE_POLICY</a></td>
<td class="cellalignment98" headers="r46c1-t2 r1c2-t2">Updates a policy.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="refentry"><a id="CHDFIAHI"></a>
<div id="CCREF0602" class="refsect1">
<h2 class="refsect1">ADD_ATTR_SECTION<a id="sthref1265"></a><a id="sthref1266"></a><a id="sthref1267"></a><a id="sthref1268"></a><a id="sthref1269"></a></h2>
<p>Adds an attribute section to an XML section group. This procedure is useful for defining attributes in XML documents as sections. This enables you to search XML attribute text with the <code dir="ltr">WITHIN</code> operator.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use <code dir="ltr">AUTO_SECTION_GROUP</code>, attribute sections are created automatically. Attribute sections created automatically are named in the form <code dir="ltr">tag@attribute</code>.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1270"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_ATTR_SECTION(
  group_name     in    varchar2,
  section_name   in    varchar2,
  tag            in    varchar2);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Specify the name of the XML section group. You can add attribute sections only to XML section groups.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Specify the name of the attribute section. This is the name used for <code dir="ltr">WITHIN</code> queries on the attribute text.</p>
<p>The section name you specify cannot contain the colon (:), comma (,), or dot (.) characters. The section name must also be unique within <code dir="ltr">group_name</code>. Section names are case-insensitive.</p>
<p>Attribute section names can be no more than 64 bytes long.</p>
</dd>
<dt>tag</dt>
<dd>
<p>Specify the name of the attribute in <span class="syntaxinline">tag@attr</span> form. This parameter is case-sensitive.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1271"></a>Examples</p>
<p>Consider an XML file that defines the <code dir="ltr">BOOK</code> tag with a <code dir="ltr">TITLE</code> attribute as follows:</p>
<pre dir="ltr">
&lt;BOOK TITLE="Tale of Two Cities"&gt; 
  It was the best of times. 
&lt;/BOOK&gt; 
</pre>
<p>To define the title attribute as an attribute section, create an <code dir="ltr">XML_SECTION_GROUP</code> and define the attribute section as follows:</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('myxmlgroup', 'XML_SECTION_GROUP');
ctx_ddl.add_attr_section('myxmlgroup', 'booktitle', 'BOOK@TITLE');
end;
</pre>
<p>When you define the <code dir="ltr">TITLE</code> attribute section as such and index the document set, you can query the XML attribute text as follows:</p>
<pre dir="ltr">
'Cities within booktitle'
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i999153"></a>
<div id="CCREF0604" class="refsect1">
<h2 class="refsect1">ADD_FIELD_SECTION<a id="sthref1272"></a><a id="sthref1273"></a><a id="sthref1274"></a><a id="sthref1275"></a></h2>
<p>Creates a field section and adds the section to an existing section group. This enables field section searching with the <a href="cqoper.htm#i998525">WITHIN</a> operator.</p>
<p>Field sections are delimited by start and end tags. By default, the text within field sections are indexed as a sub-document separate from the rest of the document.</p>
<p>Unlike zone sections, field sections cannot nest or overlap. As such, field sections are best suited for non-repeating, non-overlapping sections such as <code dir="ltr">TITLE</code> and <code dir="ltr">AUTHOR</code> markup in e-mail- or news-type documents.</p>
<p>Because of how field sections are indexed, <a href="cqoper.htm#i998525">WITHIN</a> queries on field sections are usually faster than <code dir="ltr">WITHIN</code> queries on zone sections.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1276"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_FIELD_SECTION(
  group_name     in    varchar2,
  section_name   in    varchar2,
  tag            in    varchar2,
  visible        in    boolean default FALSE
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Specify the name of the section group to which <code dir="ltr">section_name</code> is added. You can add up to 64 field sections to a single section group. Within the same group, section zone names and section field names cannot be the same.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Specify the name of the section to add to the <code dir="ltr">group_name</code>. Use this name to identify the section in queries. Avoid using names that contain non-alphanumeric characters such as _, because these characters must be escaped in queries. Section names are case-insensitive.</p>
<p>Within the same group, zone section names and field section names cannot be the same. The terms <span class="italic">Paragraph</span> and <span class="italic">Sentence</span> are reserved for special sections.</p>
<p>Section names need not be unique across tags. You can assign the same section name to more than one tag, which makes details transparent to searches.</p>
</dd>
<dt>tag</dt>
<dd>
<p>Specify the tag that marks the start of a section. For example, if the tag is &lt;H1&gt;, then specify H1. The start tag you specify must be unique within a section group.</p>
<p>If <code dir="ltr">group_name</code> is an <code dir="ltr">HTML_SECTION_GROUP</code>, then you can create field sections for the META tag's <code dir="ltr">NAME/CONTENT</code> attribute pairs. To do so, specify <code dir="ltr">tag</code> as <code dir="ltr">meta@namevalue</code> where <code dir="ltr">namevalue</code> is the value of the <code dir="ltr">NAME</code> attribute whose <code dir="ltr">CONTENT</code> attribute is to be indexed as a section. Refer to the example <a href="#CEGHDBHA">"Creating Sections for <code dir="ltr">&lt;META&gt;</code> Tags"</a>.</p>
<p>Oracle Text knows what the end tags look like from the <code dir="ltr">group_type</code> parameter you specify when you create the section group.</p>
</dd>
<dt>visible</dt>
<dd>
<p>Specify <code dir="ltr">TRUE</code> to make the text visible within the rest of the document.</p>
<p>By default the <code dir="ltr">visible</code> flag is <code dir="ltr">FALSE</code>. This means that Oracle Text indexes the text within field sections as a sub-document separate from the rest of the document. <a id="sthref1277"></a>However, you can set the visible flag to <code dir="ltr">TRUE</code> if you want text within the field section to be indexed as part of the enclosing document.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1278"></a>Examples</p>
<p class="subhead1"><a id="CCREF23867"></a>Visible and Invisible Field Sections</p>
<p>The following example defines a section group <code dir="ltr">basicgroup</code> of the <code dir="ltr">BASIC_SECTION_GROUP</code> type. It then creates a field section in <code dir="ltr">basicgroup</code> called <code dir="ltr">Author</code> for the <code dir="ltr">&lt;A&gt;</code> tag. It also sets the visible flag to <code dir="ltr">FALSE</code>:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.create_section_group('basicgroup', 'BASIC_SECTION_GROUP');
ctx_ddl.add_field_section('basicgroup', 'Author', 'A', FALSE);
</pre>
<pre dir="ltr">
end;
</pre>
<p>Because the <code dir="ltr">Author</code> field section is not visible, to find text within the <code dir="ltr">Author</code> section, you must use the <a href="cqoper.htm#i998525">WITHIN</a> operator as follows:</p>
<pre dir="ltr">
'(Martin Luther King) WITHIN Author'
</pre>
<p>A query of <span class="italic">Martin Luther King</span> without the <code dir="ltr">WITHIN</code> operator does not return instances of this term in field sections. To query text within field sections without specifying <code dir="ltr">WITHIN</code>, you must set the visible flag to <code dir="ltr">TRUE</code> when you create the section as follows:</p>
<pre dir="ltr">
begin
ctx_ddl.add_field_section('basicgroup', 'Author', 'A', TRUE);
end;
</pre>
<p class="subhead1"><a id="CEGHDBHA"></a><a id="CCREF23868"></a>Creating Sections for <code dir="ltr">&lt;META&gt;</code> Tags</p>
<p>When you use the <code dir="ltr">HTML_SECTION_GROUP</code>, you can create sections for <code dir="ltr">META</code> tags.</p>
<p>Consider an<a id="sthref1279"></a> HTML document that has a <code dir="ltr">META</code> tag as follows:</p>
<pre dir="ltr">
&lt;META NAME="author" CONTENT="ken"&gt;
</pre>
<p>To create a field section that indexes the <code dir="ltr">CONTENT</code> attribute for the <code dir="ltr">&lt;META NAME="author"&gt;</code> tag:</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('myhtmlgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_field_section('myhtmlgroup', 'author', 'META@AUTHOR');
end
</pre>
<p>After indexing with section group <code dir="ltr">mygroup</code>, query the document as follows:</p>
<pre dir="ltr">
'ken WITHIN author'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1280"></a>Limitations<a id="sthref1281"></a></p>
<p class="subhead1"><a id="CCREF23869"></a>Nested Sections</p>
<p>Field sections cannot be nested. For example, if you define a field section to start with <code dir="ltr">&lt;TITLE&gt;</code> and define another field section to start with <code dir="ltr">&lt;FOO&gt;</code>, the two sections <span class="italic">cannot</span> be nested as follows:</p>
<pre dir="ltr">
&lt;TITLE&gt; dog &lt;FOO&gt; cat &lt;/FOO&gt; &lt;/TITLE&gt;
</pre>
<p>To work with nested section define them as zone sections.</p>
<p class="subhead1"><a id="CCREF23870"></a>Repeated Sections<a id="sthref1282"></a></p>
<p>Repeated field sections are allowed, but <code dir="ltr">WITHIN</code> queries treat them as a single section. The following is an example of repeated field section in a document:</p>
<pre dir="ltr">
&lt;TITLE&gt; cat &lt;/TITLE&gt;
&lt;TITLE&gt; dog &lt;/TITLE&gt;
</pre>
<p>The query (<span class="italic">dog and cat) within title</span> returns the document, even though these words occur in different sections.</p>
<p>To have <code dir="ltr">WITHIN</code> queries distinguish repeated sections, define them as zone sections.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1283"></a>Related Topics</p>
<p><a href="cqoper.htm#i998525">"WITHIN"</a></p>
<p><a href="cdatadic.htm#i1009342">"Section Group Types"</a></p>
<p><a href="#i997893">"CREATE_SECTION_GROUP"</a></p>
<p><a href="#i997526">"ADD_ZONE_SECTION"</a></p>
<p><a href="#i997153">"ADD_SPECIAL_SECTION"</a></p>
<p><a href="#i998299">"REMOVE_SECTION"</a></p>
<p><a href="#i998158">"DROP_SECTION_GROUP"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997112"></a>
<div id="CCREF0606" class="refsect1">
<h2 class="refsect1"><a id="sthref1284"></a><a id="sthref1285"></a><a id="sthref1286"></a>ADD_INDEX</h2>
<p>Use this procedure to add a sub-index to a catalog index preference. Create this preference by naming one or more columns in the base table.</p>
<p>Because you create sub-indexes to improve the response time of structured queries, the column you add should be used in the <code dir="ltr">structured_query</code> clause of the <code dir="ltr">CATSEARCH</code> operator at query time.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1287"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_INDEX(set_name in varchar2,
</pre>
<pre dir="ltr">
column_list varchar2,
storage_clause varchar2);
</pre>
<dl>
<dt>set_name</dt>
<dd>
<p>Specify the name of the index set.</p>
</dd>
<dt>column_list</dt>
<dd>
<p>Specify a comma separated list of columns to index. At index time, any column listed here cannot have a NULL value in any row in the base table. If any row is NULL during indexing, then an error is raised.</p>
<p>Always ensure that your columns have non-NULL values before and after indexing.</p>
</dd>
<dt>storage_clause</dt>
<dd>
<p>Specify a storage clause.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1288"></a>Example</p>
<p>Consider a table called <code dir="ltr">AUCTION</code> with the following schema:</p>
<pre dir="ltr">
create table auction(
</pre>
<pre dir="ltr">
item_id number,
title varchar2(100),
category_id number,
price number,
bid_close date);
</pre>
<pre dir="ltr">
</pre>
<p>Assume that queries on the table involve a mandatory text query clause and optional structured conditions on <code dir="ltr">category_id</code>. Results must be sorted based on <code dir="ltr">bid_close</code>.</p>
<p>You can create a catalog index to support the different types of structured queries a user might enter.</p>
<p>To create the indexes, first create the index set preference then add the required indexes to it:</p>
<pre dir="ltr">
begin
  ctx_ddl.create_index_set('auction_iset');
  ctx_ddl.add_index('auction_iset','bid_close');
  ctx_ddl.add_index('auction_iset','category_id, bid_close');
end;
</pre>
<p>Create the combined catalog index with <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> as follows:</p>
<pre dir="ltr">
create index auction_titlex on AUCTION(title) indextype is CTXCAT parameters
('index set auction_iset');
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1289"></a>Querying</p>
<p>To query the title column for the word <span class="italic">pokemon</span>, enter regular and mixed queries as follows:</p>
<pre dir="ltr">
select * from AUCTION where CATSEARCH(title, 'pokemon',NULL)&gt; 0;
select * from AUCTION where CATSEARCH(title, 'pokemon', 'category_id=99 order by
bid_close desc')&gt; 0;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1290"></a>Notes</p>
<p><code dir="ltr">VARCHAR2</code> columns in the column list of a <code dir="ltr">CTXCAT</code> index of an index set cannot exceed 30 bytes.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1291"></a>Related Topic</p>
<p><a href="#i998279">"REMOVE_INDEX"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="BJFHJFIJ"></a>
<div id="CCREF2099" class="refsect1">
<h2 class="refsect1">ADD_MDATA<a id="sthref1292"></a><a id="sthref1293"></a><a id="sthref1294"></a><a id="sthref1295"></a><a id="sthref1296"></a></h2>
<p>Use this procedure to change the metadata of a document that has been specified as an <code dir="ltr">MDATA</code> section. After this call, <code dir="ltr">MDATA</code> queries involving the named <code dir="ltr">MDATA</code> value will find documents with the given <code dir="ltr">MDATA</code> value.</p>
<p>There are two versions of <code dir="ltr">CTX_DDL.ADD_MDATA</code>: one for adding a single metadata value to a single rowid, and one for handing multiple values, multiple rowids, or both.</p>
<p><code dir="ltr">CTX_DDL.ADD_MDATA</code> is transactional; it takes effect immediately in the calling session, can be seen only in the calling session, can be reversed with a <code dir="ltr">ROLLBACK</code> command, and must be committed to take permanent effect.</p>
<p>Use CTX_DDL.<a href="#BJFGGBCJ">REMOVE_MDATA</a> to remove metadata values from already-indexed documents. Only the owner of the index is allowed to call <code dir="ltr">ADD_MDATA</code> and <code dir="ltr">REMOVE_MDATA</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1297"></a>Syntax</p>
<p>This is the syntax for adding a single value to a single rowid:</p>
<pre dir="ltr">
CTX_DDL.ADD_MDATA(
     idx_name           IN VARCHAR2, 
     section_name       IN VARCHAR2, 
     mdata_value        IN VARCHAR2,
     mdata_rowid        IN VARCHAR2,
     [part_name]        IN VARCHAR2]
);
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>Name of the text index that contains the named <span class="variable">rowid</span>.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Name of the <code dir="ltr">MDATA</code> section.</p>
</dd>
<dt>mdata_value</dt>
<dd>
<p>The metadata value to add to the document.</p>
</dd>
<dt>mdata_rowid</dt>
<dd>
<p>The rowid to which to add the metadata value.</p>
</dd>
<dt>[part_name]</dt>
<dd>
<p>Name of the index partition, if any. Must be provided for local partitioned indexes and must be NULL for global, non-partitioned indexes.</p>
</dd>
</dl>
<p>This is the syntax for handling multiple values, multiple rowids, or both. This version is more efficient for large numbers of new values or rowids.</p>
<pre dir="ltr">
CTX_DDL.ADD_MDATA(
     idx_name           IN VARCHAR2, 
     section_name       IN VARCHAR2, 
     mdata_values       SYS.ODCIVARCHAR2LIST,
     mdata_rowids       SYS.ODCIRIDLIST,
     [part_name]        IN VARCHAR2]
);
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>Name of the text index that contains the named <span class="variable">rowids</span>.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Name of the <code dir="ltr">MDATA</code> section.</p>
</dd>
<dt>mdata_values</dt>
<dd>
<p>List of metadata values. If a metadata value contains a comma, the comma must be escaped with a backslash.</p>
</dd>
<dt>mdata_rowids</dt>
<dd>
<p>The rowids to which to add the metadata values.</p>
</dd>
<dt>[part_name]</dt>
<dd>
<p>Name of the index partition, if any. Must be provided for local partitioned indexes and must be NULL for global, non-partitioned indexes.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1298"></a>Example</p>
<p>This example updates a single value:</p>
<pre dir="ltr">
select rowid from mytab where contains(text, 'MDATA(sec, value')&gt;0;
No rows returned
exec ctx_ddl.add_mdata('my_index', 'sec', 'value', 'ABC');
select rowid from mytab where contains(text, 'MDATA(sec, value')&gt;0;
ROWID
-----
ABC
</pre>
<p>This example updates multiple values:</p>
<pre dir="ltr">
begin
ctx_ddl.add_mdata('my_index', 'sec',
     sys.odcivarchar2list('value1','value2','value3'),
     sys.odciridlist('ABC','DEF'));
end;
</pre>
<p>This is equivalent to:</p>
<pre dir="ltr">
begin
ctx_ddl.add_mdata('my_index', 'sec', 'value1', 'ABC');
ctx_ddl.add_mdata('my_index', 'sec', 'value1', 'DEF');
ctx_ddl.add_mdata('my_index', 'sec', 'value2', 'ABC');
ctx_ddl.add_mdata('my_index', 'sec', 'value2', 'DEF');
ctx_ddl.add_mdata('my_index', 'sec', 'value3', 'ABC');
ctx_ddl.add_mdata('my_index', 'sec', 'value3', 'DEF');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1299"></a>Notes</p>
<p>If a rowid is not yet indexed, <code dir="ltr">CTX_DDL.ADD.MDATA</code> completes without error, but an error is logged in <code dir="ltr">CTX_USER_INDEX_ERRORS</code>.</p>
<p>These updates are updates directly on the index itself, not on the actual contents stored in the base table. Therefore, they will not survive when the Text index is rebuilt.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1300"></a>Related Topics</p>
<p>See also <a href="#BJFFGAAA">"ADD_MDATA_SECTION"</a>; <a href="#BJFGGBCJ">"REMOVE_MDATA"</a>; <a href="cqoper.htm#BGBCFHDB">"MDATA"</a>; as well as the Section Searching chapter of the <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CEGCABJJ"></a>
<div id="CCREF2100" class="refsect1">
<h2 class="refsect1">ADD_MDATA_COLUMN<a id="sthref1301"></a><a id="sthref1302"></a><a id="sthref1303"></a><a id="sthref1304"></a><a id="sthref1305"></a></h2>
<p>Use this procedure to map the <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column named in <span class="italic">column_name</span> to the <code dir="ltr">MDATA</code> section named in <span class="italic">section_name</span>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1306"></a>Syntax</p>
<p>The syntax is as follows:</p>
<pre dir="ltr">
CTX_DDL.ADD_MDATA_COLUMN(
     group_name         IN VARCHAR2,
     section_name       IN VARCHAR2,
     column_name        IN VARCHAR2,
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Name of the group that contains the section.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Name of the <code dir="ltr">MDATA</code> section.</p>
</dd>
<dt>column_name</dt>
<dd>
<p>Name of the <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column to add to the <code dir="ltr">MDATA</code> section.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1307"></a>Restrictions</p>
<p><code dir="ltr">MDATA</code> sections that are created with <code dir="ltr">CTX_DDL.ADD_MDATA_COLUMN</code> cannot have their values changed using <code dir="ltr">CTX_DDL.ADD_MDATA</code> or <code dir="ltr">CTX_DDL.REMOVE_MDATA</code>. Doing so will result in errors being returned. The section values must be updated using SQL.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1308"></a>Notes</p>
<ul>
<li>
<p>The stored datatype for <code dir="ltr">MDATA</code> sections is <code dir="ltr">text</code>. Therefore, the value of the <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column is converted to <code dir="ltr">text</code> during indexing. For non-text datatypes, the <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> columns are normalized to an internal format during indexing. If the section is queried with an <code dir="ltr">MDATA</code> operator, then the <code dir="ltr">MDATA</code> query string will also be normalized to the internal format before processing.</p>
</li>
<li>
<p>When a <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column is mapped as <code dir="ltr">MDATA</code>, the cost-based optimizer in Oracle Text tries to avoid using the Oracle Text composite domain index to process range predicate(s) on that <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column. This is because range predicates on <code dir="ltr">MDATA</code> <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> columns are processed less efficiently than if they were declared as <code dir="ltr">SDATA</code>. For this reason, you should not add a <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column as <code dir="ltr">MDATA</code> if you plan to do range searches on the column.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1309"></a>Related Topics</p>
<p><a href="cqoper.htm#BGBCFHDB">"MDATA"</a></p>
<p><a href="#BJFFGAAA">"ADD_MDATA_SECTION"</a></p>
<p><a href="#BJFGGBCJ">"REMOVE_MDATA"</a></p>
<p><a href="#CEGFAEJJ">"ADD_SDATA_COLUMN"</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Chapter 8, "Searching Document Sections in Oracle Text" in <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="BJFFGAAA"></a>
<div id="CCREF2101" class="refsect1">
<h2 class="refsect1">ADD_MDATA_SECTION<a id="sthref1310"></a><a id="sthref1311"></a><a id="sthref1312"></a><a id="sthref1313"></a><a id="sthref1314"></a></h2>
<p>Use this procedure to add an <code dir="ltr">MDATA</code> section, with an accompanying value, to an existing section group. <code dir="ltr">MDATA</code> sections cannot be added to Null Section groups, Path Section groups, or Auto Section groups.</p>
<p>Section values undergo a simplified normalization:</p>
<ul>
<li>
<p>Leading and trailing whitespace on the value is removed.</p>
</li>
<li>
<p>The value is truncated to 64 bytes.</p>
</li>
<li>
<p>The value is indexed as a single value; if the value consists of multiple words, it is not broken up.</p>
</li>
<li>
<p>Case is preserved. If the document is dynamically generated, then implement case-insensitivity by uppercasing <code dir="ltr">MDATA</code> values and making sure to search only in uppercase.</p>
</li>
</ul>
<p>Use CTX_DDL.<a href="#i998299">REMOVE_SECTION</a> to remove sections.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1315"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_MDATA_SECTION(
     group_name    IN VARCHAR2,
     section_name  IN VARCHAR2, 
     tag           IN VARCHAR2, 
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Name of the section group that will contain the <code dir="ltr">MDATA</code> section.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Name of the <code dir="ltr">MDATA</code> section.</p>
</dd>
<dt>tag</dt>
<dd>
<p>The value of the <code dir="ltr">MDATA</code> section. For example, if the section is <code dir="ltr">&lt;AUTHOR&gt;</code>, the value could be <span class="italic">Cynthia Kadohata</span> (author of the novel <span class="italic">The Floating World</span>). More than one <span class="variable">tag</span> can be assigned to a given <code dir="ltr">MDATA</code> section.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1316"></a>Example</p>
<p>This example creates an <code dir="ltr">MDATA</code> section called <code dir="ltr">auth</code>.</p>
<pre dir="ltr">
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_mdata_section('htmgroup', 'auth', 'author');
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1317"></a>Related Topics</p>
<p><a href="#BJFHJFIJ">"ADD_MDATA"</a></p>
<p><a href="#BJFGGBCJ">"REMOVE_MDATA"</a></p>
<p><a href="cqoper.htm#BGBCFHDB">"MDATA"</a></p>
<p><a href="#i997893">"CREATE_SECTION_GROUP"</a></p>
<p>The Section Searching chapter of the <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="BABCBFCB"></a>
<div class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">ADD_NDATA_SECTION</h2>
<p>Use this procedure to find matches that are spelled in a similar way. The value of an <code dir="ltr">NDATA</code> section is extracted from the document text like other sections, but is indexed as name data. <code dir="ltr">NDATA</code> sections are stored in the <code dir="ltr">CTX_USER_SECTIONS</code> view.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1318"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_NDATA_SECTION (
   group_name    IN VARCHAR2,
   section_name  IN VARCHAR2,
   tag           IN VARCHAR2);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Name of the group that contains the section.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Name of the <code dir="ltr">NDATA</code> section.</p>
</dd>
<dt>tag</dt>
<dd>
<p>Name of the tag that marks the start of a section. For example, if the tag is &lt;H1&gt;, specify H1. The start tag you specify must be unique within a section group.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1319"></a>Notes</p>
<p><code dir="ltr">NDATA</code> sections support both single and multi-byte data, however, there are character- and term-based limitations. <code dir="ltr">NDATA</code> section data that is indexed is constrained as follows:</p>
<ul>
<li>
<p>number of characters in a single, white space delimited term</p>
<p>511</p>
</li>
<li>
<p>number of white space delimited terms</p>
<p>255</p>
</li>
<li>
<p>total number of characters, including white spaces</p>
<p>511</p>
</li>
</ul>
<p><code dir="ltr">NDATA</code> section data that exceeds these constraints are truncated.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1320"></a>Example</p>
<p>The following example defines a section group <code dir="ltr">namegroup</code> of the <code dir="ltr">BASIC_SECTION_GROUP</code> type. It then creates an <code dir="ltr">NDATA</code> section in <code dir="ltr">namegroup</code> called <code dir="ltr">firstname</code>.</p>
<pre dir="ltr">
begin
  ctx_ddl.create_section_group('namegroup', 'BASIC_SECTION_GROUP');
  ctx_ddl.add_ndata_section('namegroup', 'firstname', 'fname1');
end;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CEGFAEJJ"></a>
<div id="CCREF2102" class="refsect1">
<h2 class="refsect1">ADD_SDATA_COLUMN<a id="sthref1321"></a><a id="sthref1322"></a><a id="sthref1323"></a><a id="sthref1324"></a><a id="sthref1325"></a></h2>
<p>Use this procedure to map the <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> or <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> column named in <span class="italic">column_name</span> to the <code dir="ltr">SDATA</code> section named in <span class="italic">section_name</span>. By default, all <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> columns are mapped as <code dir="ltr">SDATA</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1326"></a>Syntax</p>
<p>The syntax is as follows:</p>
<pre dir="ltr">
CTX_DDL.ADD_SDATA_COLUMN(
     group_name         IN VARCHAR2, 
     section_name       IN VARCHAR2, 
     column_name        IN VARCHAR2,
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Name of the group that contains the section.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Name of the <code dir="ltr">SDATA</code> section.</p>
</dd>
<dt>column_name</dt>
<dd>
<p>Name of the <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column to add to the <code dir="ltr">SDATA</code> section.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1327"></a>Notes</p>
<ul>
<li>
<p>Mapping <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> columns to sections is optional. If no section mapping exists for a <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column, then it is mapped to an <code dir="ltr">SDATA</code> section, and the section name will be the name of the <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column.</p>
</li>
<li>
<p>If a section group is not specified during <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> of a composite domain index, then system default section group settings will be used, and a <code dir="ltr">SDATA</code> section will be created for each of the <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> and <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> columns.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because section name does not allow certain special characters and is case insensitive, if the column name is case sensitive or contains special characters, then an error will be raised. To work around this problem, you need to map the column to an <code dir="ltr">MDATA</code> or <code dir="ltr">SDATA</code> section before creating the index. Refer to CTX_DDL.<a href="#CEGCABJJ">ADD_MDATA_COLUMN</a> or CTX_DDL.<a href="#CEGFAEJJ">ADD_SDATA_COLUMN</a> in this chapter.</div>
</li>
<li>
<p>An error will be raised if a column mapped to <code dir="ltr">MDATA</code> also appears in the <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> column clause.</p>
</li>
<li>
<p>Column section names are unique to their section group. That is, you cannot have an <code dir="ltr">MDATA</code> column section named <code dir="ltr">FOO</code> if you already have an <code dir="ltr">MDATA</code> column section named <code dir="ltr">FOO</code>. Furthermore, you cannot have a field section named <code dir="ltr">FOO</code> if you already have an <code dir="ltr">SDATA</code> column section named <code dir="ltr">FOO</code>. This is true whether it is implicitly created (by <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> for <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> or <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clauses) or explicitly created (by <code dir="ltr">CTX_DDL.ADD_SDATA_COLUMN</code>).</p>
</li>
<li>
<p>One section name can only be mapped to one <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column, and vice versa. For example, mapping a section to more than one column or mapping a column to more than one section is not allowed.</p>
</li>
<li>
<p>Column sections can be added to any type of section group, including the <code dir="ltr">NULL</code> section group.</p>
</li>
<li>
<p>32 is the maximum number for <code dir="ltr">SDATA</code> sections and columns.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1328"></a>Related Topics</p>
<p><a href="cqoper.htm#CHDCBFHF">"SDATA"</a></p>
<p><a href="#CEGGBEIC">"ADD_SDATA_SECTION"</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Chapter 8, "Searching Document Sections in Oracle Text" in <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CEGGBEIC"></a>
<div id="CCREF2103" class="refsect1">
<h2 class="refsect1">ADD_SDATA_SECTION<a id="sthref1329"></a><a id="sthref1330"></a><a id="sthref1331"></a><a id="sthref1332"></a><a id="sthref1333"></a></h2>
<p>This procedure adds an <code dir="ltr">SDATA</code> section to a section group. By default, all <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> columns are mapped as <code dir="ltr">SDATA</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1334"></a>Syntax</p>
<p>The syntax is as follows:</p>
<pre dir="ltr">
CTX_DDL.ADD_SDATA_SECTION(
     group_name         IN VARCHAR2, 
     section_name       IN VARCHAR2, 
     tag                IN VARCHAR2,
     datatype           IN VARCHAR2, default NULL,
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Name of the group that contains the section.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Name of the <code dir="ltr">SDATA</code> section.</p>
</dd>
<dt>tag</dt>
<dd>
<p>Name of the tag to add to the <code dir="ltr">SDATA</code> section.</p>
</dd>
<dt>datatype</dt>
<dd>
<p>Specifies the stored format for the data, as well as the semantics of comparison in later use in <code dir="ltr">SDATA</code> operators. The default is <code dir="ltr">VARCHAR2</code>, but if specified must be one of the following values:</p>
<ul>
<li>
<p><code dir="ltr">VARCHAR2</code></p>
</li>
<li>
<p><code dir="ltr">CHAR</code></p>
</li>
<li>
<p><code dir="ltr">RAW</code></p>
</li>
<li>
<p><code dir="ltr">NUMBER</code></p>
</li>
<li>
<p><code dir="ltr">DATE</code></p>
</li>
</ul>
<p>The <code dir="ltr">VARCHAR2</code> datatype stores up to 249 bytes of character data in the database character set. Values larger than this result in a per-document indexing error. Note that leading and trailing whitespace are always trimmed from <code dir="ltr">SDATA</code> section values when extracted by the sectioner. This is different than <code dir="ltr">SDATA</code> columns. Column values are never trimmed. No lexing is performed on the value from either kind of <code dir="ltr">SDATA</code>.</p>
<p>The <code dir="ltr">CHAR</code> datatype stores up to 249 bytes of character data in the database character set. Values larger than this result in a per-document indexing error. Note that leading and trailing whitespace are always trimmed from <code dir="ltr">SDATA</code> section values when extracted by the sectioner. This is different than <code dir="ltr">SDATA</code> columns. Column values are never trimmed. No lexing is performed on the value from either kind of <code dir="ltr">SDATA</code>. To be consistent with SQL, the comparisons of <code dir="ltr">CHAR</code> datatype <code dir="ltr">SDATA</code> values are blank-padded comparisons.</p>
<p><code dir="ltr">RAW</code> datatype stores up to 249 bytes of binary data. Values larger than this result in a per-document indexing error. The value is converted from hexadecimal string representation. That is, to store a value of <code dir="ltr">65</code>, the document should look like <code dir="ltr">&lt;TAG&gt;40&lt;/TAG&gt;</code>, and not <code dir="ltr">&lt;TAG&gt;65&lt;/TAG&gt;</code> or <code dir="ltr">&lt;TAG&gt;A&lt;/TAG&gt;</code>.</p>
<p>The <code dir="ltr">DATE</code> datatype values must conform to the following format: <code dir="ltr">YYYY-MM-DD</code> or <code dir="ltr">YYYY-MM-DD HH24:MI:SS</code>. That is, to store a <code dir="ltr">DATE</code> value of "Nov. 24, 2006 10:32pm 36sec", the document should look like <code dir="ltr">&lt;TAG&gt;2006-11-24 22:32:36&lt;/TAG&gt;</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1335"></a>Limitations</p>
<ul>
<li>
<p><code dir="ltr">SDATA</code> are single-occurrence only. If multiple instances of an <code dir="ltr">SDATA</code> tag are encountered in a single document, then later instances supersede the value set by earlier instances. This means that the last occurrence of an <code dir="ltr">SDATA</code> tag takes effect.</p>
</li>
<li>
<p>If no <code dir="ltr">SDATA</code> tag occurs in a given document, then this is treated as an <code dir="ltr">SDATA</code> value of <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>Empty <code dir="ltr">SDATA</code> tags are treated as <code dir="ltr">NULL</code> values.</p>
</li>
<li>
<p><code dir="ltr">SDATA</code> sections cannot be nested. Sections that are nested inside are ignored.</p>
</li>
<li>
<p>32 is the maximum number for <code dir="ltr">SDATA</code> sections and columns.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1336"></a>Related Topics</p>
<p><a href="cqoper.htm#CHDCBFHF">"SDATA"</a></p>
<p><a href="#CEGFAEJJ">"ADD_SDATA_COLUMN"</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Chapter 8, "Searching Document Sections in Oracle Text" in <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997153"></a>
<div id="CCREF0608" class="refsect1">
<h2 class="refsect1">ADD_SPECIAL_SECTION <a id="sthref1337"></a><a id="sthref1338"></a><a id="sthref1339"></a><a id="sthref1340"></a><a id="sthref1341"></a></h2>
<p>Adds a special section, either <code dir="ltr">SENTENCE</code> or <code dir="ltr">PARAGRAPH</code>, to a section group. This enables searching within sentences or paragraphs in documents with the <a href="cqoper.htm#i998525">WITHIN</a> operator.</p>
<p>A special section in a document is a section which is not explicitly tagged like zone and field sections. The start and end of special sections are detected when the index is created. Oracle Text supports two such sections: <span class="italic">paragraph</span> and <span class="italic">sentence</span>.</p>
<p>The sentence and paragraph boundaries are determined by the lexer. For example, the lexer recognizes sentence and paragraph section boundaries as follows:</p>
<div id="CCREF23871" class="tblformal">
<p class="titleintable"><a id="sthref1342"></a><a id="sthref1343"></a>Table 7-1 Paragraph and Sentence Section Boundaries</p>
<table class="cellalignment103" title="Paragraph and Sentence Section Boundaries" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t8">Special Section</th>
<th class="cellalignment97" id="r1c2-t8">Boundary</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t8" headers="r1c1-t8">
<p>SENTENCE</p>
</td>
<td class="cellalignment98" headers="r2c1-t8 r1c2-t8">
<p>WORD/PUNCT/WHITESPACE</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t8" headers="r1c1-t8">&nbsp;</td>
<td class="cellalignment98" headers="r3c1-t8 r1c2-t8">
<p>WORD/PUNCT/NEWLINE</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t8" headers="r1c1-t8">
<p>PARAGRAPH</p>
</td>
<td class="cellalignment98" headers="r4c1-t8 r1c2-t8">
<p>WORD/PUNCT/NEWLINE/WHITESPACE (indented paragraph)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t8" headers="r1c1-t8">&nbsp;</td>
<td class="cellalignment98" headers="r5c1-t8 r1c2-t8">
<p>WORD/PUNCT/NEWLINE/NEWLINE (block paragraph)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The punctuation, whitespace, and newline characters are determined by your lexer settings and can be changed.</p>
<p>If the lexer cannot recognize the boundaries, no sentence or paragraph sections are indexed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1344"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_SPECIAL_SECTION(
                 group_name    IN VARCHAR2, 
                 section_name  IN VARCHAR2);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Specify the name of the section group.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Specify <code dir="ltr">SENTENCE</code> or <code dir="ltr">PARAGRAPH</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1345"></a>Example</p>
<p>The following example enables searching within sentences within HTML documents:</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_special_section('htmgroup', 'SENTENCE');
end;
</pre>
<p>Add zone sections to the group to enable zone searching in addition to sentence searching. The following example adds the zone section <code dir="ltr">Headline</code> to the section group <code dir="ltr">htmgroup</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_special_section('htmgroup', 'SENTENCE');
ctx_ddl.add_zone_section('htmgroup', 'Headline', 'H1');
end;
</pre>
<p>If you are only interested in sentence or paragraph searching within documents and not interested in defining zone or field sections, then use the <code dir="ltr">NULL_SECTION_GROUP</code> as follows:</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('nullgroup', 'NULL_SECTION_GROUP');
ctx_ddl.add_special_section('nullgroup', 'SENTENCE');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1346"></a>Related Topics</p>
<p><a href="cqoper.htm#i998525">"WITHIN"</a></p>
<p><a href="cdatadic.htm#i1009342">"Section Group Types"</a></p>
<p><a href="#i997893">"CREATE_SECTION_GROUP"</a></p>
<p><a href="#i997526">"ADD_ZONE_SECTION"</a></p>
<p><a href="#i999153">"ADD_FIELD_SECTION"</a></p>
<p><a href="#i998299">"REMOVE_SECTION"</a></p>
<p><a href="#i998158">"DROP_SECTION_GROUP"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997253"></a>
<div id="CCREF0610" class="refsect1">
<h2 class="refsect1">ADD_STOPCLASS <a id="sthref1347"></a><a id="sthref1348"></a><a id="sthref1349"></a></h2>
<p>Adds a stopclass to a stoplist. A stopclass is a class of tokens that is not to be indexed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1350"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_STOPCLASS(
  stoplist_name  in   varchar2,
  stopclass      in   varchar2
);
</pre>
<dl>
<dt>stoplist_name</dt>
<dd>
<p>Specify the name of the stoplist.</p>
</dd>
<dt>stopclass</dt>
<dd>
<p>Specify the stopclass to be added to <code dir="ltr">stoplist_name</code>. Currently, only the <code dir="ltr">NUMBERS</code> class is supported. It is not possible to create a custom stopclass.</p>
<p><code dir="ltr">NUMBERS</code> includes tokens that follow the number pattern: digits, <code dir="ltr">numgroup</code>, and <code dir="ltr">numjoin</code> only. Therefore, <span class="italic">123ABC</span> is not a number, nor is <span class="italic">A123</span>. These are labeled as <code dir="ltr">MIXED</code>. <span class="italic">$123</span> is not a number (this token is not common in a text index because non-alphanumerics become whitespace by default). In the United States, <span class="italic">123.45</span> is a number, but <span class="italic">123.456.789</span> is not; in Europe, where numgroup may be '.', the reverse is true.</p>
<p>The maximum number of stopwords, stopthemes, and stopclasses you can add to a stoplist is 4095.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1351"></a>Example</p>
<p>The following example adds a stopclass of <code dir="ltr">NUMBERS</code> to the stoplist <code dir="ltr">mystop</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.add_stopclass('mystop', 'NUMBERS');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1352"></a>Related Topics</p>
<p><a href="#i998026">"CREATE_STOPLIST"</a></p>
<p><a href="#i998343">"REMOVE_STOPCLASS"</a></p>
<p><a href="#i998178">"DROP_STOPLIST"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997287"></a>
<div id="CCREF0612" class="refsect1">
<h2 class="refsect1">ADD_STOP_SECTION<a id="sthref1353"></a><a id="sthref1354"></a><a id="sthref1355"></a></h2>
<p>Adds a stop section to an automatic section group. Adding a stop section causes the automatic section indexing operation to ignore the specified section in XML documents.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Adding a stop section causes no section information to be created in the index. However, the text within a stop section is always searchable.</div>
<p>Adding a stop section is useful when your documents contain many low information tags. Adding stop sections also improves indexing performance with the automatic section group.</p>
<p>The number of stop sections you can add is unlimited.</p>
<p>Stop sections do not have section names and hence are not recorded in the section views.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1356"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_STOP_SECTION(
                 section_group IN VARCHAR2, 
                 tag  IN VARCHAR2);
</pre>
<dl>
<dt>section_group</dt>
<dd>
<p>Specify the name of the automatic section group. If you do not specify an automatic section group, then this procedure returns an error.</p>
</dd>
<dt>tag</dt>
<dd>
<p>Specify the tag to ignore during indexing. This parameter is case-sensitive. Defining a stop tag as such also stops the tag's attribute sections, if any.</p>
<p>Qualify the tag with document type in the form <code dir="ltr">(doctype)tag</code>. For example, if you wanted to make the <code dir="ltr">&lt;fluff&gt;</code> tag a stop section only within the <code dir="ltr">mydoc</code> document type, specify <code dir="ltr">(mydoc)fluff</code> for tag.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1357"></a>Example</p>
<p class="subhead1"><a id="CCREF23872"></a>Defining Stop Sections</p>
<p>The following example adds a stop section identified by the tag &lt;<code dir="ltr">fluff&gt;</code> to the automatic section group <code dir="ltr">myauto</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.add_stop_section('myauto', 'fluff');
end;
</pre>
<p>This example also stops any attribute sections contained within <code dir="ltr">&lt;fluff&gt;</code>. For example, if a document contained:</p>
<pre dir="ltr">
&lt;fluff type="computer"&gt;
</pre>
<p>Then the preceding example also stops the attribute section <code dir="ltr">fluff@type.</code></p>
<p class="subhead1"><a id="CCREF23873"></a>Doctype Sensitive Stop Sections</p>
<p>The following example creates a stop section for the tag &lt;<code dir="ltr">fluff&gt;</code> only in documents that have a root element of <code dir="ltr">mydoc</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.add_stop_section('myauto', '(mydoc)fluff');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1358"></a>Related Topics</p>
<p><a href="csql.htm#CIHBFDCE">"ALTER INDEX"</a></p>
<p><a href="#i997893">"CREATE_SECTION_GROUP"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997338"></a>
<div id="CCREF0614" class="refsect1">
<h2 class="refsect1">ADD_STOPTHEME<a id="sthref1359"></a><a id="sthref1360"></a><a id="sthref1361"></a></h2>
<p>Adds a single stoptheme to a stoplist. A stoptheme is a theme that is not to be indexed.</p>
<p>In English, query on indexed themes using the <a href="cqoper.htm#BABJFFAD">ABOUT</a> operator.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1362"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_STOPTHEME(
  stoplist_name  in   varchar2,
  stoptheme      in   varchar2
);
</pre>
<dl>
<dt>stoplist_name</dt>
<dd>
<p>Specify the name of the stoplist.</p>
</dd>
<dt>stoptheme</dt>
<dd>
<p>Specify the stoptheme to be added to <code dir="ltr">stoplist_name</code>. The system normalizes the <code dir="ltr">stoptheme</code> you enter using the knowledge base. If the normalized theme is more than one theme, then the system does not process your stoptheme. For this reason, Oracle recommends that you submit single stopthemes.</p>
<p>The maximum number of stopwords, stopthemes, and stopclasses you can add to a stoplist is 4095.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1363"></a>Example</p>
<p>The following example adds the stoptheme <code dir="ltr">banking</code> to the stoplist <code dir="ltr">mystop</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.add_stoptheme('mystop', 'banking');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1364"></a>Related Topics</p>
<p><a href="#i998026">"CREATE_STOPLIST"</a></p>
<p><a href="#i998369">"REMOVE_STOPTHEME"</a></p>
<p><a href="#i998178">"DROP_STOPLIST"</a></p>
<p><a href="cqoper.htm#BABJFFAD">"ABOUT"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997383"></a>
<div id="CCREF0616" class="refsect1">
<h2 class="refsect1">ADD_STOPWORD <a id="sthref1365"></a><a id="sthref1366"></a><a id="sthref1367"></a></h2>
<p>Use this procedure to add a single stopword to a stoplist.</p>
<p>To create a list of stopwords, you must call this procedure once for each word.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1368"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_STOPWORD(
</pre>
<pre dir="ltr">
stoplist_name  in   varchar2,
stopword       in   varchar2,
language       in varchar2 default NULL
</pre>
<pre dir="ltr">
);
</pre>
<dl>
<dt>stoplist_name</dt>
<dd>
<p>Specify the name of the stoplist.</p>
</dd>
<dt>stopword</dt>
<dd>
<p>Specify the stopword to be added.</p>
<p>Language-specific stopwords must be unique across the other stopwords specific to the language. For example, it is valid to have a German <span class="italic">die</span> and an English <span class="italic">die</span> in the same stoplist.</p>
<p>The maximum number of stopwords, stopthemes, and stopclasses you can add to a stoplist is 4095.</p>
</dd>
<dt>language</dt>
<dd>
<p>Specify the language of <code dir="ltr">stopword</code> when the stoplist you specify with <code dir="ltr">stoplist_name</code> is of type <code dir="ltr">MULTI_STOPLIST</code>. You must specify the globalization support name or abbreviation of an Oracle Text-supported language.</p>
<p>To make a stopword active in multiple languages, specify <code dir="ltr">ALL</code> for this parameter. For example, defining <code dir="ltr">ALL</code> stopwords is useful when you have international documents that contain English fragments that need to be stopped in any language.</p>
<p>An <code dir="ltr">ALL</code> stopword is active in all languages. If you use the multi-lexer, the language-specific lexing of the stopword occurs, just as if it had been added multiple times in multiple specific languages.</p>
<p>Otherwise, specify <code dir="ltr">NULL</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1369"></a>Example</p>
<p class="subhead1"><a id="CCREF23874"></a>Single Language Stoplist</p>
<p>The following example adds the stopwords <span class="italic">because, notwithstanding, nonetheless,</span> and <span class="italic">therefore</span> to the stoplist <code dir="ltr">mystop</code>:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.add_stopword('mystop', 'because');
ctx_ddl.add_stopword('mystop', 'notwithstanding');
ctx_ddl.add_stopword('mystop', 'nonetheless');
ctx_ddl.add_stopword('mystop', 'therefore');
</pre>
<pre dir="ltr">
end;
</pre>
<p class="subhead1"><a id="CCREF23875"></a>Multi-Language Stoplist</p>
<p>The following example adds the German word <span class="italic">die</span> to a multi-language stoplist:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.add_stopword('mystop', 'Die','german');
</pre>
<pre dir="ltr">
end;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Add stopwords after you create the index with <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code>.</div>
<p class="subhead1"><a id="CCREF23876"></a>Adding An ALL Stopword</p>
<p>The following adds the word <span class="italic">the</span> as an <code dir="ltr">ALL</code> stopword to the multi-language stoplist <span class="italic">globallist</span>:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.add_stopword('globallist','the','ALL');
</pre>
<pre dir="ltr">
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1370"></a>Related Topics</p>
<p><a href="#i998026">"CREATE_STOPLIST"</a></p>
<p><a href="#i998395">"REMOVE_STOPWORD"</a></p>
<p><a href="#i998178">"DROP_STOPLIST"</a></p>
<p><a href="csql.htm#CIHBFDCE">"ALTER INDEX"</a></p>
<p><a href="astopsup.htm#CEGBGCDF">Appendix E, "Oracle Text Supplied Stoplists"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997457"></a>
<div id="CCREF0618" class="refsect1">
<h2 class="refsect1">ADD_SUB_LEXER <a id="sthref1371"></a><a id="sthref1372"></a><a id="sthref1373"></a></h2>
<p>Add a sub-lexer to a multi-lexer preference. A sub-lexer identifies a language in a multi-lexer (multi-language) preference. Use a multi-lexer preference when you want to index more than one language.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1374"></a>Restrictions</p>
<p>The following restrictions apply to using <code dir="ltr">CTX_DDL.ADD_SUB_LEXER</code>:</p>
<ul>
<li>
<p>The invoking user must be the owner of the multi-lexer or <code dir="ltr">CTXSYS</code>.</p>
</li>
<li>
<p>The <span class="syntaxinline">lexer_name</span> parameter must name a preference which is a multi-lexer lexer.</p>
</li>
<li>
<p>A lexer for default must be defined before the multi-lexer can be used in an index.</p>
</li>
<li>
<p>The sub-lexer preference owner must be the same as multi-lexer preference owner.</p>
</li>
<li>
<p>The sub-lexer preference must not be a multi-lexer lexer.</p>
</li>
<li>
<p>A sub-lexer preference cannot be dropped while it is being used in a multi-lexer preference.</p>
</li>
<li>
<p><code dir="ltr">CTX_DDL.ADD_SUB_LEXER</code> records only a reference. The sub-lexer values are copied at create index time to index value storage.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1375"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_SUB_LEXER(
             lexer_name in varchar2,
             language  in varchar2,
             sub_lexer in varchar2,
             alt_value in varchar2 default null
);
</pre>
<dl>
<dt>lexer_name</dt>
<dd>
<p>Specify the name of the multi-lexer preference.</p>
</dd>
<dt>language</dt>
<dd>
<p>Specify the globalization support language name or abbreviation of the sub-lexer. For example, specify <code dir="ltr">JAPANESE</code> or <code dir="ltr">JA</code> for Japanese.</p>
<p>The sub-lexer you specify with <code dir="ltr">sub_lexer</code> is used when the language column has a value case-insensitive equal to the globalization support name of abbreviation of <code dir="ltr">language</code>.</p>
<p>Specify <code dir="ltr">DEFAULT</code> to assign a default sub-lexer to use when the value of the language column in the base table is null, invalid, or unmapped to a sub-lexer. The <code dir="ltr">DEFAULT</code> lexer is also used to parse stopwords.</p>
<p>If a sub-lexer definition for <code dir="ltr">language</code> already exists, then it is replaced by this call.</p>
</dd>
<dt>sub_lexer</dt>
<dd>
<p>Specify the name of the sub-lexer to use for this language.</p>
</dd>
<dt>alt_value</dt>
<dd>
<p>Optionally specify an alternate value for <code dir="ltr">language</code>.</p>
<p>If you specify <code dir="ltr">DEFAULT</code> for <code dir="ltr">language</code>, then you cannot specify an <code dir="ltr">alt_value</code>.</p>
<p>The <code dir="ltr">alt_value</code> is limited to 30 bytes and cannot be a globalization support language name, abbreviation, or <code dir="ltr">DEFAULT</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1376"></a>Example</p>
<p>This example shows how to create a multi-language text table and how to set up the multi-lexer to index the table.</p>
<p>Create the multi-language table with a primary key, a text column, and a language column as follows:</p>
<pre dir="ltr">
create table globaldoc (
   doc_id number primary key,
   lang varchar2(3),
   text clob
);
</pre>
<p>Assume that the table holds mostly English documents, with an occasional German or Japanese document. To handle the three languages, you must create three sub-lexers: one for English, one for German, and one for Japanese as follows:</p>
<pre dir="ltr">
ctx_ddl.create_preference('english_lexer','basic_lexer');
ctx_ddl.set_attribute('english_lexer','index_themes','yes');
ctx_ddl.set_attribtue('english_lexer','theme_language','english');

ctx_ddl.create_preference('german_lexer','basic_lexer');
ctx_ddl.set_attribute('german_lexer','composite','german');
ctx_ddl.set_attribute('german_lexer','mixed_case','yes');
ctx_ddl.set_attribute('german_lexer','alternate_spelling','german');

ctx_ddl.create_preference('japanese_lexer','japanese_vgram_lexer');
</pre>
<p>Create the multi-lexer preference:</p>
<pre dir="ltr">
ctx_ddl.create_preference('global_lexer', 'multi_lexer');
</pre>
<p>Because the stored documents are mostly English, make the English lexer the default:</p>
<pre dir="ltr">
ctx_ddl.add_sub_lexer('global_lexer','default','english_lexer');
</pre>
<p>Add the German and Japanese lexers in their respective languages. Also assume that the language column is expressed in ISO 639-2, so add those as alternative values.</p>
<pre dir="ltr">
ctx_ddl.add_sub_lexer('global_lexer','german','german_lexer','ger');
ctx_ddl.add_sub_lexer('global_lexer','japanese','japanese_lexer','jpn');
</pre>
<p>Create the index <code dir="ltr">globalx</code>, specifying the multi-lexer preference and the language column in the parameters string as follows:</p>
<pre dir="ltr">
create index globalx on globaldoc(text) indextype is ctxsys.context
parameters ('lexer global_lexer language column lang');
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997526"></a>
<div id="CCREF0620" class="refsect1">
<h2 class="refsect1">ADD_ZONE_SECTION<a id="sthref1377"></a><a id="sthref1378"></a><a id="sthref1379"></a><a id="sthref1380"></a></h2>
<p>Creates a zone section and adds the section to an existing section group. This enables zone section searching with the <a href="cqoper.htm#i998525">WITHIN</a> operator.</p>
<p>Zone sections are sections delimited by start and end tags. The <code dir="ltr">&lt;B&gt;</code> and <code dir="ltr">&lt;/B&gt;</code> tags in HTML, for instance, marks a range of words which are to be rendered in boldface.</p>
<p>Zone sections can be nested within one another, can overlap, and can occur more than once in a document.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1381"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.ADD_ZONE_SECTION(
  group_name     in    varchar2,
  section_name   in    varchar2,
  tag            in    varchar2
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Specify the name of the section group to which <code dir="ltr">section_name</code> is added.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Specify the name of the section to add to the group_name. Use this name to identify the section in <code dir="ltr">WITHIN</code> queries. Avoid using names that contain non-alphanumeric characters such as _, because most of these characters are special must be escaped in queries. Section names are case-insensitive.</p>
<p>Within the same group, zone section names and field section names cannot be the same. The terms <span class="italic">Paragraph</span> and <span class="italic">Sentence</span> are reserved for special sections.</p>
<p>Section names need not be unique across tags. You can assign the same section name to more than one tag, making details transparent to searches.</p>
</dd>
<dt>tag</dt>
<dd>
<p>Specify the pattern which marks the start of a section. For example, if <code dir="ltr">&lt;H1&gt;</code> is the HTML tag, specify <code dir="ltr">H1</code> for <code dir="ltr">tag</code>. The start tag you specify must be unique within a section group.</p>
<p>Oracle Text knows what the end tags look like from the <code dir="ltr">group_type</code> parameter you specify when you create the section group.</p>
<p>If <code dir="ltr">group_name</code> is an <code dir="ltr">HTML_SECTION_GROUP</code>, you can create zone sections for the META tag's <code dir="ltr">NAME/CONTENT</code> attribute pairs. To do so, specify <code dir="ltr">tag</code> as <code dir="ltr">meta@namevalue</code> where <code dir="ltr">namevalue</code> is the value of the <code dir="ltr">NAME</code> attribute whose <code dir="ltr">CONTENT</code> attributes are to be indexed as a section. Refer to the example.</p>
<p>If <code dir="ltr">group_name</code> is an <code dir="ltr">XML_SECTION_GROUP</code>, you can optionally qualify <code dir="ltr">tag</code> with a document type (root element) in the form <code dir="ltr">(doctype)tag</code>. Doing so makes <code dir="ltr">section_name</code> sensitive to the XML document type declaration. Refer to the example.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1382"></a>Examples</p>
<p class="subhead1"><a id="CCREF23877"></a>Creating HTML Sections<a id="sthref1383"></a><a id="sthref1384"></a></p>
<p>The following example defines a section group called <code dir="ltr">htmgroup</code> of type <code dir="ltr">HTML_SECTION_GROUP</code>. It then creates a zone section in <code dir="ltr">htmgroup</code> called <code dir="ltr">headline</code> identified by the &lt;H1&gt; tag:</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_zone_section('htmgroup', 'heading', 'H1');
end;
</pre>
<p>After indexing with section group <code dir="ltr">htmgroup</code>, query within the heading section by issuing a query as follows:</p>
<pre dir="ltr">
'Oracle WITHIN heading'
</pre>
<p class="subhead1"><a id="CCREF23878"></a>Creating Sections for <code dir="ltr">&lt;META NAME&gt;</code> Tags <a id="sthref1385"></a></p>
<p>You can create zone sections for HTML META tags when you use the <code dir="ltr">HTML_SECTION_GROUP</code>.</p>
<p>Consider an HTML document that has a <code dir="ltr">META</code> tag as follows:</p>
<pre dir="ltr">
&lt;META NAME="author" CONTENT="ken"&gt;
</pre>
<p>To create a zone section that indexes all <code dir="ltr">CONTENT</code> attributes for the <code dir="ltr">META</code> tag whose <code dir="ltr">NAME</code> value is author:</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
ctx_ddl.add_zone_section('htmgroup', 'author', 'meta@author');
end
</pre>
<p>After indexing with section group <code dir="ltr">htmgroup</code>, query the document as follows:</p>
<pre dir="ltr">
'ken WITHIN author'
</pre>
<p class="subhead1"><a id="CCREF23879"></a>Creating Document Type Sensitive Sections (XML Documents Only)<a id="sthref1386"></a></p>
<p>You have an XML document set that contains the <code dir="ltr">&lt;book&gt;</code> tag declared for different document types (DTDs). You want to create a distinct book section for each document type.</p>
<p>Assume that <code dir="ltr">myDTDname</code> is declared as an XML document type as follows:</p>
<pre dir="ltr">
&lt;!DOCTYPE myDTDname&gt;
&lt;myDTDname&gt;
 ...
</pre>
<p>(Note: the <code dir="ltr">DOCTYPE</code> must match the top-level tag.)</p>
<p>Within <code dir="ltr">myDTDname</code>, the element <code dir="ltr">&lt;book&gt;</code> is declared. For this tag, create a section named <code dir="ltr">mybooksec</code> that is sensitive to the tag's document type as follows:</p>
<pre dir="ltr">
begin
ctx_ddl.create_section_group('myxmlgroup', 'XML_SECTION_GROUP');
ctx_ddl.add_zone_section('myxmlgroup', 'mybooksec', '(myDTDname)book');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1387"></a>Notes</p>
<p class="subhead1"><a id="CCREF23880"></a>Repeated Sections<a id="sthref1388"></a><a id="sthref1389"></a></p>
<p>Zone sections can repeat. Each occurrence is treated as a separate section. For example, if &lt;H1&gt; denotes a <code dir="ltr">heading</code> section, they can repeat in the same documents as follows:</p>
<p>&lt;H1&gt; The Brown Fox &lt;/H1&gt;</p>
<p>&lt;H1&gt; The Gray Wolf &lt;/H1&gt;</p>
<p>Assuming that these zone sections are named <code dir="ltr">Heading</code>, the query <span class="italic">Brown WITHIN Heading</span> returns this document. However, a query of <span class="italic">(Brown and Gray) WITHIN Heading</span> does not.</p>
<p class="subhead1"><a id="CCREF23881"></a>Overlapping Sections<a id="sthref1390"></a><a id="sthref1391"></a></p>
<p>Zone sections can overlap each other. For example, if <code dir="ltr">&lt;B&gt;</code> and <code dir="ltr">&lt;I&gt;</code> denote two different zone sections, they can overlap in document as follows:</p>
<pre dir="ltr">
plain &lt;B&gt; bold &lt;I&gt; bold and italic &lt;/B&gt; only italic &lt;/I&gt;  plain
</pre>
<p class="subhead1"><a id="CCREF23882"></a>Nested Sections<a id="sthref1392"></a><a id="sthref1393"></a></p>
<p>Zone sections can nest, including themselves as follows:</p>
<pre dir="ltr">
&lt;TD&gt; &lt;TABLE&gt;&lt;TD&gt;nested cell&lt;/TD&gt;&lt;/TABLE&gt;&lt;/TD&gt;
</pre>
<p>Using the <code dir="ltr">WITHIN</code> operator, you can write queries to search for text in sections within sections. For example, assume the <code dir="ltr">BOOK1</code>, <code dir="ltr">BOOK2</code>, and <code dir="ltr">AUTHOR</code> zone sections occur as follows in documents doc1 and doc2:</p>
<p>doc1:</p>
<pre dir="ltr">
&lt;book1&gt; &lt;author&gt;Scott Tiger&lt;/author&gt; This is a cool book to read.&lt;/book1&gt;
</pre>
<p>doc2:</p>
<pre dir="ltr">
&lt;book2&gt; &lt;author&gt;Scott Tiger&lt;/author&gt; This is a great book to read.&lt;/book2&gt;
</pre>
<p>Consider the nested query:</p>
<pre dir="ltr">
'(Scott within author) within book1'
</pre>
<p>This query returns only doc1.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1394"></a>Related Topics</p>
<p><a href="cqoper.htm#i998525">"WITHIN"</a></p>
<p><a href="cdatadic.htm#i1009342">"Section Group Types"</a></p>
<p><a href="#i997893">"CREATE_SECTION_GROUP"</a></p>
<p><a href="#i999153">"ADD_FIELD_SECTION"</a></p>
<p><a href="#i997153">"ADD_SPECIAL_SECTION"</a></p>
<p><a href="#i998299">"REMOVE_SECTION"</a></p>
<p><a href="#i998158">"DROP_SECTION_GROUP"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CHDDGDDA"></a>
<div id="CCREF2104" class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">COPY_POLICY<a id="sthref1395"></a><a id="sthref1396"></a><a id="sthref1397"></a></h2>
<p>Creates a new policy from an existing policy or index.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1398"></a>Syntax</p>
<pre dir="ltr">
ctx_ddl.copy_policy(
    source_policy       VARCHAR2,
    policy_name         VARCHAR2    );
</pre>
<dl>
<dt>source_policy</dt>
<dd>
<p>The name of the policy or index being copied.</p>
</dd>
<dt>policy_name</dt>
<dd>
<p>The name of the new policy copy.</p>
</dd>
</dl>
<p>The preference values are copied from the <code dir="ltr">source_policy</code>. Both the source policy or index and the new policy must be owned by the same database user.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997653"></a>
<div id="CCREF0622" class="refsect1">
<h2 class="refsect1">CREATE_INDEX_SET<a id="sthref1399"></a><a id="sthref1400"></a></h2>
<p>Creates an index set for <code dir="ltr">CTXCAT</code> index types. Name this index set in the parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> when you create a <code dir="ltr">CTXCAT</code> index.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1401"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.CREATE_INDEX_SET(set_name in varchar2);
</pre>
<dl>
<dt>set_name</dt>
<dd>
<p>Specify the name of the index set. Name this index set in the parameter clause of <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> when you create a <code dir="ltr">CTXCAT</code> index.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997662"></a>
<div id="CCREF2105" class="refsect1">
<h2 class="refsect1">CREATE_POLICY<a id="sthref1402"></a><a id="sthref1403"></a></h2>
<p>Creates a policy to use with the <code dir="ltr">CTX_DOC.POLICY_*</code> procedures and the <code dir="ltr">ORA:CONTAINS</code> function. <code dir="ltr">ORA:CONTAINS</code> is a function you use within an <code dir="ltr">XPATH</code> query expression with <code dir="ltr">existsNode()</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDB" href="../../appdev.112/e23094/toc.htm"><span class="italic">Oracle XML DB Developer's Guide</span></a></div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1404"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.CREATE_POLICY(
         policy_name     IN VARCHAR2,
         filter          IN VARCHAR2 DEFAULT NULL,
         section_group   IN VARCHAR2 DEFAULT NULL,
         lexer           IN VARCHAR2 DEFAULT NULL,
         stoplist        IN VARCHAR2 DEFAULT NULL,
         wordlist        IN VARCHAR2 DEFAULT NULL);
</pre>
<dl>
<dt>policy_name</dt>
<dd>
<p>Specify the name for the new policy. Policy names and Text indexes share the same namespace.</p>
</dd>
<dt>filter</dt>
<dd>
<p>Specify the filter preference to use.</p>
</dd>
<dt>section_group</dt>
<dd>
<p>Specify the section group to use. You can specify any section group that is supported by <code dir="ltr">CONTEXT</code> index.</p>
</dd>
<dt>lexer</dt>
<dd>
<p>Specify the lexer preference to use. Your <code dir="ltr">INDEX_THEMES</code> attribute must be disabled.</p>
</dd>
<dt>stoplist</dt>
<dd>
<p>Specify the stoplist to use.</p>
</dd>
<dt>wordlist</dt>
<dd>
<p>Specify the wordlist to use.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1405"></a>Example</p>
<p>Create mylex lexer preference named mylex.</p>
<pre dir="ltr">
begin 
   ctx_ddl.create_preference('mylex', 'BASIC_LEXER'); 
   ctx_ddl.set_attribute('mylex', 'printjoins', '_-'); 
   ctx_ddl.set_attribute ( 'mylex', 'index_themes', 'NO');  
   ctx_ddl.set_attribute ( 'mylex', 'index_text', 'YES'); 
end; 
</pre>
<p>Create a stoplist preference named mystop.</p>
<pre dir="ltr">
begin 
  ctx_ddl.create_stoplist('mystop', 'BASIC_STOPLIST'); 
  ctx_ddl.add_stopword('mystop', 'because');
  ctx_ddl.add_stopword('mystop', 'nonetheless');
  ctx_ddl.add_stopword('mystop', 'therefore');
end;
</pre>
<p>Create a wordlist preference named 'mywordlist'.</p>
<pre dir="ltr">
begin 
 ctx_ddl.create_preference('mywordlist', 'BASIC_WORDLIST');
 ctx_ddl.set_attribute('mywordlist','FUZZY_MATCH','ENGLISH'); 
 ctx_ddl.set_attribute('mywordlist','FUZZY_SCORE','0'); 
 ctx_ddl.set_attribute('mywordlist','FUZZY_NUMRESULTS','5000'); 
 ctx_ddl.set_attribute('mywordlist','SUBSTRING_INDEX','TRUE'); 
 ctx_ddl.set_attribute('mywordlist','STEMMER','ENGLISH'); 
end; 
</pre>
<pre dir="ltr">
exec ctx_ddl.create_policy('my_policy', NULL, NULL, 'mylex', 'mystop', 
'mywordlist');
</pre>
<p>or</p>
<pre dir="ltr">
exec ctx_ddl.create_policy(policy_name =&gt; 'my_policy', 
                           lexer =&gt; 'mylex',
                           stoplist =&gt; 'mystop',
                           wordlist =&gt; 'mywordlist');
</pre>
<p>Then enter the following <code dir="ltr">existsNode()</code> query with your own defined policy:</p>
<pre dir="ltr">
select id from xmltab 
  where existsNode(doc, '/book/chapter[ ora:contains(summary,"dog or cat", 
  "my_policy") &gt;0 ]', 'xmlns:ora="http://xmlns.oracle.com/xdb" ')=1;
</pre>
<p>Update the policy with the following:</p>
<pre dir="ltr">
exec ctx_ddl.update_policy(policy_name =&gt; 'my_policy', lexer =&gt; 'my_new_lex');
</pre>
<p>Drop the policy with the following:</p>
<pre dir="ltr">
exec ctx_ddl.drop_policy(policy_name =&gt; 'my_policy');
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997746"></a>
<div id="CCREF0624" class="refsect1">
<h2 class="refsect1">CREATE_PREFERENCE <a id="sthref1406"></a><a id="sthref1407"></a><a id="sthref1408"></a><a id="sthref1409"></a></h2>
<p>Creates a preference in the Text data dictionary. Specify preferences in the parameter string of <a href="csql.htm#i997677">CREATE INDEX</a> or <a href="csql.htm#CIHBFDCE">ALTER INDEX</a>.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<code dir="ltr">CTX_DDL.CREATE_PREFERENCE</code> does not respect the current schema as set by <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">current_schema</code>. Therefore, if you need to create or delete a preference owned by another user, then you must explicitly state this, and you must have the <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1410"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.CREATE_PREFERENCE(preference_name  in varchar2, 
                          object_name      in varchar2); 
</pre>
<dl>
<dt>preference_name</dt>
<dd>
<p>Specify the name of the preference to be created.</p>
</dd>
<dt>object_name</dt>
<dd>
<p>Specify the name of the preference type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For a complete list of preference types and their associated attributes, see <a href="cdatadic.htm#BHCDHIAI">Chapter 2, "Oracle Text Indexing Elements"</a></div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1411"></a>Examples</p>
<p class="subhead1"><a id="CCREF23883"></a>Creating Text-only Index</p>
<p>The<a id="sthref1412"></a> following example creates a lexer preference that specifies a text-only index. It does so by creating a <code dir="ltr">BASIC_LEXER</code> preference called <code dir="ltr">my_lexer</code> with <code dir="ltr">CTX_DDL.CREATE_PREFERENCE</code>. It then calls CTX_DDL.<a href="#i998425">SET_ATTRIBUTE</a> twice, first specifying YES for the <code dir="ltr">INDEX_TEXT</code> attribute, then specifying NO for the <code dir="ltr">INDEX_THEMES</code> attribute.</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('my_lexer', 'BASIC_LEXER');
ctx_ddl.set_attribute('my_lexer', 'INDEX_TEXT', 'YES');
ctx_ddl.set_attribute('my_lexer', 'INDEX_THEMES', 'NO');
end;
</pre>
<p class="subhead1"><a id="CCREF23884"></a>Specifying File Data Storage<a id="sthref1413"></a><a id="sthref1414"></a></p>
<p>The following example creates a data storage preference called <code dir="ltr">mypref</code> that tells the system that the files to be indexed are stored in the operating system. The example then uses CTX_DDL.<a href="#i998425">SET_ATTRIBUTE</a> to set the <code dir="ltr">PATH</code> attribute of to the directory <code dir="ltr">/docs</code>.</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('mypref', 'FILE_DATASTORE');
ctx_ddl.set_attribute('mypref', 'PATH', '/docs'); 
end;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about data storage, see <a href="cdatadic.htm#i1006307">"Datastore Types"</a></div>
<p class="subhead1"><a id="CCREF23885"></a>Creating Master/Detail Relationship<a id="sthref1415"></a></p>
<p>Use CTX_DDL.<a href="#i997746">CREATE_PREFERENCE</a> to create a preference with <code dir="ltr">DETAIL_DATASTORE</code>. Use CTX_DDL.<a href="#i998425">SET_ATTRIBUTE</a> to set the attributes for this preference. The following example shows how this is done:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('my_detail_pref', 'DETAIL_DATASTORE');
ctx_ddl.set_attribute('my_detail_pref', 'binary', 'true');
ctx_ddl.set_attribute('my_detail_pref', 'detail_table', 'my_detail');
ctx_ddl.set_attribute('my_detail_pref', 'detail_key', 'article_id');
ctx_ddl.set_attribute('my_detail_pref', 'detail_lineno', 'seq');
ctx_ddl.set_attribute('my_detail_pref', 'detail_text', 'text');
end;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about master/detail, see <a href="cdatadic.htm#i1006478">"DETAIL_DATASTORE"</a></div>
<p class="subhead1"><a id="CCREF23886"></a>Specifying Storage Attributes<a id="sthref1416"></a></p>
<p>The following examples specify that the index tables are to be created in the <code dir="ltr">foo</code> tablespace with an initial extent of 1K:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('mystore', 'BASIC_STORAGE');
ctx_ddl.set_attribute('mystore', 'I_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'K_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'R_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'S_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'N_TABLE_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
ctx_ddl.set_attribute('mystore', 'I_INDEX_CLAUSE',
                        'tablespace foo storage (initial 1K)'); 
end;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cdatadic.htm#i1009245">Storage Types</a></div>
<p class="subhead1"><a id="CCREF23887"></a>Creating Preferences with No Attributes</p>
<p>When you create preferences with types that have no attributes, you need only create the preference, as in the following example which sets the filter to the <code dir="ltr">NULL_FILTER</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('my_null_filter', 'NULL_FILTER');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1417"></a>Notes</p>
<p>If <code dir="ltr">s_table_clause</code> is specified for a storage preference in an index without <code dir="ltr">SDATA</code>, then it has no effect on the index, and the index creation will still succeed.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1418"></a>Related Topics</p>
<p><a href="#i998425">"SET_ATTRIBUTE"</a></p>
<p><a href="#i998137">"DROP_PREFERENCE"</a></p>
<p><a href="csql.htm#i997677">"CREATE INDEX"</a></p>
<p><a href="csql.htm#CIHBFDCE">"ALTER INDEX"</a></p>
<p><a href="cdatadic.htm#BHCDHIAI">Chapter 2, "Oracle Text Indexing Elements"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997893"></a>
<div id="CCREF0626" class="refsect1">
<h2 class="refsect1">CREATE_SECTION_GROUP <a id="sthref1419"></a><a id="sthref1420"></a><a id="sthref1421"></a></h2>
<p>Creates a section group for defining sections in a text column.</p>
<p>When you create a section group, you can add to it zone, field, or special sections with <a href="#i997526">ADD_ZONE_SECTION</a>, <a href="#i999153">ADD_FIELD_SECTION</a>, <a href="#BJFFGAAA">ADD_MDATA_SECTION</a>, or <a href="#i997153">ADD_SPECIAL_SECTION</a>.</p>
<p>When you index, name the section group in the parameter string of <a href="csql.htm#i997677">CREATE INDEX</a> or <a href="csql.htm#CIHBFDCE">ALTER INDEX</a>.</p>
<p>After indexing, query within your defined sections with the <a href="cqoper.htm#i998525">WITHIN</a> operator.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1422"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.CREATE_SECTION_GROUP(
  group_name     in    varchar2,
  group_type     in    varchar2
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Specify the section group name to create as <code dir="ltr">[user.]section_group_name</code>. This parameter must be unique within an owner.</p>
</dd>
<dt>group_type</dt>
<dd>
<p>Specify section group type. <a id="sthref1423"></a>The <span class="syntaxinline">group_type</span> parameter can be one of:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="group_type parameter" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t17">Section Group Preference</th>
<th class="cellalignment97" id="r1c2-t17">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t17" headers="r1c1-t17"><code dir="ltr"><a id="sthref1424"></a>NULL_SECTION_GROUP</code></td>
<td class="cellalignment98" headers="r2c1-t17 r1c2-t17">Use this group type when you define no sections or when you define <span class="italic">only</span> SENTENCE or PARAGRAPH sections. This is the default.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t17" headers="r1c1-t17"><code dir="ltr"><a id="sthref1425"></a>BASIC_SECTION_GROUP</code></td>
<td class="cellalignment98" headers="r3c1-t17 r1c2-t17">Use this group type for defining sections where the start and end tags are of the form <code dir="ltr">&lt;A&gt;</code> and <code dir="ltr">&lt;/A&gt;</code>.
<p>Note: This group type dopes not support input such as unbalanced parentheses, comments tags, and attributes. Use <code dir="ltr">HTML_SECTION_GROUP</code> for this type of input.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t17" headers="r1c1-t17"><code dir="ltr"><a id="sthref1426"></a><a id="sthref1427"></a>HTML_SECTION_GROUP</code></td>
<td class="cellalignment98" headers="r4c1-t17 r1c2-t17">Use this group type for indexing HTML documents and for defining sections in HTML documents.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t17" headers="r1c1-t17"><code dir="ltr"><a id="sthref1428"></a>XML_SECTION_GROUP</code></td>
<td class="cellalignment98" headers="r5c1-t17 r1c2-t17">Use this group type for indexing XML documents and for defining sections in XML documents.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t17" headers="r1c1-t17"><code dir="ltr"><a id="sthref1429"></a><a id="sthref1430"></a>AUTO_SECTION_GROUP</code></td>
<td class="cellalignment98" headers="r6c1-t17 r1c2-t17">Use this group type to automatically create a zone section for each start-tag/end-tag pair in an XML document. The section names derived from XML tags are case sensitive as in XML.
<p>Attribute sections are created automatically for XML tags that have attributes. Attribute sections are named in the form attribute@tag.</p>
<p>Stop sections, empty tags, processing instructions, and comments are not indexed.</p>
<p>The following limitations apply to automatic section groups:</p>
<ul>
<li>
<p>You cannot add zone, field, or special sections to an automatic section group.</p>
</li>
<li>
<p>Automatic sectioning does not index XML document types (root elements.) However, you can define stop sections with document type.</p>
</li>
<li>
<p>The length of the indexed tags, including prefix and namespace, cannot exceed 64 bytes. Tags longer than this are not indexed.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t17" headers="r1c1-t17"><code dir="ltr"><a id="sthref1431"></a>PATH_SECTION_GROUP</code></td>
<td class="cellalignment98" headers="r7c1-t17 r1c2-t17">Use this group type to index XML documents. Behaves like the <code dir="ltr">AUTO_SECTION_GROUP</code>.
<p>The difference is that with this section group you can do path searching with the <code dir="ltr">INPATH</code> and <code dir="ltr">HASPATH</code> operators. Queries are also case-sensitive for tag and attribute names.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t17" headers="r1c1-t17"><code dir="ltr"><a id="sthref1432"></a>NEWS_SECTION_GROUP</code></td>
<td class="cellalignment98" headers="r8c1-t17 r1c2-t17">Use this group for defining sections in newsgroup formatted documents according to RFC 1036.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1433"></a>Example</p>
<p>The following command creates a section group called <code dir="ltr">htmgroup</code> with the HTML group type.</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.create_section_group('htmgroup', 'HTML_SECTION_GROUP');
</pre>
<pre dir="ltr">
end;
</pre>
<p>The following command creates a section group called <code dir="ltr">auto</code> with the <code dir="ltr">AUTO_SECTION_GROUP</code> group type to be used to automatically index tags in XML documents.</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.create_section_group('auto', 'AUTO_SECTION_GROUP');
</pre>
<pre dir="ltr">
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1434"></a>Related Topics</p>
<p><a href="cqoper.htm#i998525">"WITHIN"</a></p>
<p><a href="cdatadic.htm#i1009342">"Section Group Types"</a></p>
<p><a href="#i997526">"ADD_ZONE_SECTION"</a></p>
<p><a href="#i999153">"ADD_FIELD_SECTION"</a></p>
<p><a href="#BJFFGAAA">"ADD_MDATA_SECTION"</a></p>
<p><a href="#i997153">"ADD_SPECIAL_SECTION"</a></p>
<p><a href="#i998299">"REMOVE_SECTION"</a></p>
<p><a href="#i998158">"DROP_SECTION_GROUP"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CEGCJHAF"></a>
<div id="CCREF2106" class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">CREATE_SHADOW_INDEX</h2>
<p>Creates index metadata (or policy) for the specified index. If the index is not partitioned, then it also creates the index tables. This procedure is only supported in Enterprise Edition of Oracle Database.</p>
<p>The following changes are not supported:</p>
<ul>
<li>
<p>Transition from non-composite domain index to composite, or changing the composite domain index columns.</p>
</li>
<li>
<p>Rebuild indexes that have partitioned index tables, for example, $I, $P, $K.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For a partitioned index, you must first call this procedure to create the shadow index metadata. This procedure will not create index tables. It has no effect on query, DML, sync, or optimize operations.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1435"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.CREATE_SHADOW_INDEX(
  idx_name          IN VARCHAR2,
  parameter_string  IN VARCHAR2 DEFAULT NULL,
  parallel_degree   IN NUMBER, DEFAULT 1
);
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>The name of a valid <code dir="ltr">CONTEXT</code> indextype.</p>
</dd>
<dt>parameter_string</dt>
<dd>
<p>For non-partitioned index, the same string as in <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code>. For partitioned index, the same string as in <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code> <code dir="ltr">PARAMETER</code>.</p>
</dd>
<dt>parallel_degree</dt>
<dd>
<p>Reserved for future use. Specify the degree of parallelism. Parallel operation is not currently supported.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1436"></a>Example</p>
<div id="CCREF23888" class="example">
<p class="titleinexample"><a id="sthref1437"></a>Example 7-1 Scheduled Global Index Recreate (Incremental Rebuild)</p>
<p>In this example, you have the finest control over each stage of <a href="#CEGJDGDD">RECREATE_INDEX_ONLINE</a>. Since <code dir="ltr">SYNC_INDEX</code> can take a time limit, you can limit <code dir="ltr">SYNC_INDEX</code> during non-business hours and incrementally recreate the index.</p>
<pre dir="ltr">
/* create lexer and original index */
exec ctx_ddl.create_preference('us_lexer','basic_lexer');
create index idx on tbl(text) indextype is ctxsys.context
  parameters('lexer us_lexer');
 
/* create a new lexer */
begin
  ctx_ddl.create_preference('e_lexer','basic_lexer');
  ctx_ddl.set_attribute('e_lexer','base_letter','yes');
  ctx_ddl.create_preference('m_lexer','multi_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','default','us_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','e','e_lexer');
end;
/
 
/* add new language column to the table for multi-lexer */
alter table tbl add(lang varchar2(10) default 'us');
 
/* create shadow index */
exec ctx_ddl.create_shadow_index('idx',
  'replace lexer m_lexer language column lang NOPOPULATE');
 
declare
  idxid integer;
begin
  /* figure out shadow index name */
  select idx_id into idxid from ctx_user_indexes
     where idx_name ='IDX';
  /* populate pending */
  ctx_ddl.populate_pending('RIO$'||idxid);
  /* time limited sync */
  ctx_ddl.sync_index(idx_name =&gt;'RIO$'||idxid,
                     maxtime =&gt;480);
  /* more sync until no pending rows for the shadow index */
end;
/* swap in the shadow index */
exec ctx_ddl.exchange_shadow_index('idx');
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1438"></a>Notes</p>
<p>The index name for the shadow index is <code dir="ltr">RIO$index_id</code>. By default it will also populate index tables for non-partitioned indexes, unless <code dir="ltr">NOPOPULATE</code> is specified in <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> or in <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code>. For a local partitioned index, it will only create index metadata without creating the index tables for each partition. Each index can have only one shadow index.</p>
<p>When building a non-partitioned index online, you can first call this procedure to create index metadata and index tables. If you specify <code dir="ltr">POPULATE</code>, then this procedure will populate the index, but will not do swapping. You can schedule the swapping at a later, preferred time.</p>
<p>If you specify <code dir="ltr">NOPOPULATE</code>, it will only create metadata for the index tables, but will not populate them. You must perform <code dir="ltr">POPULATE_PENDING</code> (CTX_DDL.<a href="#CHDJHEJB">POPULATE_PENDING</a>) to populate the pending queues after running this procedure, and then sync the indexes. This is referred to as <span class="italic">incremental</span> <span class="italic">recreate</span>.</p>
<p>Queries are all processed normally when this procedure is running.</p>
<p>If <code dir="ltr">POPULATE</code> is specified, then DML is blocked for a very short time at the beginning of populate, after which all further DML is logged into an online pending queue and processed later.</p>
<p>Sync with CTX_DDL.<a href="#i998469">SYNC_INDEX</a> runs normally on the index. <a href="#i998200">OPTIMIZE_INDEX</a> runs without doing anything, but does not return an error.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1439"></a>Related Topics</p>
<p>See also <code dir="ltr">POPULATE</code> | <code dir="ltr">NOPOPULATE</code> in <a href="csql.htm#CIHBFDCE">ALTER INDEX</a> and <a href="csql.htm#i997677">CREATE INDEX</a> in <a href="csql.htm#i996741">Chapter 1, "Oracle Text SQL Statements and Operators"</a>, and CTX_DDL.<a href="#CHDGAEFB">DROP_SHADOW_INDEX</a>, CTX_DDL.<a href="#CHDJAGBJ">EXCHANGE_SHADOW_INDEX</a>, CTX_DDL.<a href="#i998469">SYNC_INDEX</a>, and CTX_DDL.<a href="#CHDJHEJB">POPULATE_PENDING</a> in this chapter.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998026"></a>
<div id="CCREF0628" class="refsect1">
<h2 class="refsect1">CREATE_STOPLIST <a id="sthref1440"></a><a id="sthref1441"></a><a id="sthref1442"></a></h2>
<p>Use this procedure to create a new, empty stoplist. Stoplists can contain words or themes that are not to be indexed.</p>
<p>You can also create multi-language stoplists to hold language-specific stopwords. A multi-language stoplist is useful when you index a table that contains documents in different languages, such as English, German, and Japanese. When you do so, the text table must contain a language column.</p>
<p>Add either stopwords, stopclasses, or stopthemes to a stoplist using <a href="#i997383">ADD_STOPWORD</a>, <a href="#i997253">ADD_STOPCLASS</a>, or <a href="#i997338">ADD_STOPTHEME</a>. Specify a stoplist in the parameter string of <a href="csql.htm#i997677">CREATE INDEX</a> or <a href="csql.htm#CIHBFDCE">ALTER INDEX</a> to override the default stoplist <a href="cdatadic.htm#i1009790">CTXSYS.DEFAULT_STOPLIST</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1443"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.CREATE_STOPLIST(
</pre>
<pre dir="ltr">
stoplist_name IN VARCHAR2,
stoplist_type IN VARCHAR2 DEFAULT 'BASIC_STOPLIST');
</pre>
<dl>
<dt>stoplist_name</dt>
<dd>
<p>Specify the name of the stoplist to be created.</p>
</dd>
<dt>stoplist_type<a id="sthref1444"></a><a id="sthref1445"></a></dt>
<dd>
<p>Specify <code dir="ltr">BASIC_STOPLIST</code> to create a stoplist for a single language. This is the default.</p>
<p>Specify <code dir="ltr">MULTI_STOPLIST</code> to create a stoplist with language-specific stopwords.</p>
<p>At indexing time, the language column of each document is examined, and only the stopwords for that language are eliminated. At query time, the session language setting determines the active stopwords, like it determines the active lexer when using the multi-lexer.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When indexing a multi-language table with a multi-language stoplist, the table must have a language column.</div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1446"></a>Examples</p>
<div id="CCREF23889" class="example">
<p class="titleinexample"><a id="sthref1447"></a>Example 7-2 Single Language Stoplist</p>
<p>The following example creates a stoplist called <code dir="ltr">mystop</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.create_stoplist('mystop', 'BASIC_STOPLIST');
end;
</pre></div>
<!-- class="example" -->
<div id="CCREF23890" class="example">
<p class="titleinexample"><a id="sthref1448"></a>Example 7-3 Multi-Language Stoplist</p>
<p>The following example creates a multi-language stoplist called <code dir="ltr">multistop</code> and then adds tow language-specific stopwords:</p>
<pre dir="ltr">
begin
ctx_ddl.create_stoplist('multistop', 'MULTI_STOPLIST');
ctx_ddl.add_stopword('mystop', 'Die','german');
ctx_ddl.add_stopword('mystop', 'Or','english');
end;
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1449"></a>Related Topics</p>
<p><a href="#i997383">"ADD_STOPWORD"</a></p>
<p><a href="#i997253">"ADD_STOPCLASS"</a></p>
<p><a href="#i997338">"ADD_STOPTHEME"</a></p>
<p><a href="#i998178">"DROP_STOPLIST"</a></p>
<p><a href="csql.htm#i997677">"CREATE INDEX"</a></p>
<p><a href="csql.htm#CIHBFDCE">"ALTER INDEX"</a></p>
<p><a href="astopsup.htm#CEGBGCDF">Appendix E, "Oracle Text Supplied Stoplists"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998118"></a>
<div id="CCREF0630" class="refsect1">
<h2 class="refsect1">DROP_INDEX_SET</h2>
<p>Drops a <code dir="ltr">CTXCAT</code> index set created with CTX_DDL.<a href="#i997653">CREATE_INDEX_SET</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1450"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.DROP_INDEX_SET(
     set_name    IN VARCHAR2
);
</pre>
<dl>
<dt>set_name</dt>
<dd>
<p>Specify the name of the index set to drop.</p>
<p>Dropping an index set drops all of the sub-indexes it contains.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998128"></a>
<div id="CCREF2107" class="refsect1">
<h2 class="refsect1">DROP_POLICY<a id="sthref1451"></a><a id="sthref1452"></a></h2>
<p>Drops a policy created with CTX_DDL.<a href="#i997662">CREATE_POLICY</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1453"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.DROP_POLICY(
     policy_name    IN VARCHAR2
);
</pre>
<dl>
<dt>policy_name</dt>
<dd>
<p>Specify the name of the policy to drop.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998137"></a>
<div id="CCREF0632" class="refsect1">
<h2 class="refsect1">DROP_PREFERENCE <a id="sthref1454"></a><a id="sthref1455"></a><a id="sthref1456"></a></h2>
<p>The <code dir="ltr">DROP_PREFERENCE</code> procedure deletes the specified preference from the Text data dictionary. Dropping a preference does not affect indexes that have already been created using that preference.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1457"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.DROP_PREFERENCE(
     preference_name    IN VARCHAR2
);
</pre>
<dl>
<dt>preference_name</dt>
<dd>
<p>Specify the name of the preference to be dropped.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1458"></a>Example</p>
<p>The following example drops the preference <code dir="ltr">my_lexer</code>.</p>
<pre dir="ltr">
begin
ctx_ddl.drop_preference('my_lexer');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1459"></a>Related Topics</p>
<p>See also CTX_DDL.<a href="#i997746">CREATE_PREFERENCE</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998158"></a>
<div id="CCREF0634" class="refsect1">
<h2 class="refsect1">DROP_SECTION_GROUP</h2>
<p>The <code dir="ltr">DROP_SECTION_GROUP</code> procedure deletes the specified section group, as well as all the sections in the group, from the Text data dictionary.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1460"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.DROP_SECTION_GROUP(
     group_name     IN VARCHAR2
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Specify the name of the section group to delete.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1461"></a>Example</p>
<p>The following example drops the section group <code dir="ltr">htmgroup</code> and all its sections:</p>
<pre dir="ltr">
begin
ctx_ddl.drop_section_group('htmgroup');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1462"></a>Related Topics</p>
<p>See also CTX_DDL.<a href="#i997893">CREATE_SECTION_GROUP</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CHDGAEFB"></a>
<div id="CCREF2108" class="refsect1">
<h2 class="refsect1">DROP_SHADOW_INDEX</h2>
<p>Drops a shadow index for the specified index. When you drop a shadow index, if it is partitioned, then its metadata and the metadata of all this shadow index's partitions are dropped. This procedure also drops all the shadow index tables and cleans up any online pending queue.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1463"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.DROP_SHADOW_INDEX(
     idx_name       in VARCHAR2
);
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>The name of a valid <code dir="ltr">CONTEXT</code> indextype.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1464"></a>Example</p>
<p>The following example drops the shadow index <code dir="ltr">myshadowidx</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.drop_shadow_index('myshadowidx');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1465"></a>Related Topics</p>
<p>See also CTX_DDL.<a href="#CEGCJHAF">CREATE_SHADOW_INDEX</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998178"></a>
<div id="CCREF0636" class="refsect1">
<h2 class="refsect1">DROP_STOPLIST <a id="sthref1466"></a><a id="sthref1467"></a><a id="sthref1468"></a></h2>
<p>Drops a stoplist from the Text data dictionary. When you drop a stoplist, you must re-create or rebuild the index for the change to take effect.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1469"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.DROP_STOPLIST(stoplist_name in varchar2);
</pre>
<dl>
<dt>stoplist_name</dt>
<dd>
<p>Specify the name of the stoplist.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1470"></a>Example</p>
<p>The following example drops the stoplist <code dir="ltr">mystop</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.drop_stoplist('mystop');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1471"></a>Related Topics</p>
<p>See also CTX_DDL.<a href="#i998026">CREATE_STOPLIST</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CHDJAGBJ"></a>
<div id="CCREF2109" class="refsect1">
<h2 class="refsect1">EXCHANGE_SHADOW_INDEX</h2>
<p>This procedure swaps the index (or index partition) metadata and index (or index partition) data.</p>
<p>For non-partitioned indexes, this procedure swaps both the metadata and the index data, and processes the online pending queue.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1472"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.EXCHANGE_SHADOW_INDEX(
     idx_name        IN VARCHAR2
     partition_name  IN VARCHAR2 default NULL
);
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>Specify the name of the <code dir="ltr">CONTEXT</code> indextype.</p>
</dd>
</dl>
<dl>
<dt>partition_name</dt>
<dd>
<p>Specify the name of the shadow index partition. May also be NULL.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1473"></a>Example</p>
<div id="CCREF23891" class="example">
<p class="titleinexample"><a id="sthref1474"></a>Example 7-4 Global Index Recreate with Scheduled Swap</p>
<p>This example demonstrates running <code dir="ltr">CTX_DDL.EXCHANGE_SHADOW_INDEX</code> during non-business hours when query failures and DML blocking can be tolerated.</p>
<pre dir="ltr">
/* create lexer and original index */
exec ctx_ddl.create_preference('us_lexer','basic_lexer');
create index idx on tbl(text) indextype is ctxsys.context
  parameters('lexer us_lexer');
 
/* create a new lexer */
begin
  ctx_ddl.create_preference('e_lexer','basic_lexer');
  ctx_ddl.set_attribute('e_lexer','base_letter','yes');
  ctx_ddl.create_preference('m_lexer','multi_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','default','us_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','e','e_lexer');
end;
/
 
/* add new language column to the table for multi-lexer */
alter table tbl add(lang varchar2(10) default 'us');
 
/* recreate index online with the new multip-lexer */
exec ctx_ddl.create_shadow_index('idx',
  'replace lexer m_lexer language column lang');
exec ctx_ddl.exchange_shadow_index('idx');
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1475"></a>Notes</p>
<p class="subhead2"><a id="CCREF23892"></a>Using EXCHANGE_SHADOW_INDEX with Non-partitioned Indexes</p>
<p>For non-partitioned indexes, this procedure will swap both metadata and index data, and will process the online pending queue.</p>
<p>Queries will return <span class="italic">column not indexed</span> errors when swapping metadata and index data, but queries are processed normally when processing online pending queue. The period of errors being raised should be short.</p>
<p>If you specify <code dir="ltr">POPULATE</code> when you create the shadow index, and if many DML operations have been issued since the creation of the shadow index, then there could be a large pending queue. However, if you use <span class="italic">incremental recreate</span>, that is, specify <code dir="ltr">NOPOPULATE</code> when you create the shadow index, and you then populate the pending queue and sync, then the online pending queue is always empty no matter how many DML operations have occurred since <code dir="ltr">CREATE_SHADOW_INDEX</code> was issued.</p>
<p>When this procedure is running, DML will first fail with an error about index being in in-progress status. After that DML could be blocked (hang) if there are rows in online pending queue that need to be reapplied.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When this procedure is running, DML statements will fail with an error that the index is in "in-progress status." If, when this error occurs, there are rows in the online pending queue that need to be reapplied, then the DML could be blocked and hang.</div>
<p class="subhead2"><a id="CCREF23893"></a>Using EXCHANGE_SHADOW_INDEX with Partitioned Indexes</p>
<p>For partitions that are recreated with <code dir="ltr">NOSWAP</code>: when the index is partitioned, and if <span class="italic">partition_name</span> is a valid index partition, then this procedure will swap the index partition data and the index partition metadata, and will process the online pending queue for this partition.</p>
<p>This procedure swaps only one partition at a time. When you run this procedure on partitions that are recreated with <code dir="ltr">NOSWAP</code>:</p>
<ul>
<li>
<p>Queries that span multiple partitions will not return consistent results across all partitions.</p>
</li>
<li>
<p>Queries on the partition that is being swapped will return errors.</p>
</li>
<li>
<p>Queries on partitions that are already swapped will be based on the new index.</p>
</li>
<li>
<p>Queries on the partitions that haven't been swapped will be based on the old index.</p>
</li>
</ul>
<p>If the <span class="italic">partition_name</span> is NULL, then this procedure will swap the index metadata. Run this procedure as the last step when recreating a local partitioned index online.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1476"></a>Related Topics</p>
<p>See also CTX_DDL.<a href="#CEGJDGDD">RECREATE_INDEX_ONLINE</a>, CTX_DDL.<a href="#CEGCJHAF">CREATE_SHADOW_INDEX</a>, and CTX_DDL.<a href="#CHDGAEFB">DROP_SHADOW_INDEX</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998200"></a>
<div id="CCREF0638" class="refsect1">
<h2 class="refsect1"><a id="sthref1477"></a><a id="sthref1478"></a><a id="sthref1479"></a><a id="sthref1480"></a>OPTIMIZE_INDEX</h2>
<p>Use this procedure to optimize the index. Optimize your index after you synchronize it. Optimizing an index removes old data and minimizes index fragmentation, which can improve query response time. Querying and DML may proceed while optimization takes place.</p>
<p>You can optimize in fast, full, rebuild, token, or token-type mode.</p>
<ul>
<li>
<p>Fast mode compacts data but does not remove rows.</p>
</li>
<li>
<p>Full mode compacts data and removes rows.</p>
</li>
<li>
<p>Optimize in rebuild mode rebuilds the <code dir="ltr">$I</code> table (the inverted list table) in its entirety. Rebuilding an index is often significantly faster than performing a full optimization, and is more likely to result in smaller indexes, especially if the index is heavily fragmented.</p>
<p>Rebuild optimization creates a more compact copy of the <code dir="ltr">$I</code> table, and then switches the original <code dir="ltr">$I</code> table and the copy. The rebuild operation will therefore require enough space to store the copy as well as the original. (If redo logging is enabled, then additional space is required in the redo log as well.) At the end of the rebuild operation, the original <code dir="ltr">$I</code> table is dropped, and the space can be reused.</p>
<p>Optimize in rebuild mode supports partitioning on the <code dir="ltr">$I</code> table via the <code dir="ltr">i_table_clause</code> attribute of the <code dir="ltr">basic_storage</code> preference with the following limitations:</p>
<ul>
<li>
<p>The <code dir="ltr">i_index_clause</code> must specify using a local btree index if the <code dir="ltr">$I</code> table is partitioned.</p>
</li>
<li>
<p>Partitioning schemes on the <code dir="ltr">token_first</code>, <code dir="ltr">token_last</code>, or <code dir="ltr">token_count</code> columns are not allowed.</p>
</li>
</ul>
</li>
<li>
<p>In token mode, specify a specific token to be optimized (for example, all rows with documents containing the word <span class="italic">elections</span>). Use this mode to optimize index tokens that are frequently searched, without spending time on optimizing tokens that are rarely referenced. An optimized token can improve query response time (but only for queries on that token).</p>
</li>
<li>
<p>Token-type optimization is similar to token mode, except that the optimization is performed on field sections or <code dir="ltr">MDATA</code> sections (for example, sections with an <code dir="ltr">&lt;A&gt;</code> tag). This is useful in keeping critical field or <code dir="ltr">MDATA</code> sections optimal.</p>
</li>
</ul>
<p>A common strategy for optimizing indexes is to perform regular token optimizations on frequently referenced terms, and to perform rebuild optimizations less frequently. (Use CTX_REPORT.<a href="crptpkg.htm#i997315">QUERY_LOG_SUMMARY</a> to find out which queries are made most frequently.) You can perform full, fast, or token-type optimizations instead of token optimizations.</p>
<p>Some users choose to perform frequent time-limited full optimizations along with occasional rebuild optimizations.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Optimizing an index can result in better response time only if you insert, delete, or update documents in the base table after your initial indexing operation.</div>
<p>Using this procedure to optimize the index is recommended over using the <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code> statement.</p>
<p>Optimization of a large index may take a long time. To monitor the progress of a lengthy optimization, log the optimization with CTX_OUTPUT.<a href="coutpkg.htm#i996832">START_LOG</a> and check the resultant logfile from time to time.</p>
<p>Note that, unlike serial optimize full, <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX()</code> run with <code dir="ltr">optlevel</code> of <code dir="ltr">FULL</code> and <code dir="ltr">parallel_degree</code> &gt; 1 is not resumable. That is, it will not resume from where it left after a time-out or failure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is a very small window of time when a query might fail in <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> <code dir="ltr">REBUILD</code> mode when the <code dir="ltr">$I</code> table is being swapped with the optimized shadow <code dir="ltr">$I</code> table.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1481"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.OPTIMIZE_INDEX( 
</pre>
<pre dir="ltr">
idx_name        IN  VARCHAR2, 
optlevel        IN  VARCHAR2, 
maxtime         IN  NUMBER DEFAULT NULL, 
token           IN VARCHAR2 DEFAULT NULL,
part_name       IN VARCHAR2 DEFAULT NULL,
token_type      IN NUMBER DEFAULT NULL,
parallel_degree IN NUMBER DEFAULT 1); 
</pre>
<pre dir="ltr">
); 
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>Specify the name of the index. If you do not specify an index name, then Oracle Text chooses a single index to optimize.</p>
</dd>
<dt>optlevel</dt>
<dd>
<p>Specify optimization level as a string. You can specify one of the following methods for optimization:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="optlevel parameter values" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t23">optlevel value</th>
<th class="cellalignment97" id="r1c2-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t23" headers="r1c1-t23"><code dir="ltr">FAST</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_FAST</code></td>
<td class="cellalignment98" headers="r2c1-t23 r1c2-t23">This method compacts fragmented rows. However, old data is not removed.
<p><code dir="ltr">FAST</code> optimization is not supported for <code dir="ltr">CTXCAT</code> indexes. <code dir="ltr">FAST</code> optimization will not optimize <code dir="ltr">$S</code> index table.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t23" headers="r1c1-t23"><code dir="ltr">FULL</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_FULL</code></td>
<td class="cellalignment98" headers="r3c1-t23 r1c2-t23">In this mode you can optimize the entire index or a portion of the index. This method compacts rows and removes old data (deleted rows). Optimizing in full mode runs even when there are no deleted rows.
<p>Full optimization is not supported for <code dir="ltr">CTXCAT</code> indexes.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t23" headers="r1c1-t23"><code dir="ltr">REBUILD</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_REBUILD</code></td>
<td class="cellalignment98" headers="r4c1-t23 r1c2-t23">This <code dir="ltr">optlevel</code> rebuilds the <code dir="ltr">$I</code> table (the inverted list table) to produce more compact token info rows. Like <code dir="ltr">FULL</code> optimize, this mode also deletes information pertaining to deleted rows of the base table.
<p><code dir="ltr">REBUILD</code> is not supported for <code dir="ltr">CTCAT</code>, <code dir="ltr">CTXRULE</code>, or <code dir="ltr">CTXXPATH</code> indexes.</p>
<p><code dir="ltr">REBUILD</code> is not supported when the <code dir="ltr">$I</code> table is partitioned.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t23" headers="r1c1-t23"><code dir="ltr">TOKEN</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_TOKEN</code></td>
<td class="cellalignment98" headers="r5c1-t23 r1c2-t23">This method lets you specify a specific token to be optimized. Oracle Text does a full optimization on the token you specify with <span class="syntaxinline">token</span>. If no token type is provided, 0 (zero) will be used as the default.
<p>Use this method to optimize those tokens that are searched frequently.</p>
<p>Token optimization is not supported for <code dir="ltr">CTXCAT</code>, <code dir="ltr">CTXRULE</code>, and <code dir="ltr">CTXXPATH</code> indexes.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t23" headers="r1c1-t23"><code dir="ltr">TOKEN_TYPE</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_TOKEN_TYPE</code></td>
<td class="cellalignment98" headers="r6c1-t23 r1c2-t23">This optlevel optimizes on demand all tokens in the index matching the input token type.
<p>When <code dir="ltr">optlevel</code> is <code dir="ltr">TOKEN_TYPE</code>, <span class="variable">token_type</span> must be provided.<code dir="ltr">TOKEN_TYPE</code> performs <code dir="ltr">FULL</code> optimize on any token of the input <span class="variable">token_type</span>. Like a <code dir="ltr">TOKEN</code> optimize, <code dir="ltr">TOKEN_TYPE</code> optimize does not change the <code dir="ltr">FULL</code> optimize state, and runs to completion on each invocation.</p>
<p>Token_type optimization is not supported for <code dir="ltr">CTXCAT</code>, <code dir="ltr">CTXRULE</code>, and <code dir="ltr">CTXXPATH</code> indexes.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>The behavior of <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> with respect to the $S index table is as follows:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="optlevel parameter values" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t24">optlevel value</th>
<th class="cellalignment97" id="r1c2-t24">Will Optimize $S Index Table Yes/No</th>
<th class="cellalignment97" id="r1c3-t24">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t24" headers="r1c1-t24"><code dir="ltr">FAST</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_FAST</code></td>
<td class="cellalignment98" headers="r2c1-t24 r1c2-t24">No</td>
<td class="cellalignment98" headers="r2c1-t24 r1c3-t24">&nbsp;</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t24" headers="r1c1-t24"><code dir="ltr">FULL</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_FULL</code></td>
<td class="cellalignment98" headers="r3c1-t24 r1c2-t24">Yes</td>
<td class="cellalignment98" headers="r3c1-t24 r1c3-t24">
<ul>
<li>The optimize process will optimize $I table first. Once $I table optimize is finished, <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> will continue on to optimize $S index table.</li>
<li>
<p><code dir="ltr">MAXTIME</code> will also be honored. Once <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> completes optimizing $S rows for a given <code dir="ltr">SDATA_ID</code>, it will check <code dir="ltr">MAXTIME</code> and exit if total elapsed time (including time taken to optimize $I) exceeds specified <code dir="ltr">MAXTIME</code>. The next <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> with <code dir="ltr">optlevel=&gt;'FULL'</code> will pick up where it left off.</p>
</li>
<li>
<p>$S table optimize will be done in serial.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t24" headers="r1c1-t24"><code dir="ltr">REBUILD</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_REBUILD</code></td>
<td class="cellalignment98" headers="r4c1-t24 r1c2-t24">Yes</td>
<td class="cellalignment98" headers="r4c1-t24 r1c3-t24">
<ul>
<li>$S optimize will start after $I rebuild finishes.</li>
<li>
<p>$S optimize in this case will be processed the same way as $S optimize in <code dir="ltr">FULL</code> mode. $S table is optimized in place, not rebuilt.</p>
<p><span class="bold">Note:</span> If for some reason $S optimize exits abnormally, then it is recommended that you use <code dir="ltr">optlevel=&gt;TOKEN_TYPE</code> to optimize $S to avoid rebuilding the $I table again.</p>
</li>
<li>
<p>$S table optimize will be done in serial.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t24" headers="r1c1-t24"><code dir="ltr">TOKEN</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_TOKEN</code></td>
<td class="cellalignment98" headers="r5c1-t24 r1c2-t24">No</td>
<td class="cellalignment98" headers="r5c1-t24 r1c3-t24">&nbsp;</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t24" headers="r1c1-t24"><code dir="ltr">TOKEN_TYPE</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_TOKEN_TYPE</code></td>
<td class="cellalignment98" headers="r6c1-t24 r1c2-t24">Yes</td>
<td class="cellalignment98" headers="r6c1-t24 r1c3-t24">You can optimize $S rows for a given <code dir="ltr">SDATA_ID</code> by setting <code dir="ltr">optlevel =&gt; TOKEN_TYPE</code> and the <code dir="ltr">TOKEN_TYPE</code> parameter to the target <code dir="ltr">SDATA_ID</code>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></dd>
<dt>maxtime</dt>
<dd>
<p>Specify maximum optimization time, in minutes, for <code dir="ltr">FULL</code> optimize.</p>
<p>When you specify the symbol <code dir="ltr">CTX_DDL</code>.<code dir="ltr">MAXTIME_UNLIMITED</code> (or pass in NULL), the entire index is optimized. This is the default.</p>
</dd>
<dt>token</dt>
<dd>
<p>Specify the token to be optimized.</p>
</dd>
<dt>part_name</dt>
<dd>
<p>If your index is a local index, then you must specify the name of the index partition to synchronize otherwise an error is returned.</p>
<p>If your index is a global, non-partitioned index, then specify NULL, which is the default.</p>
</dd>
<dt>token_type</dt>
<dd>
<p>Specify the <code dir="ltr">token_type</code> to be optimized.</p>
</dd>
<dt>parallel_degree</dt>
<dd>
<p>Specify the parallel degree as a number for parallel optimization. The actual parallel degree depends on your resources. Note that when using <code dir="ltr">REBUILD</code>, setting <code dir="ltr">parallel_degree</code> to a value greater than 1 still results in serial execution.</p>
<p>Because the following <code dir="ltr">optlevel</code> values are executed serially, this setting is ignored for them:</p>
<ul>
<li>
<p><code dir="ltr">TOKEN</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_TOKEN</code></p>
</li>
<li>
<p><code dir="ltr">FAST</code> or <code dir="ltr">CTX_DDL.OPTLEVEL_FAST</code></p>
</li>
</ul>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1482"></a>Examples</p>
<p>The following two examples are equivalent ways of optimizing an index using fast optimization:</p>
<pre dir="ltr">
begin 
  ctx_ddl.optimize_index('myidx','FAST'); 
end;

begin
  ctx_ddl.optimize_index('myidx',CTX_DDL.OPTLEVEL_FAST);
end;
</pre>
<p>The following example optimizes the index token <span class="italic">Oracle</span>:</p>
<pre dir="ltr">
begin
  ctx_ddl.optimize_index('myidx','token', TOKEN=&gt;'Oracle');
end;
</pre>
<p>To optimize all tokens of field section <code dir="ltr">MYSEC</code> in index <code dir="ltr">MYINDEX</code>:</p>
<pre dir="ltr">
begin
  ctx_ddl.optimize_index('myindex', ctx_ddl.optlevel_token_type,
     token_type=&gt; ctx_report.token_type('myindex','field mysec text'));end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1483"></a>Notes</p>
<p>You can run <code dir="ltr">CTX_DDL.SYNC_INDEX</code> and <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> at the same time. You can also run <code dir="ltr">CTX_DDL.SYNC_INDEX</code> and <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> with parallelism at the same time. However, you should not:</p>
<ul>
<li>
<p>Run <code dir="ltr">CTX_DDL.SYNC_INDEX</code> with parallelism at the same time as <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code></p>
</li>
<li>
<p>Run <code dir="ltr">CTX_DDL.SYNC_INDEX</code> with parallelism at the same time as <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> with parallelism.</p>
</li>
</ul>
<p>If you should run one of these combinations, no error is generated; however, one operation will wait until the other is done.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="i998270"></a>Related Topics</p>
<p>See also CTX_DDL.<a href="#i998469">SYNC_INDEX</a> and <a href="csql.htm#CIHBFDCE">ALTER INDEX</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CHDJHEJB"></a>
<div id="CCREF2110" class="refsect1">
<h2 class="refsect1">POPULATE_PENDING</h2>
<p>This procedure populates the pending queue with every rowid in the base table or table partition. This procedure is only supported for <code dir="ltr">CONTEXT</code> indexes.</p>
<p>This procedure is valuable for large installations that cannot afford to have the indexing process run continuously, and, therefore, need finer control over creating text indexes. The preferred method is to create an empty index, place all the rowids into the pending queue, and build the index through CTX_DDL.<a href="#i998469">SYNC_INDEX</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1484"></a>Syntax</p>
<pre dir="ltr">
ctx_ddl.populate_pending(
  idx_name  IN VARCHAR2,
  part_name IN VARCHAR2 DEFAULT NULL
);
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>Name of the <code dir="ltr">CONTEXT</code> indextype.</p>
</dd>
<dt>part_name</dt>
<dd>
<p>Name of the index partition, if any. Must be provided for local partitioned indexes and must be NULL for global, non-partitioned indexes.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1485"></a>Notes</p>
<p>The <code dir="ltr">SYNC_INDEX</code> is blocked for the duration of the processing. The index unit must be totally empty (<code dir="ltr">idx_docid_count</code> = 0, <code dir="ltr">idx_nextid</code> = 1). The rowids of rows waiting to be indexed are inserted into table <code dir="ltr">ctxsys.dr$pending</code>. You should ensure that there is sufficient space in this table to hold the rowids of the base table.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1486"></a>Related Topics</p>
<p>See also <a href="#i998469">SYNC_INDEX</a>, <a href="#CEGCJHAF">CREATE_SHADOW_INDEX</a>, <a href="#CHDGAEFB">DROP_SHADOW_INDEX</a>, <a href="#CHDJAGBJ">EXCHANGE_SHADOW_INDEX</a>, <a href="#CEGJDGDD">RECREATE_INDEX_ONLINE</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CEGJDGDD"></a>
<div id="CCREF2111" class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">RECREATE_INDEX_ONLINE</h2>
<p>Recreates the specified index, or recreates the passed-in index partition if the index is local partitioned. For global non-partitioned indexes, this is a one-step procedure. For local partitioned indexes, this procedure must be run separately on every partition after first using <a href="#CEGCJHAF">CREATE_SHADOW_INDEX</a> to create a shadow policy (or metadata). This procedure is only supported in Enterprise Edition of Oracle Database.</p>
<p>The following changes are not supported:</p>
<ul>
<li>
<p>Transitioning from non-composite domain index to composite, or changing the composite domain index columns.</p>
</li>
<li>
<p>Rebuilding indexes that have partitioned index tables, for example, <code dir="ltr">$I</code>, <code dir="ltr">$P</code>, <code dir="ltr">$K</code>.</p>
</li>
</ul>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1487"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.RECREATE_INDEX_ONLINE(
   idx_name          IN VARCHAR2,
   parameter_string  IN VARCHAR2 default NULL,
   parallel_degree   IN NUMBER default 1,
   partition_name    IN VARCHAR2 default NULL
);
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>The name of a valid <code dir="ltr">CONTEXT</code> indextype.</p>
</dd>
<dt>parameter_string</dt>
<dd>
<p>If the index is a global non-partitioned index, specify the same index-level parameter string as in <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code>. Must start with <code dir="ltr">REPLACE</code>, if it is not <code dir="ltr">NULL</code>. Optionally specify <code dir="ltr">SWAP</code> or <code dir="ltr">NOSWAP</code>. The default is <code dir="ltr">SWAP</code>.</p>
</dd>
<dt>parallel_degree</dt>
<dd>
<p>Reserved for future use. Specify the degree of parallelism. Parallel operation is not supported in the current release.</p>
</dd>
<dt>partition_name</dt>
<dd>
<p>Specify the name of a valid index partition for a local partitioned index. Otherwise, the default is <code dir="ltr">NULL</code>. If the index is partitioned, then first pass a partition name, and then specify the partition-level parameter string for <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code> <code dir="ltr">REBUILD</code> <code dir="ltr">PARTITION</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1488"></a>Examples</p>
<div id="CCREF23894" class="example">
<p class="titleinexample"><a id="sthref1489"></a>Example 7-5 Recreate Simple Global Index</p>
<p>The following example creates an index <code dir="ltr">idx</code> with a <code dir="ltr">BASIC_LEXER</code>-based preference <code dir="ltr">us_lexer</code>. It then recreates the index with a new <code dir="ltr">MULTI_LEXER</code> based preference <code dir="ltr">m_lexer</code> in one step. You can use this one step approach when you do not mind that a query might fail for a small window of time at the end of the operation, and DML might get blocked at the beginning for a short time and again at the end.</p>
<pre dir="ltr">
/* create lexer and original index */
exec ctx_ddl.create_preference('us_lexer','basic_lexer');
create index idx on tbl(text) indextype is ctxsys.context
  parameters('lexer us_lexer');
 
/* create a new lexer */
begin
  ctx_ddl.create_preference('e_lexer','basic_lexer');
  ctx_ddl.set_attribute('e_lexer','base_letter','yes');
  ctx_ddl.create_preference('m_lexer','multi_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','default','us_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','e','e_lexer');
end;
/
 
/* add new language column to the table for multi-lexer */
alter table tbl add(lang varchar2(10) default 'us');
 
/* recreate index online with the new multip-lexer */
exec ctx_ddl.recreate_index_online('idx',
  'replace lexer m_lexer language column lang');
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" -->
<div id="CCREF23895" class="example">
<p class="titleinexample"><a id="CHDJEFFH"></a>Example 7-6 Local Index Recreate with All-At-Once Swap</p>
<p>The following example creates a local partitioned index <code dir="ltr">idxp</code> with a basic lexer <code dir="ltr">us_lexer</code>. It has two index partitions <code dir="ltr">idx_p1</code> and <code dir="ltr">idx_p2</code>. It then recreates a local partitioned index <code dir="ltr">idxp</code> online with partition <code dir="ltr">idx_p1</code>, which will have a new storage preference <code dir="ltr">new_store</code>. The swapping of the partition metadata and index partition data occur at the end. In this example, queries spanning multiple partitions return consistent results across partitions when recreate is in process, except at the end when <a href="#CHDJAGBJ">EXCHANGE_SHADOW_INDEX</a> is running. The extra space required is the combined index size of partition <code dir="ltr">idx_p1</code> and <code dir="ltr">idx_p2</code>.</p>
<pre dir="ltr">
/* create a basic lexer and a local partition index with the lexer*/
exec ctx_ddl.create_preference('us_lexer','basic_lexer');
create index idxp on tblp(text) indextype is ctxsys.context local
  (partition idx_p1,
   partition idx_p2)
 parameters('lexer us_lexer');
 
/* create new preferences  */
begin
  ctx_ddl.create_preference('my_store','basic_storage');
  ctx_ddl.set_attribute('my_store','i_table_clause','tablespace tbs');
end;
/
begin
  ctx_ddl.create_preference('e_lexer','basic_lexer');
  ctx_ddl.set_attribute('e_lexer','base_letter','yes');
  ctx_ddl.create_preference('m_lexer','multi_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','default','us_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','e','e_lexer');
end;
/
 
/* add new language column */
alter table tblp add column (lang varchar2(10) default 'us');
 
/* create a shadow policy with a new lexer */
exec ctx_ddl.create_shadow_index('idxp', null,
  'replace lexer m_lexer language column lang');
 
/* recreate every index partition online without swapping */
exec ctx_ddl.recreate_index_online('idxp',
   'replace storage my_store NOSWAP', 1, 'idx_p1');
exec ctx_ddl.recreate_index_online('idxp','replace NOSWAP',1,'idx_p2');
 
/* exchange in shadow index partition all at once */
exec ctx_ddl.exchange_shadow_index('idxp',
      'idx_p1') /* exchange index partition data*/
exec ctx_ddl.exchange_shadow_index('idxp',
      'idx_p2') /* exchange index partition data*/
 
/* exchange in shadow index metadata */
exec ctx_ddl.exchange_shadow_index('idxp')
</pre></div>
<!-- class="example" -->
<div id="CCREF23896" class="example">
<p class="titleinexample"><a id="sthref1490"></a>Example 7-7 Local Index Recreate with Per-Partition Swap</p>
<p>This example performs the same tasks as <a href="#CHDJEFFH">Example 7-6, "Local Index Recreate with All-At-Once Swap"</a>, except that each index partition is swapped in as it is completed. Queries across all partitions may return inconsistent results in this example.</p>
<pre dir="ltr">
/* create a basic lexer and a local partition index with the lexer*/
exec ctx_ddl.create_preference('us_lexer','basic_lexer');
create index idxp on tblp(text) indextype is ctxsys.context local
  (partition idx_p1,
   partition idx_p2)
 parameters('lexer us_lexer');
 
/* create new preferences  */
begin
  ctx_ddl.create_preference('my_store','basic_storage');
  ctx_ddl.set_attribute('my_store','i_table_clause','tablespace tbs');
end;
/
begin
  ctx_ddl.create_preference('e_lexer','basic_lexer');
  ctx_ddl.set_attribute('e_lexer','base_letter','yes');
  ctx_ddl.create_preference('m_lexer','multi_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','default','us_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','e','e_lexer');
end;
/
 
/* add new language column */
alter table tblp add column (lang varchar2(10) default 'us');
 
/* create a shadow policy with a new lexer *
exec ctx_ddl.create_shadow_index('idxp',
  'replace lexer m_lexer language column lang');
 
/* recreate every index partition online and swap (default) */
exec ctx_ddl.recreate_index_online('idxp',
       'replace storage my_store', 1, 'idx_p1');
exec ctx_ddl.recreate_index_online('idxp', 'replace SWAP', 1, 'idx_p2',
   
    /* exchange in shadow index metadata */
exec ctx_ddl.exchange_shadow_index('idxp') 
</pre></div>
<!-- class="example" -->
<div id="CCREF23897" class="example">
<p class="titleinexample"><a id="CHDDIJFH"></a>Example 7-8 Scheduled Local Index Recreate with All-At-Once Swap</p>
<p>This example shows the incremental recreation of a local partitioned index, where partitions are all swapped at the end.</p>
<pre dir="ltr">
/* create a basic lexer and a local partition index with the lexer*/
exec ctx_ddl.create_preference('us_lexer','basic_lexer');
create index idxp on tblp(text) indextype is ctxsys.context local
  (partition idx_p1,
   partition idx_p2)
 parameters('lexer us_lexer');
 
/* create new preferences  */
begin
  ctx_ddl.create_preference('my_store','basic_storage');
  ctx_ddl.set_attribute('my_store','i_table_clause','tablespace tbs');
end;
/
begin
  ctx_ddl.create_preference('e_lexer','basic_lexer');
  ctx_ddl.set_attribute('e_lexer','base_letter','yes');
  ctx_ddl.create_preference('m_lexer','multi_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','default','us_lexer');
  ctx_ddl.add_sub_lexer('m_lexer','e','e_lexer');
end;
/
 
/* add new language column */
alter table tblp add column (lang varchar2(10) default 'us');
 
/* create a shadow policy with a new lexer *
exec ctx_ddl.create_shadow_index('idxp',
  'replace lexer m_lexer language column lang');
/* create shadow partition with new storage preference */
exec ctx_ddl.recreate_index_online('idxp', 'replace storage ctxsys.default_storage nopopulate',1,'idx_p1');
exec ctx_ddl.recreate_index_online('idxp', 'replace storage ctxsys.default_storage nopopulate',1,'idx_p2');
 
declare
  idxid integer;
  ixpid integer;
begin
  select idx_id into idxid from ctx_user_indexes
    where idx_name = 'IDXP';
  select ixp_id into ixpid from ctx_user_index_partitions
    where ixp_index_name = 'IDXP'
          and ixp_index_partition_name = 'IDX_P1';
  /* populate pending */
  ctx_ddl.populate_pending('RIO$'||idxid, 'RIO$'||idxid||'#'||ixpid);
  /* incremental sync
  ctx_ddl.sync_index('RIO$'||idxid, null, 'RIO$'||idxid||'#'||ixpid,
                      maxtime=&gt;400);
  /* more incremental sync until no more pending rows */
 
  select ixp_id into ixpid from ctx_user_index_partitions
    where ixp_index_name = 'IDXP'
          and ixp_index_partition_name = 'IDX_P2';
  /* populate pending */
  ctx_ddl.populate_pending('RIO$'||idxid, 'RIO$'||idxid||'#'||ixpid);
  /* incremental sync
  ctx_ddl.sync_index('RIO$'||idxid, null, 'RIO$'||idxid||'#'||ixpid,
                      maxtime=&gt;400);
  /* more incremental sync until no more pending rows */
end;
/
  
exec ctx_ddl.exchange_shadow_index('idxp','idx_p1');
exec ctx_ddl.exchange_shadow_index('idxp','idx_p2');
exec ctx_ddl.exchange_shadow_index('idxp');
</pre></div>
<!-- class="example" -->
<div id="CCREF23898" class="example">
<p class="titleinexample"><a id="sthref1491"></a>Example 7-9 Schedule Local Index Recreate with Per-Partition Swap</p>
<p>For incremental recreate where partitions are swapped as they becomes available, follow the steps in example <a href="#CHDDIJFH">Example 7-8, "Scheduled Local Index Recreate with All-At-Once Swap"</a>, except instead of waiting until all syncs are finished before starting exchange shadow index, <a href="#CHDJAGBJ">EXCHANGE_SHADOW_INDEX</a> is done for each partition right after sync is finished.</p>
</div>
<!-- class="example" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1492"></a>Notes</p>
<p class="subhead2"><a id="CCREF23899"></a>Using RECREATE_INDEX_ONLINE with Global Non-partitioned Indexes</p>
<p>For global indexes, this procedure provides a one-step process to recreate an index online. It recreates an index, with new preference values, while preserving base table DML and query capability during the recreate process.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the new index is created alongside the existing index, this operation requires additional storage roughly equal to the size of the existing index.</div>
<dl>
<dt>DML Behavior</dt>
<dd>
<p>Because this procedure is performed online, DML on the base table are permitted during this operation, and are processed as normal. All DML statements that occur during <code dir="ltr">RECREATE_INDEX_ONLINE</code> are logged into an online pending queue.</p>
<p>Towards the end of the recreate operation, there will be a short duration when DML will fail with an error being raised stating that the index is in an in-progress status. DML may hang again during the process, and the duration will depend on how many DML are logged in the online pending queue since the start of the recreate process.</p>
<p>Note that after the recreate index operation is complete, new information, from all the DML that becomes pending since <code dir="ltr">RECREATE_INDEX_ONLINE</code> started, may not be immediately reflected. As with creating an index with <code dir="ltr">INDEXTYPE</code> <code dir="ltr">IS</code> <code dir="ltr">ctxsys.context</code> <code dir="ltr">ONLINE</code>, the index should be synchronized after the recreate index operation is complete, to bring it fully up-to-date.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>CTX_DDL.<a href="#CEGCJHAF">CREATE_SHADOW_INDEX</a> and CTX_DDL.<a href="#CHDJAGBJ">EXCHANGE_SHADOW_INDEX</a> for information about how to manually go through each stage of recreation, and to schedule each step to run at a preferred time</p>
</li>
<li>
<p>The <code dir="ltr">ONLINE</code> parameter under <a href="csql.htm#i997737">"Syntax for CONTEXT Index Type"</a></p>
</li>
</ul>
</div>
</dd>
<dt>Sync and Optimize Behavior</dt>
<dd>
<p>Syncs issued against the index during the recreate operation are processed against the old, existing data. Syncs are also blocked during the same window when queries return errors. Optimize commands issued against the index during the recreate operation return immediately without error and without processing.</p>
</dd>
<dt>Query Behavior</dt>
<dd>
<p>During the recreate operation, the index can be queried normally most of the time. Queries return results based on the existing index and policy (or metadata) until after the final swap.</p>
<p>There is a short interval towards the end of <code dir="ltr">RECREATE_INDEX_ONLINE</code> when queries will return an error indicating that the column is not indexed. This duration should be short for regular queries. It is mainly the time taken for swapping data segments of the shadow index tables and the index tables, plus the time to delete all the rows in the pending queue. This is the same window of time when DML will fail.</p>
<p>During <code dir="ltr">RECREATE_INDEX_ONLINE</code>, if you issue DML statements and synchronize them, then you will be able to see the new rows when you query on the existing index. However, after <code dir="ltr">RECREATE_INDEX_ONLINE</code> finishes (swapping completes and query is on the new index) and before sync is performed, it is possible that you will not be able to query on the new rows, which once could be queried on the old index.</p>
</dd>
</dl>
<div class="infobox-note">
<p class="notep1">Note:</p>
Transactional queries are not supported.</div>
<p class="subhead2"><a id="CCREF23900"></a>Using RECREATE_INDEX_ONLINE with Local Partitioned Indexes</p>
<p>If the index is local partitioned, you cannot recreate index in one step. You must first create a shadow policy, and then run this procedure for every partition. You can specify <code dir="ltr">SWAP</code> or <code dir="ltr">NOSWAP</code> to indicate whether <code dir="ltr">RECREATE_INDEX_ONLINE</code> partition will swap the index partition data and index partition metadata or not. If the partition was built with <code dir="ltr">NOSWAP</code>, then another call to <code dir="ltr">EXCHANGE_SHADOW_INDEX</code> must be invoked later against this partition.</p>
<p>This procedure can also be used to update the metadata (for example, storage preference) of each partition when you specify <code dir="ltr">NOPOPULATE</code> in the parameter string. This is useful for incremental building of a shadow index through time-limited sync.</p>
<p>If <code dir="ltr">NOPOPULATE</code> is specified, then <code dir="ltr">NOSWAP</code> is silently enforced.</p>
<dl>
<dt>NOSWAP Behavior</dt>
<dd>
<p>During the recreate of the index partition, since no swapping is performed, queries on the partition are processed regularly. Until the swapping stage is reached, queries spanning multiple partitions return consistent results across partitions.</p>
<p>DML and sync are processed normally. Running optimize on partitions that are being recreated, or that have been built (but not swapped), simply returns without doing anything. Running optimize on a partition that has not been rebuilt processes normally.</p>
<p>As with a global index, when all of the partitions use <code dir="ltr">NOSWAP</code>, the additional storage requirement is roughly equal to the size of the existing index.</p>
</dd>
<dt>SWAP Behavior</dt>
<dd>
<p>Because index partition data and metadata are swapped after index recreate, queries that span multiple partitions will not return consistent results from partition to partition, but will always be correct with respect to each index partition. There is also a short interval towards the end of partition recreate, when the index partition is swapped, during which a query will return a "column not indexed" error.</p>
<p>When partitions are recreated with <code dir="ltr">SWAP</code>, the additional storage requirement for the operation is equal to the size of the existing index partition.</p>
<p>DML on the partition is blocked. Sync is also blocked during swapping.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1493"></a>Related Topics</p>
<p>See also <a href="#CEGCJHAF">CREATE_SHADOW_INDEX</a> and <a href="#CHDGAEFB">DROP_SHADOW_INDEX</a>, and <a href="#CHDJAGBJ">EXCHANGE_SHADOW_INDEX</a>, as well as <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998279"></a>
<div id="CCREF0640" class="refsect1">
<h2 class="refsect1">REMOVE_INDEX</h2>
<p>Removes the index with the specified column list from a <code dir="ltr">CTXCAT</code> index set preference.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This procedure does not remove a <code dir="ltr">CTXCAT</code> sub-index from the existing index. To do so, you must drop your index and re-index with the modified index set preference.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1494"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.REMOVE_INDEX(
</pre>
<pre dir="ltr">
    set_name       IN VARCHAR2,
     column_list    IN VARCHAR2
     language       IN VARCHAR2 default NULL
);
</pre>
<dl>
<dt>set_name</dt>
<dd>
<p>Specify the name of the index set.</p>
</dd>
<dt>column_list</dt>
<dd>
<p>Specify the name of the column list to remove.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="BJFGGBCJ"></a>
<div id="CCREF2112" class="refsect1">
<h2 class="refsect1">REMOVE_MDATA<a id="sthref1495"></a><a id="sthref1496"></a><a id="sthref1497"></a><a id="sthref1498"></a><a id="sthref1499"></a></h2>
<p>Use this procedure to remove metadata values, which are associated with an <code dir="ltr">MDATA</code> section, from a document. Only the owner of the index is allowed to call <a href="#BJFHJFIJ">ADD_MDATA</a> and <code dir="ltr">REMOVE_MDATA</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1500"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.REMOVE_MDATA(
     idx_name           IN VARCHAR2, 
     section_name       IN VARCHAR2, 
     values             SYS.ODCIVARCHAR2LIST,
     rowids             SYS.ODCIRIDLIST,
     [part_name]        IN VARCHAR2]
);
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>Name of the text index that contains the named <span class="variable">rowids</span>.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Name of the <code dir="ltr">MDATA</code> section.</p>
</dd>
<dt>values</dt>
<dd>
<p>List of metadata values. If a metadata value contains a comma, the comma must be escaped with a backslash.</p>
</dd>
<dt>rowids</dt>
<dd>
<p><code dir="ltr">Rowids</code> from which to remove the metadata values.</p>
</dd>
<dt>[part_name]</dt>
<dd>
<p>Name of the index partition, if any. Must be provided for local partitioned indexes and must be NULL for global, non-partitioned indexes.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1501"></a>Example</p>
<p>This example removes the <code dir="ltr">MDATA</code> value <span class="italic">blue</span> from the <code dir="ltr">MDATA</code> section <code dir="ltr">BGCOLOR</code>.</p>
<pre dir="ltr">
ctx_ddl.remove_mdata('idx_docs', 'bgcolor', 'blue', 'rows'); 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1502"></a>Related Topics</p>
<p>See also <a href="#BJFHJFIJ">"ADD_MDATA"</a>; <a href="#BJFFGAAA">"ADD_MDATA_SECTION"</a>; <a href="cqoper.htm#BGBCFHDB">"MDATA"</a>; as well as the Section Searching chapter of <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1503"></a>Notes</p>
<p>These updates are updates directly on the index itself, not on the actual contents stored in the base table. Therefore, they will not survive when the Text index is rebuilt.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998299"></a>
<div id="CCREF0642" class="refsect1">
<h2 class="refsect1">REMOVE_SECTION <a id="sthref1504"></a><a id="sthref1505"></a><a id="sthref1506"></a></h2>
<p>The <code dir="ltr">REMOVE_SECTION</code> procedure removes the specified section from the specified section group. You can specify the section by name or ID. View section ID with the <code dir="ltr">CTX_USER_SECTIONS</code> view.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1507"></a>Syntax 1</p>
<p>Use the following syntax to remove a section by section name:</p>
<pre dir="ltr">
CTX_DDL.REMOVE_SECTION(
  group_name       in    varchar2, 
  section_name     in    varchar2
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Specify the name of the section group from which to delete <code dir="ltr">section_name</code>.</p>
</dd>
<dt>section_name</dt>
<dd>
<p>Specify the name of the section to delete from <code dir="ltr">group_name</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1508"></a>Syntax 2</p>
<p>Use the following syntax to remove a section by section ID:</p>
<pre dir="ltr">
CTX_DDL.REMOVE_SECTION(
  group_name     in    varchar2,
  section_id     in    number
);
</pre>
<dl>
<dt>group_name</dt>
<dd>
<p>Specify the name of the section group from which to delete <code dir="ltr">section_id</code>.</p>
</dd>
<dt>section_id</dt>
<dd>
<p>Specify the section ID of the section to delete from <code dir="ltr">group_name</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1509"></a>Example</p>
<p>The following example drops a section called <code dir="ltr">Title</code> from the <code dir="ltr">htmgroup</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.remove_section('htmgroup', 'Title');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1510"></a>Related Topics</p>
<p><a href="#i999153">"ADD_FIELD_SECTION"</a></p>
<p><a href="#i997153">"ADD_SPECIAL_SECTION"</a></p>
<p><a href="#i997526">"ADD_ZONE_SECTION"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998343"></a>
<div id="CCREF0644" class="refsect1">
<h2 class="refsect1">REMOVE_STOPCLASS <a id="sthref1511"></a><a id="sthref1512"></a><a id="sthref1513"></a></h2>
<p>Removes a stopclass from a stoplist.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1514"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.REMOVE_STOPCLASS(
  stoplist_name  in   varchar2,
  stopclass      in   varchar2
);
</pre>
<dl>
<dt>stoplist_name</dt>
<dd>
<p>Specify the name of the stoplist.</p>
</dd>
<dt>stopclass</dt>
<dd>
<p>Specify the name of the stopclass to be removed.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1515"></a>Example</p>
<p>The following example removes the stopclass <code dir="ltr">NUMBERS</code> from the stoplist <code dir="ltr">mystop</code>.</p>
<pre dir="ltr">
begin
ctx_ddl.remove_stopclass('mystop', 'NUMBERS');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1516"></a>Related Topics</p>
<p><a href="#i997253">"ADD_STOPCLASS"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998369"></a>
<div id="CCREF0646" class="refsect1">
<h2 class="refsect1">REMOVE_STOPTHEME <a id="sthref1517"></a><a id="sthref1518"></a><a id="sthref1519"></a></h2>
<p>Removes a stoptheme from a stoplist.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1520"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.REMOVE_STOPTHEME(
  stoplist_name   in   varchar2,
  stoptheme       in   varchar2
);
</pre>
<dl>
<dt>stoplist_name</dt>
<dd>
<p>Specify the name of the stoplist.</p>
</dd>
<dt>stoptheme</dt>
<dd>
<p>Specify the stoptheme to be removed from <code dir="ltr">stoplist_name</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1521"></a>Example</p>
<p>The following example removes the stoptheme <span class="italic">banking</span> from the stoplist <code dir="ltr">mystop</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.remove_stoptheme('mystop', 'banking');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1522"></a>Related Topics</p>
<p><a href="#i997338">"ADD_STOPTHEME"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998395"></a>
<div id="CCREF0648" class="refsect1">
<h2 class="refsect1">REMOVE_STOPWORD <a id="sthref1523"></a><a id="sthref1524"></a><a id="sthref1525"></a></h2>
<p>Removes a stopword from a stoplist. To have the removal of a stopword be reflected in the index, you must rebuild your index.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1526"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.REMOVE_STOPWORD(
</pre>
<pre dir="ltr">
stoplist_name  in   varchar2,
stopword       in   varchar2,
language       in   varchar2 default NULL
</pre>
<pre dir="ltr">
);
</pre>
<dl>
<dt>stoplist_name</dt>
<dd>
<p>Specify the name of the stoplist.</p>
</dd>
<dt>stopword</dt>
<dd>
<p>Specify the stopword to be removed from <code dir="ltr">stoplist_name</code>.</p>
</dd>
<dt>language</dt>
<dd>
<p>Specify the language of <code dir="ltr">stopword</code> to remove when the stoplist you specify with <code dir="ltr">stoplist_name</code> is of type <code dir="ltr">MULTI_STOPLIST</code>. You must specify the globalization support name or abbreviation of an Oracle Text-supported language. You can also remove <code dir="ltr">ALL</code> stopwords.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1527"></a>Example</p>
<p>The following example removes a stopword <span class="italic">because</span> from the stoplist <code dir="ltr">mystop</code>:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.remove_stopword('mystop','because');
</pre>
<pre dir="ltr">
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1528"></a>Related Topics</p>
<p><a href="#i997383">"ADD_STOPWORD"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CEGIHFBA"></a>
<div id="CCREF23901" class="refsect1">
<h2 class="refsect1">REMOVE_SUB_LEXER<a id="sthref1529"></a><a id="sthref1530"></a><a id="sthref1531"></a></h2>
<p>Removes a sub-lexer from a multi-lexer preference. You cannot remove the lexer for <code dir="ltr">DEFAULT</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1532"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.REMOVE_SUB_LEXER(
</pre>
<pre dir="ltr">
lexer_name  in   varchar2,
language    in   varchar2 default NULL
</pre>
<pre dir="ltr">
);
</pre>
<dl>
<dt>lexer_name</dt>
<dd>
<p>Specify the name of the multi-lexer preference.</p>
</dd>
<dt>language</dt>
<dd>
<p>Specify the language of the sub-lexer to remove. You must specify the globalization support name or abbreviation of an Oracle Text-supported language.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1533"></a>Example</p>
<p>The following example removes a sub-lexer <span class="italic">german_lexer</span> of language <code dir="ltr">german</code>:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.remove_sub_lexer('german_lexer','german');
</pre>
<pre dir="ltr">
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1534"></a>Related Topics</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CEGHCHIC"></a>
<div id="CCREF2113" class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1"><a id="sthref1535"></a><a id="sthref1536"></a><a id="sthref1537"></a><a id="sthref1538"></a>REPLACE_INDEX_METADATA</h2>
<p>Use this procedure to replace metadata in local domain indexes at the global (index) level.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">ALTER INDEX PARAMETERS</code> command performs the same function as this procedure and can replace more than just metadata. For that reason, using <code dir="ltr">ALTER INDEX PARAMETERS</code> is the preferred method of replacing metadata at the global (index) level and should be used in place of this procedure when possible. For more information, see <a href="csql.htm#BJECABDI">"ALTER INDEX PARAMETERS Syntax"</a>.
<p><code dir="ltr">CTX_REPLACE_INDEX_METADATA</code> may be deprecated in a future release of Oracle Text.</p>
</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1539"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.REPLACE_INDEX_METADATA(idx_name IN VARCHAR2,  
                      parameter_string IN VARCHAR2); 
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>Specify the name of the index whose metadata you want to replace.</p>
</dd>
<dt>parameter_string</dt>
<dd>
<p>Specify the parameter string to be passed to <code dir="ltr">ALTER INDEX</code>. This must begin with '<code dir="ltr">REPLACE METADATA</code>'.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1540"></a>Notes</p>
<p><code dir="ltr">ALTER INDEX REBUILD PARAMETERS ('REPLACE METADATA')</code> does not work for a local partitioned index at the index (global) level; you cannot, for example, use that <code dir="ltr">ALTER INDEX</code> syntax to change a global preference, such as filter or lexer type, without rebuilding the index. Therefore, <code dir="ltr">CTX_DDL.REPLACE_INDEX_METADATA</code> is provided as a method of overcoming this limitation of <code dir="ltr">ALTER INDEX</code>.</p>
<p>Though it is meant as a way to replace metadata for a local partitioned index, <code dir="ltr">CTX_DDL.REPLACE_INDEX_METADATA</code> can be used on a global, non-partitioned index, as well.</p>
<p><code dir="ltr">REPLACE_INDEX_METADATA</code> cannot be used to change the sync type at the partition level; that is, <span class="variable">parameter_string</span> cannot be '<code dir="ltr">REPLACE METADATA SYNC</code>'. For that purpose, use <code dir="ltr">ALTER INDEX REBUILD PARTITION</code> to change the sync type at the partition level.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1541"></a>Related Topics</p>
<p>See also <a href="csql.htm#BJECABDI">"ALTER INDEX PARAMETERS Syntax"</a> and <a href="csql.htm#i996850">"ALTER INDEX REBUILD Syntax"</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998425"></a>
<div id="CCREF0650" class="refsect1">
<h2 class="refsect1">SET_ATTRIBUTE <a id="sthref1542"></a><a id="sthref1543"></a><a id="sthref1544"></a></h2>
<p>Sets a preference attribute. Use this procedure after you have created a preference with CTX_DDL.<a href="#i997746">CREATE_PREFERENCE</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1545"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.SET_ATTRIBUTE(preference_name IN VARCHAR2,  
                      attribute_name  IN VARCHAR2,  
                      attribute_value IN VARCHAR2); 
</pre>
<dl>
<dt>preference_name</dt>
<dd>
<p>Specify the name of the preference.</p>
</dd>
<dt>attribute_name</dt>
<dd>
<p>Specify the name of the attribute.</p>
</dd>
<dt>attribute_value</dt>
<dd>
<p>Specify the attribute value. Specify boolean values as <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code>, <code dir="ltr">T</code> or <code dir="ltr">F</code>, <code dir="ltr">YES</code> or <code dir="ltr">NO</code>, <code dir="ltr">Y</code> or <code dir="ltr">N</code>, <code dir="ltr">ON</code> or <code dir="ltr">OFF</code>, or <code dir="ltr">1</code> or <code dir="ltr">0</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1546"></a>Example</p>
<p class="subhead1"><a id="CCREF23902"></a>Specifying File Data Storage</p>
<p>The following example creates a data storage preference called <code dir="ltr">filepref</code> that tells the system that the files to be indexed are stored in the operating system. The example then uses CTX_DDL.<a href="#i998425">SET_ATTRIBUTE</a> to set the <code dir="ltr">PATH</code> attribute to the directory <code dir="ltr">/docs</code>.</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('filepref', 'FILE_DATASTORE');
ctx_ddl.set_attribute('filepref', 'PATH', '/docs'); 
end;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about data storage, see <a href="cdatadic.htm#i1006307">"Datastore Types"</a>
<p>For more examples of using <code dir="ltr">SET_ATTRIBUTE</code>, see <a href="#i997746">"CREATE_PREFERENCE"</a></p>
</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998469"></a>
<div id="CCREF0652" class="refsect1">
<h2 class="refsect1">SYNC_INDEX<a id="sthref1547"></a><a id="sthref1548"></a></h2>
<p>Synchronizes the index to process inserts, updates, and deletes to the base table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because <code dir="ltr">CTX_DDL.SYNC_INDEX</code> issues implicit commits, calling <code dir="ltr">CTX_DDL.SYNC_INDEX</code> in a trigger is strongly discouraged. Doing so can result in errors being raised, as both <code dir="ltr">SYNC_INDEX</code> and post-commit <code dir="ltr">$R</code> <code dir="ltr">LOB</code> maintenance try to update the same <code dir="ltr">$R</code> <code dir="ltr">LOB</code>.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1549"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.SYNC_INDEX(
</pre>
<pre dir="ltr">
idx_name       IN  VARCHAR2 DEFAULT NULL
memory          IN VARCHAR2 DEFAULT NULL,
part_name       IN VARCHAR2 DEFAULT NULL,
parallel_degree IN NUMBER DEFAULT 1
maxtime         IN NUMBER DEFAULT NULL,
locking         IN NUMBER DEFAULT LOCK_WAIT
); 
</pre>
<dl>
<dt>idx_name</dt>
<dd>
<p>Specify the name of the index to synchronize.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When <code dir="ltr">idx_name</code> is null, all <code dir="ltr">CONTEXT</code>, <code dir="ltr">CTXRULE</code>, and <code dir="ltr">CTXXPATH</code> indexes that have pending changes are synchronized. You must be connected as <code dir="ltr">ctxsys</code> to perform this operation. Each index or index partition is synchronized in sequence, one after the other. Because of this, the individual syncs are performed with locking set to <code dir="ltr">NOWAIT</code> and maxtime set to <code dir="ltr">0</code>. Any values that you specify for locking or maxtime on the <code dir="ltr">SYNC_INDEX</code> call are ignored. However, the <code dir="ltr">memory</code> and <code dir="ltr">parallel_degree</code> parameters are passed on to the individual synchronizations.</div>
</dd>
<dt>memory</dt>
<dd>
<p>Specify the runtime memory to use for synchronization. This value overrides the <code dir="ltr">DEFAULT_INDEX_MEMORY</code> system parameter.</p>
<p><a id="sthref1550"></a>The memory parameter specifies the amount of memory Oracle Text uses for the synchronization operation before flushing the index to disk. Specifying a large amount of memory:</p>
</dd>
</dl>
<ul>
<li>
<p>Improves indexing performance because there is less I/O</p>
</li>
<li>
<p>Improves query performance and maintenance because there is less fragmentation</p>
</li>
<li>
<p>The indexing memory size specified in the second argument applies to each parallel slave. For exmaple, if the <code dir="ltr">memory</code> argument is set to 500M and <code dir="ltr">parallel_degree</code> is set to 2, then ensure that there is at least 1GB of memory available on the system used for the parallel <code dir="ltr">SYNC_INDEX</code>.</p>
</li>
</ul>
<p>Specifying smaller amounts of memory increases disk I/O and index fragmentation, but might be useful when runtime memory is scarce.</p>
<dl>
<dt>part_name</dt>
<dd>
<p>If your index is a local index, then you must specify the name of the index partition to synchronize otherwise an error is returned.</p>
<p>If your index is a global, non-partitioned index, then specify NULL, which is the default.</p>
</dd>
<dt>parallel_degree</dt>
<dd>
<p>Specify the degree to run parallel synchronize. A number greater than 1 turns on parallel synchronize. The actual degree of parallelism might be smaller depending on your resources.</p>
</dd>
<dt>maxtime</dt>
<dd>
<p>Indicate a suggested time limit on the operation, in minutes. <code dir="ltr">SYNC_INDEX</code> will process as many documents in the queue as possible within the time limit. The <code dir="ltr">maxtime</code> value of NULL is equivalent to <code dir="ltr">CTX_DDL.MAXTIME_UNLIMITED</code>. This parameter is ignored when <code dir="ltr">SYNC_INDEX</code> is invoked without an index name, in which case <code dir="ltr">maxtime</code> value of 0 is used instead. The <code dir="ltr">locking</code> parameter is ignored for automatic syncs (that is, <code dir="ltr">SYNC</code> <code dir="ltr">ON</code> <code dir="ltr">COMMIT</code> or <code dir="ltr">SYNC</code> <code dir="ltr">EVERY</code>).</p>
<p>The time limit specified is treated as approximate. The actual time taken may be somewhat less than or greater than what you specify. The "time clock" for <code dir="ltr">maxtime</code> does not start until the SYNC lock is acquired.</p>
</dd>
<dt>locking</dt>
<dd>
<p>Configure how <code dir="ltr">SYNC_INDEX</code> deals with the situation where another sync is already running on the same index or index partition. When locking is ignored because <code dir="ltr">SYNC_INDEX</code> is invoked without an index name, then locking value of <code dir="ltr">LOCK_NOWAIT</code> is used instead. The <code dir="ltr">locking</code> parameter is ignored for automatic syncs (that is, <code dir="ltr">SYNC</code> <code dir="ltr">ON</code> <code dir="ltr">COMMIT</code> or <code dir="ltr">SYNC</code> <code dir="ltr">EVERY</code>).</p>
<p>The options for <code dir="ltr">locking</code> are:</p>
</dd>
</dl>
<div class="inftblinformal">
<table class="cellalignment96" title="Locing options" summary="locking options" dir="ltr">
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r1c1-t33"><code dir="ltr">CTX_DDL.LOCK_WAIT</code></td>
<td class="cellalignment98">If another sync is running, wait until the running sync is complete, then begin sync. (In the event of not being able to get a lock, it will wait forever and ignore the <code dir="ltr">maxtime</code> setting.)</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t33"><code dir="ltr">CTX_DDL.LOCK_NOWAIT</code></td>
<td class="cellalignment98" headers="r2c1-t33">If another sync is running, immediately returns without error.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t33"><code dir="ltr">CTX_DDL.LOCK_NOWAIT_ERROR</code></td>
<td class="cellalignment98" headers="r3c1-t33">If another sync is running, error "DRG-51313: timeout while waiting for DML or optimize lock" is raised.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1551"></a>Example</p>
<p>The following example synchronizes the index <code dir="ltr">myindex</code> with 2 megabytes of memory:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.sync_index('myindex', '2M');
</pre>
<pre dir="ltr">
end;
</pre>
<p>The following example synchronizes the <code dir="ltr">part1</code> index partition with 2 megabytes of memory:</p>
<pre dir="ltr">
begin
</pre>
<pre dir="ltr">
ctx_ddl.sync_index('myindex', '2M', 'part1');
</pre>
<pre dir="ltr">
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1552"></a>Notes</p>
<p>You can run <code dir="ltr">CTX_DDL.SYNC_INDEX</code> and <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> at the same time. You can also run <code dir="ltr">CTX_DDL.SYNC_INDEX</code> and <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> with parallelism at the same time. However, you should not run <code dir="ltr">CTX_DDL.SYNC_INDEX</code> with parallelism at the same time as <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code>, nor <code dir="ltr">CTX_DDL.SYNC_INDEX</code> with parallelism at the same time as <code dir="ltr">CTX_DDL.OPTIMIZE_INDEX</code> with parallelism. If you should run one of these combinations, no error is generated; however, one operation will wait until the other is done.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1553"></a>Related Topics</p>
<p><a href="csql.htm#CIHBFDCE">"ALTER INDEX"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998511"></a>
<div id="CCREF0654" class="refsect1">
<h2 class="refsect1">UNSET_ATTRIBUTE <a id="sthref1554"></a><a id="sthref1555"></a><a id="sthref1556"></a></h2>
<p>Removes a set attribute from a preference.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1557"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.UNSET_ATTRIBUTE(preference_name varchar2,
                        attribute_name  varchar2);
</pre>
<dl>
<dt>preference_name</dt>
<dd>
<p>Specify the name of the preference.</p>
</dd>
<dt>attribute_name</dt>
<dd>
<p>Specify the name of the attribute.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1558"></a>Example</p>
<p class="subhead1"><a id="CCREF23903"></a>Enabling/Disabling Alternate Spelling<a id="sthref1559"></a></p>
<p>The following example shows how you can enable alternate spelling for German and disable alternate spelling with <code dir="ltr">CTX_DDL.UNSET_ATTRIBUTE</code>:</p>
<pre dir="ltr">
begin
ctx_ddl.create_preference('GERMAN_LEX', 'BASIC_LEXER');
ctx_ddl.set_attribute('GERMAN_LEX', 'ALTERNATE_SPELLING', 'GERMAN');
end;
</pre>
<p>To disable alternate spelling, use the <code dir="ltr">CTX_DDL.UNSET_ATTRIBUTE</code> procedure as follows:</p>
<pre dir="ltr">
begin
ctx_ddl.unset_attribute('GERMAN_LEX', 'ALTERNATE_SPELLING');
end;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1560"></a>Related Topics</p>
<p><a href="#i998425">"SET_ATTRIBUTE"</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998543"></a>
<div id="CCREF2114" class="refsect1">
<h2 class="refsect1">UPDATE_POLICY<a id="sthref1561"></a><a id="sthref1562"></a></h2>
<p>Updates a policy created with <code dir="ltr">CREATE_POLICY</code>. Replaces the preferences of the policy. Null arguments are not replaced.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1563"></a>Syntax</p>
<pre dir="ltr">
CTX_DDL.UPDATE_POLICY(
         policy_name     IN VARCHAR2,
         filter          IN VARCHAR2 DEFAULT NULL,
         section_group   IN VARCHAR2 DEFAULT NULL,
         lexer           IN VARCHAR2 DEFAULT NULL,
         stoplist        IN VARCHAR2 DEFAULT NULL,
         wordlist        IN VARCHAR2 DEFAULT NULL);
</pre>
<dl>
<dt>policy_name</dt>
<dd>
<p>Specify the name of the policy to update.</p>
</dd>
<dt>filter</dt>
<dd>
<p>Specify the filter preference to use.</p>
</dd>
<dt>section_group</dt>
<dd>
<p>Specify the section group to use.</p>
</dd>
<dt>lexer</dt>
<dd>
<p>Specify the lexer preference to use.</p>
</dd>
<dt>stoplist</dt>
<dd>
<p>Specify the stoplist to use.</p>
</dd>
<dt>wordlist</dt>
<dd>
<p>Specify the wordlist to use.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" --></div>
<!-- class="refentry" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment89">
<tr>
<td class="cellalignment98">
<table class="cellalignment94">
<tr>
<td class="cellalignment93"><a href="cclspkg.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment93"><a href="cdocpkg.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1998, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment100">
<table class="cellalignment92">
<tr>
<td class="cellalignment93"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment93"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment93"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment93"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment93"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment93"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
