<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Oracle Text CONTAINS Query Operators</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1071" />
<meta name="dcterms.created" content="2015-10-23T12:26:34Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Text Reference" />
<meta name="dcterms.identifier" content="E24436-05" />
<meta name="dcterms.isVersionOf" content="CCREF" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1998, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="cdatadic.htm" title="Previous" type="text/html" />
<link rel="Next" href="cqspcl.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e24436.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/29</span> <!-- End Header -->
<div id="CCREF0300" class="chapter"><a id="CHDEGDDF"></a>
<h1 class="chapter"><span class="secnum">3</span> Oracle Text CONTAINS Query Operators</h1>
<p><a id="CCREF9908"></a><a id="sthref914"></a>This chapter describes operator precedence and provides descriptions, syntax, and examples for every <a href="csql.htm#i997503">CONTAINS</a> operator. The following topics are covered:</p>
<ul>
<li>
<p><a href="#BABBJGFJ">Operator Precedence</a></p>
</li>
<li>
<p><a href="#BABJFFAD">ABOUT</a></p>
</li>
<li>
<p><a href="#i997062">ACCUMulate ( , )</a></p>
</li>
<li>
<p><a href="#i997198">AND (&amp;)</a></p>
</li>
<li>
<p><a href="#i997220">Broader Term (BT, BTG, BTP, BTI)</a></p>
</li>
<li>
<p><a href="#CHDFAIDJ">DEFINEMERGE</a></p>
</li>
<li>
<p><a href="#CHDIHDAC">DEFINESCORE</a></p>
</li>
<li>
<p><a href="#i997305">EQUIValence (=)</a></p>
</li>
<li>
<p><a href="#i997330">Fuzzy</a></p>
</li>
<li>
<p><a href="#i997393">HASPATH</a></p>
</li>
<li>
<p><a href="#i997443">INPATH</a></p>
</li>
<li>
<p><a href="#BGBCFHDB">MDATA</a></p>
</li>
<li>
<p><a href="#i997714">MINUS (-)</a></p>
</li>
<li>
<p><a href="#CHDCGJAE">MNOT</a></p>
</li>
<li>
<p><a href="#BABDCIIC">Narrower Term (NT, NTG, NTP, NTI)</a></p>
</li>
<li>
<p><a href="#CCHDHHBE">NDATA</a></p>
</li>
<li>
<p><a href="#i997808">NEAR (;)</a></p>
</li>
<li>
<p><a href="#i997901">NOT (~)</a></p>
</li>
<li>
<p><a href="#i997930">OR (|)</a></p>
</li>
<li>
<p><a href="#i999023">Preferred Term (PT)</a></p>
</li>
<li>
<p><a href="#i997990">Related Term (RT)</a></p>
</li>
<li>
<p><a href="#CHDCBFHF">SDATA</a></p>
</li>
<li>
<p><a href="#i998027">soundex (!)</a></p>
</li>
<li>
<p><a href="#i998055">stem ($)</a></p>
</li>
<li>
<p><a href="#BABECGDJ">Stored Query Expression (SQE)</a></p>
</li>
<li>
<p><a href="#i998165">SYNonym (SYN)</a></p>
</li>
<li>
<p><a href="#i998207">threshold (&gt;)</a></p>
</li>
<li>
<p><a href="#i998235">Translation Term (TR)</a></p>
</li>
<li>
<p><a href="#i998287">Translation Term Synonym (TRSYN)</a></p>
</li>
<li>
<p><a href="#i998342">Top Term (TT)</a></p>
</li>
<li>
<p><a href="#i998379">weight (*)</a></p>
</li>
<li>
<p><a href="#i998461">wildcards (% _)</a></p>
</li>
<li>
<p><a href="#i998525">WITHIN</a></p>
</li>
</ul>
<a id="BABBJGFJ"></a>
<div id="CCREF2082" class="sect1">
<h2 class="sect1"><span class="secnum">3.1</span> Operator Precedence</h2>
<p><a id="sthref915"></a><a id="sthref916"></a>Operator precedence determines the order in which the components of a query expression are evaluated. Text query operators can be divided into two sets of operators that have their own order of evaluation. These two groups are described later as Group 1 and Group 2.</p>
<p>In all cases, query expressions are evaluated in order from left to right according to the precedence of their operators. Operators with higher precedence are applied first. Operators of equal precedence are applied in order of their appearance in the expression from left to right.</p>
<a id="CHDHIDBJ"></a>
<div id="CCREF2083" class="sect2">
<h3 class="sect2"><span class="secnum">3.1.1</span> Group 1 Operators</h3>
<p>Within query expressions, the Group 1 operators have the following order of evaluation from highest precedence to lowest:</p>
<ol>
<li>
<p><a href="#i997305">EQUIValence (=)</a></p>
</li>
<li>
<p><a href="#i997808">NEAR (;)</a></p>
</li>
<li>
<p><a href="#i998379">weight (*)</a>, <a href="#i998207">threshold (&gt;)</a></p>
</li>
<li>
<p><a href="#i997714">MINUS (-)</a></p>
</li>
<li>
<p><a href="#i997901">NOT (~)</a></p>
</li>
<li>
<p><a href="#CHDCGJAE">MNOT</a></p>
</li>
<li>
<p><a href="#i998525">WITHIN</a></p>
</li>
<li>
<p><a href="#i997198">AND (&amp;)</a></p>
</li>
<li>
<p><a href="#i997930">OR (|)</a></p>
</li>
<li>
<p><a href="#i997062">ACCUMulate ( , )</a></p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<div id="CCREF2084" class="sect2"><a id="sthref917"></a>
<h3 class="sect2"><span class="secnum">3.1.2</span> Group 2 Operators and Characters</h3>
<p>Within query expressions, the Group 2 operators have the following order of evaluation from highest to lowest:</p>
<ol>
<li>
<p>Wildcard Characters</p>
</li>
<li>
<p><a href="#i998055">stem ($)</a></p>
</li>
<li>
<p><a href="#i997330">Fuzzy</a></p>
</li>
<li>
<p><a href="#i998027">soundex (!)</a></p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<div id="CCREF2085" class="sect2"><a id="sthref918"></a>
<h3 class="sect2"><span class="secnum">3.1.3</span> Procedural Operators</h3>
<p>Other operators not listed under Group 1 or Group 2 are procedural. These operators have no sense of precedence attached to them. They include the SQE and thesaurus operators.</p>
</div>
<!-- class="sect2" -->
<div id="CCREF2086" class="sect2"><a id="sthref919"></a>
<h3 class="sect2"><span class="secnum">3.1.4</span> Precedence Examples <a id="sthref920"></a></h3>
<div id="CCREF23815" class="tblformal">
<p class="titleintable"><a id="sthref921"></a><a id="sthref922"></a>Table 3-1 Query Expression Precedence Examples</p>
<table class="cellalignment103" title="Query Expression Precedence Examples" summary="This table shows the order of evaluation of query expressions." dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t2"><span class="bold">Query Expression</span></th>
<th class="cellalignment97" id="r1c2-t2">Order of Evaluation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t2" headers="r1c1-t2">
<p>w1 | w2 &amp; w3</p>
</td>
<td class="cellalignment98" headers="r2c1-t2 r1c2-t2">
<p>(w1) | (w2 &amp; w3)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t2" headers="r1c1-t2">
<p>w1 &amp; w2 | w3</p>
</td>
<td class="cellalignment98" headers="r3c1-t2 r1c2-t2">
<p>(w1 &amp; w2) | w3</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t2" headers="r1c1-t2">
<p>?w1, w2 | w3 &amp; w4</p>
</td>
<td class="cellalignment98" headers="r4c1-t2 r1c2-t2">
<p>(?w1), (w2 | (w3 &amp; w4))</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t2" headers="r1c1-t2">
<p>abc = def ghi &amp; jkl = mno</p>
</td>
<td class="cellalignment98" headers="r5c1-t2 r1c2-t2">
<p>((abc = def) ghi) &amp; (jkl=mno)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t2" headers="r1c1-t2">
<p>dog and cat WITHIN body</p>
</td>
<td class="cellalignment98" headers="r6c1-t2 r1c2-t2">
<p>dog and (cat WITHIN body)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a id="sthref923"></a><a id="sthref924"></a>In the first example, because <code dir="ltr">AND</code> has a higher precedence than <code dir="ltr">OR</code>, the query returns all documents that contain <span class="italic">w1</span> and all documents that contain both <span class="italic">w2</span> and <span class="italic">w3</span>.</p>
<p>In the second example, the query returns all documents that contain both <span class="italic">w1</span> and <span class="italic">w2</span> and all documents that contain <span class="italic">w3</span>.</p>
<p>In the third example, the fuzzy operator is first applied to <span class="italic">w1</span>, then the <code dir="ltr">AND</code> operator is applied to arguments <span class="italic">w3</span> and <span class="italic">w4</span>, then the <code dir="ltr">OR</code> operator is applied to term <span class="italic">w2</span> and the results of the <code dir="ltr">AND</code> operation, and finally, the score from the fuzzy operation on <span class="italic">w1</span> is added to the score from the <code dir="ltr">OR</code> operation.</p>
<p>The fourth example shows that the equivalence operator has higher precedence than the <code dir="ltr">AND</code> operator.</p>
<p>The fifth example shows that the <code dir="ltr">AND</code> operator has lower precedence than the <code dir="ltr">WITHIN</code> operator.</p>
</div>
<!-- class="sect2" -->
<div id="CCREF2087" class="sect2"><a id="sthref925"></a>
<h3 class="sect2"><span class="secnum">3.1.5</span> <a id="sthref926"></a><a id="sthref927"></a><a id="sthref928"></a>Altering Precedence</h3>
<p>Precedence is altered by grouping characters as follows:</p>
<ul>
<li>
<p>Within parentheses, expansion or execution of operations is resolved before other expansions regardless of operator precedence.</p>
</li>
<li>
<p>Within parentheses, precedence of operators is maintained during evaluation of expressions.</p>
</li>
<li>
<p>Within parentheses, expansion operators are not applied to expressions unless the operators are also within the parentheses.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cqspcl.htm#i1006200">"Grouping Characters"</a> in <a href="cqspcl.htm#g1007569">Chapter 4, "Special Characters in Oracle Text Queries"</a></div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<div class="refentry"><a id="BABJFFAD"></a>
<div id="CCREF0301" class="refsect1">
<h2 class="refsect1">ABOUT<a id="sthref929"></a><a id="sthref930"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref931"></a>General Behavior</p>
<p>Use the <code dir="ltr">ABOUT</code> operator to return documents that are related to a query term or phrase. In English and French, <code dir="ltr">ABOUT</code> enables you to query on concepts, even if a concept is not actually part of a query. For example, an <code dir="ltr">ABOUT</code> query on <span class="italic">heat</span> might return documents related to temperature, even though the term <span class="italic">temperature</span> is not part of the query.</p>
<p>In other languages, using <code dir="ltr">ABOUT</code> will often increase the number of returned documents and may improve the sorting order of results. For all languages, Oracle Text scores results for an <code dir="ltr">ABOUT</code> query with the most relevant document receiving the highest score.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref932"></a>English and French Behavior</p>
<p>In English and French, use the <code dir="ltr">ABOUT</code> operator to query on concepts. The system looks up concept information in the theme component of the index. Create a theme component to your index by setting the <code dir="ltr">INDEX_THEMES</code> <a href="cdatadic.htm#i1007615">BASIC_LEXER</a> attribute to <code dir="ltr">YES</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You need not have a theme component in the index to enter <code dir="ltr">ABOUT</code> queries in English and French. However, having a theme component in the index yields the best results for <code dir="ltr">ABOUT</code> queries.</div>
<p>Oracle Text retrieves documents that contain concepts that are related to your query word or phrase. For example, if you enter an <code dir="ltr">ABOUT</code> query on <span class="italic">California</span>, the system might return documents that contain the terms <span class="italic">Los Angeles</span> and <span class="italic">San Francisco</span>, which are cities in California.The document need not contain the term <span class="italic">California</span> to be returned in this <code dir="ltr">ABOUT</code> query.</p>
<p>The word or phrase specified in your <code dir="ltr">ABOUT</code> query need not exactly match the themes stored in the index. Oracle Text normalizes the word or phrase before performing lookup in the index.</p>
<p>You can use the <code dir="ltr">ABOUT</code> operator with the <code dir="ltr">CONTAINS</code> and <code dir="ltr">CATSEARCH</code> SQL operators. In the case of <code dir="ltr">CATSEARCH</code>, you must use query templating with the <code dir="ltr">CONTEXT</code> grammar to query on the indexed themes. See <a href="#i999256">ABOUT Query with CATSEARCH</a> in the Examples section.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref933"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="ABOUT Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t5">Syntax</th>
<th class="cellalignment97" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t5" headers="r1c1-t5">about(<span class="variable">phrase</span>)</td>
<td class="cellalignment98" headers="r2c1-t5 r1c2-t5">In all languages, increases the number of relevant documents returned for the same query without the <code dir="ltr">ABOUT</code> operator.The <span class="italic">phrase</span> parameter can be a single word or a phrase, or a string of words in free text format.
<p>In English and French, returns documents that contain concepts related to <span class="italic">phrase</span>, provided the <code dir="ltr">BASIC_LEXER</code> <code dir="ltr">INDEX_THEMES</code> attribute is set to YES at index time.</p>
<p>The score returned is a relevance score.</p>
<p>Oracle Text ignores any query operators that are included in <span class="italic">phrase</span>.</p>
<p>If your index contains only theme information, an <code dir="ltr">ABOUT</code> operator and operand must be included in your query on the text column or else Oracle Text returns an error.</p>
<p>The <span class="italic">phrase</span> you specify cannot be more than 4000 characters.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref934"></a>Case-Sensitivity<a id="sthref935"></a></p>
<p><code dir="ltr">ABOUT</code> queries give the best results when your query is formulated with proper case. This is because the normalization of your query is based on the knowledge catalog which is case-sensitive.</p>
<p>However, you need not type your query in exact case to obtain results from an <code dir="ltr">ABOUT</code> query. The system does its best to interpret your query. For example, if you enter a query of <span class="italic">CISCO</span> and the system does not find this in the knowledge catalog, the system might use <span class="italic">Cisco</span> as a related concept for look-up.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref936"></a>Improving ABOUT Results</p>
<p>The <code dir="ltr">ABOUT</code> operator uses the supplied knowledge base in English and French to interpret the phrase you enter. Your <code dir="ltr">ABOUT</code> query therefore is limited to knowing and interpreting the concepts in the knowledge base.</p>
<p>Improve the results of your <code dir="ltr">ABOUT</code> queries by adding your application-specific terminology to the knowledge base.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cexec.htm#i1006426">"Extending the Knowledge Base"</a> in <a href="cexec.htm#BABCABHG">Chapter 14, "Oracle Text Utilities"</a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref937"></a>Limitations</p>
<p>The phrase you specify in an <code dir="ltr">ABOUT</code> query cannot be more than 4000 characters.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref938"></a>Examples<a id="sthref939"></a></p>
<p class="subhead1"><a id="CCREF23816"></a>Single Words</p>
<p>To search for documents that are about soccer, use the following syntax:</p>
<pre dir="ltr">
'about(soccer)'
</pre>
<p class="subhead1"><a id="CCREF23817"></a>Phrases</p>
<p>Further refine the query to include documents about soccer rules in international competition by entering the phrase as the query term:</p>
<pre dir="ltr">
'about(soccer rules in international competition)'
</pre>
<p>In this English example, Oracle Text returns all documents that have themes of <span class="variable">soccer</span>, <span class="variable">rules</span>, or <span class="variable">international competition</span>.</p>
<p>In terms of scoring, documents which have all three themes will generally score higher than documents that have only one or two of the themes.</p>
<p class="subhead1"><a id="CCREF23818"></a>Unstructured Phrases</p>
<p>You can also query on unstructured phrases, such as the following:</p>
<pre dir="ltr">
'about(japanese banking investments in indonesia)'
</pre>
<p class="subhead1"><a id="CCREF23819"></a>Combined Queries</p>
<p>Use other operators, such as <code dir="ltr">AND</code> or <code dir="ltr">NOT</code>, to combine <code dir="ltr">ABOUT</code> queries with word queries. For example, enter the following combined <code dir="ltr">ABOUT</code> and word query:</p>
<pre dir="ltr">
'about(dogs) and cat'
</pre>
<p>Combine an <code dir="ltr">ABOUT</code> query with another <code dir="ltr">ABOUT</code> query as follows:</p>
<pre dir="ltr">
'about(dogs) not about(labradors)'
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot combine <code dir="ltr">ABOUT</code> with the <code dir="ltr">WITHIN</code> operator, as for example 'A<span class="italic">BOUT (xyz) WITHIN abc'</span>.</div>
<p class="subhead1"><a id="i999256"></a><a id="CCREF23820"></a>ABOUT Query with CATSEARCH</p>
<p>Enter <code dir="ltr">ABOUT</code> queries with <code dir="ltr">CATSEARCH</code> using the query template method with grammar set to <code dir="ltr">CONTEXT</code> as follows:</p>
<pre dir="ltr">
select pk||' ==&gt; '||text from test
where catsearch(text,
'&lt;query&gt; 
  &lt;textquery grammar="context"&gt;
     about(California)
  &lt;/textquery&gt;
  &lt;score datatype="integer"/&gt;
&lt;/query&gt;','')&gt;0
order by pk; 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997062"></a>
<div id="CCREF0302" class="refsect1">
<h2 class="refsect1">ACCUMulate ( , )<a id="sthref940"></a><a id="sthref941"></a><a id="sthref942"></a><a id="sthref943"></a></h2>
<p>Use the <code dir="ltr">ACCUM</code> operator to search for documents that contain at least one occurrence of any query terms, with the returned documents ranked by a cumulative score based on how many query terms are found (and how frequently).</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref944"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="ACCUM Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t8">Syntax</th>
<th class="cellalignment97" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t8" headers="r1c1-t8"><span class="variable">term1</span>,<span class="variable">term2</span>
<p><span class="variable">term1</span> ACCUM <span class="variable">term2</span></p>
</td>
<td class="cellalignment98" headers="r2c1-t8 r1c2-t8">Returns documents that contain <span class="italic">term1</span> or <span class="italic">term2</span>. Ranks documents according to document term weight, with the highest scores assigned to documents that have the highest total term weight.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref945"></a>ACCUMulate Scoring<a id="sthref946"></a><a id="sthref947"></a></p>
<p>ACCUMulate first scores documents on how many query terms a document matches. A document that matches more terms will always score higher than a document that matches fewer terms, even if the terms appear more frequently in the latter. In other words, if you search for <span class="italic">dog ACCUM cat</span>, you'll find that</p>
<pre dir="ltr">
the dog played with the cat 
</pre>
<p>scores higher than</p>
<pre dir="ltr">
the big dog played with the little dog while a third dog ate the dog food
</pre>
<p>Scores are divided into ranges. In a two-term <code dir="ltr">ACCUM</code>, hits that match both terms will always score between 51 and 100, whereas hits matching only one of the terms will score between 1 and 50. Likewise, for a three-term <code dir="ltr">ACCUM</code>, a hit matching one term will score between 1 and 33; a hit matching two terms will score between 34 and 66, and a hit matching all three terms will score between 67 and 100. <span class="italic">Within these ranges</span>, normal scoring algorithms apply.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ascore.htm#g635054">Appendix F, "The Oracle Text Scoring Algorithm"</a> for more information on how scores are calculated</div>
<p>You can assign different weights to different terms. For example, in a query of the form</p>
<pre dir="ltr">
soccer, Brazil*3
</pre>
<p>the term <span class="italic">Brazil</span> is weighted three times as heavily as <span class="italic">soccer</span>. Therefore, the document</p>
<pre dir="ltr">
people play soccer because soccer is challenging and fun 
</pre>
<p>will score lower than</p>
<pre dir="ltr">
Brazil is the largest nation in South America
</pre>
<p>but both documents will rank below</p>
<pre dir="ltr">
soccer is the national sport of Brazil
</pre>
<p>Note that a query of <span class="italic">soccer ACCUM Brazil*3</span> is equivalent to <span class="italic">soccer ACCUM Brazil ACCUM Brazil ACCUM Brazil</span>. Because each query term <span class="italic">Brazil</span> is considered independent, the entire query is scored as though it has four terms, not two, and thus has four scoring ranges. The first Brazil-and-soccer example document shown above scores in the first range (1-25), the second scores in the third range (51-75), and the third scores in the fourth range (76-100). (No document scores in the second range, because any document with <span class="italic">Brazil</span> in it will be considered to match at least three query terms.)</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref948"></a>Example</p>
<pre dir="ltr">
set serveroutput on;
DROP TABLE accumtbl;
CREATE TABLE accumtbl (id NUMBER, text VARCHAR2(4000) );
 
INSERT INTO accumtbl VALUES ( 1, 'the little dog played with the big dog 
      while the other dog ate the dog food');
INSERT INTO accumtbl values (2, 'the cat played with the dog');
 
CREATE INDEX accumtbl_idx ON accumtbl (text) indextype is ctxsys.context;
  
PROMPT dog ACCUM cat
SELECT SCORE(10) FROM accumtbl WHERE CONTAINS (text, 'dog ACCUM cat', 10)
   &gt; 0;
 
PROMPT dog*3 ACCUM cat
SELECT SCORE(10) FROM accumtbl WHERE CONTAINS (text, 'dog*3 ACCUM cat', 10)
   &gt; 0;
</pre>
<p>This produces the following output. Note that the document with both <span class="italic">dog</span> and <span class="italic">cat</span> scores highest.</p>
<pre dir="ltr">
dog ACCUM cat
   ID  SCORE(10)
----- ----------
    1          6
    2         52
 
dog*3 ACCUM cat
   ID  SCORE(10)
----- ----------
    1         53
    2         76
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref949"></a>Related Topics</p>
<p>See also <a href="#i998379">weight (*)</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997198"></a>
<div id="CCREF0304" class="refsect1">
<h2 class="refsect1">AND (&amp;)<a id="sthref950"></a><a id="sthref951"></a></h2>
<p>Use the <code dir="ltr">AND</code> operator to search for documents that contain at least one occurrence of each of the query terms.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref952"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="AND Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t10">Syntax</th>
<th class="cellalignment97" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t10" headers="r1c1-t10"><span class="variable">term1</span>&amp;<span class="variable">term2</span>
<p><span class="variable">term1</span> and <span class="variable">term2</span></p>
</td>
<td class="cellalignment98" headers="r2c1-t10 r1c2-t10">Returns documents that contain <span class="italic">term1</span> and <span class="italic">term2</span>. Returns the minimum score of its operands. All query terms must occur; lower score taken.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref953"></a>Example</p>
<p>To obtain all the documents that contain the terms <span class="italic">blue</span> and <span class="italic">black</span> and <span class="italic">red</span>, enter the following query:</p>
<pre dir="ltr">
'blue &amp; black &amp; red'
</pre>
<p>In an <code dir="ltr">AND</code> query, the score returned is the score of the lowest query term. In this example, if the three individual scores for the terms <span class="italic">blue, black,</span> and <span class="italic">red</span> is 10, 20 and 30 within a document, the document scores 10.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref954"></a>Related Topics</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The <code dir="ltr">AND</code> operator returns documents that contain <span class="italic">all</span> of the query terms, while <code dir="ltr">OR</code> operator returns documents that contain <span class="italic">any</span> of the query terms. See <a href="#i997930">"OR (|)"</a>.</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997220"></a>
<div id="CCREF0305" class="refsect1">
<h2 class="refsect1">Broader Term (BT, BTG, BTP, BTI)<a id="sthref955"></a><a id="sthref956"></a><a id="sthref957"></a><a id="sthref958"></a><a id="sthref959"></a><a id="sthref960"></a><a id="sthref961"></a></h2>
<p>Use the broader term operators (<code dir="ltr">BT</code>, <code dir="ltr">BTG</code>, <code dir="ltr">BTP</code>, <code dir="ltr">BTI</code>) to expand a query to include the term that has been defined in a thesaurus as the broader or higher level term for a specified term. They can also expand the query to include the broader term for the broader term and the broader term for that broader term, and so on up through the thesaurus hierarchy.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref962"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="BT Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t12">Syntax</th>
<th class="cellalignment97" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t12" headers="r1c1-t12">BT(<span class="variable">term</span>[(<span class="variable">qualifier</span>)][,<span class="variable">level</span>][,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r2c1-t12 r1c2-t12">Expands a query to include the term defined in the thesaurus as a broader term for <code dir="ltr">term</code>.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t12" headers="r1c1-t12">BTG(<span class="variable">term</span>[(<span class="variable">qualifier</span>)][,<span class="variable">level</span>][,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r3c1-t12 r1c2-t12">Expands a query to include all terms defined in the thesaurus as broader generic terms for <code dir="ltr">term</code>.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t12" headers="r1c1-t12">BTP(<span class="variable">term</span>[(<span class="variable">qualifier</span>)][,<span class="variable">level</span>][,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r4c1-t12 r1c2-t12">Expands a query to include all the terms defined in the thesaurus as broader partitive terms for <code dir="ltr">term</code>.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t12" headers="r1c1-t12">BTI(<span class="variable">term</span>[(<span class="variable">qualifier</span>)][,<span class="variable">level</span>][,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r5c1-t12 r1c2-t12">Expands a query to include all the terms defined in the thesaurus as broader instance terms for <code dir="ltr">term</code>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>term</dt>
<dd>
<p>Specify the operand for the broader term operator. Oracle Text expands <span class="syntaxinline">term</span> to include the broader term entries defined for the term in the thesaurus specified by <span class="syntaxinline">thes</span>. For example, if you specify <span class="italic">BTG(dog)</span>, the expansion includes only those terms that are defined as broader term generic for <span class="italic">dog</span>. You cannot specify expansion operators in the <code dir="ltr">term</code> argument.</p>
<p>The number of broader terms included in the expansion is determined by the value for <code dir="ltr">level</code>.</p>
</dd>
<dt>qualifier<a id="sthref963"></a><a id="sthref964"></a></dt>
<dd>
<p>Specify a qualifier for <code dir="ltr">term</code>, if <code dir="ltr">term</code> is a homograph (word or phrase with multiple meanings, but the same spelling) that appears in two or more nodes in the same hierarchy branch of <code dir="ltr">thes</code>.</p>
<p>If a qualifier is not specified for a homograph in a broader term query, the query expands to include the broader terms of all the homographic terms.</p>
</dd>
<dt>level</dt>
<dd>
<p>Specify the number of levels traversed in the thesaurus hierarchy to return the broader terms for the specified term. For example, a level of 1 in a BT query returns the broader term entry, if one exists, for the specified term. A level of 2 returns the broader term entry for the specified term, as well as the broader term entry, if one exists, for the broader term.</p>
<p>The level argument is optional and has a default value of one (1). Zero or negative values for the level argument return only the original query term.</p>
</dd>
<dt>thes</dt>
<dd>
<p>Specify the name of the thesaurus used to return the expansions for the specified term. <a id="sthref965"></a><a id="sthref966"></a>The <span class="syntaxinline">thes</span> argument is optional and has a default value of <code dir="ltr">DEFAULT</code>. A thesaurus named <code dir="ltr">DEFAULT</code> <span class="italic">must</span> exist in the thesaurus tables if you use this default value.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you specify <code dir="ltr">thes</code>, then you must also specify <code dir="ltr">level</code>.</div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref967"></a>Examples</p>
<p>The following query returns all documents that contain the term <span class="italic">tutorial</span> or the <code dir="ltr">BT</code> term defined for <span class="italic">tutorial</span> in the <code dir="ltr">DEFAULT</code> thesaurus:</p>
<pre dir="ltr">
'BT(tutorial)'
</pre>
<p>When you specify a thesaurus name, you must also specify <code dir="ltr">level</code> as in:</p>
<pre dir="ltr">
'BT(tutorial, 2, mythes)'
</pre>
<p class="subhead1"><a id="CCREF23821"></a>Broader Term Operator on Homographs<a id="sthref968"></a></p>
<p>If <span class="italic">machine</span> is a broader term for <span class="italic">crane (building equipment)</span> and <span class="italic">bird</span> is a broader term for <span class="italic">crane (waterfowl)</span> and no qualifier is specified for a broader term query, the query</p>
<pre dir="ltr">
BT(crane) 
</pre>
<p>expands to:</p>
<pre dir="ltr">
'{crane} or {machine} or {bird}'
</pre>
<p>If <span class="italic">waterfowl</span> is specified as a qualifier for <span class="italic">crane</span> in a broader term query, the query</p>
<pre dir="ltr">
BT(crane{(waterfowl)}) 
</pre>
<p>expands to the query:</p>
<pre dir="ltr">
'{crane} or {bird}' 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
When specifying a qualifier in a broader or narrower term query, the qualifier and its notation (parentheses) must be escaped, as is shown in this example.</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref969"></a>Related Topics</p>
<p>Browse a thesaurus using procedures in the <code dir="ltr">CTX_THES</code> package.</p>
</div>
<!-- class="refsubsect" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
CTX_THES.<a href="cthes.htm#i997067">BT</a> in <a href="cthes.htm#g1010323">Chapter 12, "CTX_THES Package"</a> for more information on browsing the broader terms in your thesaurus</div>
</div>
<!-- class="refsect1" -->
<a id="CHDFAIDJ"></a>
<div id="CCREF9900" class="refsect1">
<h2 class="refsect1">DEFINEMERGE<a id="sthref970"></a><a id="sthref971"></a><a id="sthref972"></a><a id="sthref973"></a></h2>
<p>Use the <code dir="ltr">DEFINEMERGE</code> operator to define how the score of child nodes of the <code dir="ltr">AND</code> and <code dir="ltr">OR</code> should be merged. The <code dir="ltr">DEFINEMERGE</code> operator can be used as operand(s) of any operators that allow <code dir="ltr">AND</code> or <code dir="ltr">OR</code> as operands. The score can be merged in three ways: picking the minimum value, picking the maximum value, or calculating the average score of all child nodes.</p>
<p>Use <a href="#CHDIHDAC">DEFINESCORE</a> before using <code dir="ltr">DEFINEMERGE</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref974"></a>Syntax</p>
<pre dir="ltr">
DEFINEMERGE ( (  (text_query1), (text_query2), &hellip; )  , operator, merge_method )
</pre>
<div class="inftblinformal">
<table class="cellalignment96" title="DEFINEMERGE Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t16">Syntax</th>
<th class="cellalignment97" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t16" headers="r1c1-t16"><span class="variable">text_query1,2 ...</span></td>
<td class="cellalignment98" headers="r2c1-t16 r1c2-t16">Defines the search criteria. These parameters can have any value that is valid for the AND/OR operator.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t16" headers="r1c1-t16"><span class="italic">operator</span></td>
<td class="cellalignment98" headers="r3c1-t16 r1c2-t16">Defines the relationship between the two <code dir="ltr">text_query</code> parameters.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t16" headers="r1c1-t16"><span class="italic">merge_method</span></td>
<td class="cellalignment98" headers="r4c1-t16 r1c2-t16">Defines how the score of the text_query should be merged. Possible values: <code dir="ltr">MIN</code>, <code dir="ltr">MAX</code>, <code dir="ltr">AVG</code>, <code dir="ltr">ADD</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref975"></a>Example</p>
<div id="CCREF23822" class="example">
<p class="titleinexample"><a id="sthref976"></a>Example 3-1 DEFINEMERGE and text_query</p>
<p>The following examples show only the <code dir="ltr">text_query</code> part of a <code dir="ltr">CONTAINS</code> query:</p>
<pre dir="ltr">
'DEFINEMERGE ( ((dog), (cat)), OR, AVG)'
</pre>
<p>Queries for the term "dog" or "cat," using the average relevance score of both terms as the merged score.</p>
</div>
<!-- class="example" -->
<pre dir="ltr">
'DEFINEMERGE (((dog , cat) , (blue or black)), AND, MIN )'
</pre>
<p>Queries for the expression "dog <code dir="ltr">ACCUM</code> cat" and "blue <code dir="ltr">OR</code> black," using the default scoring schemes and then using the minimum score of the two as the merged-score.</p>
<pre dir="ltr">
'DEFINEMERGE( ((DEFINESCORE(dog, DISCRETE)) , (cat)), AND, MAX)'
</pre>
<p>Queries for the term "dog" using the <code dir="ltr">DISCRETE</code> scoring, and for the term "cat" using the default relevant scoring, and then using the maximum score of the two as the merged-score.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref977"></a>Related Topic</p>
<p><a href="#CHDIHDAC">DEFINESCORE</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CHDIHDAC"></a>
<div id="CCREF9901" class="refsect1">
<h2 class="refsect1">DEFINESCORE<a id="sthref978"></a><a id="sthref979"></a><a id="sthref980"></a><a id="sthref981"></a><a id="sthref982"></a></h2>
<p>Use the <code dir="ltr">DEFINESCORE</code> operator to define how a term or phrase, or a set of term equivalences will be scored. The definition of a scoring expression can consist of an arithmetic expression of predefined scoring components and numeric literals.</p>
<p><a href="#CHDFAIDJ">DEFINEMERGE</a> can be used after <code dir="ltr">DEFINESCORE</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref983"></a>Syntax</p>
<pre dir="ltr">
DEFINESCORE (query_term, scoring_expression)
</pre>
<dl>
<dt>query_term</dt>
<dd>
<p>The query term or phrase. Expressions containing the following operators are also allowed:</p>
<div class="inftblinformal">
<table class="cellalignment96" summary="query_term" dir="ltr">
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r1c1-t17">-</td>
<td class="cellalignment98">-</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t17"><code dir="ltr">ABOUT</code></td>
<td class="cellalignment98" headers="r2c1-t17"><code dir="ltr">EQUIV(=)</code></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t17"><code dir="ltr">Fuzzy</code></td>
<td class="cellalignment98" headers="r3c1-t17"><code dir="ltr">Soundex (!)</code></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t17"><code dir="ltr">Stem ($)</code></td>
<td class="cellalignment98" headers="r4c1-t17"><code dir="ltr">Wildcards (% _)</code></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t17"><code dir="ltr">SDATA</code></td>
<td class="cellalignment98" headers="r5c1-t17"><code dir="ltr">MDATA</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></dd>
</dl>
</div>
<!-- class="refsubsect" -->
<dl>
<dt>scoring_expression</dt>
<dd>
<p>An arithmetic expression that describes how the <code dir="ltr">query_term</code> should be scored. This operand is a string that contains the following components:</p>
<ul>
<li>
<p>Arithmetic operators: <code dir="ltr">+ - * /</code>. The precedence is multiplication and division (*, /) first before addition and subtraction (+, -).</p>
</li>
<li>
<p>Grouping operators: <code dir="ltr">()</code>. Parentheses can be used to alter the precedence of the arithmetic operators.</p>
</li>
<li>
<p>Absolute function: <code dir="ltr">ABS(n)</code> returns the absolute value of <code dir="ltr">n</code>; where <code dir="ltr">n</code> is any expression that returns a number.</p>
</li>
<li>
<p>Logarithmic function: <code dir="ltr">LOG(n)</code> returns the base-10 logarithmic value of <code dir="ltr">n</code> ; where <code dir="ltr">n</code> is any expression that returns a number.</p>
</li>
<li>
<p>Predefined scoring components: Each of the following scoring components returns a value of 0 - 100, depending on different criteria:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="scoring_expression variables" summary="Predefined scoring list" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t18">Name</th>
<th class="cellalignment97" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t18" headers="r1c1-t18"><code dir="ltr">DISCRETE</code></td>
<td class="cellalignment98" headers="r2c1-t18 r1c2-t18">If the term exists in the document, score = 100. Otherwise, score = 0.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t18" headers="r1c1-t18"><code dir="ltr">OCCURRENCE</code></td>
<td class="cellalignment98" headers="r3c1-t18 r1c2-t18">Score based on the number of occurrences.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t18" headers="r1c1-t18"><code dir="ltr">RELEVANCE</code></td>
<td class="cellalignment98" headers="r4c1-t18 r1c2-t18">Score based on the document's relevance.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t18" headers="r1c1-t18"><code dir="ltr">COMPLETION</code></td>
<td class="cellalignment98" headers="r5c1-t18 r1c2-t18">Score based on coverage. Documents will score higher if the ratio between the number of the matching terms and the number of all terms in the section (counting stop words) is higher. The <code dir="ltr">COMPLETION</code> scoring is only applicable when used with the <code dir="ltr">WITHIN</code> operator to search in zone sections.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t18" headers="r1c1-t18"><code dir="ltr">IGNORE</code></td>
<td class="cellalignment98" headers="r6c1-t18 r1c2-t18">Ignore the scoring of this term. This component should be used alone. Otherwise, the query will return a syntax error. If the scoring of the only term in the query is set to <code dir="ltr">IGNORE</code>, then all the matching documents should be returned with the same score of 100.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></li>
</ul>
</dd>
</dl>
<div class="infobox-note">
<p class="notep1">Note:</p>
For numeric literals, any number literal can be used that conforms to the SQL pattern of number literal, and is within the range of the double precision floating point (<code dir="ltr">-3.4e38</code> to <code dir="ltr">3.4e38</code>).</div>
<p class="subhead2"><a id="CCREF23823"></a>scoring_expression Syntax</p>
<pre dir="ltr">
&lt;Exp&gt;   :=         &lt;Exp&gt; + &lt;Term&gt; | &lt;Exp&gt; - &lt;Term&gt; |  &lt;Term&gt;
 
&lt;Term&gt;   :=         &lt;Term&gt; * &lt;Factor&gt; | &lt;Term&gt; / &lt;Factor&gt; | &lt;Factor&gt;
 
&lt;Factor&gt; :=         &lt;&lt;NumericLiterals &gt;&gt;| DISCRETE | OCCURRENCE | RELEVANCE |
         COMPLETION | IGNORE |  ( &lt;Exp&gt; ) | -&lt;Factor&gt; | Abs(&lt;Exp&gt;) | Log(&lt;Exp&gt;)
</pre>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="CHDGBDJA"></a>Examples</p>
<pre dir="ltr">
'DEFINESCORE (dog, OCCURRENCE)'
</pre>
<p>Queries for the word <span class="italic">dog</span>, and scores each document using the occurrence score. Returns the score as integer.</p>
<pre dir="ltr">
'DEFINESCORE (Labradors are big dog, RELEVANCE)'
</pre>
<p>Queries for the phrase <span class="italic">Labradors</span> <span class="italic">are</span> <span class="italic">big</span> <span class="italic">dogs</span>, and scores each document using the relevance score.</p>
<pre dir="ltr">
'cat and DEFINESCORE (dog, IGNORE)'
</pre>
<p>Queries for the words <span class="italic">dog</span> and <span class="italic">cat</span>, using only the default relevance score of <span class="italic">cat</span> as the overall score of the document. Returns the score as integer.</p>
<pre dir="ltr">
'DEFINESCORE (dog, IGNORE)'
</pre>
<p>Queries for the word <span class="italic">dog</span>, and returns all documents with the word <span class="italic">dog</span>. The result is the same as if all documents get a score of 100. Returns the score as integer.</p>
<pre dir="ltr">
'DEFINESCORE (dog, ABS (100-RELEVANCE))'
</pre>
<p>Queries for the word <span class="italic">dog</span>, and scores each document using the absolute value of 100 minus the relevance score. Returns the score as integer.</p>
<pre dir="ltr">
'cat and DEFINESCORE (dog, RELEVANCE*5 - OCCURRENCE)'
</pre>
<p>Returns a syntax error: Two pre-defined components are used.</p>
<p>When <code dir="ltr">DEFINESCORE</code> is used with query templates, the <code dir="ltr">scoring_expression</code> overrides the values specified by the template. The following example queries for "dog" and "cat," scores "cat" using <code dir="ltr">OCCURRENCE</code><code dir="ltr">(COUNT)</code> and scores "dog" based on <code dir="ltr">RELEVANCE</code>.</p>
<pre dir="ltr">
query&gt;
      &lt;textquery grammar="CONTEXT" lang="english"&gt;
                 DEFINESCORE(dog, RELEVANCE) and  cat
      &lt;/textquery&gt;
      &lt;score datatype="INTEGER" algorithm="COUNT"/&gt;
&lt;/query&gt;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref984"></a>Limitations</p>
<ul>
<li>
<p>If the <code dir="ltr">ABOUT</code> operator is used in <code dir="ltr">query_term</code>, the <code dir="ltr">OCCURRENCE</code> and <code dir="ltr">COMPLETION</code> scoring will not be applicable. If used, the query will return a syntax error.</p>
</li>
<li>
<p>The <code dir="ltr">IGNORE</code> score cannot be used as right hand of the minus operator. If used, then a syntax error will occur.</p>
</li>
<li>
<p>The <code dir="ltr">COMPLETION</code> score is only applicable if the <code dir="ltr">DEFINESCORE</code> is used with a <code dir="ltr">WITHIN</code> operator to search in zone sections, for example:</p>
<pre dir="ltr">
&amp;rsquor;DEFINESCORE (dog, COMPLETION) within zonesection'
</pre>
<p>otherwise, the query will return a syntax error.</p>
</li>
<li>
<p>For the left hand operand of <code dir="ltr">WITHIN</code>:</p>
<ul>
<li>
<p>All nodes must use the same predefined-scoring component. (If not specified, then the predefined scoring is <code dir="ltr">RELEVANCE</code>.)</p>
</li>
<li>
<p>If the nodes use <code dir="ltr">DISCRETE</code> or <code dir="ltr">COMPLETION</code>, then only the <code dir="ltr">AND</code> and <code dir="ltr">OR</code> operator is allowed as the left hand children of <code dir="ltr">WITHIN</code>.</p>
</li>
<li>
<p>If the nodes use <code dir="ltr">DISCRETE</code> or <code dir="ltr">COMPLETION</code>, then <code dir="ltr">WITHIN</code> will use the max score of all section instances as the score.</p>
</li>
<li>
<p>If the nodes use <code dir="ltr">RELEVANCE</code> or <code dir="ltr">OCCURRENCE</code>, then <code dir="ltr">WITHIN</code> will use the summation of the score of all section instances as the score.</p>
</li>
</ul>
</li>
<li>
<p>Only one predefined scoring component can be used in the <code dir="ltr">scoring_expression</code> at one time. If more than one predefined scoring component is used, then a syntax error will occur.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref985"></a>Notes</p>
<ul>
<li>
<p>The <code dir="ltr">DEFINESCORE</code> operator, the absolute function, the logarithmic function, and the pre-defined scoring components are case-insensitive.</p>
</li>
<li>
<p>The <code dir="ltr">query_term</code> and the <code dir="ltr">scoring_expression</code> parameters are mandatory.</p>
</li>
<li>
<p>The final score of the <code dir="ltr">DEFINESCORE</code> operator will be truncated to be in the 0 &ndash; 100 range. If the data type is <code dir="ltr">INTEGER</code>, then the score is rounded up.</p>
</li>
<li>
<p>The intermediate data type of the scoring value is a double precision float. As a result, the value is limited to be in the <code dir="ltr">-3.4e38</code> to <code dir="ltr">3.4e38</code> range. If the intermediate scoring of any document exceeds the value, then the score will be truncated. If an integer scoring is required, then the score will always be rounded up after the score is calculated.</p>
</li>
<li>
<p>The <code dir="ltr">DEFINESCORE</code> operator can be used as an operand of the following operators:</p>
<ul>
<li>
<p>AND</p>
</li>
<li>
<p>NOT</p>
</li>
<li>
<p>INPATH</p>
</li>
<li>
<p>THRESHOLD</p>
</li>
<li>
<p>WITHIN</p>
</li>
<li>
<p>SQE</p>
</li>
<li>
<p>OR</p>
</li>
<li>
<p>DEFINEMERGE</p>
</li>
<li>
<p>MINUS</p>
</li>
<li>
<p>WEIGHT</p>
</li>
<li>
<p>ACCUM</p>
</li>
</ul>
<p>For example, the following statement is valid:</p>
<pre dir="ltr">
DEFINESCORE(&amp;rsquor;dog', OCCURRENCE) AND DEFINESCORE(&amp;rsquor;cat', RELEVANCE)
</pre>
<p>Queries for the term "dog" using occurrence scoring, and the term "cat" using relevance scoring.</p>
</li>
<li>
<p>If <code dir="ltr">DEFINESCORE</code> is used as a parameter of other operators, then an error will be returned. For example, the following example returns an error:</p>
<pre dir="ltr">
SYN(DEFINESCORE(&amp;rsquor;cat', OCCURRENCE))
</pre></li>
<li>
<p>When used with query templates, the <code dir="ltr">scoring_expression</code> overrides the values specified by the template. For example,</p>
<pre dir="ltr">
query&gt;
    &lt;textquery grammar="CONTEXT" lang="english"&gt;
        DEFINESCORE(dog, RELEVANCE) and  cat
    &lt;/textquery&gt;
    &lt;score datatype="INTEGER" algorithm="COUNT"/&gt;
&lt;/query&gt;
</pre>
<p>Queries for "dog" and "cat", scores "cat" using <code dir="ltr">OCCURRENCE(COUNT)</code>, and scores "dog" based on <code dir="ltr">RELEVANCE</code>.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref986"></a>Related Topic</p>
<p><a href="#CHDFAIDJ">DEFINEMERGE</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997305"></a>
<div id="CCREF0306" class="refsect1">
<h2 class="refsect1">EQUIValence (=)<a id="sthref987"></a><a id="sthref988"></a><a id="sthref989"></a><a id="sthref990"></a></h2>
<p>Use the <code dir="ltr">EQUIV</code> operator to specify an acceptable substitution for a word in a query.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref991"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="EQUIV Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t21">Syntax</th>
<th class="cellalignment97" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t21" headers="r1c1-t21"><span class="variable">term1</span>=<span class="variable">term2</span>
<p><span class="variable">term1</span> equiv <span class="variable">term2</span></p>
</td>
<td class="cellalignment98" headers="r2c1-t21 r1c2-t21">Specifies that <span class="syntaxinline">term2</span> is an acceptable substitution for <span class="syntaxinline">term1</span><span class="italic">.</span> Score calculated as the sum of all occurrences of both terms.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref992"></a>Example</p>
<p>The following example returns all documents that contain either the phrase <span class="italic">alsatians are big dogs</span> or <span class="italic">labradors are big dogs</span>:</p>
<pre dir="ltr">
'labradors=alsatians are big dogs'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref993"></a>Operator Precedence</p>
<p><a id="sthref994"></a>The <code dir="ltr">EQUIV</code> operator has higher precedence than all other operators except the expansion operators (fuzzy, soundex, stem).</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997330"></a>
<div id="CCREF0307" class="refsect1">
<h2 class="refsect1">Fuzzy<a id="sthref995"></a><a id="sthref996"></a><a id="sthref997"></a></h2>
<p>Use the <code dir="ltr">fuzzy</code> operator to expand queries to include words that are spelled similarly to the specified term. This type of expansion is helpful for finding more accurate results when there are frequent misspellings in your document set.</p>
<p>The <code dir="ltr">fuzzy</code> syntax enables you to rank the result set so that documents that contain words with high similarity to the query word are scored higher than documents with lower similarity. You can also limit the number of expanded terms.</p>
<p>Unlike stem expansion, the number of words generated by a <code dir="ltr">fuzzy</code> expansion depends on what is in the index. Results can vary significantly according to the contents of the index.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref998"></a>Supported Languages</p>
<p>Oracle Text supports <code dir="ltr">fuzzy</code> definitions for English, French, German, Italian, Dutch, Spanish, Portuguese, Japanese, OCR, and auto-language detection.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref999"></a>Stopwords</p>
<p>If the <code dir="ltr">fuzzy</code> expansion returns a stopword, the stopword is not included in the query or highlighted by <code dir="ltr">CTX_DOC.HIGHLIGHT</code> or <code dir="ltr">CTX_DOC.MARKUP</code>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1000"></a>Base-Letter Conversion</p>
<p>If base-letter conversion is enabled for a text column and the query expression contains a <code dir="ltr">fuzzy</code> operator, Oracle Text operates on the base-letter form of the query.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1001"></a>Syntax</p>
<pre dir="ltr">
fuzzy(term, score, numresults, weight)
</pre>
<div class="inftblinformal">
<table class="cellalignment96" title="Fuzzy Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t22">Parameter</th>
<th class="cellalignment97" id="r1c2-t22">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t22" headers="r1c1-t22">term</td>
<td class="cellalignment98" headers="r2c1-t22 r1c2-t22">Specify the word on which to perform the <code dir="ltr">fuzzy</code> expansion. Oracle Text expands <span class="syntaxinline">term</span> to include words only in the index. The word needs to be at least 3 characters for the <code dir="ltr">fuzzy</code> operator to process it.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t22" headers="r1c1-t22">score</td>
<td class="cellalignment98" headers="r3c1-t22 r1c2-t22">Specify a similarity score. Terms in the expansion that score below this number are discarded. Use a number between 1 and 80. The default is 60.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t22" headers="r1c1-t22">numresults</td>
<td class="cellalignment98" headers="r4c1-t22 r1c2-t22">Specify the maximum number of terms to use in the expansion of <span class="syntaxinline">term</span>. Use a number between 1 and 5000. The default is 100.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t22" headers="r1c1-t22">weight</td>
<td class="cellalignment98" headers="r5c1-t22 r1c2-t22">Specify <code dir="ltr">WEIGHT</code> or <code dir="ltr">W</code> for the results to be weighted according to their similarity scores.
<p>Specify <code dir="ltr">NOWEIGHT</code> or <code dir="ltr">N</code> for no weighting of results.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1002"></a>Examples</p>
<p>Consider the <code dir="ltr">CONTAINS</code> query:</p>
<pre dir="ltr">
...CONTAINS(TEXT, 'fuzzy(government, 70, 6, weight)', 1) &gt; 0;
</pre>
<p>This query expands to the first six <code dir="ltr">fuzzy</code> variations of <span class="italic">government</span> in the index that have a similarity score over 70.</p>
<p>In addition, documents in the result set are weighted according to their similarity to <span class="italic">government</span>. Documents containing words most similar to government receive the highest score.</p>
<p>Skip unnecessary parameters using the appropriate number of commas. For example:</p>
<pre dir="ltr">
'fuzzy(government,,,weight)'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1003"></a>Backward Compatibility Syntax</p>
<p>The old <code dir="ltr">fuzzy</code> syntax from previous releases is still supported. This syntax is as follows:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="Old FUZZY syntax for backward compatibility" summary="parameter description" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t23">Parameter</th>
<th class="cellalignment97" id="r1c2-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t23" headers="r1c1-t23">?term</td>
<td class="cellalignment98" headers="r2c1-t23 r1c2-t23">Expands <span class="syntaxinline">term</span> to include all terms with similar spellings as the specified term. <span class="syntaxinline">Term</span> needs to be at least 3 characters for the <code dir="ltr">fuzzy</code> operator to process it.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997393"></a>
<div id="CCREF0308" class="refsect1">
<h2 class="refsect1">HASPATH<a id="sthref1004"></a><a id="sthref1005"></a></h2>
<p>Use this operator to find all <code dir="ltr">XML</code> documents that contain a specified section path. You can also use this operator to do section equality testing.</p>
<p>Your index must be created with the <code dir="ltr">PATH_SECTION_GROUP</code> for this operator to work.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1006"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="HASPATH Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t24">Syntax</th>
<th class="cellalignment97" id="r1c2-t24">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t24" headers="r1c1-t24">HASPATH(path)</td>
<td class="cellalignment98" headers="r2c1-t24 r1c2-t24">Searches an XML document set and returns a score of 100 for all documents where <span class="italic">path</span> exists. Separate parent and child paths with the / character. For example, you can specify <span class="italic">A/B/C</span>.
<p>See example.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t24" headers="r1c1-t24">HASPATH(A="value")</td>
<td class="cellalignment98" headers="r3c1-t24 r1c2-t24">Searches an XML document set and returns a score of 100 for all documents that have the element A with content <span class="italic">value</span> and only <span class="italic">value</span>.
<p>See example.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="CHDDBDHD"></a>Using Special Characters with HASPATH and INPATH</p>
<p><a id="sthref1007"></a><a id="sthref1008"></a><a id="sthref1009"></a>The following rules govern the use of special characters with regard to both the <code dir="ltr">HASPATH</code> and <code dir="ltr">INPATH</code> operators:</p>
<ul>
<li>
<p>Left-brace ({) and right-brace (}) characters are not allowed inside <code dir="ltr">HASPATH</code> or <code dir="ltr">INPATH</code> expressions unless they are inside the equality operand enclosed by double quotes. So both '<code dir="ltr">HASPATH({/A/B})</code>' and '<code dir="ltr">HASPATH(/A/{B})</code>' will return errors. However, '<code dir="ltr">HASPATH(/A[B="{author}"])</code>' will be parsed correctly.</p>
</li>
<li>
<p>With exception of the backslash (\), special characters, such as dollar sign ($), percent sign (%), underscore (_), left brace ({), and right brace (}), when inside the equality operand enclosed by double or single quotes, have no special meaning. (That is, no stemming, wildcard expansion, or similar processing will be performed on them.) However, they are still subject to regular text lexing and will be translated to whitespace, with the exception of characters declared as printjoins. A backslash will still escape any character that immediately follows it.</p>
<p>For example, if the hyphen (-) and the double quote character (") are defined as printjoins in a lexer preference, then:</p>
<ul>
<li>
<p>The string <span class="italic">B_TEXT</span> inside <code dir="ltr">HASPATH(/A[B="B_TEXT")</code> will be lexed as the phrase <span class="italic">B TEXT</span>.</p>
</li>
<li>
<p>The string <span class="italic">B-TEXT</span> inside <code dir="ltr">HASPATH(/A[B="B-TEXT")</code> will be lexed as the word <span class="italic">B-TEXT</span>.</p>
</li>
<li>
<p>The string <span class="italic">B'TEXT</span> inside <code dir="ltr">HASPATH(/A[B="B'TEXT")</code> will be lexed as the word <span class="italic">B"TEXT</span>. You must use a backslash to escape the double quote between <span class="italic">B</span> and <span class="italic">TEXT</span>, or you will get a parsing error.</p>
</li>
<li>
<p>The string <span class="italic">{B_TEXT}</span> inside <code dir="ltr">HASPATH(/A[B="{B_TEXT}")</code> will be lexed as a phrase <span class="italic">B TEXT</span>.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1010"></a>Example</p>
<p class="subhead1"><a id="CCREF23824"></a>Path Testing</p>
<p>The query</p>
<pre dir="ltr">
HASPATH(A/B/C)
</pre>
<p>finds and returns a score of 100 for the document</p>
<pre dir="ltr">
&lt;A&gt;&lt;B&gt;&lt;C&gt;dog&lt;/C&gt;&lt;/B&gt;&lt;/A&gt;
</pre>
<p>without the query having to reference <span class="italic">dog</span> at all.</p>
<p class="subhead1"><a id="CCREF23825"></a>Section Equality Testing</p>
<p>The query</p>
<pre dir="ltr">
dog INPATH A
</pre>
<p>finds</p>
<pre dir="ltr">
&lt;A&gt;dog&lt;/A&gt;
</pre>
<p>but it also finds</p>
<pre dir="ltr">
&lt;A&gt;dog park&lt;/A&gt;
</pre>
<p>To limit the query to the term <span class="italic">dog</span> and nothing else, you can use a section equality test with the <code dir="ltr">HASPATH</code> operator. For example,</p>
<pre dir="ltr">
HASPATH(A="dog")
</pre>
<p>finds and returns a score of 100 only for the first document, and not the second.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1011"></a>Limitations</p>
<p>Because of how XML section data is recorded, false matches might occur with XML sections that are completely empty as follows:</p>
<p>&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;/C&gt;&lt;/B&gt;&lt;D&gt;&lt;E&gt;&lt;/E&gt;&lt;/D&gt;&lt;/A&gt;</p>
<p>A query of <code dir="ltr">HASPATH(A/B/E)</code> or <code dir="ltr">HASPATH(A/D/C)</code> falsely matches this document. This type of false matching can be avoided by inserting text between empty tags.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997443"></a>
<div id="CCREF0309" class="refsect1">
<h2 class="refsect1">INPATH<a id="sthref1012"></a><a id="sthref1013"></a></h2>
<p>Use this operator to do path searching in XML documents. This operator is like the <code dir="ltr">WITHIN</code> operator except that the right-hand side is a parentheses enclosed path, rather than a single section name.</p>
<p>Your index must be created with the <code dir="ltr"><a id="sthref1014"></a>PATH_SECTION_GROUP</code> for the <code dir="ltr">INPATH</code> operator to work.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1015"></a>Syntax</p>
<p>The <code dir="ltr">INPATH</code> operator has the following syntax:</p>
<p class="subhead1"><a id="CCREF23826"></a>Top-Level Tag Searching</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Top Level)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t25">Syntax</th>
<th class="cellalignment97" id="r1c2-t25">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t25" headers="r1c1-t25">term INPATH (/A)
<p>term INPATH (A)</p>
</td>
<td class="cellalignment98" headers="r2c1-t25 r1c2-t25">Returns documents that have <span class="italic">term</span> within the &lt;A&gt; and &lt;/A&gt; tags.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23827"></a>Any-Level Tag Searching</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Any Level)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t26">Syntax</th>
<th class="cellalignment97" id="r1c2-t26">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t26" headers="r1c1-t26">term INPATH (//A)</td>
<td class="cellalignment98" headers="r2c1-t26 r1c2-t26">Returns documents that have <span class="italic">term</span> in the &lt;A&gt; tag at any level. This query is the same as <span class="italic">'term WITHIN A</span>'</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23828"></a>Direct Parentage Path Searching</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Direct Parentage Path)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t27">Syntax</th>
<th class="cellalignment97" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t27" headers="r1c1-t27">term INPATH (A/B)</td>
<td class="cellalignment98" headers="r2c1-t27 r1c2-t27">Returns documents where <span class="italic">term</span> appears in a B element which is a direct child of a top-level A element.
<p>For example, a document containing</p>
<p><code dir="ltr">&lt;A&gt;&lt;B&gt;term&lt;/B&gt;&lt;/A&gt;</code></p>
<p>is returned.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23829"></a>Single-Level Wildcard Searching</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Single-Level Wildcard Searchng)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t28">Syntax</th>
<th class="cellalignment97" id="r1c2-t28">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t28" headers="r1c1-t28">term INPATH (A/*/B)</td>
<td class="cellalignment98" headers="r2c1-t28 r1c2-t28">Returns documents where <span class="italic">term</span> appears in a B element which is a grandchild (two levels down) of a top-level A element.
<p>For example a document containing</p>
<p><code dir="ltr">&lt;A&gt;&lt;D&gt;&lt;B&gt;term&lt;/B&gt;&lt;/D&gt;&lt;/A&gt;</code></p>
<p>is returned.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23830"></a>Multi-level Wildcard Searching</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Multi-Level Wildcard)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t29">Syntax</th>
<th class="cellalignment97" id="r1c2-t29">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t29" headers="r1c1-t29">term INPATH (A/*/B/*/*/C)</td>
<td class="cellalignment98" headers="r2c1-t29 r1c2-t29">Returns documents where <span class="italic">term</span> appears in a C element which is 3 levels down from a B element which is two levels down (grandchild) of a top-level A element.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23831"></a>Any-Level Descendant Searching</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Any-Level Descendant Searching)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t30">Syntax</th>
<th class="cellalignment97" id="r1c2-t30">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t30" headers="r1c1-t30">term INPATH(A//B)</td>
<td class="cellalignment98" headers="r2c1-t30 r1c2-t30">Returns documents where term appears in a B element which is some descendant (any level) of a top-level A element.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23832"></a>Attribute Searching</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Attribute Searching)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t31">Syntax</th>
<th class="cellalignment97" id="r1c2-t31">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t31" headers="r1c1-t31">term INPATH (//A/@B)</td>
<td class="cellalignment98" headers="r2c1-t31 r1c2-t31">Returns documents where <span class="italic">term</span> appears in the B attribute of an A element at any level. Attributes must be bound to a direct parent.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23833"></a>Descendant/Attribute Existence Testing</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Descendant/Attribute Existence Testing)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t32">Syntax</th>
<th class="cellalignment97" id="r1c2-t32">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t32" headers="r1c1-t32">term INPATH (A[B])</td>
<td class="cellalignment98" headers="r2c1-t32 r1c2-t32">Returns documents where term appears in a top-level A element which has a B element as a direct child.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t32" headers="r1c1-t32">term INPATH (A[.//B])</td>
<td class="cellalignment98" headers="r3c1-t32 r1c2-t32">Returns documents where term appears in a top-level A element which has a B element as a descendant at any level.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t32" headers="r1c1-t32">term INPATH (//A[@B])</td>
<td class="cellalignment98" headers="r4c1-t32 r1c2-t32">Finds documents where term appears in an A element at any level which has a B attribute. Attributes must be tied to a direct parent.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23834"></a>Attribute Value Testing</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Attribute Value Testing)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t33">Syntax</th>
<th class="cellalignment97" id="r1c2-t33">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t33" headers="r1c1-t33">term INPATH (A[@B = "value"])</td>
<td class="cellalignment98" headers="r2c1-t33 r1c2-t33">Finds all documents where <span class="italic">term</span> appears in a top-level A element which has a B attribute whose value is <span class="italic">value</span>.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t33" headers="r1c1-t33">term INPATH (A[@B != "value"])</td>
<td class="cellalignment98" headers="r3c1-t33 r1c2-t33">Finds all documents where <span class="italic">term</span> appears in a top-level A element which has a B attribute whose value is not <span class="italic">value</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23835"></a>Tag Value Testing</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Tag Value Testing)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t34">Syntax</th>
<th class="cellalignment97" id="r1c2-t34">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t34" headers="r1c1-t34">term INPATH (A[B = "value"]))</td>
<td class="cellalignment98" headers="r2c1-t34 r1c2-t34">Returns documents where <span class="italic">term</span> appears in an A tag which has a B tag whose value is <span class="italic">value</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23836"></a>Not</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (NOT)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t35">Syntax</th>
<th class="cellalignment97" id="r1c2-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t35" headers="r1c1-t35">term INPATH (A[NOT(B)])</td>
<td class="cellalignment98" headers="r2c1-t35 r1c2-t35">Finds documents where <span class="italic">term</span> appears in a top-level A element which does not have a B element as an immediate child.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23837"></a>AND and OR Testing</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (AND and OR Testing)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t36">Syntax</th>
<th class="cellalignment97" id="r1c2-t36">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t36" headers="r1c1-t36">term INPATH (A[B and C])</td>
<td class="cellalignment98" headers="r2c1-t36 r1c2-t36">Finds documents where term appears in a top-level A element which has a B and a C element as an immediate child.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t36" headers="r1c1-t36">term INPATH (A[B and @C="value"]])</td>
<td class="cellalignment98" headers="r3c1-t36 r1c2-t36">Finds documents where <span class="italic">term</span> appears in a top-level A element which has a B element and a C attribute whose value is <span class="italic">value</span>.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t36" headers="r1c1-t36">term INPATH (A [B OR C])</td>
<td class="cellalignment98" headers="r4c1-t36 r1c2-t36">Finds documents where <span class="italic">term</span> appears in a top-level A element which has a B element or a C element.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="CCREF23838"></a>Combining Path and Node Tests</p>
<div class="inftblinformal">
<table class="cellalignment96" title="INPATH Syntax (Combining Path and Node Tests)" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t37">Syntax</th>
<th class="cellalignment97" id="r1c2-t37">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t37" headers="r1c1-t37">term INPATH (A[@B = "value"]/C/D)</td>
<td class="cellalignment98" headers="r2c1-t37 r1c2-t37">Returns documents where <span class="italic">term</span> appears in aD element which is the child of a C element, which is the child of a top-level A element with a B attribute whose value is <span class="italic">value</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1016"></a>Nested INPATH</p>
<p>Nest the entire <code dir="ltr">INPATH</code> expression in another <code dir="ltr">INPATH</code> expression as follows:</p>
<pre dir="ltr">
(dog INPATH (//A/B/C)) INPATH (D)
</pre>
<p>When you do so, the two <code dir="ltr">INPATH</code> paths are completely independent. The outer <code dir="ltr">INPATH</code> path does not change the context node of the inner <code dir="ltr">INPATH</code> path. For example:</p>
<pre dir="ltr">
(dog INPATH (A)) INPATH (D)
</pre>
<p>never finds any documents, because the inner <code dir="ltr">INPATH</code> is looking for <span class="italic">dog</span> within the top-level tag A, and the outer <code dir="ltr">INPATH</code> constrains that to document with top-level tag D. A document can have only one top-level tag, so this expression never finds any documents.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1017"></a>Case-Sensitivity</p>
<p>Tags and attribute names in path searching are case-sensitive. That is,</p>
<pre dir="ltr">
dog INPATH (A)
</pre>
<p>finds <code dir="ltr">&lt;A&gt;dog&lt;/A&gt;</code> but does not find <code dir="ltr">&lt;a&gt;dog&lt;/a&gt;</code>. Instead use</p>
<pre dir="ltr">
dog INPATH (a)
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1018"></a>Using Special Characters with INPATH</p>
<p>See <a href="#CHDDBDHD">"Using Special Characters with HASPATH and INPATH"</a> for information on using special characters, such as the percent sign (%) or the backslash (\), with <code dir="ltr">INPATH</code>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1019"></a>Examples</p>
<p class="subhead1"><a id="CCREF23839"></a>Top-Level Tag Searching</p>
<p>To find all documents that contain the term <span class="italic">dog</span> in the top-level tag &lt;A&gt;:</p>
<pre dir="ltr">
dog INPATH (/A)
</pre>
<p>or</p>
<pre dir="ltr">
dog INPATH(A)
</pre>
<p class="subhead1"><a id="CCREF23840"></a>Any-Level Tag Searching</p>
<p>To find all documents that contain the term <span class="italic">dog</span> in the &lt;A&gt; tag at any level:</p>
<pre dir="ltr">
dog INPATH(//A)
</pre>
<p>This query finds the following documents:</p>
<pre dir="ltr">
&lt;A&gt;dog&lt;/A&gt;
</pre>
<p>and</p>
<pre dir="ltr">
&lt;C&gt;&lt;B&gt;&lt;A&gt;dog&lt;/A&gt;&lt;/B&gt;&lt;/C&gt;
</pre>
<p class="subhead1"><a id="CCREF23841"></a>Direct Parentage Searching</p>
<p>To find all documents that contain the term <span class="italic">dog</span> in a B element that is a direct child of a top-level A element:</p>
<pre dir="ltr">
dog INPATH(A/B)
</pre>
<p>This query finds the following XML document:</p>
<pre dir="ltr">
&lt;A&gt;&lt;B&gt;My dog is friendly.&lt;/B&gt;&lt;A&gt;
</pre>
<p>but does not find:</p>
<pre dir="ltr">
&lt;C&gt;&lt;B&gt;My dog is friendly.&lt;/B&gt;&lt;/C&gt;
</pre>
<p class="subhead1"><a id="CCREF23842"></a>Tag Value Testing</p>
<p>You can test the value of tags. For example, the query:</p>
<pre dir="ltr">
dog INPATH(A[B="dog"])
</pre>
<p>Finds the following document:</p>
<pre dir="ltr">
&lt;A&gt;&lt;B&gt;dog&lt;/B&gt;&lt;/A&gt;
</pre>
<p>But does not find:</p>
<pre dir="ltr">
&lt;A&gt;&lt;B&gt;My dog is friendly.&lt;/B&gt;&lt;/A&gt;
</pre>
<p class="subhead1"><a id="CCREF23843"></a>Attribute Searching</p>
<p>You can search the content of attributes. For example, the query:</p>
<pre dir="ltr">
dog INPATH(//A/@B)
</pre>
<p>Finds the document</p>
<pre dir="ltr">
&lt;C&gt;&lt;A  B="snoop dog"&gt; &lt;/A&gt; &lt;/C&gt;
</pre>
<p class="subhead1"><a id="CCREF23844"></a>Attribute Value Testing</p>
<p>You can test the value of attributes. For example, the query</p>
<pre dir="ltr">
California INPATH (//A[@B = "home address"])
</pre>
<p>Finds the document:</p>
<pre dir="ltr">
&lt;A B="home address"&gt;San Francisco, California, USA&lt;/A&gt;
</pre>
<p>But does not find:</p>
<pre dir="ltr">
&lt;A B="work address"&gt;San Francisco, California, USA&lt;/A&gt;
</pre>
<p class="subhead1"><a id="CCREF23845"></a>Path Testing</p>
<p>You can test if a path exists with the <code dir="ltr">HASPATH</code> operator. For example, the query:</p>
<pre dir="ltr">
HASPATH(A/B/C)
</pre>
<p>finds and returns a score of 100 for the document</p>
<pre dir="ltr">
&lt;A&gt;&lt;B&gt;&lt;C&gt;dog&lt;/C&gt;&lt;/B&gt;&lt;/A&gt;
</pre>
<p>without the query having to reference <span class="italic">dog</span> at all.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1020"></a>Limitations</p>
<p class="subhead1"><a id="CCREF23846"></a>Testing for Equality</p>
<p>The following is an example of an <code dir="ltr">INPATH</code> equality test.</p>
<pre dir="ltr">
dog INPATH (A[@B = "foo"])
</pre>
<p>The following limitations apply for these expressions:</p>
<ul>
<li>
<p>Only equality and inequality are supported. Range operators and functions are not supported.</p>
</li>
<li>
<p>The left hand side of the equality must be an attribute. Tags and literals here are not enabled.</p>
</li>
<li>
<p>The right hand side of the equality must be a literal. Tags and attributes here are not allowed.</p>
</li>
<li>
<p>The test for equality depends on your lexer settings. With the default settings, the query</p>
<pre dir="ltr">
dog INPATH (A[@B= "pot of gold"])
</pre>
<p>matches the following sections:</p>
<pre dir="ltr">
&lt;A B="POT OF GOLD"&gt;dog&lt;/A&gt;
</pre>
<p>and</p>
<pre dir="ltr">
&lt;A B="pot of gold"&gt;dog&lt;/A&gt;
</pre>
<p>because lexer is case-insensitive by default.</p>
<pre dir="ltr">
&lt;A B="POT IS GOLD"&gt;dog&lt;/A&gt;
</pre>
<p>because <span class="italic">of</span> and <span class="italic">is</span> are default stopwords in English, and a stopword matches any stopword word.</p>
<pre dir="ltr">
&lt;A B="POT_OF_GOLD"&gt;dog&lt;/A&gt;
</pre>
<p>because the underscore character is not a join character by default.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="BGBCFHDB"></a>
<div id="CCREF2088" class="refsect1">
<h2 class="refsect1">MDATA<a id="sthref1021"></a><a id="sthref1022"></a><a id="sthref1023"></a></h2>
<p>Use the <code dir="ltr">MDATA</code> operator to query documents that contain <code dir="ltr">MDATA</code> sections. <code dir="ltr">MDATA</code> sections are metadata that have been added to documents to speed up mixed querying.</p>
<p><code dir="ltr">MDATA</code> queries are treated exactly as literals. For example, with the query:</p>
<pre dir="ltr">
MDATA(price, $1.24)
</pre>
<p>the <span class="italic">$</span> is not interpreted as a stem operator, nor is the . (period) transformed into whitespace. A right (close) parenthesis terminates the <code dir="ltr">MDATA</code> operator, so that <code dir="ltr">MDATA</code> values that have close parentheses cannot be searched.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1024"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="MDATA Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t38">Syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t38" headers="r1c1-t38">MDATA(<span class="variable">sectionname</span>, <span class="variable">value</span>)</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>sectionname</dt>
<dd>
<p>The name of the <code dir="ltr">MDATA</code> section(s) to search. <code dir="ltr">MDATA</code> will also search <code dir="ltr">DATE</code> or numerical equality if the <code dir="ltr">sectionname</code> parameter is mapped to a <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column of <code dir="ltr">DATE</code> or some numerical type.</p>
</dd>
<dt>value</dt>
<dd>
<p>The value of the <code dir="ltr">MDATA</code> section. For example, if an <code dir="ltr">MDATA</code> section called <code dir="ltr">Booktype</code> has been created, it might have a value of <span class="italic">paperback</span>.</p>
<p>For <code dir="ltr">MDATA</code> operator on <code dir="ltr">MDATA</code> sections that are mapped to a <code dir="ltr">DATE</code> <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column, the <code dir="ltr">MDATA</code> value must follow the Date format: <code dir="ltr">YYYY-MM-DD HH24:MI:SS</code>. Otherwise, the expected rows will not be returned. If the time component is omitted, it will default to <code dir="ltr">00:00:00</code>, according to SQL semantics.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1025"></a>Example</p>
<p>Suppose you want to query for books written by the writer <span class="italic">Nigella</span> <span class="italic">Lawson</span> that contain the word <span class="italic">summer</span>. Assuming that an <code dir="ltr">MDATA</code> section called <code dir="ltr">AUTHOR</code> has been declared, you can query as follows:</p>
</div>
<!-- class="refsubsect" -->
<pre dir="ltr">
SELECT id FROM idx_docs
  WHERE CONTAINS(text, 'summer AND MDATA(author, Nigella Lawson)')&gt;0
</pre>
<p>This query will only be successful if an <code dir="ltr">AUTHOR</code> tag has the exact value <span class="italic">Nigella Lawson</span> (after simplified tokenization). <span class="italic">Nigella</span> or <span class="italic">Ms. Nigella Lawson</span> will not work.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1026"></a>Notes</p>
<p><code dir="ltr">MDATA</code> query values ignore stopwords.</p>
<p>The <code dir="ltr">MDATA</code> operator returns 100 or 0, depending on whether the document is a match.</p>
<p>The <code dir="ltr">MDATA</code> operator is not supported for <code dir="ltr">CTXCAT</code>, <code dir="ltr">CTXRULE</code>, or <code dir="ltr">CTXXPATH</code> indexes.</p>
<p><a href="#BGBGJFDH">Table 3-2</a> shows how <code dir="ltr">MDATA</code> interacts with some other query operators:</p>
<div id="CCREF23847" class="tblformal">
<p class="titleintable"><a id="sthref1027"></a><a id="BGBGJFDH"></a>Table 3-2 MDATA and Other Query Operators</p>
<table class="cellalignment103" title="MDATA and Other Query Operators" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t39">Operator</th>
<th class="cellalignment97" id="r1c2-t39">Example</th>
<th class="cellalignment97" id="r1c3-t39">Allowed?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t39" headers="r1c1-t39">
<p>AND</p>
</td>
<td class="cellalignment98" headers="r2c1-t39 r1c2-t39">
<p>dog &amp; MDATA(a, b)</p>
</td>
<td class="cellalignment98" headers="r2c1-t39 r1c3-t39">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t39" headers="r1c1-t39">
<p>OR</p>
</td>
<td class="cellalignment98" headers="r3c1-t39 r1c2-t39">
<p>dog | MDATA(a, b)</p>
</td>
<td class="cellalignment98" headers="r3c1-t39 r1c3-t39">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t39" headers="r1c1-t39">
<p>NOT</p>
</td>
<td class="cellalignment98" headers="r4c1-t39 r1c2-t39">
<p>dog ~ MDATA(a, b)</p>
</td>
<td class="cellalignment98" headers="r4c1-t39 r1c3-t39">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t39" headers="r1c1-t39">
<p>MINUS</p>
</td>
<td class="cellalignment98" headers="r5c1-t39 r1c2-t39">
<p>dog - MDATA(a, b)</p>
</td>
<td class="cellalignment98" headers="r5c1-t39 r1c3-t39">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t39" headers="r1c1-t39">
<p>ACCUM</p>
</td>
<td class="cellalignment98" headers="r6c1-t39 r1c2-t39">
<p>dog , MDATA(a, b)</p>
</td>
<td class="cellalignment98" headers="r6c1-t39 r1c3-t39">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t39" headers="r1c1-t39">
<p>PHRASE</p>
</td>
<td class="cellalignment98" headers="r7c1-t39 r1c2-t39">
<p>MDATA(a, b) dog</p>
</td>
<td class="cellalignment98" headers="r7c1-t39 r1c3-t39">
<p>no</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r8c1-t39" headers="r1c1-t39">
<p>NEAR</p>
</td>
<td class="cellalignment98" headers="r8c1-t39 r1c2-t39">
<p>MDATA(a, b) ; dog</p>
</td>
<td class="cellalignment98" headers="r8c1-t39 r1c3-t39">
<p>no</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r9c1-t39" headers="r1c1-t39">
<p>WITHIN, HASPATH, INPATH</p>
</td>
<td class="cellalignment98" headers="r9c1-t39 r1c2-t39">
<p>MDATA(a, b) WITHIN c</p>
</td>
<td class="cellalignment98" headers="r9c1-t39 r1c3-t39">
<p>no</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r10c1-t39" headers="r1c1-t39">
<p>Thesaurus</p>
</td>
<td class="cellalignment98" headers="r10c1-t39 r1c2-t39">
<p>MDATA(a, SYN(b))</p>
</td>
<td class="cellalignment98" headers="r10c1-t39 r1c3-t39">
<p>no</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r11c1-t39" headers="r1c1-t39">
<p>expansion</p>
</td>
<td class="cellalignment98" headers="r11c1-t39 r1c2-t39">
<p>MDATA(a, $b)</p>
<p>MDATA(a, b%)</p>
<p>MDATA(a, !b)</p>
<p>MDATA(a, ?b)</p>
</td>
<td class="cellalignment98" headers="r11c1-t39 r1c3-t39">
<p>no (syntactically allowed, but the inner operator is treated as literal text)</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r12c1-t39" headers="r1c1-t39">
<p>ABOUT</p>
</td>
<td class="cellalignment98" headers="r12c1-t39 r1c2-t39">
<p>ABOUT(MDATA(a,b))</p>
<p>MDATA(ABOUT(a))</p>
</td>
<td class="cellalignment98" headers="r12c1-t39 r1c3-t39">
<p>no (syntactically allowed, but the inner operator is treated as literal text)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>When <code dir="ltr">MDATA</code> sections repeat, each instance is a separate and independent value. For instance, the document</p>
<pre dir="ltr">
&lt;AUTHOR&gt;Terry Pratchett&lt;/AUTHOR&gt;&lt;AUTHOR&gt;Douglas Adams&lt;/AUTHOR&gt;
</pre>
<p>can be found with any of the following queries:</p>
<pre dir="ltr">
MDATA(author, Terry Pratchett)
MDATA(author, Douglas Adams)
MDATA(author, Terry Pratchett) and MDATA(author, Douglas Adams)
</pre>
<p>but not any of the following:</p>
<pre dir="ltr">
MDATA(author, Terry Pratchett Douglas Adams)
MDATA(author, Terry Pratchett &amp; Douglas Adams)
MDATA(author, Pratchett Douglas)
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1028"></a>Related Topics</p>
<p>See also <a href="cddlpkg.htm#BJFHJFIJ">"ADD_MDATA"</a> and <a href="cddlpkg.htm#BJFFGAAA">"ADD_MDATA_SECTION"</a>, as well as the Section Searching chapter of the <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997714"></a>
<div id="CCREF0310" class="refsect1">
<h2 class="refsect1">MINUS (-)<a id="sthref1029"></a><a id="sthref1030"></a><a id="sthref1031"></a><a id="sthref1032"></a></h2>
<p>Use the <code dir="ltr">MINUS</code> operator to lower the score of documents that contain unwanted noise terms. <code dir="ltr">MINUS</code> is useful when you want to search for documents that contain one query term but want the presence of a second term to cause a document to be ranked lower.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1033"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="MINUS Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t40">Syntax</th>
<th class="cellalignment97" id="r1c2-t40">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t40" headers="r1c1-t40"><span class="variable">term1</span>-<span class="variable">term2</span>
<p><span class="variable">term1</span> minus <span class="variable">term2</span></p>
</td>
<td class="cellalignment98" headers="r2c1-t40 r1c2-t40">Returns documents that contain <span class="italic">term1</span>. Calculates score by subtracting the score of <span class="italic">term2</span> from the score of <span class="italic">term1</span>. Only documents with positive score are returned.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1034"></a>Example</p>
<p>Suppose a query on the term <span class="italic">cars</span> always returned high scoring documents about <span class="italic">Ford cars</span>. You can lower the scoring of the Ford documents by using the expression:</p>
<pre dir="ltr">
'cars - Ford'
</pre>
<p>In essence, this expression returns documents that contain the term <span class="italic">cars</span> and possibly <span class="italic">Ford.</span> However, the score for a returned document is the score of <span class="italic">cars</span> minus the score of <span class="italic">Ford</span>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1035"></a>Related Topics</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997901">"NOT (~)"</a></div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CHDCGJAE"></a>
<div id="CCREF23848" class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">MNOT</h2>
<p>The Mild Not (<code dir="ltr">MNOT</code>) operator is similar to the <code dir="ltr">NOT</code> and <code dir="ltr">MINUS</code> operators. The Mild Not operator returns hits where the the left child is not contained by the right child. Both children can only be <code dir="ltr">TERM</code> or <code dir="ltr">PHRASE</code> nodes.</p>
<p>The semantics can be illustrated with a query of "term1 mnot term1 term2", where the hits for "term1 term2" will be filtered out. For example:</p>
<ul>
<li>
<p>A document with only <span class="italic">term1</span> will be returned, with score unchanged.</p>
</li>
<li>
<p>A document with only <span class="italic">term1</span> <span class="italic">term2</span> will not be returned.</p>
</li>
<li>
<p>A document with <span class="italic">term1</span> <span class="italic">term1</span> <span class="italic">term2</span> will be returned, but the score will be calculated using just the first <span class="italic">term1</span> hit.</p>
</li>
</ul>
<p>The behavior described in the third bullet is different from the behavior of <code dir="ltr">NOT</code>, which does not return this type of document.</p>
<p>The <code dir="ltr">MNOT</code> operator is more specific than the <code dir="ltr">MINUS</code> operator, in that the left child must be contained by the right child. If it is not, the Mild Not operator ignores the right child. Also, for Mild Not, the right child is a true filter, that is, it does not simply subtract the scores of left child and right child.</p>
<p>The <code dir="ltr">MNOT</code> operator has precedence lower than <code dir="ltr">NOT</code> and higher than <code dir="ltr">WITHIN</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1036"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" summary="MNOT Operator" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t42">Syntax</th>
<th class="cellalignment97" id="r1c2-t42">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t42" headers="r1c1-t42"><span class="variable">term1</span> mnot <span class="variable">term1 term2</span></td>
<td class="cellalignment98" headers="r2c1-t42 r1c2-t42">Returns docs that contain <span class="italic">term1</span> unless it is part of the phrase <span class="italic">term1</span> <span class="italic">term2</span>.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t42" headers="r1c1-t42"><span class="italic">term1</span> mnot <span class="italic">term2</span></td>
<td class="cellalignment98" headers="r3c1-t42 r1c2-t42">Returns all documents that contain <span class="italic">term1</span>. It will be the same query as just <span class="italic">term1</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1037"></a>Example</p>
<p>The children of the <code dir="ltr">MNOT</code> operator must be a <code dir="ltr">TERM</code> or <code dir="ltr">PHRASE</code>.</p>
<pre dir="ltr">
SELECT * FROM docs
WHERE CONTAINS(txt, 'term1 mnot term1 term2') &gt;0
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1038"></a>Related Topics</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997901">"NOT (~)"</a></div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="BABDCIIC"></a>
<div id="CCREF0311" class="refsect1">
<h2 class="refsect1">Narrower Term (NT, NTG, NTP, NTI)<a id="sthref1039"></a><a id="sthref1040"></a><a id="sthref1041"></a><a id="sthref1042"></a><a id="sthref1043"></a><a id="sthref1044"></a><a id="sthref1045"></a></h2>
<p>Use the narrower term operators (<code dir="ltr">NT</code>, <code dir="ltr">NTG</code>, <code dir="ltr">NTP</code>, <code dir="ltr">NTI</code>) to expand a query to include all the terms that have been defined in a thesaurus as the narrower or lower level terms for a specified term. They can also expand the query to include all of the narrower terms for each narrower term, and so on down through the thesaurus hierarchy.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1046"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="NT Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t44">Syntax</th>
<th class="cellalignment97" id="r1c2-t44">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t44" headers="r1c1-t44">NT(<span class="variable">term</span>[(<span class="variable">qualifier</span>)][,<span class="variable">level</span>][,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r2c1-t44 r1c2-t44">Expands a query to include all the lower level terms defined in the thesaurus as narrower terms for <span class="syntaxinline">term</span><span class="italic">.</span></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t44" headers="r1c1-t44">NTG(<span class="variable">term</span>[(<span class="variable">qualifier</span>)][,<span class="variable">level</span>][,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r3c1-t44 r1c2-t44">Expands a query to include all the lower level terms defined in the thesaurus as narrower generic terms for <span class="syntaxinline">term</span><span class="italic">.</span></td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t44" headers="r1c1-t44">NTP(<span class="variable">term</span>[(<span class="variable">qualifier</span>)][,<span class="variable">level</span>][,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r4c1-t44 r1c2-t44">Expands a query to include all the lower level terms defined in the thesaurus as narrower partitive terms for <span class="syntaxinline">term</span>.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t44" headers="r1c1-t44">NTI(<span class="variable">term</span>[(<span class="variable">qualifier</span>)][,<span class="variable">level</span>][,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r5c1-t44 r1c2-t44">Expands a query to include all the lower level terms defined in the thesaurus as narrower instance terms for <span class="syntaxinline">term</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>term</dt>
<dd>
<p>Specify the operand for the narrower term operator. <code dir="ltr">term</code> is expanded to include the narrower term entries defined for the term in the thesaurus specified by <code dir="ltr">thes</code>. The number of narrower terms included in the expansion is determined by the value for <code dir="ltr">level</code>. You cannot specify expansion operators in the <code dir="ltr">term</code> argument.</p>
</dd>
<dt>qualifier</dt>
<dd>
<p>Specify a qualifier for <code dir="ltr">term</code>, if <code dir="ltr">term</code> is a homograph (word or phrase with multiple meanings, but the same spelling) that appears in two or more nodes in the same hierarchy branch of <code dir="ltr">thes</code>.</p>
<p>If a qualifier is not specified for a homograph in a narrower term query, the query expands to include all of the narrower terms of all homographic terms.</p>
</dd>
<dt>level</dt>
<dd>
<p>Specify the number of levels traversed in the thesaurus hierarchy to return the narrower terms for the specified term. For example, a level of 1 in an <code dir="ltr">NT</code> query returns all the narrower term entries, if any exist, for the specified term. A level of 2 returns all the narrower term entries for the specified term, as well as all the narrower term entries, if any exist, for each narrower term.</p>
<p>The level argument is optional and has a default value of one (1). Zero or negative values for the level argument return only the original query term.</p>
</dd>
<dt>thes</dt>
<dd>
<p>Specify the name of the thesaurus used to return the expansions for the specified term. <a id="sthref1047"></a>The <span class="syntaxinline">thes</span> argument is optional and has a default value of <code dir="ltr">DEFAULT</code>. A thesaurus named <code dir="ltr">DEFAULT</code> <span class="italic">must</span> exist in the thesaurus tables if you use this default value.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you specify <code dir="ltr">thes</code>, then you must also specify <code dir="ltr">level</code>.</div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1048"></a>Examples</p>
<p>The following query returns all documents that contain either the term <span class="italic">cat</span> or any of the <code dir="ltr">NT</code> terms defined for <span class="italic">cat</span> in the <code dir="ltr">DEFAULT</code> thesaurus:</p>
<pre dir="ltr">
'NT(cat)'
</pre>
<p>If you specify a thesaurus name, then you must also specify <code dir="ltr">level</code> as in:</p>
<pre dir="ltr">
'NT(cat, 2, mythes)'
</pre>
<p>The following query returns all documents that contain either <span class="italic">fairy tale</span> or any of the narrower instance terms for <span class="italic">fairy tale</span> as defined in the <code dir="ltr">DEFAULT</code> thesaurus:</p>
<pre dir="ltr">
'NTI(fairy tale)'
</pre>
<p>That is, if the terms <span class="italic">cinderella</span> and <span class="italic">snow white</span> are defined as narrower term instances for <span class="italic">fairy tale</span>, Oracle Text returns documents that contain <span class="italic">fairy tale, cinderella,</span> or <span class="italic">snow white.</span></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1049"></a>Notes</p>
<p>Each hierarchy in a thesaurus represents a distinct, separate branch, corresponding to the four narrower term operators. In a narrower term query, Oracle Text only expands the query using the branch corresponding to the specified narrower term operator.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1050"></a>Related Topics</p>
<p>Browse a thesaurus using procedures in the <code dir="ltr">CTX_THES</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
CTX_THES.<a href="cthes.htm#i997685">NT</a> in <a href="cthes.htm#g1010323">Chapter 12, "CTX_THES Package"</a> for more information on browsing the narrower terms in your thesaurus</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="CCHDHHBE"></a>
<div class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">NDATA</h2>
<p>Use the <code dir="ltr">NDATA</code> operator to find matches that are spelled in a similar way or where rearranging the terms of the specified phrase is useful. It is helpful for finding more accurate results when there are frequent misspellings (or inaccurate orderings) of name data in the document set. This operator can be used only on defined <code dir="ltr">NDATA</code> sections. The <code dir="ltr">NDATA</code> syntax enables you to rank the result set so that documents that contain words with high orthographic similarity are scored higher than documents with lower similarity.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1051"></a>Normalization</p>
<p>A lexer does not process <code dir="ltr">NDATA</code> query phrases. Users can, however, set base letter and alternate spelling attributes for a particular section group containing <code dir="ltr">NDATA</code> sections. Query case is normalized and non-character data (except for white space) is removed (for example, numerical or punctuation).</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1052"></a>Syntax</p>
<pre dir="ltr">
ndata(sectionname, phrase [,order][,proximity])
</pre>
<div class="inftblinformal">
<table class="cellalignment96" summary="Parameter values" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t47">Parameter Name</th>
<th class="cellalignment97" id="r1c2-t47">Default Value</th>
<th class="cellalignment97" id="r1c3-t47">Parameter Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t47" headers="r1c1-t47"><code dir="ltr">sectionname</code></td>
<td class="cellalignment98" headers="r2c1-t47 r1c2-t47">&nbsp;</td>
<td class="cellalignment98" headers="r2c1-t47 r1c3-t47">Specify the name of a defined <code dir="ltr">NDATA</code> sections to query (that is, <code dir="ltr">section_name</code>)</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t47" headers="r1c1-t47"><code dir="ltr">phrase</code></td>
<td class="cellalignment98" headers="r3c1-t47 r1c2-t47">&nbsp;</td>
<td class="cellalignment98" headers="r3c1-t47 r1c3-t47">Specify the phrase for the name data query.
<p>The phrase parameter can be a single word or a phrase, or a string of words in free text format.</p>
<p>The score returned is a relevant score.</p>
<p>Oracle Text ignores any query operators that are included in <code dir="ltr">phrase</code>.</p>
<p>The phrase should be a minimum of two characters in length and should not exceed 4000 characters in length.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t47" headers="r1c1-t47"><code dir="ltr">order</code></td>
<td class="cellalignment98" headers="r4c1-t47 r1c2-t47"><code dir="ltr">NOORDER</code></td>
<td class="cellalignment98" headers="r4c1-t47 r1c3-t47">Specify whether individual tokens (terms) in a query should be matched in-order or in any order. The order parameter provides a primary filter for matching candidate documents.
<p><code dir="ltr">ORDER</code> or <code dir="ltr">O</code> - The query terms are matched in-order.</p>
<p><code dir="ltr">NOORDER</code> o <code dir="ltr">N</code> [DEFAULT] - The query terms are matched in any order.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t47" headers="r1c1-t47"><code dir="ltr">proximity</code></td>
<td class="cellalignment98" headers="r5c1-t47 r1c2-t47"><code dir="ltr">NOPROXIMITY</code></td>
<td class="cellalignment98" headers="r5c1-t47 r1c3-t47">Specify whether the proximity of terms should influence the similarity score of candidate matches. That is, if the proximity parameter is enabled, non-matching additional terms between matching terms will reduce the similarity score of candidate matches.
<p><code dir="ltr">PROXIMITY</code> or <code dir="ltr">P</code> - The similarity score influenced by the proximity of query terms in candidate matches.</p>
<p><code dir="ltr">NOPROXIMITY</code> or <code dir="ltr">N</code> [DEFAULT] - The similarity score is not influenced by the proximity of query terms in candidate matches.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1053"></a>Examples</p>
<p>An <code dir="ltr">NDATA</code> query on an indexed surname section name that matches terms in the query phrase in any order without influencing the similarity score by the proximity of the black and smith terms has the form:</p>
<pre dir="ltr">
SELECT entryid, SCORE(1) FROM people WHERE
CONTAINS(idx_column, 'NDATA(surname, black smith)',1)&gt;0;
</pre>
<p>An <code dir="ltr">NDATA</code> query on an indexed surname section name that matches terms in the query phrase in any order and in which similarity scores are influenced by the proximity of the black and smith terms has the form:</p>
<pre dir="ltr">
SELECT entryid, SCORE(1) FROM people WHERE
CONTAINS(idx_column, 'NDATA(surname, black smith,,proximity)',1)&gt;0;
</pre>
<p>An <code dir="ltr">NDATA</code> query on an indexed surname section name that matches terms in the query phrase in-order without influencing the similarity score by the proximity of the black and smith terms has the form:</p>
<pre dir="ltr">
SELECT entryid, SCORE(1) FROM people WHERE
CONTAINS(idx_column, 'NDATA(surname, black smith, order)',1)&gt;0;
</pre>
<p>An <code dir="ltr">NDATA</code> query on an indexed surname section name that matches terms in the query phrase in-order and in which similarity scores are influenced by the proximity of the black and smith terms has the form:</p>
<pre dir="ltr">
SELECT entryid, SCORE(1) FROM people WHERE
CONTAINS(idx_column, 'NDATA(surname, black smith, order, proximity)',1)&gt;0;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1054"></a>Notes</p>
<p>The <code dir="ltr">NDATA</code> query operator does not provide offset information. As such, it cannot be used as a child of <code dir="ltr">WITHIN</code>, <code dir="ltr">NEAR(;)</code>, or <code dir="ltr">EQUIV(=)</code>, and <code dir="ltr">NDATA</code> sections will be ignored by <code dir="ltr">CTX_DOC.HIGHLIGHT</code>, <code dir="ltr">CTX_DOC.SNIPPET</code>, and <code dir="ltr">CTX_DOC.MARKUP</code>. The <code dir="ltr">NDATA</code> operator also is not supported in the <code dir="ltr">CTXCAT</code> grammar. It can be used with other operators, including <code dir="ltr">OR</code> and query templates.</p>
<p>A use case of the <code dir="ltr">NDATA</code> operator may involve finding a particular entry based on an approximate spelling of a person's full-name and an estimated date-of-birth. Supposing the entries' date-of-births are stored as an <code dir="ltr">SDATA</code> section, user-defined scoring's alternate scoring template can be used to combine the scores of the full-name's <code dir="ltr">NDATA</code> section data and the date-of-birth's <code dir="ltr">SDATA</code> section data.</p>
<p>The name john smith is queried for the section specified by the fullname section_name. Altering the <code dir="ltr">NDATA</code> operator's score based on the closeness of the <code dir="ltr">SDATA</code> section's date-of-birth to the date 08-NOV-2005 modifies the ranking of matching documents:</p>
<pre dir="ltr">
&lt;query&gt;
   &lt;textquery grammar="CONTEXT" lang="english"&gt;
       NDATA(fullname, john smith)
   &lt;/textquery&gt;
   &lt;score algorithm="COUNT" normalization_expr = 
       "doc_score-(DATE(8-NOV-2005)-sdata:dob)"/&gt;
&lt;/query&gt;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997808"></a>
<div id="CCREF0313" class="refsect1">
<h2 class="refsect1">NEAR (;)</h2>
<p>Use the <code dir="ltr">NEAR</code> operator to return a score based on the proximity of two or more query terms. Oracle Text returns higher scores for terms closer together and lower scores for terms farther apart in a document.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">NEAR</code> operator works with only word queries. You cannot use <code dir="ltr">NEAR</code> in <code dir="ltr">ABOUT</code> queries.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1055"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="NEAR Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t49">Syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t49" headers="r1c1-t49">NEAR((<span class="variable">word1</span>, <span class="variable">word2</span>,..., <span class="variable">wordn</span>) [, max_span [, order]])
<p>Backward compatibility syntax: <span class="italic">word1; word2</span></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>word<span class="italic">1-n</span></dt>
<dd>
<p>Specify the terms in the query separated by commas. The query terms can be single words or phrases and may make use of other query operators (see <a href="#CHDFBBEH">"NEAR with Other Operators"</a>).</p>
</dd>
<dt>max_span <a id="sthref1056"></a><a id="sthref1057"></a></dt>
<dd>
<p>Optionally specify the size of the biggest clump. The default is 100. Oracle Text returns an error if you specify a number greater than 100.</p>
<p>A clump is the smallest group of words in which all query terms occur. All clumps begin and end with a query term.</p>
<p>For near queries with two terms, <code dir="ltr">max_span</code> is the maximum distance allowed between the two terms. For example, to query on <span class="italic">dog</span> and <span class="italic">cat</span> where <span class="italic">dog</span> is within 6 words of <span class="italic">cat</span>, enter the following query:</p>
<pre dir="ltr">
'near((dog, cat), 6)'
</pre></dd>
<dt>order</dt>
<dd>
<p>Specify <code dir="ltr">TRUE</code> for Oracle Text to search for terms in the order you specify. The default is <code dir="ltr">FALSE</code>.</p>
<p>For example, to search for the words <span class="italic">monday</span>, <span class="italic">tuesday</span>, and <span class="italic">wednesday</span> in that order with a maximum clump size of 20, enter the following query:</p>
<pre dir="ltr">
'near((monday, tuesday, wednesday), 20, TRUE)'
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To specify <code dir="ltr">order</code>, then you must always specify a number for <code dir="ltr">max_span</code>.</div>
<p>Oracle Text might return different scores for the same document when you use identical query expressions that have the <code dir="ltr">order</code> flag set differently. For example, Oracle Text might return different scores for the same document when you enter the following queries:</p>
<pre dir="ltr">
'near((dog, cat), 50, FALSE)'
'near((dog, cat), 50, TRUE)'
</pre></dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1058"></a>NEAR Scoring<a id="sthref1059"></a><a id="sthref1060"></a></p>
<p>The scoring for the <code dir="ltr">NEAR</code> operator combines frequency of the terms with proximity of terms. For each document that satisfies the query, Oracle Text returns a score between 1 and 100 that is proportional to the number of clumps in the document and inversely proportional to the average size of the clumps. This means many small clumps in a document result in higher scores, because small clumps imply closeness of terms.</p>
<p>The number of terms in a query also affects score. Queries with many terms, such as seven, generally need fewer clumps in a document to score 100 than do queries with few terms, such as two.</p>
<p>A<a id="sthref1061"></a> <span class="italic">clump</span> is the smallest group of words in which all query terms occur. All clumps begin and end with a query term. Define clump size with the <code dir="ltr">max_span</code> parameter, as described in this section.</p>
<p>The size of a clump does not include the query terms themselves. So for the query <code dir="ltr">NEAR((DOG, CAT), 1)</code>, <span class="italic">dog cat</span> will be a match, and <span class="italic">dog ate cat</span> will be a match, but <span class="italic">dog sat on cat</span> will <span class="italic">not</span> be a match.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="CHDFBBEH"></a>NEAR with Other Operators<a id="sthref1062"></a><a id="sthref1063"></a><a id="sthref1064"></a></p>
<p>You can use the <code dir="ltr">NEAR</code> operator with other operators such as <code dir="ltr">AND</code> and <code dir="ltr">OR</code>. Scores are calculated in the regular way.</p>
<p>For example, to find all documents that contain the terms <span class="italic">tiger</span>, <span class="italic">lion</span>, and <span class="italic">cheetah</span> where the terms <span class="italic">lion</span> and <span class="italic">tiger</span> are within 10 words of each other, enter the following query:</p>
<pre dir="ltr">
'near((lion, tiger), 10) AND cheetah'
</pre>
<p>The score returned for each document is the lower score of the near operator and the term <span class="italic">cheetah</span>.</p>
<p>You can also use the equivalence operator to substitute a single term in a near query:</p>
<pre dir="ltr">
'near((stock crash, Japan=Korea), 20)'
</pre>
<p>This query asks for all documents that contain the phrase <span class="italic">stock crash</span> within twenty words of <span class="italic">Japan</span> or <span class="italic">Korea</span>.</p>
<p>The following <code dir="ltr">NEAR</code> syntax is now valid:</p>
<pre dir="ltr">
SELECT * FROM docs WHERE CONTAINS(txt, 'near((aterm1 aterm2 ... atermI 
OR bterm1 bterm2 ... btermJ
OR cterm1 cterm2 ... ctermK, dterm))') &gt;0
</pre>
<p>There can be any number of <code dir="ltr">OR</code>s in a given <code dir="ltr">NEAR</code> child, and the <code dir="ltr">OR</code> can appear in any of the <code dir="ltr">NEAR</code> children.</p>
<p>The <code dir="ltr">NEAR</code> within <code dir="ltr">NEAR</code> feature allows users to use nested proximity queries. Users can execute queries such as the following:</p>
<pre dir="ltr">
SELECT * FROM docs 
WHERE CONTAINS(txt, 'near((near((term1, term2),5), term3), 100)')&gt;0
</pre>
<p>This will return documents where <span class="italic">term1</span>, <span class="italic">term2</span>, and <span class="italic">term3</span> are near within a 100 token window and, additionally, the tokens <span class="italic">term1</span> and <span class="italic">term2</span> are near within a 5 token window.</p>
<p>Mixing the semicolon and <code dir="ltr">NEAR</code> syntax is not supported and will throw an error. That is, the queries <code dir="ltr">"near((a;b,c),3)" or "near((a,b));c"</code> will be disallowed.</p>
<p>The following operators also work with <code dir="ltr">NEAR</code> and <code dir="ltr">;</code> :</p>
<ul>
<li>
<p><code dir="ltr">EQUIV</code></p>
</li>
<li>
<p>All expansion operators that produce words, phrases, or <code dir="ltr">EQUIV</code>. These include:</p>
<ul>
<li>
<p>soundex</p>
</li>
<li>
<p>fuzzy</p>
</li>
<li>
<p>wildcards</p>
</li>
<li>
<p>stem</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1065"></a>Backward Compatibility NEAR Syntax<a id="sthref1066"></a></p>
<p>You can write near queries using the syntax of previous Oracle Text releases. For example, to find all documents where <span class="italic">lion</span> occurs near <span class="italic">tiger</span>, write:</p>
<pre dir="ltr">
'lion near tiger'
</pre>
<p>or with the semi-colon as follows:</p>
<pre dir="ltr">
'lion;tiger'
</pre>
<p>This query is equivalent to the following query:</p>
<pre dir="ltr">
'near((lion, tiger), 100, FALSE)'
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Only the syntax of the <code dir="ltr">NEAR</code> operator is backward compatible. In the example, the score returned is calculated using the clump method as described in this section.</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1067"></a>Highlighting with the NEAR Operator<a id="sthref1068"></a><a id="sthref1069"></a></p>
<p>When you use highlighting and your query contains the <code dir="ltr">near</code> operator, all occurrences of all terms in the query that satisfy the proximity requirements are highlighted. Highlighted terms can be single words or phrases.</p>
<p>For example, assume a document contains the following text:</p>
<pre dir="ltr">
Chocolate and vanilla are my favorite ice cream flavors.  I like chocolate served
in a waffle cone, and vanilla served in a cup with carmel syrup.
</pre>
<p>If the query is <span class="italic">near((chocolate, vanilla)), 100, FALSE),</span> the following is highlighted:</p>
<pre dir="ltr">
&lt;&lt;Chocolate&gt;&gt; and &lt;&lt;vanilla&gt;&gt; are my favorite ice cream flavors.  I like
&lt;&lt;chocolate&gt;&gt; served in a waffle cone, and &lt;&lt;vanilla&gt;&gt; served in a cup with
caramel syrup.
</pre>
<p>However, if the query is <span class="italic">near((chocolate, vanilla)), 4, FALSE),</span> only the following is highlighted:</p>
<pre dir="ltr">
&lt;&lt;Chocolate&gt;&gt; and &lt;&lt;vanilla&gt;&gt; are my favorite ice cream flavors.  I like
chocolate served in a waffle cone, and vanilla served in a cup with carmel syrup.
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cdocpkg.htm#CEGCIDAJ">Chapter 8, "CTX_DOC Package"</a> for more information about the procedures for highlighting</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1070"></a>Section Searching and NEAR</p>
<p>Use the <code dir="ltr">NEAR</code> operator with the <code dir="ltr">WITHIN</code> operator for section searching as follows:</p>
<pre dir="ltr">
'near((dog, cat), 10) WITHIN Headings'
</pre>
<p>When evaluating expressions such as these, Oracle Text looks for clumps that lie entirely within the given section.</p>
<p>In this example, only those clumps that contain <span class="italic">dog</span> and <span class="italic">cat</span> that lie entirely within the section <span class="italic">Headings</span> are counted. That is, if the term <span class="italic">dog</span> lies within <span class="italic">Headings</span> and the term <span class="italic">cat</span> lies five words from <span class="italic">dog</span>, but outside of <span class="italic">Headings</span>, this pair of words does not satisfy the expression and is not counted.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997901"></a>
<div id="CCREF0317" class="refsect1">
<h2 class="refsect1">NOT (~)<a id="sthref1071"></a><a id="sthref1072"></a><a id="sthref1073"></a></h2>
<p>Use the <code dir="ltr">NOT</code> operator to search for documents that contain one query term and not another.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1074"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="NOT Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t53">Syntax</th>
<th class="cellalignment97" id="r1c2-t53">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t53" headers="r1c1-t53"><span class="variable">term1</span>~<span class="variable">term2</span>
<p><span class="variable">term1</span> not <span class="variable">term2</span></p>
</td>
<td class="cellalignment98" headers="r2c1-t53 r1c2-t53">Returns documents that contain <span class="italic">term1</span> and not <span class="italic">term2</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1075"></a>Examples</p>
<p>To obtain the documents that contain the term <span class="italic">animals</span> but not <span class="italic">dogs</span>, use the following expression:</p>
<pre dir="ltr">
'animals ~ dogs'
</pre>
<p>Similarly, to obtain the documents that contain the term <span class="italic">transportation</span> but not <span class="italic">automobiles</span> or <span class="italic">trains</span>, use the following expression:</p>
<pre dir="ltr">
'transportation not (automobiles or trains)'
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">NOT</code> operator does not affect the scoring produced by the other logical operators.</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1076"></a>Related Topics</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997714">"MINUS (-)"</a></div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i997930"></a>
<div id="CCREF0319" class="refsect1">
<h2 class="refsect1">OR (|)<a id="sthref1077"></a><a id="sthref1078"></a><a id="sthref1079"></a></h2>
<p>Use the <code dir="ltr">OR</code> operator to search for documents that contain at least one occurrence of <span class="italic">any</span> of the query terms.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1080"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="OR Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t56">Syntax</th>
<th class="cellalignment97" id="r1c2-t56">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t56" headers="r1c1-t56"><span class="variable">term1</span>|<span class="variable">term2</span>
<p><span class="variable">term1</span> or <span class="variable">term2</span></p>
</td>
<td class="cellalignment98" headers="r2c1-t56 r1c2-t56">Returns documents that contain <span class="italic">term1</span> or <span class="italic">term2</span>. Returns the maximum score of its operands. At least one term must exist; higher score taken.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1081"></a>Examples</p>
<p>To obtain the documents that contain the term <span class="italic">cats</span> or the term <span class="italic">dogs</span>, use either of the following expressions:</p>
<pre dir="ltr">
'cats | dogs'
'cats OR dogs'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1082"></a>Scoring</p>
<p>In an <code dir="ltr">OR</code> query, the score returned is the score for the highest query term. In the example, if the scores for <span class="italic">cats</span> and <span class="italic">dogs</span> is 30 and 40 within a document, the document scores 40.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1083"></a>Related Topics</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The <code dir="ltr">OR</code> operator returns documents that contain <span class="italic">any</span> of the query terms, while the <code dir="ltr">AND</code> operator returns documents that contain <span class="italic">all</span> query terms. See <a href="#i997198">"AND (&amp;)"</a>.</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i999023"></a>
<div id="CCREF0321" class="refsect1">
<h2 class="refsect1">Preferred Term (PT)<a id="sthref1084"></a><a id="sthref1085"></a><a id="sthref1086"></a><a id="sthref1087"></a></h2>
<p>Use the preferred term operator (<code dir="ltr">PT</code>) to replace a term in a query with the preferred term that has been defined in a thesaurus for the term.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1088"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="PT Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t58">Syntax</th>
<th class="cellalignment97" id="r1c2-t58">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t58" headers="r1c1-t58">PT(<span class="variable">term</span>[,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r2c1-t58 r1c2-t58">Replaces the specified word in a query with the preferred term for <span class="italic">term</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>term</dt>
<dd>
<p>Specify the operand for the preferred term operator. <span class="syntaxinline">term</span> is replaced by the preferred term defined for the term in the specified thesaurus. However, if no <code dir="ltr">PT</code> entries are defined for the term, <span class="syntaxinline">term</span> is not replaced in the query expression and <span class="syntaxinline">term</span> is the result of the expansion.</p>
<p>You cannot specify expansion operators in the <code dir="ltr">term</code> argument.</p>
</dd>
<dt>thes</dt>
<dd>
<p>Specify the name of the thesaurus used to return the expansions for the specified term. The <span class="syntaxinline">thes</span> argument is optional and has a default value of <code dir="ltr">DEFAULT</code>. As a result, a thesaurus named <code dir="ltr">DEFAULT</code> <span class="italic">must</span> exist in the thesaurus tables before using any of the thesaurus operators.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1089"></a>Example</p>
<p>The term <span class="italic">automobile</span> has a preferred term of <span class="italic">car</span> in a thesaurus. A <code dir="ltr">PT</code> query for <span class="italic">automobile</span> returns all documents that contain the word <span class="italic">car</span>. Documents that contain the word <span class="italic">automobile</span> are not returned.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1090"></a>Related Topics</p>
<p>Browse a thesaurus using procedures in the <code dir="ltr">CTX_THES</code> package.</p>
</div>
<!-- class="refsubsect" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
CTX_THES.<a href="cthes.htm#i998005">PT</a> in <a href="cthes.htm#g1010323">Chapter 12, "CTX_THES Package"</a> form more information on browsing the preferred terms in your thesaurus</div>
</div>
<!-- class="refsect1" -->
<a id="i997990"></a>
<div id="CCREF0323" class="refsect1">
<h2 class="refsect1">Related Term (RT)<a id="sthref1091"></a><a id="sthref1092"></a><a id="sthref1093"></a><a id="sthref1094"></a></h2>
<p>Use the related term operator (<code dir="ltr">RT</code>) to expand a query to include all related terms that have been defined in a thesaurus for the term.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1095"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="RT Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t60">Syntax</th>
<th class="cellalignment97" id="r1c2-t60">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t60" headers="r1c1-t60">RT(<span class="variable">term</span>[,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r2c1-t60 r1c2-t60">Expands a query to include all the terms defined in the thesaurus as a related term for <code dir="ltr">term</code>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>term</dt>
<dd>
<p>Specify the operand for the related term operator. <code dir="ltr">term</code> is expanded to include <code dir="ltr">term</code> and all the related entries defined for <code dir="ltr">term</code> in <code dir="ltr">thes</code>.</p>
<p>You cannot specify expansion operators in the <code dir="ltr">term</code> argument.</p>
</dd>
<dt>thes</dt>
<dd>
<p>Specify the name of the thesaurus used to return the expansions for the specified term. The <code dir="ltr">thes</code> argument is optional and has a default value of <code dir="ltr">DEFAULT</code>. As a result, a thesaurus named <code dir="ltr">DEFAULT</code> <span class="italic">must</span> exist in the thesaurus tables before using any of the thesaurus operators.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1096"></a>Example</p>
<p>The term <span class="italic">dog</span> has a related term of <span class="italic">wolf</span>. An RT query for <span class="italic">dog</span> returns all documents that contain the word <span class="italic">dog</span> and <span class="italic">wolf</span>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1097"></a>Related Topics</p>
<p>Browse a thesaurus using procedures in the <code dir="ltr">CTX_THES</code> package</p>
</div>
<!-- class="refsubsect" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
CTX_THES.<a href="cthes.htm#i998069">RT</a> in <a href="cthes.htm#g1010323">Chapter 12, "CTX_THES Package"</a> for more information on browsing the related terms in your thesaurus</div>
</div>
<!-- class="refsect1" -->
<a id="CHDCBFHF"></a>
<div id="CCREF2089" class="refsect1">
<h2 class="refsect1">SDATA<a id="sthref1098"></a><a id="sthref1099"></a><a id="sthref1100"></a></h2>
<p>Use the <code dir="ltr">SDATA</code> operator to perform tests on <code dir="ltr">SDATA</code> sections and columns, which contain structured data values. <code dir="ltr">SDATA</code> sections speed up mixed querying and ordering. This operator provides structured predicate support for <code dir="ltr">CONTAINS</code>, which extends non-SQL interfaces such as <code dir="ltr">count_hits</code> or the result set interface.</p>
<p><code dir="ltr">SDATA</code> operators should only be used as descendants of <code dir="ltr">AND</code> operators that also have non-<code dir="ltr">SDATA</code> children.</p>
<p><code dir="ltr">SDATA</code> queries perform on string or numeric literals, and on date strings. The string literal and date string are enclosed within single or double quote characters. The numeric value is not enclosed in quote characters, and must conform to the SQL format of <code dir="ltr">NUMBER</code>. For example:</p>
<pre dir="ltr">
CONTAINS(text, "dog and SDATA(category = ''news'')")&gt;0 ...

SDATA(rating between 1.2 and 3.4) ...

SDATA(author LIKE 'FFORDE%') ...

SDATA(date &gt;='2005-09-18') ...
</pre>
<p>Closed parentheses are permitted, as long as they are enclosed in single or double quotes.</p>
<p>The <code dir="ltr">SDATA</code> operator can be used in query templates.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1101"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="SDATA Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t62">Syntax</th>
<th class="cellalignment97" id="r1c2-t62"><br /></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t62" headers="r1c1-t62">SData</td>
<td class="cellalignment98" headers="r2c1-t62 r1c2-t62">:= "SDATA" "(" SDataPredicate ")"</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t62" headers="r1c1-t62">SDataPredicate</td>
<td class="cellalignment98" headers="r3c1-t62 r1c2-t62">:= <span class="italic">sectionname</span> SDataTest</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t62" headers="r1c1-t62">SDataTest</td>
<td class="cellalignment98" headers="r4c1-t62 r1c2-t62">:= &lt;SDataSingleOp SDataLiteral&gt; | SDataBetweenOp | &lt;"is" ("not")? "null"&gt;</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t62" headers="r1c1-t62">SDataSingleOp</td>
<td class="cellalignment98" headers="r5c1-t62 r1c2-t62">:= ("&lt;" | "&lt;=" | "=" | "&gt;=" | "&gt;" | "!=" | "&lt;&gt;" | "like") SDataLiteral</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t62" headers="r1c1-t62">SDataBetweenOp</td>
<td class="cellalignment98" headers="r6c1-t62 r1c2-t62">:= "between" SDataLiteral "and" SDataLiteral</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t62" headers="r1c1-t62">SDataLiteral</td>
<td class="cellalignment98" headers="r7c1-t62 r1c2-t62">:= <span class="italic">numeric_literal</span> | "'" <span class="italic">string_literal</span> "'" | "'" <span class="italic">date_string</span> "'"</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>sectionname</dt>
<dd>
<p>The name of the <code dir="ltr">SDATA</code> section(s) on which to search and perform the test, or check.</p>
</dd>
<dt>SDataLiteral</dt>
<dd>
<p>The value of the <code dir="ltr">SDATA</code> section. This must be either a string literal, numeric literal, or a date string.</p>
<p>The <code dir="ltr">SDATA</code> operator returns a score of 100 if the enclosed predicate returns <code dir="ltr">TRUE</code>, and returns <code dir="ltr">0</code> otherwise. In the case of a <code dir="ltr">NULL</code> value, the <code dir="ltr">SDATA</code> operator returns a score of <code dir="ltr">0</code> (since in SQL it would not return <code dir="ltr">TRUE</code>).</p>
<p>Multi-valued semantics are not defined, as multi-valued <code dir="ltr">SDATA</code> sections are not supported.</p>
<p>Comparison of strings is case sensitive. The <code dir="ltr">BINARY</code> collation is always used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For the <code dir="ltr">SDATA</code> operator on <code dir="ltr">SDATA</code> sections that are mapped to a <code dir="ltr">DATE</code> <code dir="ltr">FILTER</code> <code dir="ltr">BY</code> column, the <code dir="ltr">SDATA</code> value must follow the Date format: <code dir="ltr">YYYY-MM-DD</code> or <code dir="ltr">YYYY-MM-DD HH24:MI:SS</code>. Otherwise, the expected rows will not be returned. If the time component is omitted, it will default to <code dir="ltr">00:00:00</code>, according to SQL semantics. This Date format is always used, regardless of the setting of the <code dir="ltr">NLS_DATE_FORMAT</code> environment variable.</div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1102"></a>Examples</p>
<p>Suppose that you want to query for books in the fiction category that contain the word <span class="italic">summer</span>. Assuming that an <code dir="ltr">SDATA</code> section called <code dir="ltr">CATEGORY</code> has been declared, you can query as follows:</p>
</div>
<!-- class="refsubsect" -->
<pre dir="ltr">
SELECT id FROM idx_docs
  WHERE CONTAINS(text, 'summer AND SDATA(category = "fiction")')&gt;0
</pre>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1103"></a>Restrictions</p>
<ul>
<li>
<p>An error is raised if the section name is not a defined <code dir="ltr">SDATA</code> section. The source of the section (for example, tag versus column) is not important.</p>
</li>
<li>
<p>The syntax precludes <code dir="ltr">RHS</code> <code dir="ltr">SDATA</code> and expressions.</p>
</li>
<li>
<p><code dir="ltr">SDATA</code> operators cannot be children of <code dir="ltr">WITHIN</code>, <code dir="ltr">INPATH</code>, <code dir="ltr">HASPATH</code>, or <code dir="ltr">NEAR</code>.</p>
</li>
<li>
<p>The datatype of the named <code dir="ltr">SDATA</code> section must be compatible with the literal provided (and the operator, for example, <code dir="ltr">LIKE</code>) or an error is raised.</p>
</li>
<li>
<p><code dir="ltr">SDATA</code> operators are not supported in <code dir="ltr">CTXRULE</code> query documents.</p>
</li>
<li>
<p><code dir="ltr">SDATA</code> operators have no effect on highlighting.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1104"></a>Notes</p>
<p>Oracle recommends using <code dir="ltr">SDATA</code> operators only as descendants of <code dir="ltr">AND</code> operators that also have non-<code dir="ltr">SDATA</code> children. Essentially, use <code dir="ltr">SDATA</code> operators as secondary (that is, checking or non-driving) criteria. For instance, "find documents with DOG that also have price &gt; 5", rather than "find documents with rating &gt; 4". Other usage may operate properly, but may not have optimal performance.</p>
<p>The following examples are consistent with recommended use:</p>
<pre dir="ltr">
dog &amp; SDATA(foo = 5)
</pre>
<p>The <code dir="ltr">SDATA</code> is a child of an <code dir="ltr">AND</code> operator that also has non-<code dir="ltr">SDATA</code> children.</p>
<pre dir="ltr">
dog &amp; (SDATA(foo = 5) | SDATA(x = 1))
</pre>
<p>Although the <code dir="ltr">SDATA</code> operators here are children of <code dir="ltr">OR</code>, they are still descendants of an <code dir="ltr">AND</code> operator with non-<code dir="ltr">SDATA</code> children.</p>
<p>The following examples show use that is not recommended:</p>
<pre dir="ltr">
SDATA(foo = 5)
</pre>
<p>Here, <code dir="ltr">SDATA</code> is the only criteria and, therefore, the driving criteria.</p>
<pre dir="ltr">
dog | SDATA(bar = 9)
</pre>
<p>The <code dir="ltr">SDATA</code> in this example is a child of an <code dir="ltr">OR</code> operator rather than an <code dir="ltr">AND</code>.</p>
<pre dir="ltr">
SDATA(foo = 5) &amp; SDATA(bar = 7)
</pre>
<p>While both <code dir="ltr">SDATA</code> operators in this example are descendants of <code dir="ltr">AND</code>, this <code dir="ltr">AND</code> operator does not have non-<code dir="ltr">SDATA</code> children.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1105"></a>Related Topics</p>
<p><a href="cddlpkg.htm#CEGFAEJJ">ADD_SDATA_COLUMN</a></p>
<p><a href="cddlpkg.htm#CEGGBEIC">ADD_SDATA_SECTION</a></p>
<p><a href="aviews.htm#i8879">CTX_SECTIONS</a> in <a href="aviews.htm#CHDEIJFC">Appendix G, "Oracle Text Views"</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p>Chapter 8, "Searching Document Sections in Oracle Text" in <a class="olink CCAPP0800" href="../../text.112/e24435/csection.htm#CCAPP0800"><span class="italic">Oracle Text Application Developer's Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998027"></a>
<div id="CCREF0325" class="refsect1">
<h2 class="refsect1">soundex (!)<a id="sthref1106"></a><a id="sthref1107"></a><a id="sthref1108"></a></h2>
<p><a id="sthref1109"></a>Use the soundex (!) operator to expand queries to include words that have similar sounds; that is, words that sound like other words. This function enables comparison of words that are spelled differently, but sound alike in English.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1110"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="soundex Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t65">Syntax</th>
<th class="cellalignment97" id="r1c2-t65">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t65" headers="r1c1-t65">!<span class="variable">term</span></td>
<td class="cellalignment98" headers="r2c1-t65 r1c2-t65">Expands a query to include all terms that sound the same as the specified term (English-language text only).</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1111"></a>Example</p>
<pre dir="ltr">
SELECT ID, COMMENT FROM EMP_RESUME
WHERE CONTAINS (COMMENT, '!SMYTHE') &gt; 0 ;

ID COMMENT 
-- ------------
23 Smith is a hard worker who..
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1112"></a>Language</p>
<p>Soundex works best for languages that use a 7-bit character set, such as English. It can be used, with lesser effectiveness, for languages that use an 8-bit character set, such as many Western European languages.</p>
<p>If you have base-letter conversion specified for a text column and the query expression contains a soundex operator, then Oracle Text operates on the base-letter form of the query.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998055"></a>
<div id="CCREF0327" class="refsect1">
<h2 class="refsect1">stem ($)<a id="sthref1113"></a><a id="sthref1114"></a><a id="sthref1115"></a><a id="sthref1116"></a></h2>
<p>Use the stem ($) operator to search for terms that have the same linguistic root as the query term.</p>
<p>If you use the <code dir="ltr">BASIC_LEXER</code> to index your language, stemming performance can be improved by using the index_stems attribute.</p>
<p>The Oracle Text stemmer, licensed from XSoft Division of Xerox Corporation, supports the following languages with the <a href="cdatadic.htm#i1007615">BASIC_LEXER</a>: English, French, Spanish, Italian, German, and Dutch.</p>
<p><a id="sthref1117"></a><a id="sthref1118"></a>Japanese stemming is supported with the <a href="cdatadic.htm#i1008067">JAPANESE_LEXER</a>.</p>
<p>Specify your stemming language with the <a href="cdatadic.htm#i1008935">BASIC_WORDLIST</a> wordlist preference.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1119"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="stem Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t66">Syntax</th>
<th class="cellalignment97" id="r1c2-t66">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t66" headers="r1c1-t66">$<span class="variable">term</span></td>
<td class="cellalignment98" headers="r2c1-t66 r1c2-t66">Expands a query to include all terms having the same stem or root word as the specified term.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1120"></a>Examples</p>
<div class="inftblinformal">
<table class="cellalignment96" title="stem Syntax Examples" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t67">Input</th>
<th class="cellalignment97" id="r1c2-t67">Expands To</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t67" headers="r1c1-t67">$scream</td>
<td class="cellalignment98" headers="r2c1-t67 r1c2-t67">scream screaming screamed</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t67" headers="r1c1-t67">$distinguish</td>
<td class="cellalignment98" headers="r3c1-t67 r1c2-t67">distinguish distinguished distinguishes</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t67" headers="r1c1-t67">$guitars</td>
<td class="cellalignment98" headers="r4c1-t67 r1c2-t67">guitars guitar</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r5c1-t67" headers="r1c1-t67">$commit</td>
<td class="cellalignment98" headers="r5c1-t67 r1c2-t67">commit committed</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r6c1-t67" headers="r1c1-t67">$cat</td>
<td class="cellalignment98" headers="r6c1-t67 r1c2-t67">cat cats</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r7c1-t67" headers="r1c1-t67">$sing</td>
<td class="cellalignment98" headers="r7c1-t67 r1c2-t67">sang sung sing</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1121"></a>Behavior with Stopwords</p>
<p>If stem returns a word designated as a stopword, the stopword is not included in the query or highlighted by <code dir="ltr">CTX_QUERY.HIGHLIGHT</code> or <code dir="ltr">CTX_QUERY.MARKUP</code>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1122"></a>Related Topics</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about enabling the stem operator with BASIC_LEXER, see <a href="cdatadic.htm#i1007615">"BASIC_LEXER"</a> in <a href="cdatadic.htm#BHCDHIAI">Chapter 2, "Oracle Text Indexing Elements"</a>.</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="BABECGDJ"></a>
<div id="CCREF0329" class="refsect1">
<h2 class="refsect1">Stored Query Expression (SQE)<a id="sthref1123"></a><a id="sthref1124"></a><a id="sthref1125"></a><a id="sthref1126"></a></h2>
<p>Use the SQE operator to call a stored query expression created with the <code dir="ltr">CTX_QUERY.STORE_SQE</code> procedure.</p>
<p>Stored query expressions can be used for creating predefined bins for organizing and categorizing documents or to perform iterative queries, in which an initial query is refined using one or more additional queries.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1127"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="SQE Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t69">Syntax</th>
<th class="cellalignment97" id="r1c2-t69">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t69" headers="r1c1-t69">SQE(<span class="variable">SQE_name</span>)</td>
<td class="cellalignment98" headers="r2c1-t69 r1c2-t69">Returns the results for the stored query expression <span class="italic">SQE_name</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1128"></a>Examples</p>
<p><a id="sthref1129"></a>To create an SQE named <span class="italic">disasters</span>, use <code dir="ltr">CTX_QUERY.STORE_SQE</code> as follows:</p>
<pre dir="ltr">
begin
ctx_query.store_sqe('disasters', 'hurricane or earthquake or blizzard');
end;
</pre>
<p>This stored query expression returns all documents that contain either <span class="italic">hurricane</span>, <span class="italic">earthquake</span> or <span class="italic">blizzard</span>.</p>
<p>This SQE can then be called within a query expression as follows:</p>
<pre dir="ltr">
SELECT SCORE(1), docid FROM news
WHERE CONTAINS(resume, 'sqe(disasters)', 1)&gt; 0 
ORDER BY SCORE(1);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1130"></a>Limitations</p>
<p>Up to 100 stored query expressions (SQEs) can be stored in a single Text query. If a Text query has more than 100 SQEs, including nested SQEs, then the query fails and error DRG-50949 is raised.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998165"></a>
<div id="CCREF0331" class="refsect1">
<h2 class="refsect1">SYNonym (SYN)<a id="sthref1131"></a><a id="sthref1132"></a><a id="sthref1133"></a><a id="sthref1134"></a></h2>
<p>Use the synonym operator (<code dir="ltr">SYN</code>) to expand a query to include all the terms that have been defined in a thesaurus as synonyms for the specified term.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1135"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="SYN Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t70">Syntax</th>
<th class="cellalignment97" id="r1c2-t70">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t70" headers="r1c1-t70">SYN(<span class="variable">term</span>[,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r2c1-t70 r1c2-t70">Expands a query to include all the terms defined in the thesaurus as synonyms for <code dir="ltr">term</code>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>term</dt>
<dd>
<p>Specify the operand for the synonym operator. <code dir="ltr">term</code> is expanded to include <code dir="ltr">term</code> and all the synonyms defined for <code dir="ltr">term</code> in <code dir="ltr">thes</code>.</p>
<p>You cannot specify expansion operators in the <code dir="ltr">term</code> argument.</p>
</dd>
<dt>thes</dt>
<dd>
<p>Specify the name of the thesaurus used to return the expansions for the specified term. The <code dir="ltr">thes</code> argument is optional and has a default value of <code dir="ltr">DEFAULT</code>. A thesaurus named <code dir="ltr">DEFAULT</code> must exist in the thesaurus tables if you use this default value.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1136"></a>Examples</p>
<p>The following query expression returns all documents that contain the term <span class="italic">dog</span> or any of the synonyms defined for <span class="italic">dog</span> in the <code dir="ltr">DEFAULT</code> thesaurus:</p>
<pre dir="ltr">
'SYN(dog)'
</pre>
<p class="subhead1"><a id="CCREF23849"></a>Compound Phrases in Synonym Operator</p>
<p>Expansion of compound phrases for a term in a synonym query are returned as <code dir="ltr">AND</code> conjunctives.</p>
<p>For example, the compound phrase <span class="italic">temperature + measurement + instruments</span> is defined in a thesaurus as a synonym for the term <span class="italic">thermometer</span>. In a synonym query for <span class="italic">thermometer</span>, the query is expanded to:</p>
<pre dir="ltr">
{thermometer} OR ({temperature}&amp;{measurement}&amp;{instruments})
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1137"></a>Related Topics</p>
<p>Browse your thesaurus using procedures in the <code dir="ltr">CTX_THES</code> package.</p>
</div>
<!-- class="refsubsect" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
CTX_THES.<a href="cthes.htm#i998163">SYN</a> in <a href="cthes.htm#g1010323">Chapter 12, "CTX_THES Package"</a> for more information on browsing the synonym terms in your thesaurus</div>
</div>
<!-- class="refsect1" -->
<a id="i998207"></a>
<div id="CCREF0333" class="refsect1">
<h2 class="refsect1">threshold (&gt;)<a id="sthref1138"></a><a id="sthref1139"></a><a id="sthref1140"></a><a id="sthref1141"></a></h2>
<p>Use the threshold operator (&gt;) in two ways:</p>
<ul>
<li>
<p>at the expression level</p>
</li>
<li>
<p>at the query term level</p>
</li>
</ul>
<p>The threshold operator at the expression level eliminates documents in the result set that score below a threshold number.</p>
<p>The threshold operator at the query term level selects a document based on how a term scores in the document.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1142"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="threshold Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t72">Syntax</th>
<th class="cellalignment97" id="r1c2-t72">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t72" headers="r1c1-t72"><span class="italic">expression</span>&gt;n
<p><span class="italic">term</span>&gt;n</p>
</td>
<td class="cellalignment98" headers="r2c1-t72 r1c2-t72">Returns only those documents in the result set that score above the threshold <span class="italic">n</span>.
<p>Within an expression, returns documents that contain the query term with score of at least <span class="italic">n</span>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1143"></a>Examples</p>
<p>At the expression level, to search for documents that contain <span class="italic">relational databases</span> and to return only documents that score greater than 75, use the following expression:</p>
<pre dir="ltr">
'relational databases &gt; 75'
</pre>
<p>At the query term level, to select documents that have at least a score of 30 for <span class="italic">lion</span> and contain <span class="italic">tiger,</span> use the following expression:</p>
<pre dir="ltr">
'(lion &gt; 30) and tiger'
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998235"></a>
<div id="CCREF0335" class="refsect1">
<h2 class="refsect1">Translation Term (TR)<a id="sthref1144"></a><a id="sthref1145"></a><a id="sthref1146"></a><a id="sthref1147"></a></h2>
<p>Use the translation term operator (<code dir="ltr">TR</code>) to expand a query to include all defined foreign language equivalent terms.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1148"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="TR Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t73">Syntax</th>
<th class="cellalignment97" id="r1c2-t73">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t73" headers="r1c1-t73">TR(<span class="variable">term</span>[<span class="italic">, lang,</span> [<span class="variable">thes</span>]])</td>
<td class="cellalignment98" headers="r2c1-t73 r1c2-t73">Expands <span class="italic">term</span> to include all the foreign equivalents that are defined for <span class="italic">term</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>term</dt>
<dd>
<p>Specify the operand for the translation term operator. <code dir="ltr">term</code> is expanded to include all the foreign language entries defined for <code dir="ltr">term</code> in <code dir="ltr">thes</code>. You cannot specify expansion operators in the <code dir="ltr">term</code> argument.</p>
</dd>
<dt>lang</dt>
<dd>
<p>Optionally, specify which foreign language equivalents to return in the expansion. The language you specify must match the language as defined in <code dir="ltr">thes</code>. (You may specify only one language at a time.) If you omit this parameter or specify it as <code dir="ltr">ALL</code>, the system expands to use all defined foreign language terms.</p>
</dd>
<dt>thes</dt>
<dd>
<p>Optionally, specify the name of the thesaurus used to return the expansions for the specified term. The <code dir="ltr">thes</code> argument has a default value of <code dir="ltr">DEFAULT</code>. As a result, a thesaurus named <code dir="ltr">DEFAULT</code> <span class="italic">must</span> exist in the thesaurus tables before you can use any of the thesaurus operators.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you specify <code dir="ltr">thes</code>, then you must also specify <code dir="ltr">lang</code>.</div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1149"></a>Examples</p>
<p>Consider a thesaurus <code dir="ltr">MY_THES</code> with the following entries for <span class="italic">cat</span>:</p>
<pre dir="ltr">
cat 
  SPANISH: gato 
  FRENCH:  chat 
</pre>
<p>To search for all documents that contain <span class="italic">cat</span> and the spanish translation of <span class="italic">cat</span>, enter the following query:</p>
<pre dir="ltr">
'tr(cat, spanish, my_thes)'
</pre>
<p>This query expands to:</p>
<pre dir="ltr">
'{cat}|{gato}'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1150"></a>Related Topics</p>
<p>Browse a thesaurus using procedures in the <code dir="ltr">CTX_THES</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
CTX_THES.<a href="cthes.htm#i998280">TR</a> in <a href="cthes.htm#g1010323">Chapter 12, "CTX_THES Package"</a> for more information on browsing the related terms in your thesaurus</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998287"></a>
<div id="CCREF0337" class="refsect1">
<h2 class="refsect1">Translation Term Synonym (TRSYN)<a id="sthref1151"></a><a id="sthref1152"></a><a id="sthref1153"></a><a id="sthref1154"></a></h2>
<p>Use the translation term operator (<code dir="ltr">TR</code>) to expand a query to include all the defined foreign equivalents of the query term, the synonyms of query term, and the foreign equivalents of the synonyms.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1155"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="TRSYN Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t76">Syntax</th>
<th class="cellalignment97" id="r1c2-t76">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t76" headers="r1c1-t76">TRSYN(<span class="variable">term</span>[<span class="italic">, lang,</span> [<span class="variable">thes</span>]])</td>
<td class="cellalignment98" headers="r2c1-t76 r1c2-t76">Expands <code dir="ltr">term</code> to include foreign equivalents of <code dir="ltr">term</code>, the synonyms of <code dir="ltr">term</code>, and the foreign equivalents of the synonyms.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>term</dt>
<dd>
<p>Specify the operand for this operator. <code dir="ltr">term</code> is expanded to include all the foreign language entries and synonyms defined for <code dir="ltr">term</code> in <code dir="ltr">thes</code>. You cannot specify expansion operators in the <code dir="ltr">term</code> argument.</p>
</dd>
<dt>lang</dt>
<dd>
<p>Optionally, specify which foreign language equivalents to return in the expansion. The language you specify must match the language as defined in <code dir="ltr">thes</code>. If you omit this parameter, the system expands to use all defined foreign language terms.</p>
</dd>
<dt>thes</dt>
<dd>
<p>Optionally, specify the name of the thesaurus used to return the expansions for the specified term. The <code dir="ltr">thes</code> argument has a default value of <code dir="ltr">DEFAULT</code>. As a result, a thesaurus named <code dir="ltr">DEFAULT</code> <span class="italic">must</span> exist in the thesaurus tables before you can use any of the thesaurus operators.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you specify <code dir="ltr">thes</code>, then you must also specify <code dir="ltr">lang</code>.</div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1156"></a>Examples</p>
<p>Consider a thesaurus <code dir="ltr">MY_THES</code> with the following entries for <span class="italic">cat</span>:</p>
<pre dir="ltr">
cat 
  SPANISH: gato 
  FRENCH:  chat 
  SYN lion 
    SPANISH: leon 
</pre>
<p>To search for all documents that contain <span class="italic">cat</span>, the spanish equivalent of <span class="italic">cat</span>, the synonym of <span class="italic">cat</span>, and the spanish equivalent of <span class="italic">lion</span>, enter the following query:</p>
<pre dir="ltr">
'trsyn(cat, spanish, my_thes)'
</pre>
<p>This query expands to:</p>
<pre dir="ltr">
'{cat}|{gato}|{lion}|{leon}'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1157"></a>Related Topics</p>
<p>Browse a thesaurus using procedures in the <code dir="ltr">CTX_THES</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
CTX_THES.<a href="cthes.htm#i998365">TRSYN</a> in <a href="cthes.htm#g1010323">Chapter 12, "CTX_THES Package"</a> for more information on browsing the translation and synonym terms in your thesaurus</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998342"></a>
<div id="CCREF0339" class="refsect1">
<h2 class="refsect1">Top Term (TT)<a id="sthref1158"></a><a id="sthref1159"></a><a id="sthref1160"></a><a id="sthref1161"></a></h2>
<p>Use the top term operator (<code dir="ltr">TT</code>) to replace a term in a query with the <span class="italic"><a id="sthref1162"></a>top term</span> that has been defined for the term in the standard hierarchy (Broader Term [<code dir="ltr">BT</code>], Narrower Term [<code dir="ltr">NT]</code>) in a thesaurus. A top term is the broadest conceptual term related to a given query term. For example, a thesaurus might define the following hierarchy:</p>
<pre dir="ltr">
DOG 
   BT1 CANINE 
     BT2 MAMMAL 
       BT3 VERTEBRATE 
         BT4 ANIMAL
</pre>
<p>The top term for <span class="italic">dog</span> in this thesaurus is <span class="italic">animal</span>.</p>
<p>Top terms in the generic (<code dir="ltr">BTG</code>, <code dir="ltr">NTG</code>), partitive (<code dir="ltr">BTP</code>, <code dir="ltr">NTP</code>), and instance (<code dir="ltr">BTI</code>, <code dir="ltr">NTI</code>) hierarchies are not returned.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1163"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="TT Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t79">Syntax</th>
<th class="cellalignment97" id="r1c2-t79">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t79" headers="r1c1-t79">TT(<span class="variable">term</span>[,<span class="variable">thes</span>])</td>
<td class="cellalignment98" headers="r2c1-t79 r1c2-t79">Replaces the specified word in a query with the top term in the standard hierarchy (<code dir="ltr">BT</code>, <code dir="ltr">NT</code>) for <span class="syntaxinline">term</span>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<dl>
<dt>term</dt>
<dd>
<p>Specify the operand for the top term operator. <code dir="ltr">term</code> is replaced by the top <code dir="ltr">term</code> defined for the term in the specified thesaurus. However, if no <code dir="ltr">TT</code> entries are defined for <code dir="ltr">term</code>, <code dir="ltr">term</code> is not replaced in the query expression and <code dir="ltr">term</code> is the result of the expansion.</p>
<p>You cannot specify expansion operators in the <code dir="ltr">term</code> argument.</p>
</dd>
<dt>thes</dt>
<dd>
<p>Specify the name of the thesaurus used to return the expansions for the specified term. The <code dir="ltr">thes</code> argument is optional and has a default value of <code dir="ltr">DEFAULT</code>. A thesaurus named <code dir="ltr">DEFAULT</code> must exist in the thesaurus tables if you use this default value.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1164"></a>Example</p>
<p>The term <span class="italic">dog</span> has a top term of <span class="italic">animal</span> in the standard hierarchy of a thesaurus. A <code dir="ltr">TT</code> query for <span class="italic">dog</span> returns all documents that contain the phrase <span class="italic">animal</span>. Documents that contain the word <span class="italic">dog</span> are not returned.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1165"></a>Related Topics</p>
<p>Browse your thesaurus using procedures in the <code dir="ltr">CTX_THES</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
CTX_THES.<a href="cthes.htm#i998450">TT</a> for more information on browsing the top terms in your thesaurus</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998379"></a>
<div id="CCREF0341" class="refsect1">
<h2 class="refsect1">weight (*)<a id="sthref1166"></a><a id="sthref1167"></a><a id="sthref1168"></a><a id="sthref1169"></a></h2>
<p>The weight operator multiplies the score by the given factor, topping out at 100 when the score exceeds 100. For example, the query <span class="italic">cat, dog*2</span> sums the score of <span class="italic">cat</span> with twice the score of <span class="italic">dog</span>, topping out at 100 when the score is greater than 100.</p>
<p>In expressions that contain more than one query term, use the weight operator to adjust the relative scoring of the query terms. Reduce the score of a query term by using the weight operator with a number less than 1; increase the score of a query term by using the weight operator with a number greater than 1 and less than 10.</p>
<p>The weight operator is useful in <a href="#i997062">ACCUMulate ( , )</a>, <a href="#i997198">AND (&amp;)</a>, or <a href="#i997930">OR (|)</a> queries when the expression has more than one query term. With no weighting on individual terms, the score cannot tell which of the query terms occurs the most. With term weighting, you can alter the scores of individual terms and hence make the overall document ranking reflect the terms you are interested in.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1170"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="weight Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t81">Syntax</th>
<th class="cellalignment97" id="r1c2-t81">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t81" headers="r1c1-t81"><span class="variable">term</span>*<span class="variable">n</span></td>
<td class="cellalignment98" headers="r2c1-t81 r1c2-t81">Returns documents that contain <code dir="ltr">term</code>. Calculates score by multiplying the raw score of <code dir="ltr">term</code> by <span class="syntaxinline">n</span>, where <span class="syntaxinline">n</span> is a number from 0.1 to 10.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1171"></a>Examples</p>
<p>Suppose you have a collection of sports articles. You are interested in the articles about Brazilian soccer. It turns out that a regular query on <span class="italic">soccer or Brazil</span> returns many high ranking articles on US soccer. To raise the ranking of the articles on Brazilian soccer, enter the following query:</p>
<pre dir="ltr">
'soccer or Brazil*3'
</pre>
<p><a href="#g1024843">Table 3-3</a> illustrates how the weight operator can change the ranking of three hypothetical documents A, B, and C, which all contain information about soccer. The columns in the table show the total score of four different query expressions on the three documents.</p>
<div id="CCREF23850" class="tblformal">
<p class="titleintable"><a id="sthref1172"></a><a id="g1024843"></a>Table 3-3 Score Samples</p>
<table class="cellalignment103" title="Score Samples" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t82"><br /></th>
<th class="cellalignment97" id="r1c2-t82">soccer</th>
<th class="cellalignment97" id="r1c3-t82">Brazil</th>
<th class="cellalignment97" id="r1c4-t82">soccer or Brazil</th>
<th class="cellalignment97" id="r1c5-t82">soccer or Brazil*3</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t82" headers="r1c1-t82">
<p>A</p>
</td>
<td class="cellalignment98" headers="r2c1-t82 r1c2-t82">
<p>20</p>
</td>
<td class="cellalignment98" headers="r2c1-t82 r1c3-t82">
<p>10</p>
</td>
<td class="cellalignment98" headers="r2c1-t82 r1c4-t82">
<p>20</p>
</td>
<td class="cellalignment98" headers="r2c1-t82 r1c5-t82">
<p>30</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t82" headers="r1c1-t82">
<p>B</p>
</td>
<td class="cellalignment98" headers="r3c1-t82 r1c2-t82">
<p>10</p>
</td>
<td class="cellalignment98" headers="r3c1-t82 r1c3-t82">
<p>30</p>
</td>
<td class="cellalignment98" headers="r3c1-t82 r1c4-t82">
<p>30</p>
</td>
<td class="cellalignment98" headers="r3c1-t82 r1c5-t82">
<p>90</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t82" headers="r1c1-t82">
<p>C</p>
</td>
<td class="cellalignment98" headers="r4c1-t82 r1c2-t82">
<p>50</p>
</td>
<td class="cellalignment98" headers="r4c1-t82 r1c3-t82">
<p>20</p>
</td>
<td class="cellalignment98" headers="r4c1-t82 r1c4-t82">
<p>50</p>
</td>
<td class="cellalignment98" headers="r4c1-t82 r1c5-t82">
<p>60</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The score in the third column containing the query <span class="italic">soccer or Brazil</span> is the score of the highest scoring term. The score in the fourth column containing the query <span class="italic">soccer or Brazil*3</span> is the larger of the score of the first column <span class="italic">soccer</span> and of the score <span class="italic">Brazil</span> multiplied by three, <span class="italic">Brazil*3</span>.</p>
<p>With the initial query of <span class="italic">soccer or Brazil</span>, the documents are ranked in the order C B A. With the query of <span class="italic">soccer or Brazil*3</span>, the documents are ranked B C A, which is the preferred ranking.</p>
<p>Weights can be added to multiple terms. The query <span class="italic">Brazil OR (soccer AND Brazil)*3</span> will increase the relative scores for documents that contain both <span class="italic">soccer</span> and <span class="italic">Brazil</span>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998461"></a>
<div id="CCREF0344" class="refsect1">
<h2 class="refsect1">wildcards (% _)</h2>
<p><a id="sthref1173"></a><a id="sthref1174"></a><a id="sthref1175"></a>Wildcard characters can be used in query expressions to expand word searches into pattern searches. The wildcard characters are:</p>
<div class="inftblinformal">
<table class="cellalignment96" title="wildcards Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t83">Wildcard Character</th>
<th class="cellalignment97" id="r1c2-t83">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t83" headers="r1c1-t83">%</td>
<td class="cellalignment98" headers="r2c1-t83 r1c2-t83">The percent wildcard can appear any number of times at any part of the search term. The search term will be expanded into an equivalence list of terms. The list consists of all terms in the index that match the wildcarded term, with zero or more characters in place of the percent character.</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t83" headers="r1c1-t83">_</td>
<td class="cellalignment98" headers="r3c1-t83 r1c2-t83">The underscore wildcard specifies a single position in which any character can occur.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>The total number of wildcard expansions from all words in a query containing unescaped wildcard characters cannot exceed the maximum number of expansions specified by the <code dir="ltr">BASIC_WORDLIST</code> attribute <code dir="ltr">WILDCARD_MAXTERMS</code>. For more information, see <a href="cdatadic.htm#i1008935">"BASIC_WORDLIST"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a wildcard expression translates to a stopword, the stopword is not included in the query and not highlighted by CTX_DOC.<a href="cdocpkg.htm#i997035">HIGHLIGHT</a> or CTX_DOC.<a href="cdocpkg.htm#i997146">MARKUP</a>.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1176"></a>Right-Truncated Queries</p>
<p>Right truncation involves placing the wildcard on the right-hand-side of the search string.</p>
<p>For example, the following query expression finds all terms beginning with the pattern <span class="italic">scal</span>:</p>
<pre dir="ltr">
'scal%'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1177"></a>Left- and Double-Truncated Queries<a id="sthref1178"></a></p>
<p>Left truncation involves placing the wildcard on the left-hand-side of the search string.</p>
<p>To find words such as <span class="italic">king</span>, <span class="italic">wing</span> or <span class="italic">sing</span>, write the query as follows:</p>
<pre dir="ltr">
'_ing'
</pre>
<p>For all words that end with <span class="italic">ing</span>, enter:</p>
<pre dir="ltr">
'%ing'
</pre>
<p>Combine left-truncated and right-truncated searches to create double-truncated searches. The following query finds all documents that contain words that contain the substring <span class="italic">%benz%</span></p>
<pre dir="ltr">
'%benz%'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1179"></a>Improving Wildcard Query Performance<a id="sthref1180"></a><a id="sthref1181"></a></p>
<p>Improve wildcard query performance by adding a substring or prefix index.</p>
<p>When your wildcard queries are left- and double-truncated, you can improve query performance by creating a substring index. Substring indexes improve query performance for all types of left-truncated wildcard searches such as <span class="italic">%ed</span>, <span class="italic">_ing</span>, or <span class="italic">%benz%</span>.</p>
<p>When your wildcard queries are right-truncated, you can improve performance by creating a prefix index. A prefix index improves query performance for wildcard searches such as <span class="italic">to%</span>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cdatadic.htm#i1008935">"BASIC_WORDLIST"</a> in <a href="cdatadic.htm#BHCDHIAI">Chapter 2, "Oracle Text Indexing Elements"</a> for more information about creating substring and prefix indexes</div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" -->
<a id="i998525"></a>
<div id="CCREF0330" class="refsect1">
<h2 class="refsect1">WITHIN<a id="sthref1182"></a><a id="sthref1183"></a><a id="sthref1184"></a><a id="sthref1185"></a><a id="sthref1186"></a><a id="sthref1187"></a><a id="sthref1188"></a><a id="sthref1189"></a><a id="sthref1190"></a><a id="sthref1191"></a></h2>
<p>Use the <code dir="ltr">WITHIN</code> operator to narrow a query down into document sections. Document sections can be one of the following:</p>
<ul>
<li>
<p>Zone sections</p>
</li>
<li>
<p>Field sections</p>
</li>
<li>
<p>Attribute sections</p>
</li>
<li>
<p>Special sections (sentence or paragraph)</p>
</li>
</ul>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1192"></a>Syntax</p>
<div class="inftblinformal">
<table class="cellalignment96" title="WITHIN Syntax" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment90">
<th class="cellalignment97" id="r1c1-t86">Syntax</th>
<th class="cellalignment97" id="r1c2-t86">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment90">
<td class="cellalignment98" id="r2c1-t86" headers="r1c1-t86"><span class="italic">expression</span> WITHIN <span class="italic">section</span></td>
<td class="cellalignment98" headers="r2c1-t86 r1c2-t86">Searches for <span class="syntaxinline">expression</span> within the pre-defined zone, field, or attribute <span class="syntaxinline">section</span>.
<p>If section is a zone, <span class="syntaxinline">expression</span> can contain one or more <code dir="ltr">WITHIN</code> operators (nested <code dir="ltr">WITHIN</code>) whose section is a zone or special section.</p>
<p>If section is a field or attribute section, expression cannot contain another <code dir="ltr">WITHIN</code> operator.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r3c1-t86" headers="r1c1-t86"><span class="variable">expression</span> WITHIN SENTENCE</td>
<td class="cellalignment98" headers="r3c1-t86 r1c2-t86">Searches for documents that contain <span class="syntaxinline">expression</span> within a sentence. Specify an <code dir="ltr">AND</code> or <code dir="ltr">NOT</code> query for <span class="syntaxinline">expression</span>.
<p>The <span class="syntaxinline">expression</span> can contain one or more <code dir="ltr">WITHIN</code> operators (nested <code dir="ltr">WITHIN</code>) whose section is a zone or special section.</p>
</td>
</tr>
<tr class="cellalignment90">
<td class="cellalignment98" id="r4c1-t86" headers="r1c1-t86"><span class="variable">expression</span> WITHIN PARAGRAPH</td>
<td class="cellalignment98" headers="r4c1-t86 r1c2-t86">Searches for documents that contain <span class="syntaxinline">expression</span> within a paragraph. Specify an <code dir="ltr">AND</code> or <code dir="ltr">NOT</code> query for <span class="syntaxinline">expression</span>.
<p><span class="syntaxinline">The expression</span> can contain one or more <code dir="ltr">WITHIN</code> operators (nested <code dir="ltr">WITHIN</code>) whose section is a zone or special section.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1193"></a>WITHIN Limitations<a id="sthref1194"></a></p>
<p>The <code dir="ltr">WITHIN</code> operator has the following limitations:</p>
<ul>
<li>
<p>You cannot embed the <code dir="ltr">WITHIN</code> clause in a phrase. For example, you cannot write: <span class="italic">term1 WITHIN section term2</span></p>
</li>
<li>
<p>Because <code dir="ltr">WITHIN</code> is a reserved word, you must escape the word with braces to search on it.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1195"></a>WITHIN Operator Examples</p>
<p class="subhead1"><a id="i998559"></a><a id="CCREF23851"></a>Querying Within Zone Sections</p>
</div>
<!-- class="refsubsect" -->
<p>To find all the documents that contain the term <span class="italic">San Francisco</span> within the section <span class="italic">Headings,</span> write the query as follows:</p>
<pre dir="ltr">
'San Francisco WITHIN Headings'
</pre>
<p>To find all the documents that contain the term <span class="italic">sailing</span> and contain the term <span class="italic">San Francisco</span> within the section <span class="italic">Headings</span>, write the query in one of two ways:</p>
<pre dir="ltr">
'(San Francisco WITHIN Headings) and sailing'

'sailing and San Francisco WITHIN Headings'
</pre>
<p class="subhead2"><a id="CCREF23852"></a>Compound Expressions with WITHIN</p>
<p>To find all documents that contain the terms <span class="italic">dog</span> and <span class="italic">cat</span> within the same section <span class="italic">Headings</span>, write the query as follows:</p>
<pre dir="ltr">
'(dog and cat) WITHIN Headings'
</pre>
<p>This query is logically different from:</p>
<pre dir="ltr">
'dog WITHIN Headings and cat WITHIN Headings'
</pre>
<p>This query finds all documents that contain <span class="italic">dog</span> and <span class="italic">cat</span> where the terms <span class="italic">dog</span> and <span class="italic">cat</span> are in <span class="italic">Headings</span> sections, regardless of whether they occur in the same <span class="italic">Headings</span> section or different sections.</p>
<p class="subhead2"><a id="CCREF23853"></a><a id="sthref1196"></a>Near with WITHIN</p>
<p>To find all documents in which <span class="italic">dog</span> is near <span class="italic">cat</span> within the section <span class="italic">Headings</span>, write the query as follows:</p>
<pre dir="ltr">
'dog near cat WITHIN Headings'
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The near operator has higher precedence than the <code dir="ltr">WITHIN</code> operator so braces are not necessary in this example. This query is equivalent to <span class="italic">(dog near cat) WITHIN Headings</span>.</div>
<p class="subhead1"><a id="CCREF23854"></a>Nested WITHIN Queries<a id="sthref1197"></a><a id="sthref1198"></a><a id="sthref1199"></a></p>
<p>You can nest the within operator to search zone sections within zone sections.</p>
<p>For example, assume that a document set had the zone section <code dir="ltr">AUTHOR</code> nested within the zone <code dir="ltr">BOOK</code> section. Write a nested <code dir="ltr">WITHIN</code> query to find all occurrences of <span class="italic">scott</span> within the <code dir="ltr">AUTHOR</code> section of the <code dir="ltr">BOOK</code> section as follows:</p>
<pre dir="ltr">
'(scott WITHIN AUTHOR) WITHIN BOOK'
</pre>
<p class="subhead1"><a id="CCREF23855"></a>Querying Within Field Sections<a id="sthref1200"></a><a id="sthref1201"></a></p>
<p>The syntax for querying within a field section is the same as querying within a zone section. The syntax for most of the examples given in the previous section, <a href="#i998559">"Querying Within Zone Sections"</a>, apply to field sections.</p>
<p>However, field sections behave differently from zone sections in terms of</p>
<ul>
<li>
<p>Visibility: Make text within a field section invisible.</p>
</li>
<li>
<p>Repeatability: <code dir="ltr">WITHIN</code> queries cannot distinguish repeated field sections.</p>
</li>
<li>
<p>Nestability: You cannot enter a nested <code dir="ltr">WITHIN</code> query with a field section.</p>
</li>
</ul>
<p>The following sections describe these differences.</p>
<p class="subhead2"><a id="CCREF23856"></a>Visible Flag in Field Sections</p>
<p>When a field section is created with the visible flag set to <code dir="ltr">FALSE</code> in <code dir="ltr">CTX_DDL.ADD_FIELD_SECTION</code>, the text within a field section can only be queried using the <code dir="ltr">WITHIN</code> operator.</p>
<p>For example, assume that <code dir="ltr">TITLE</code> is a field section defined with visible flag set to <code dir="ltr">FALSE</code>. Then the query <span class="italic">dog</span> without the <code dir="ltr">WITHIN</code> operator will <span class="italic">not</span> find a document containing:</p>
<pre dir="ltr">
&lt;TITLE&gt;The dog&lt;/TITLE&gt; I like my pet.
</pre>
<p>To find such a document, use the <code dir="ltr">WITHIN</code> operator as follows:</p>
<pre dir="ltr">
'dog WITHIN TITLE'
</pre>
<p>Alternatively, set the visible flag to <code dir="ltr">TRUE</code> when you define <code dir="ltr">TITLE</code> as a field section with <code dir="ltr">CTX_DDL.ADD_FIELD_SECTION</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cddlpkg.htm#i999153">"ADD_FIELD_SECTION"</a> in <a href="cddlpkg.htm#g1014415">Chapter 7, "CTX_DDL Package"</a> for more information about creating field sections</div>
<p class="subhead2"><a id="CCREF23857"></a>Repeated Field Sections<a id="sthref1202"></a><a id="sthref1203"></a></p>
<p><code dir="ltr">WITHIN</code> queries <span class="italic">cannot</span> distinguish repeated field sections in a document. For example, consider the document with the repeated section <code dir="ltr">&lt;author&gt;</code>:</p>
<pre dir="ltr">
&lt;author&gt; Charles Dickens &lt;/author&gt;
&lt;author&gt; Martin Luther King &lt;/author&gt;
</pre>
<p>Assuming that <code dir="ltr">&lt;author&gt;</code> is defined as a field section, a query such as (<span class="italic">charles and martin) within author</span> returns the document, even though these words occur in separate tags.</p>
<p>To have <code dir="ltr">WITHIN</code> queries distinguish repeated sections, define the sections as zone sections.</p>
<p class="subhead2"><a id="CCREF23858"></a>Nested Field Sections</p>
<p>You cannot enter a nested <code dir="ltr">WITHIN</code> query with field sections. Doing so raises an error.</p>
<p class="subhead1"><a id="CCREF23859"></a>Querying Within Sentence or Paragraphs<a id="sthref1204"></a><a id="sthref1205"></a></p>
<p>Querying within sentence or paragraph boundaries is useful to find combinations of words that occur in the same sentence or paragraph. To query sentence or paragraphs, you must first add the special section to your section group before you index. Do so with <code dir="ltr">CTX_DDL.ADD_SPECIAL_SECTION</code>.</p>
<p>To find documents that contain <span class="italic">dog</span> and <span class="italic">cat</span> within the same sentence:</p>
<pre dir="ltr">
'(dog and cat) WITHIN SENTENCE'
</pre>
<p>To find documents that contain <span class="italic">dog</span> and <span class="italic">cat</span> within the same paragraph:</p>
<pre dir="ltr">
'(dog and cat) WITHIN PARAGRAPH'
</pre>
<p>To find documents that contain sentences with the word <span class="italic">dog</span> but not <span class="italic">cat</span>:</p>
<pre dir="ltr">
'(dog not cat) WITHIN SENTENCE'
</pre>
<p class="subhead1"><a id="CCREF23860"></a>Querying Within Attribute Sections<a id="sthref1206"></a><a id="sthref1207"></a><a id="sthref1208"></a></p>
<p>Query within attribute sections when you index with either <code dir="ltr">XML_SECTION_GROUP</code> or <code dir="ltr">AUTO_SECTION_GROUP</code> as your section group type.</p>
<p>Assume you have an XML document as follows:</p>
<pre dir="ltr">
&lt;book title="Tale of Two Cities"&gt;It was the best of times.&lt;/book&gt;
</pre>
<p>Define the section <code dir="ltr">title@book</code> to be the attribute section <code dir="ltr">title</code>. Do so with the <code dir="ltr">CTX_DLL.ADD_ATTR_SECTION</code> procedure or dynamically after indexing with <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use the <code dir="ltr">AUTO_SECTION_GROUP</code> to index XML documents, the system automatically creates attribute sections and names them in the form <code dir="ltr">attribute@tag</code>.
<p>If you use the <code dir="ltr">XML_SECTION_GROUP</code>, you can name attribute sections anything with <code dir="ltr">CTX_DDL.ADD_ATTR_SECTION</code>.</p>
</div>
<p>To search on <span class="italic">Tale</span> within the attribute section <code dir="ltr">title</code>, enter the following query:</p>
<pre dir="ltr">
'Tale WITHIN title'
</pre>
<p class="subhead2"><a id="CCREF23861"></a>Constraints for Querying Attribute Sections</p>
<p>The following constraints apply to querying within attribute sections:</p>
<ul>
<li>
<p>Regular queries on attribute text do not hit the document unless qualified in a within clause. Assume you have an XML document as follows:</p>
</li>
</ul>
<pre dir="ltr">
&lt;book title="Tale of Two Cities"&gt;It was the best of times.&lt;/book&gt;
</pre>
<p>A query on <span class="italic">Tale</span> by itself does not produce a hit on the document unless qualified with <code dir="ltr">WITHIN title@book</code>. (This behavior is like field sections when you set the visible flag set to false.)</p>
<ul>
<li>
<p>You cannot use attribute sections in a nested <code dir="ltr">WITHIN</code> query.</p>
</li>
<li>
<p>Phrases ignore attribute text. For example, if the original document looked like:</p>
</li>
</ul>
<pre dir="ltr">
Now is the time for all good &lt;word type="noun"&gt; men &lt;/word&gt; to come to the aid.
</pre>
<p>Then this document would hit on the regular query <span class="italic">good men</span>, ignoring the intervening attribute text.</p>
<ul>
<li>
<p><code dir="ltr">WITHIN</code> queries can distinguish repeated attribute sections. This behavior is like zone sections but unlike field sections. For example, you have a document as follows:</p>
</li>
</ul>
<pre dir="ltr">
&lt;book title="Tale of Two Cities"&gt;It was the best of times.&lt;/book&gt;
&lt;book title="Of Human Bondage"&gt;The sky broke dull and gray.&lt;/book&gt;
</pre>
<p>Assume that <code dir="ltr">book</code> is a zone section and <code dir="ltr">book@author</code> is an attribute section. Consider the query:</p>
<pre dir="ltr">
'(Tale and Bondage) WITHIN book@author'
</pre>
<p>This query does <span class="italic">not</span> hit the document, because <span class="italic">tale</span> and <span class="italic">bondage</span> are in different occurrences of the attribute section <code dir="ltr">book@author</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref1209"></a>Notes</p>
<p class="subhead1"><a id="CCREF23862"></a>Section Names</p>
<p>The <code dir="ltr">WITHIN</code> operator requires you to know the name of the section you search. A list of defined sections can be obtained using the <a href="aviews.htm#i8879">CTX_SECTIONS</a> or <a href="aviews.htm#i6721">CTX_USER_SECTIONS</a> views.</p>
<p class="subhead1"><a id="CCREF23863"></a>Section Boundaries</p>
<p>For special and zone sections, the terms of the query must be fully enclosed in a particular occurrence of the section for the document to satisfy the query. This is not a requirement for field sections.</p>
<p>For example, consider the query where <span class="italic">bold</span> is a zone section:</p>
<pre dir="ltr">
'(dog and cat) WITHIN bold'
</pre>
<p>This query finds:</p>
<pre dir="ltr">
&lt;B&gt;dog cat&lt;/B&gt;
</pre>
<p>but it does not find:</p>
<pre dir="ltr">
&lt;B&gt;dog&lt;/B&gt;&lt;B&gt;cat&lt;/B&gt;
</pre>
<p>This is because dog and cat must be in the same <span class="italic">bold</span> section.</p>
<p>This behavior is especially useful for special sections, where</p>
<pre dir="ltr">
'(dog and cat) WITHIN sentence'
</pre>
<p>means find <span class="italic">dog</span> and <span class="italic">cat</span> within the same sentence.</p>
<p>Field sections on the other hand are meant for non-repeating, embedded metadata such as a title section. Queries within field sections cannot distinguish between occurrences. All occurrences of a field section are considered to be parts of a single section. For example, the query:</p>
<pre dir="ltr">
(dog and cat) WITHIN title
</pre>
<p>can find a document like this:</p>
<p>&lt;TITLE&gt;dog&lt;/TITLE&gt;&lt;TITLE&gt;cat&lt;/TITLE&gt;</p>
<p>In return for this field section limitation and for the overlap and nesting limitations, field section queries are generally faster than zone section queries, especially if the section occurs in every document, or if the search term is common.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" --></div>
<!-- class="refentry" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment89">
<tr>
<td class="cellalignment98">
<table class="cellalignment94">
<tr>
<td class="cellalignment93"><a href="cdatadic.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment93"><a href="cqspcl.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1998, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment100">
<table class="cellalignment92">
<tr>
<td class="cellalignment93"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment93"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment93"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment93"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment93"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment93"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
